;;; -*- Mode: tdl; coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2018
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  lextypes.tdl
;;;
;;;  Lexical types (i.e., word classes)
;;;
;;;  Rob Malouf, 3-Nov-1994
;;;
;;;  $Id: lextypes.tdl 7479 2010-02-21 23:11:30Z danf $

;:message "Lexical types".

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LEXICAL DEFAULTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nonconj := word &
  [ SYNSEM [ LOCAL.CONJ cnil,
             PUNCT no_punctuation_min ] ].

nonque := word &
  [ SYNSEM.NONLOC.QUE 0-dlist ].  

nonrel := word &
  [ SYNSEM.NONLOC.REL 0-dlist ].  

nonslash := word &
  [ SYNSEM.NONLOC.SLASH 0-dlist ].

; Most words combine with their complements (if any) to produce a phrase,
; but a few, like "twenty" as in "twenty-two" and "five" as in "five o'clock",
; produce a sign which is still a word -- one with [ SYNSEM lex_synsem ].

hc-to-phr := word &
  [ SYNSEM.LOCAL.CAT.HC-LEX - ].

mcna := word &
  [ SYNSEM.LOCAL.CAT.MC na ].

non_affix_bearing := word &
  [ INFLECTD + ].

;; Relevant combinations of these seven lexical defaults

nons-m := nonslash & mcna.
noncs-m := nons-m & nonconj.
nonc-h := nonconj & hc-to-phr.
nonc-m-nab := nonconj & mcna & non_affix_bearing.
noncs-m-nab := nonc-m-nab & nonslash.
noncs-hm := noncs-m & hc-to-phr.
noncs-hm-nab := noncs-hm & noncs-m-nab.
noncrs-hm := noncs-hm & nonrel.
noncqrs-hm := noncrs-hm & nonque.
noncqrs-hm-nab := noncqrs-hm & noncs-m-nab.
nonrs := nonrel & nonslash.
nonrs-hm := nons-m & hc-to-phr & nonrs.
noncrs := nonrs & nonconj.
noncqrs := noncrs & nonque.
noncrs-nab := noncrs & non_affix_bearing.
noncqrs-nab := noncqrs & non_affix_bearing.
noncrs-m := noncs-m & noncrs.
noncqrs-m := noncrs-m & nonque.
noncrs-m-nab := noncrs-m & noncs-m-nab.
noncqrs-m-nab := noncrs-m-nab & nonque.
nonc-hm := nonconj & hc-to-phr & mcna.
noncqs := nonconj & nonque & nonslash.
noncqs-hm := noncs-hm & noncqs.
noncqs-m-nab := noncqs & noncs-m-nab.
noncqs-hm-nab := noncqs-hm & noncs-m-nab.
nonc-h-nab := nonconj & hc-to-phr & non_affix_bearing.
noncr-h-nab := nonc-h-nab & nonrel.
noncqr-h-nab := noncr-h-nab & nonque.
nonc-hm-nab := nonc-h-nab & mcna.
noncqrs-h-nab := noncqrs & nonc-h-nab.
noncr-hm-nab := noncr-h-nab & mcna.
noncrs-hm-nab := noncrs-hm & noncs-m-nab.
nonrs-nab := nonrs & non_affix_bearing.

; que_word's have all the defaults EXCEPT nonque
que_word := noncrs-hm-nab.

; For words with non-default PUNCT
non-qr-h-nab := basic_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT.HC-LEX -,
		     CONJ cnil ],
	     NONLOC [ QUE 0-dlist,
		      REL 0-dlist ] ] ].

norm_nonconj_word := nonc-hm-nab.

;;;;;
;; Non-local amalgmation types

basic_zero_arg := synsem &
  [ LOCAL.ARG-S < >,
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ] ].

zero_arg := basic_zero_arg & lex_synsem &
  [ LOCAL.CONT [ HCONS <! !>,
		 ICONS <! !> ] ].

;; DPF 13-may-09 Removed identif of --SLTOP with that of ARG-S: see next.
;; DPF 2012-12-12 - In fact, we don't want the --SLTOP of the subject to be
;; bound in general (not just for the one-args, but for all arities), since
;; (1) subject gaps don't get entangled in across-the-board extraction like
;; complements and modifiers do (because we conjoin and then extract); and
;; (2) identifying the subject's --SLTOP with that of its head can lead to
;; circularity in scoping, as in sentences with both a conjoined subject and
;; a conjoined VP, such as *Kim and Lee would dance and smile*.  This is
;; because the coordination rules identify the mother's LTOP and --SLTOP,
;; and the LTOP of *Kim and Lee* is as usual identified with that of *would*,
;; but *would*'s --SLTOP is also identified with that of its complement, and
;; that complement, since it is conjoined, also identifies its own LTOP and
;; --SLTOP.  So if *would* also identified its subject's --SLTOP with its
;; own, we would get by transitivity the identity of *would*'s LTOP with
;; its complement's LTOP.
;
basic_one_arg := canonical_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH #slash,
			       REL #rel,
			       QUE #que ] ] > ],
    NONLOC [ SLASH #slash,
             REL #rel,
             QUE #que ] ].

one_arg := basic_one_arg &
  [ LOCAL.CONT [ HCONS <! !>,
		 ICONS <! !> ] ].

basic_two_arg := basic_lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle,
				       LAST #slast ],
			       REL [ LIST #rmiddle,
				     LAST #rlast ],
			       QUE [ LIST #qmiddle,
				     LAST #qlast ] ] ],
		    [ NONLOC [ SLASH [ LIST #sfirst,
				       LAST #smiddle ],
			       REL [ LIST #rfirst,
				     LAST #rmiddle ],
			       QUE [ LIST #qfirst,
				     LAST #qmiddle ] ] ] > ],
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ],
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].


two_arg := basic_two_arg &
  [ LOCAL.CONT [ HCONS <! !>,
	         ICONS <! !> ] ].

; 'Kim is worth admiring.'
; 'Paris is pretty to look at'
;
;; Note no identification of --SLTOP of VP complement and self, since SLASH of
;; the complement is not passed up.
;;
adj_vpslash_two_arg := lex_synsem &
  [ LOCAL.ARG-S < [ NONLOC [ SLASH #slash,
                             REL [ LIST #rmiddle,
                                   LAST #rlast ],
                             QUE [ LIST #qmiddle,
                                   LAST #qlast ] ] ],
		  [ NONLOC [ REL [ LIST #rfirst,
                                   LAST #rmiddle ],
                             QUE [ LIST #qfirst,
                                   LAST #qmiddle ] ] ] >,
    NONLOC [ SLASH #slash,
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

generic_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ REL [ LIST #rmiddle2,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qlast ] ] ],
                    [ NONLOC [ REL [ LIST #rfirst,
                                     LAST #rmiddle1 ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
                    [ NONLOC [ REL [ LIST #rmiddle1,
                                     LAST #rmiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ] > ],
    NONLOC [ REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

;; DPF 2013-02-13 - Don't unify --SLTOP of second complement, since it is
;; often a scopal argument.  Push down to the few relevant (nonscope-comp) 
;; subtypes
;; DPF 2015-08-20 - Re 2013-02-13: But we get non-empty SLASH also in scopal
;; arguments, of course, and unless we identify --SLTOP of the head and of
;; such a slashed complement, we lose a crucial identity, as can be seen in
;; examples such as *where did you think the dog was* where the --SLTOP of
;; *think the dog was* would remain unbound, and hence the filler's LTOP has
;; no way to be identified (via qeq) with think's ARG3. 
;; So let's put this reentrancy back in, and remind ourselves of any remaining
;; difficulty.
;;
basic_three_arg := generic_three_arg &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle2,
                                   LAST #slast ] ],
                  [ NONLOC.SLASH [ LIST #sfirst,
                                   LAST #smiddle1 ] ],
                  [ NONLOC.SLASH [ LIST #smiddle1,
                                   LAST #smiddle2 ] ] >,
    NONLOC.SLASH [ LIST #sfirst,
                   LAST #slast ] ].

three_arg := basic_three_arg &
  [ LOCAL.CONT [ HCONS <! !>,
		 ICONS <! !> ] ].

; Don't amalgamate SLASH of last complement
tough_three_arg := generic_three_arg &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle1,
                                   LAST #slast ] ],
                  [ NONLOC.SLASH [ LIST #sfirst,
                                   LAST #smiddle1 ] ],
                  synsem >,
    NONLOC.SLASH [ LIST #sfirst,
                   LAST #slast ] ].

; Don't amalgamate REL of last complement (it-cleft, 'have X to finish')
norel_three_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle2,
                                       LAST #slast ],
                               REL [ LIST #rmiddle,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qlast ] ] ],
                    [ NONLOC [ SLASH [ LIST #sfirst,
                                       LAST #smiddle1 ],
                               REL [ LIST #rfirst,
                                     LAST #rmiddle ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
                    [ NONLOC [ SLASH [ LIST #smiddle1,
                                       LAST #smiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ] > ],
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ],
             REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

basic_four_arg := lex_synsem &
  [ LOCAL [ ARG-S < [ NONLOC [ REL [ LIST #rmiddle3,
                                     LAST #rlast ],
                               QUE [ LIST #qmiddle3,
                                     LAST #qlast ] ] ],
		    [ NONLOC [ REL [ LIST #rfirst,
                                     LAST #rmiddle1 ],
                               QUE [ LIST #qfirst,
                                     LAST #qmiddle1 ] ] ],
		    [ NONLOC [ REL [ LIST #rmiddle1,
                                     LAST #rmiddle2 ],
                               QUE [ LIST #qmiddle1,
                                     LAST #qmiddle2 ] ] ],
		    [ NONLOC [ REL [ LIST #rmiddle2,
                                     LAST #rmiddle3 ],
                               QUE [ LIST #qmiddle2,
                                     LAST #qmiddle3 ] ] ] > ],
    NONLOC [ REL [ LIST #rfirst,
                   LAST #rlast ],
             QUE [ LIST #qfirst,
                   LAST #qlast ] ] ].

four_arg := basic_four_arg &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle3,
                                       LAST #slast ] ] ],
		    [ NONLOC [ SLASH [ LIST #sfirst,
                                       LAST #smiddle1 ] ] ],
		    [ NONLOC [ SLASH [ LIST #smiddle1,
                                       LAST #smiddle2 ] ] ],
		    [ NONLOC [ SLASH [ LIST #smiddle2,
                                       LAST #smiddle3 ] ] ] > ],
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ] ] ].

; Don't amalgamate SLASH of last complement
tough_four_arg := basic_four_arg &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle2,
                                       LAST #slast ] ] ],
		    [ NONLOC [ SLASH [ LIST #sfirst,
                                       LAST #smiddle1 ] ] ],
		    [ NONLOC [ SLASH [ LIST #smiddle1,
                                       LAST #smiddle2 ] ] ],
		    synsem > ],
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ] ] ].

; Don't amalgamate SLASH of third complement with tough-adj comparatives
; *easier for us to admire than Kim*
;;
tough_four_arg_compar := basic_four_arg &
  [ LOCAL [ ARG-S < [ NONLOC [ SLASH [ LIST #smiddle2,
                                       LAST #slast ] ] ],
		    [ NONLOC [ SLASH [ LIST #sfirst,
                                       LAST #smiddle1 ] ] ],
		    synsem,
		    [ NONLOC [ SLASH [ LIST #smiddle1,
                                       LAST #smiddle2 ] ] ] > ],
    NONLOC [ SLASH [ LIST #sfirst,
                     LAST #slast ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBCATEGORIZATIONS -- synsems for verbs, adjectives, prepositions, nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

nomod_synsem := lex_synsem &
  [ LOCAL.CAT [ HEAD.MOD < >,
		VAL.SUBJ < > ] ].

scopal_mod := mod_local.
intersective_mod := mod_local.

scopal_mod_local := scopal_mod & local.
int_mod_local := intersective_mod & local.

; DPF 27-May-99 - Changed [MC na] in NOMP_CAT to [MC na_or_-] to allow 
; acc-verbal-gerunds to be NP complements, even though they are built via the 
; head_subj rule.
; DPF 18-Nov-99 - Removed PRD + since this prevented e.g. "ten past five" where
; "ten" is [PRD -], and "past" requires a nomp_cat specifier.
; DPF 07-Jan-01 - We would like to capture the generalization that nominal
; phrases which have been assigned case (nominative or accusative) must also
; be [ MSG no_msg ] to block, e.g., spurious analyses for verbal gerunds
; which have been built via the subj-head rule.  But for now have to stipulate
; this for each occurrence in subcats.
; DPF 21-Mar-01 - Made COMPS for nomp_cat be < > rather than *olist* to avoid
; spurious ambiguity for partitives, as in "some arrived", since they have to
; undergo the n_optcomp pumping rule in order to be able to take a specifier
; as in "almost all arrived".
; DPF 20-Dec-01 - Added SPEC < > in nomp_cat to exclude measure-NPs.
; DPF 8-Feb-02 - But this prevents NPs from ever being specifiers (given the
; constraint on SPR..SPEC in the h-spec rule.  So remove this constraint, and
; try to remember the examples that were supposed to be excluded.
; DPF 20-May-02 - Why MOOD on nomp_cat?
; DPF 27-Oct-02 - Would like to say about all nomp's that they are 
; [DIV strict_sort], as we've already been doing (asymmetrically) for
; verbs' subjects for a while now, to avoid spurious ambiguity for e.g.
; "Fridays are inconvenient",  thus extending this to other uses of NPs.
; But AGR.DIV is not in CAT, so we can't, and we have to replicate this
; constraint everywhere, as we've already had to do for [CONJ cnil].  Maybe
; a better approach could be found, maybe with defaults?
; DPF 4-Nov-02 - Added MOD < > since we can no longer distinguish modnp guys
; (output of npadv_mod rule) by their having a non-empty SUBJ.
; DPF 7-jul-04 - Removed [ TAM.MOOD ind_or_mod_subj ] from nomp_cat, since
; it's not clear what it was supposed to do.
; DPF 27-aug-04 - Removed [PRD -] constraint, since we want "as much rice
; as possible" which is [PRD +].
; DPF 04-mar-06 - Re 4-Nov-02, removed MOD < > since some NPs (e.g. yofc) have
; non-empty MOD, and np_adv_c's have INDEX event rather than index.
; DPF 09-apr-09 - Changed HEAD from nominal to supnoun to exclude modnp.

nomp_cat_min := cat_min.

nomp_cat := nomp_cat_min & cat &
  [ HEAD supnoun &
	 [ POSS -,
           MOD < > ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na_or_- ].

; DPF (8-Jan-99) Added accusative and nominative subtypes of nomp_cat, since 
; nominative ones are not 'mobile' - see fundamentals.tdl, and still want to
; keep _min types to reduce size of feature structures, even with CASE
; restriction.

nomp_cat_nom_min := nomp_cat_min.
nomp_cat_acc_min := nomp_cat_min.
nomp_cat_nonnom_min := nomp_cat_min.

nomp_cat_nom := nomp_cat_nom_min & nomp_cat &
  [ HEAD.CASE nom ].

nomp_cat_acc := nomp_cat_acc_min & nomp_cat &
  [ HEAD.CASE acc ].

nomp_cat_nonnom := nomp_cat_nonnom_min & nomp_cat &
  [ HEAD.CASE non_nom ].

np_cat_min := nomp_cat_min.
np_cat_nom_min := nomp_cat_nom_min & np_cat_min.
np_cat_acc_min := nomp_cat_acc_min & np_cat_min.
np_cat_nonnom_min := nomp_cat_nonnom_min & np_cat_min.

np_cat_nom := nomp_cat_nom & np_cat_nom_min &
  [ HEAD supnoun ].

np_cat_nonnom := nomp_cat_nonnom & np_cat_nonnom_min &
  [ HEAD supnoun ].

np_cat_acc := nomp_cat_acc & np_cat_acc_min & np_cat_nonnom &
  [ HEAD supnoun ].

;; DPF (30-Apr-98) In saturated phrase subcats, SUBJ must be < >, not *olist*,
;; since we need to have SUBJ < > unify with the filler in filler_head phrases,
;; and the filler is constrained to be SUBJ *prolist* which has a distinct 
;; synsem type (pro_ss) which is constrained to be [OPT -].
;; DPF 27-May-99 - Having eliminated the need for *prolist* to be OPT -, we
;; can now make saturated phrases require SUBJ to be *olist* rather than < >, 
;; which means verbal gerunds can have an optional SUBJ but still themselves 
;; be subjects or complements.
;; DPF (28-Jul-98) Added MOD < > to exclude non-finite relative clauses, which
;; are otherwise not distinguishable from nomp's.  Maybe also needed to 
;; exclude the second (modifier) entries for temporal NPs like "Tuesday".
;; DPF 09-Jun-99 - Removed MOD < > (see above), since relative clauses are now
;; all marked with non-empty REL, and because this constraint was falsely 
;; blocking "one to three pm" as an NP complement, because it has a 
;; non-empty MOD.
;;
s_cat_unspec := cat &
  [ HEAD verbal,
    VAL [ SUBJ *olist*,
	  COMPS < > ] ].

;; DPF 2013-02-11 - Constrain MC to bool, in order to exclude relative
;; clauses, as in ecoc:2065708
;;
basic_s_cat_v_c := s_cat_unspec &
  [ VAL.SPR *olist*,
    MC bool ].

s_cat_v_c := basic_s_cat_v_c &
  [ HEAD.INV -,
    VAL.SUBJ *olist*,
    MC - ].

s_cat_fin_or_inf_unspec := s_cat_unspec &
  [ HEAD [ VFORM fin_or_inf,
           TAM indic_tam ] ].

s_cat_fin_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD [ VFORM fin ] ].

s_cat_inf_unspec := s_cat_fin_or_inf_unspec &
  [ HEAD.VFORM inf ].

basic_s_cat_fin_or_inf_v_c := basic_s_cat_v_c & s_cat_fin_or_inf_unspec.

s_cat_fin_or_inf_v_c := basic_s_cat_fin_or_inf_v_c & s_cat_v_c.

s_cat_fin_v_c := s_cat_v_c & s_cat_fin_unspec.

s_cat_inf_v_c := s_cat_v_c & s_cat_inf_unspec.

; Removed HEAD comp, to allow "I demand he be here"
s_cat_bse := s_cat_v_c &
  [ HEAD [ VFORM bse,
	   TAM.TENSE real_tense ] ].

s_cat := s_cat_unspec &
  [ HEAD verb & [ TAM.TENSE real_tense ] ].

s_cat_fin := s_cat & s_cat_fin_unspec &
  [ HEAD.INV - ].

; DPF 17-Jul-03 - Removed MC + since blocked e.g. "I assume you stayed to chat"
s_cat_fin_or_imp := s_cat &
  [ HEAD.VFORM fin_or_imp,
    MC bool ].

n_or_v_cat_min := cat_min.
n_or_v_cat := n_or_v_cat_min & cat &
  [ HEAD nominal_or_verbal,
    VAL.COMPS < > ].

vp_cat := n_or_v_cat &
  [ HEAD verbal &
	 [ INV -,
           MOD *anti_list* ],
    VAL.SUBJ < synsem_min & [ NONLOC [ SLASH 0-dlist,
                                       REL 0-dlist,
                                       QUE 0-dlist ] ] >,
    MC na ].

vp_inf_cat := vp_cat &
  [ HEAD [ VFORM inf,
	   PRD - ],
    VAL.SUBJ < synsem > ].

vp_bse_unspec_cat := vp_cat &
  [ HEAD verb &
	 [ VFORM bse_only,
	   PRD - ] ].

vp_prp_cat := vp_cat &
  [ HEAD.VFORM prp ].

; DPF 19-Oct-02 - Changed MOOD from indicative to indicative* to
; allow coord of "I will stay so you should leave"
vp_bse_cat := vp_bse_unspec_cat &
  [ HEAD.TAM [ MOOD indicative,
               TENSE no_tense ] ].

s_or_vp_inf_cat := cat &
  [ HEAD verbal &
         [ VFORM inf,
           MOD *anti_list* ],
    VAL [ COMPS < > ],
    MC na_or_- ].

; DPF 10-Jun-99 - Removed MOD < > (cf note in templates.tdl)
; DPF 11-Jul-99 - Added restriction that SPR be [HEAD det] to prevent 
; adjectives from modifying partitives and odd nouns like hour_prep words.
; DPF 28-Aug-99 - Removed SPR: OPT - to allow relative clauses to modify
; generic-pro's like "anything" and still have the result look like an NP.
; DPF 10-May-01 - Removed [SPR..HEAD det] to allow modifiers of generic_pro
; entries as in "everyone important to me"
; DPF 2-Nov-01 - Added SPR < synsem > to exclude "happy here" with n_adv "here"
; DPF 03-may-04 - Consider adding SPEC < anti_synsem_min > to nbar_cat, so 
; these aren't tempted to unify with measure_nps.

nbar_cat_min := n_or_v_cat_min.

basic_nbar_cat := n_or_v_cat &
  [ HEAD noun_or_nomger_or_nadj &
	 [ POSS - ],
    VAL [ SUBJ < >,
          SPR < synsem_min, ... >,
          COMPS < > ],
    MC na ].

; DPF 18-mar-09 - Restricted SPR to quant_rel, to avoid spurious ambiguity
; since bare NPs otherwise act like nbars.
;; DPF 2016-07-04 - Restrict SPR to unexpressed, to avoid spurious analysis 
;; for *Kim became competent*
;; DPF 2016-10-21 - Generalized SPR..MIN to non_pronoun_q_or_no_rel, so we can
;; also get *the word he*.
;;
nbar_cat := nbar_cat_min & basic_nbar_cat &
  [ HEAD noun_or_nomger,
    VAL.SPR < unexpressed & [ --MIN non_pronoun_q_or_no_rel ], ... > ].

;; DPF 2016-12-06 - Generalized HEAD from adverbee to adverbee_or_modnp since
;; we want to allow *the people here again*
;;
adverbee_cat := cat &
  [ HEAD adverbee_or_modnp ].

; DPF 4-Nov-02 - Added MOD < synsem_min > to block NPs, now that we don't have
; presence of SUBJ synsem on all predicative phrases.
; DPF 24-Jun-03 - Removed MOD, since verbs now MOD empty.  Instead, use
; HEAD v_or_a_or_p to exclude NPs.
; DPF 12-oct-05 - Can't constrain MOD to synsem, to exclude e.g. adj "a":
; "*find it a", since verbs have non-empty MOD constrained to anti_synsem.
; So instead constrain semantics of this "a".

prd_or_adv_cat := cat &
  [ HEAD non_noun_or_adv &
         [ PRD +,
           MOD < [ LOCAL intersective_mod ] >,
           TAM.TENSE tense ],
    VAL [ SUBJ *olist*,
	  SPR *olist*,
	  COMPS < > ],
    MC na ].

;; DPF 2013-10-18 - Tried moving the AUX - constraint from prd_cat to this
;; more general type, since it seems that we never want infinitival 
;; relatives as predicative complements.  But the copula needs its complement
;; unmarked for AUX in order to allow "B is being interviewed by Abrams."  So
;; just stamp AUX - on each of the non-copula uses of this type.
;;
basic_prd_cat := prd_or_adv_cat &
  [ HEAD v_or_a_or_p ].

; DPF 18-oct-03 - Restricted prd_cat to phrases which can modify nouns, in 
; order to avoid spurious ambiguity for e.g. prepositions that are lexically
; split between noun-modifying and verb-modifying, as "make the check to Kim".
; DPF 01-sept-06 - Added SPR *cons* to block infinitival relatives as
; ordinary prd_cats, to block spurious analysis for e.g. "Kim turned out to
; be tall", while still allowing such relatives to appear as complements of
; the copula 'be' as in "Kim is to be elected."
; DPF 27-sept-06 - Re 01-sept-06: But this prevents "Kim got very tall", so
; instead require AUX -, which still blocks infinitival relatives.

prd_cat := basic_prd_cat &
  [ HEAD [ MOD < [ LOCAL.CAT.HEAD basic_noun ] >,
           TAM.TENSE untensed,
	   AUX - ] ].

basic_pp_cat := cat &
  [ HEAD prep_or_modnp,
    VAL [ SPR *olist*,
          COMPS < > ],
    MC na ].

; Only for complements of verbs, to avoid spurious ambiguity (e.g with 'into')
pp_cat := basic_pp_cat &
  [ HEAD [ MOD < [ LOCAL.CAT.HEAD verb ] >,
           PRD + ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Linking Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Linking types specify the relationship between valence positions and 
;; semantic roles.

linking_type := lex_synsem.

atrans_lt := linking_type &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN no_role_rel,
                  VAL.SUBJ < [ --SIND it-ind & #subjind ] > ],
            CONT.HOOK.XARG #subjind ],
    LKEYS.--+ARGIND it-ind ].

arg1_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ --MIN nom_or_mnp_rel,
                             --SIND #subjind & basic_non_expl,
			     LOCAL.CONT.HOOK.LTOP #ltop ] >,
            CONT.HOOK [ LTOP #ltop,
			XARG #subjind ] ],
    LKEYS.KEYREL arg1_relation & [ ARG1 #subjind ] ].

; DPF 12-Mar-03 - As per agreement with AAC, changed treatment of unaccusatives
; so they introduce an ARG1, not an ARG2 - they are to be related to their
; causative alternation (if any) via lexical rule which introduces an 
; additional cause_rel.
; unacc_lt := arg1_subj_lt.

basic_arg12_lt := arg1_subj_lt & 
  [ LOCAL.CAT.VAL.COMPS 
            < [ --SIND #objind & basic_non_expl ], ... >,
    LKEYS.KEYREL arg12_relation & [ ARG1 non_expl-ind,
				    ARG2 #objind ] ].

arg12_lt := basic_arg12_lt &
  [ LOCAL.CAT.VAL.COMPS 
            < [ LOCAL.CONT.HOOK.LTOP #lbl ], ... >,
    LKEYS.KEYREL.LBL #lbl ].

trans_lt := arg12_lt &
  [ LKEYS.KEYREL.ARG2 basic_non_expl-ind ].

arg12h_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], ... >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel &
	         [ ARG1 non_expl-ind,
		   ARG2 handle & #mhand ] ].

; Maybe only for main verb "have" and for possessive "got"

poss_lt := linking_type &         
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.LTOP #lbl,
			       --SIND #subjind & non_expl-ind ] >,
		      COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #objind & 
						    non_expl-ind ] ], ... > ],
	    CONT [ HOOK [ INDEX #arg0,
                          XARG #subjind ],
                   RELS <! arg12_relation & 
                         [ LBL #lbl,
			   ARG0 #arg0,
                           ARG1 #subjind,
                           ARG2 #objind ] !> ] ] ].

expl_obj_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND it-ind ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS [ KEYREL #keyrel & [ ARG1 non_expl-ind ],
	    --+ARGIND it-ind ] ].

; 'prefer it if ...'
; 'make it clear that ...'
expl_obj_cp_lt := expl_obj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    [ LOCAL.CONT.HOOK [ LTOP #vhand ] ],
			    ... >,
            CONT [ HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & [ ARG2 handle & #mhand ] ].

expl_obj_prdp_lt := expl_obj_lt & basic_control_expr_lt &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #objind ], 
                            #keycomp &
                            [ LOCAL.CONT.HOOK.XARG #objind ],
                            ... >,
                    KCMP #keycomp ],
    LKEYS.KEYREL arg12_relation ].

particle_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ --MIN event_rel,
                              LOCAL.CONT.HOOK [ LTOP #vhand ] ], ... >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG1 non_expl-ind,
					      ARG2 handle & #mhand ] ].

particle_pp_cp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ --MIN selected_rel,
			      --SIND #cind & basic_non_expl ],
			    [ --MIN event_rel,
                              LOCAL.CONT.HOOK.LTOP #vhand ], ... >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG1 non_expl-ind,
					      ARG2 #cind,
					      ARG3 handle & #mhand ] ].

particle_oeq_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem,
                              [ --SIND #index & non_expl-ind ],
			      #comp &
			      [ LOCAL.CONT.HOOK [ LTOP #chand,
						  XARG #index ] ] >,
                      KCMP #comp ],
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand, LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ ARG1 non_expl-ind,
					       ARG2 #index,
					       ARG3 handle & #mhand ] ].

; DPF 19-Oct-02 - Removed SORT entity from second COMPS, since want to
; allow "that gives me an hour"
;; DPF 2017-03-01 - Removed last vestiges of SORT non-time-sort, generalizing
;; to norm-entity-or-event for first complement.
;;
ditrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
                  < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #obj2ind & non_expl-ind &
					     [ SORT entity-or-nomevent ] ] ],
		    [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #objind & non_expl-ind &
					[ SORT entity-or-nomevent ]]], ... >],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG1 non_expl-ind,
				     ARG2 #objind,
                                     ARG3 #obj2ind ] ].

tritrans_lt := ditrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, *top*, 
			    [ --MIN v_event_rel,
                              LOCAL.CONT.HOOK [ LTOP #chand ] ],
				... >,
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg1234_relation & #keyrel & [ ARG4 handle & #mhand ] ].

basic_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			< [ --MIN prep_rel,
                            LOCAL [ CAT.HEAD.TAM #tam & [ TENSE no_tense,
                                                          ASPECT no_aspect ],
                                    CONT [ HOOK [ INDEX [ E #tam,
                                                          --TPC #tpc ],
                                                  XARG #index ] ] ] ],
			  ... >,
            CONT [ HOOK.INDEX #index & [ --TPC #tpc ],
		   RELS.LIST < #keyrel, ... > ] ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].

prep_intrans_lt := basic_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
            CONT [ HOOK.LTOP #ltop,
                   RELS <! relation !> ] ] ].

prep_intrans_nosubj_lt := basic_prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
    LKEYS.KEYREL.LBL #ltop ].

;; DPF 14-Sept-00 - This type does not conform to our assumption that only 
;; handles, indices, and external arguments of COMPS synsems can be referred 
;; to in semantic construction.  But we believe we have a better analysis on 
;; the way which collapses these collocation constructions into a more general
;; account of multi-word expressions, so we allow the hack for now.
;; DPF 24-jun-08 - Re 14-Sept-00: Now fixed.

basic_empty_prep_intrans_lt := arg1_subj_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
                            LOCAL [ CAT.HEAD.PRD -,
				    CONT.HOOK.LTOP #lbl ] ], ... >,
    LKEYS.KEYREL [ LBL #lbl,
		   ARG1 non_expl-ind ] ].
		   
empty_prep_intrans_lt := basic_empty_prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #objind & 
                                                  non_expl-ind ], ... >,
    LKEYS.KEYREL arg12_relation & [ ARG2 #objind ] ].

; Kim gave to worthy causes
empty_prep_intrans_arg3_lt := basic_empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #objind & 
						    non_expl-ind ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ ARG3 #objind ] ].

; Argument coercion as in "Kim suggests on Friday"
prep_intrans_event_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS 
			 < [ --MIN prep_rel,
                             LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                    ASPECT no_aspect ],
                                     CONT.HOOK [ LTOP #ltop,
                                                 INDEX #event ] ] ], ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel & arg12_relation & [ ARG1 non_expl-ind,
					      ARG2 #event ] ].

prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --SIND #objind ], 
                            [ --MIN prep_rel,
			      LOCAL [ CAT.HEAD [ MOD < synsem_min >,
                                               TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ] ],
				      CONT.HOOK [ LTOP #cltop,
						  INDEX.SF prop,
						  XARG #objind ] ] ], ... >,
            CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #hand,
                                    LARG #cltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & arg123_relation & [ ARG3 handle & #hand ] ].

basic_empty_prep_trans_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ --MIN selected_rel,
				     LOCAL.CONT.HOOK [ LTOP #lbl,
						       INDEX #objind & 
							non_expl-ind ] ], ... >,
	    CONT.RELS.LIST.FIRST #keyrel ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ LBL #lbl,
					       ARG3 #objind ] ].

empty_prep_trans_lt := basic_empty_prep_trans_lt &
  [ LOCAL.CONT.RELS <! relation !> ].
		   
basic_prep_particle_intrans_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, [ LOCAL.CONT.HOOK.LTOP #ltop ], ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].
		   
prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ --MIN independent_rel ] > ].

empty_prep_particle_intrans_lt := basic_prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          [ --MIN selected_rel,
                            --SIND #arg2 & non_expl-ind ] >,
    LKEYS.KEYREL arg12_relation & [ ARG2 #arg2 ] ].

cp_trans_lt := basic_arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
			    [ --MIN event_rel,
                              LOCAL.CONT.HOOK [ LTOP #vhand ] ], 
			    ...>,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel &
	         [ ARG3 handle & #mhand ] ].

; "explain to Kim that ..."
basic_pp_cp_lt := basic_empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ ],
			    [ --MIN event_rel,
                              LOCAL.CONT.HOOK [ LTOP #vhand ] ],
			    ... >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #chand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel &
	         [ ARG2 handle & #chand ] ].

pp_cp_lt := basic_pp_cp_lt &
  [ LOCAL.CAT.VAL.COMPS.FIRST.--SIND #index,
    LKEYS.KEYREL.ARG3 #index ].

double_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ] ] ], 
                            [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #event ] ] ], ... >,
            CONT [ HOOK [ LTOP #ltop,
			  INDEX #event ],
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel ].


double_pp_empty_pp_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN prep_rel,
                              LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
                                                     ASPECT no_aspect ],
                                      CONT.HOOK.LTOP #ltop ] ], 
                            [ --MIN selected_rel,
			      LOCAL.CONT.HOOK [ LTOP #ltop,
						INDEX #objind & 
						     non_expl-ind ] ], ... >,
            CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG2 #objind ] ].

arg12_double_pp_lt := arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                          [ --MIN selected_rel,
                            --SIND #ind1 & non_expl-ind ], 
                          [ --MIN selected_rel,
			    LOCAL.CONT.HOOK [ LTOP #lbl,
					      INDEX #ind2 & 
						   non_expl-ind ] ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ LBL #lbl,
			     ARG3 #ind1,
			     ARG4 #ind2 ] ].

; DPF 24-jun-08 - FIX: should make this a subtype of arg1_subj_lt ...
s_equi_lt := linking_type &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK 
					[ LTOP #lbl,
					  INDEX #index & non_expl-ind ],
			     --SIND #index ] >,
	    CONT.HOOK.XARG #index ],
    LKEYS.KEYREL arg12_relation &
	         [ LBL #lbl,
		   ARG1 #index & non_expl-ind ] ].

equi_prd_lt := linking_type & 
  [ LOCAL [ CAT.VAL.KCMP [ --MIN independent_rel,
                           --SIND #event ],
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ ARG2 #event ] ].

; ERB (14-12-97) Subj_equi verbs now require that their complement have
; a pro_ss subject.  This might be redundant if some other supertype of
; all equi verbs requires prpstn_m_rel on the complement.

; ERB (21-01-98) This pro_ss needs to be constrained to be unslashed.

subj_equi_lt := s_equi_lt &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #xarg ] >,
                    KCMP.LOCAL.CONT.HOOK.XARG #xarg ] ].

; 'try to leave'
subj_equi_inf_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT [ HOOK [ LTOP #vhand,
					     INDEX.SF prop-or-comm ] ],
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG2 handle & #mhand ] ].

subj_equi_prp_or_bse_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
                                           INDEX [ E.TENSE no_tense,
                                                   SF prop-or-comm ] ],
            CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG2 handle & #chand ] ].

obj_equi_prp_lt := subj_equi_lt &
  [ LOCAL [ CAT.VAL [ KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
                                             INDEX [ E.TENSE no_tense,
                                                     SF prop-or-comm ] ],
                      COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #lbl,
						    INDEX #ind ] ],
            CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #lbl,
			     ARG2 #ind,
			     ARG3 handle & #chand ] ].

; ERB (14-12-97) comp's subj is a pro_ss.  This is probably redundant since
; the to_c_prop will say that its subject is a pro_ss.

; ERB (21-01-98) The pro_ss needs to be constrained to be unslashed.

; 'persuade Kim to leave'
obj_equi_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK 
					   [ LTOP #lbl,
					     INDEX #index & non_expl-ind ],
				--SIND #index ],
			      #comp &
			      [ LOCAL.CONT.HOOK.XARG #index ] >,
                      KCMP #comp ],
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg123_relation & #keyrel &
	         [ LBL #lbl,
		   ARG1 non_expl-ind,
		   ARG2 #index ] ].

;; DPF 27-oct-09 - Maybe collapse the following two types now?

; 'persuade Kim to leave'
obj_equi_inf_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #vhand,
					   INDEX.SF prop-or-comm ],
            CONT [ HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL.ARG3 handle & #mhand ].

; 'help Kim leave'
obj_equi_bse_lt := obj_equi_lt &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL [ CAT.VAL.SUBJ < unexpressed_reg >,
                                 CONT.HOOK [ LTOP #vhand,
                                             INDEX.SF prop-or-comm ] ],
            CONT [ RELS <! relation !>,
                   HCONS <! qeq & [ HARG #mhand,
                                    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL.ARG3 handle & #mhand ].

basic_prd_comp_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
		      KCMP.LOCAL.CONT [ HOOK.LTOP #chand ] ],
            CONT [ HOOK.XARG #subjind,
                   RELS <! #keyrel !>,
		   HCONS <! qeq & [ LARG #chand ] !> ] ],
    LKEYS.KEYREL #keyrel ].

prd_comp_lt := basic_prd_comp_lt &
  [ LOCAL [ CAT.VAL.KCMP [ --MIN independent_rel,
			   --SIND.E.TENSE untensed ],
	    CONT.ICONS <! !> ] ].

obj_equi_sel_lt := arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK 
					 [ LTOP #lbl,
					   INDEX #cindex & non_expl-ind ] ], 
                            [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #c2index &
						      non_expl-ind ] ] >,
            CONT [ RELS <! #keyrel !>,
		   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel &
	         [ LBL #lbl,
		   ARG1 non_expl-ind,
		   ARG2 #cindex,
		   ARG3 #c2index ] ].

pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					       INDEX #arg2 ] ],
			   [ LOCAL.CONT.HOOK [ LTOP #chand ] ] >,
	   CONT [ RELS <! #keyrel !>,
		  HCONS <! qeq & [ HARG #arg3, LARG #chand ] !>,
		  ICONS <! !> ] ],
   LKEYS.KEYREL arg123_relation & #keyrel &
	        [ LBL #lbl,
		  ARG1 non_expl-ind,
		  ARG2 #arg2,
		  ARG3 handle & #arg3 ] ].

; 'consider Kim wise'

obj_equi_prd_lt := prd_comp_lt & obj_equi_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN basic_nom_or_mnp_rel,
			      LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #index ] ],
                            [ LOCAL.CONT.HOOK.XARG #index ] >,
            CONT [ HCONS <! [ HARG #arghand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL [ LBL #lbl,
		   ARG3 handle & #arghand ] ].

; 'promise Kim to leave'
anom_equi_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND #subjind ] >,
                      COMPS < [ LOCAL.CONT.HOOK 
					   [ LTOP #lbl,
					     INDEX #objind & non_expl-ind ] ],
			      [ LOCAL.CONT.HOOK [ LTOP #vhand,
						  XARG #subjind ] ] > ],
            CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel &
          [ LBL #lbl,
	    ARG3 handle & #mhand,
            ARG2 #objind ] ].

; 'turn out unreliable' (also resultatives like 'turned up drunk')
anom_equi_prd_lt := equi_prd_lt & s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ LOCAL.CONT.HOOK.INDEX #index ] >,
                  KCMP #comp,
		  COMPS < *top*,
			  #comp &
			  [ LOCAL.CONT.HOOK [ LTOP #vhand,
                                              XARG #index ] ] > ],
            CONT [ HCONS <! qeq & [ HARG #mhand,
				    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL.ARG3 #mhand ].

; 'turn out to be red'
anom_equi_particle_lt := s_equi_lt &
  [ LOCAL [ CAT.VAL 
		[ SUBJ < [ --SIND #index ] >,
		  COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ],
                          [ LOCAL.CONT.HOOK [ LTOP #vhand,
					      XARG #index ] ] > ],
            CONT [ HOOK [ LTOP #ltop ],
		   RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #mhand,
                                    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG2 handle & #mhand ] ].

basic_control_expr_lt := linking_type &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK [ LTOP #chand,
                                           INDEX.SF prop-or-comm ],
	    CONT [ RELS <! #keyrel !>,
                   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG2 handle & #mhand ] ].

;; DPF 2020-03-24 - Reversed LKEYS..ARG1,ARG2 as per trunk.
;;
ssr_expr_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.--SIND #ind,
		      COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #ppind ] ],
                            [ LOCAL.CONT.HOOK [ LTOP #cltop ] ] > ],
            CONT [ HOOK.XARG #ind,
		   RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #arg, LARG #cltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #lbl,
			     ARG1 #arg,
			     ARG2 #ppind & non_expl ] ].

basic_seq_prdp_expr_lt := basic_control_expr_lt &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.LTOP #lbl,
			       --SIND #subjind ] >,
                      KCMP #comp,
                      COMPS < #comp,
                              [ --MIN #ocmin & selected_rel,
                                --SIND #arg ],
                              ... > ],
            CONT.HOOK.XARG #subjind ],
    LKEYS [ KEYREL [ LBL #lbl,
		     ARG1 #subjind,
		     ARG3 #arg & non_expl-ind ],
            --OCOMPKEY #ocmin ] ].

; 'need not'
subj_rais_bse_n3sg_lt := linking_type &
  [ LOCAL [ CAT.VAL [ KCMP.LOCAL.CONT.HOOK [ LTOP #hand,
					     INDEX [ E.TENSE no_tense,
						     SF prop-or-comm ],
					     XARG #xarg ],
		      SUBJ.FIRST.--SIND #xarg ],
            CONT [ HOOK [ LTOP #ltop,
			  XARG #xarg ],
                   RELS <! #keyrel & [ LBL #vtop ],
                           #altkeyrel &
                           [ LBL #ltop,
                             ARG1 #arg ] !>,
                   HCONS <! qeq &
			   [ HARG #chand,
			     LARG #hand ],
                            qeq &
			   [ HARG #arg,
			     LARG #vtop ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL #keyrel & [ ARG1 handle & #chand ],
            ALTKEYREL #altkeyrel ] ].

seq_prdp_expr_lt := basic_seq_prdp_expr_lt &
  [ LKEYS.--OCOMPKEY _to_p_sel_rel ].

sor_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK 
					  [ LTOP #lbl,
					    INDEX #index & non_expl-ind ],
			       --SIND #index ] >,
                      COMPS < [ LOCAL.CONT.HOOK.LTOP #lbl ],
                              [ LOCAL.CONT.HOOK [ LTOP #chand ] ] > ],
            CONT [ HOOK.XARG #index,
                   RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #arg,
				    LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel &
	         [ LBL #lbl,
		   ARG1 #index,
		   ARG2 handle & #arg ] ].

sor_prop_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK 
					  [ LTOP #lbl,
					    INDEX #index & non_expl-ind ],
			       --SIND #index ] >,
                      COMPS < synsem,
                              [ LOCAL.CONT.HOOK [ LTOP #chand,
                                                  INDEX.SF prop-or-comm ] ] > ],
	    CONT [ HOOK.XARG #index,
                   RELS <! #keyrel !>,
                   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ LBL #lbl,
					      ARG1 #index,
					      ARG2 handle & #mhand ] ].

basic_expl_it_subj_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.LTOP #hand,
                               --SIND it-ind & #subjind ] >,
                      KCMP.LOCAL.CONT.HOOK.LTOP #chand ],
            CONT [ HOOK.XARG #subjind,
                   HCONS.LIST < qeq & [ HARG #mhand, LARG #chand ], ... >,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg1_relation &
          [ LBL #hand,
            ARG1 handle & #mhand ] ].

expl_it_subj_lt := basic_expl_it_subj_lt &
  [ LOCAL.CONT [ HCONS <! qeq !>, ICONS <! !> ] ].

expl_it_subj_np_cp_lt := basic_expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK 
					 [ LTOP #lbl,
					   INDEX #arg2 & non_expl-ind ]], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg12_relation & #keyrel &
                        [ LBL #lbl,
			  ARG2 #arg2 ] ].

expl_it_subj_cp_cp_lt := basic_expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #chand ] ], 
			    synsem >,
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq, qeq & [ HARG #mhand, LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ ARG2 #mhand ] ].

expl_it_subj_np_vp_lt := basic_expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #arg2 & non_expl-ind ] ],
			    [ LOCAL.CONT.HOOK.XARG #arg2 ] >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg12_relation & #keyrel &
                        [ LBL #lbl,
			  ARG2 #arg2 ] ].

; take, cost
expl_it_subj_np_np_cp_or_vp_lt := expl_it_subj_np_cp_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #ind ] ],
			    ... >,
	    CONT [ HCONS <! qeq !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation &
                        [ LBL #lbl,
			  ARG3 #ind ] ].

; cost: "It will cost (me) ten dollars for you to come along"
expl_it_subj_np_np_cp_lt := expl_it_subj_np_np_cp_or_vp_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT.VAL.SUBJ < anti_synsem_min > ].

; cost, take: "it took me ten minutes to leave"
expl_it_subj_np_np_vp_lt := expl_it_subj_np_np_cp_or_vp_lt &
  [ LOCAL.CAT.VAL [ COMPS < [ --SIND #ind ], ... >,
                    KCMP.LOCAL.CONT.HOOK.XARG #ind ] ].

; make: "it makes him angry that S"
expl_it_subj_np_prdp_cp_lt := expl_it_subj_np_cp_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ LOCAL.CONT.HOOK [ LTOP #lbl ] ],
			    ... >,
	    CONT [ HCONS <! qeq, qeq & [ HARG #harg, LARG #lbl ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation &
	         [ ARG3 #harg ] ].

;; "It ticked him off that S"
expl_it_subj_np_ptcl_cp_lt := expl_it_subj_np_cp_lt &
  [ LOCAL.CONT [ HCONS <! qeq !>,
		 ICONS <! !> ] ].

expl_it_subj_pp_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #arg ] ], ... >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg12_relation & #keyrel &
                        [ LBL #lbl,
			  ARG2 #arg & non_expl-ind ] ].

expl_it_subj_prtcl_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, synsem >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg1_relation & #keyrel ].

; 'It follows that ..."
expl_it_subj_cp_lt := expl_it_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL arg1_relation & #keyrel ].

expl_pp_inf_lt := arg1_subj_lt &
 [ LOCAL [ CAT.VAL [ COMPS < [ --SIND it-ind ],
                             [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                 INDEX #arg ] ],
			       [ LOCAL.CONT.HOOK [ LTOP #chand ] ] > ],
	   CONT [ HOOK [ LTOP #ltop ],
		  RELS <! #keyrel !>,
		  HCONS <! qeq & [ HARG #mhand, LARG #chand ] !>,
		  ICONS <! !> ] ],
   LKEYS [ KEYREL arg123_relation & #keyrel &
		  [ ARG1 non_expl-ind,
		    ARG2 #arg,
		    ARG3 handle & #mhand ],
           --+ARGIND it-ind ] ].

; 'leave it to Kim to find the answer'

expl_pp_inf_oeq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL.COMPS < *top*,
			 [ LOCAL.CONT.HOOK.INDEX #arg ],
			 [ LOCAL.CONT.HOOK.XARG #arg ] > ].

; 'arrange with Kim to meet her'

pp_inf_seq_lt := pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #arg1 ] >,
		   COMPS < *top*,
			   [ LOCAL.CONT.HOOK.XARG #arg1 ] > ] ].

; 'arrange it with Kim to meet her'
;
expl_pp_inf_seq_lt := expl_pp_inf_lt &
 [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #arg1 ] >,
		   COMPS < *top*,
			   *top*,
			   [ LOCAL.CONT.HOOK.XARG #arg1 ] > ] ].

; suffice
atrans_inf_lt := linking_type &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.--SIND #sind & it-ind,
		      COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] > ],
	    CONT [ HOOK.XARG #sind,
		   RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL arg12_relation & #keyrel & [ ARG2 handle & #arg ],
	    --+ARGIND it-ind ] ].

particle_np_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN selected_rel ],
                            [ LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #index & non_expl-ind ] ], ... >,
	    CONT.RELS.LIST.FIRST #keyrel ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ LBL #lbl,
					      ARG1 non_expl-ind,
					      ARG2 #index ] ].

basic_np_particle_lt := arg1_subj_lt & 
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK
                                         [ LTOP #ltop,
					   INDEX #index & non_expl-ind ] ], 
			    synsem, ... >,
	    CONT [ HOOK.LTOP #ltop,
		   RELS.LIST < #keyrel, ... > ] ],
    LKEYS.KEYREL arg12_relation & #keyrel & [ LBL #ltop,
					      ARG1 non_expl-ind,
					      ARG2 #index ] ].

np_particle_lt := basic_np_particle_lt &
  [ LOCAL.CONT.RELS <! relation !> ].

np_particle_pp_lt := np_particle_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem,
                            synsem &
                            [ --MIN selected_rel,
			      LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #objind & non_expl-ind ] ], ... >],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG3 #objind ] ].

np_particle_np_lt := np_particle_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          synsem,
                          synsem &
                          [ LOCAL.CONT.HOOK 
				    [ LTOP #lbl,
				      INDEX #objind & non_expl-ind ] ], ... >,
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG3 #objind ] ].
		   
basic_np_particle_cp_lt := basic_np_particle_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            synsem,
                            synsem &
                            [ LOCAL.CONT.HOOK.LTOP #cltop ], ... >,
	    CONT [ HCONS <! qeq & [ HARG #arg3,
				    LARG #cltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & [ ARG3 #arg3 ] ].

np_particle_cp_lt := basic_np_particle_cp_lt &
  [ LOCAL [ CAT.VAL.COMPS.FIRST [ --SIND #xarg,
				  LOCAL.CONT.HOOK.XARG #xarg2 ],
	    CONT [ HOOK.XARG #xarg,
		   RELS <! relation, #altkeyrel !> ] ],
    LKEYS [ KEYREL.LBL #lbl,
	    ALTKEYREL #altkeyrel & [ LBL #lbl,
				     PRED id_rel,
				     ARG1 #xarg & [ PNG #png ],
				     ARG2 #xarg2 & [ PNG #png ] ] ] ].

poss_idiom_lt := linking_type &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CONT.HOOK.XARG #xarg,
    LKEYS [ KEYREL.LBL #lbl,
	    ALTKEYREL [ LBL #lbl,
			PRED id_rel,
			ARG1.PNG #png,
			ARG2 #xarg & [ PNG #png ] ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Val Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Valence types specify the number and type of subcategorized complements.
  
valence_type := canonical_synsem.

unsat_subst := valence_type &
  [ LOCAL.CAT.VAL.SUBJ < synsem_min & [ LOCAL [ CAT nomp_cat_min,
                                                CONJ cnil ],
                                        --SIND basic_non_event ] > ].
intrans_subst := one_arg & unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < > ].

unsat_two_arg_subst := unsat_subst & abstr_lex_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ --MIN #cmin,
                                     PUNCT.LPUNCT pair_or_no_punct ], ... >,
    LEX +,
    LKEYS.--COMPKEY #cmin ].

two_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < *top* > ].

norm_two_arg_subst := two_arg_subst & basic_two_arg.

; For verbs that passivize.
; 21-Apr-00 Changed np_cat_acc_min to nomp_cat_acc_min for e.g. "kim liked 
; hiring abrams"
; DPF 29-May-01 - Removed COMPS..MSG no_msg, since this blocked
; acc-gerunds as in "I resent you giving him that" -- later reconsidered?
; DPF 26-May-03 - We don't have one obvious place to state the constraint that
; VPs are REL empty (no pied piping within VP - Ross 67?), so let's at least
; catch a good bunch of cases with this type.
;; DPF 2016-12-10 - Constrained COMPS.FIRST.SORT to be norm-entity-or-event,
;; to exclude nominalized WH-clauses, to avoid spurious ambiguity for
;; *we know why he arrived*.
;; DPF 2017-02-21 - Re 2016-12-10: But this prevents *we know his name and
;; who he hired*, so generalize to basic-entity-or-event, and live with the
;; spurious ambiguity for now.  FIX?
;;
trans_subst := unsat_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     NONLOC.REL 0-dlist,
                                     --SIND basic_non_event &
  				     [ SORT basic-entity-or-event ] ], ... > ].
  
np_trans_subst := trans_subst & norm_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem >,
	    CONT [ HCONS <! !>,
		   ICONS <! !> ] ] ].
  
; For verbs with nominal complement but that don't passivize.
non_trans_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL.CONJ cnil,
                                     NONLOC.REL 0-dlist ], ... > ].
  
;; DPF 2016-04-21 - Changed complement from nomp_cat_nonnom_min to 
;; nomp_cat_acc_min to block spurious NP-CP analysis of complement in
;; **we thought why he arrived*
;; DPF 2016-08-05 - Re 2016-04-21: But this blocks *we left town* because we
;; make the bare singular NPs be nonnom.  So push this case constraint down to
;; subtypes.
;;
np_non_trans_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & 
                          [ LOCAL.CAT nomp_cat_min,
                            --SIND index ] > ].

; became president
;; DPF 2012-12-21 - Block spurious non-empty SLASH
;; DPF 2016-07-04 - Restrict compl to SPR unexpressed, to avoid spurious
;; analysis for *Kim became competent*
;;
nbar_subst := non_trans_subst & two_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem & 
                          [ --MIN norm_nom_rel,
                            LOCAL.CAT nbar_cat_min,
			    NONLOC.SLASH 0-dlist ] > ].

basic_cp_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp &
                         [ LOCAL.CAT.HEAD.TAM.TENSE real_tense ],
                    COMPS < #comp & synsem &
			    [ LOCAL [ CAT basic_s_cat_v_c,
				      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              OPT - ] > ] ].

; Impose constraints stored in --ADDIN for base_or_non3sg verb
; Note that this has to allow for exceptional behavior for e.g.
; `demand that he be hired' where we don't what these --ADDIN constraints
cp_addin_tam_pn := synsem &
  [ LOCAL.CAT.VAL.KCMP.LOCAL [ CAT.HEAD [ TAM #tam,
					  --ADDIN [ ADDTAM #tam,
						    ADDPN #pn ] ],
			       AGR.PNG.PN #pn ] ].

cp_intrans_subst := basic_cp_intrans_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_v_c ].

; For input to nom-gerund lexical rule
basic_prep_intrans_subst := two_arg_subst.

prep_intrans_subst := basic_prep_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ],
                            NONLOC.REL 0-dlist ] > ].

unsat_three_arg_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem & [ --MIN #ocmin ], ... >,
    LKEYS.--OCOMPKEY #ocmin ].

basic_three_arg_subst := unsat_three_arg_subst & basic_three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ NONLOC.REL 0-dlist ] > ].

three_arg_subst := unsat_three_arg_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ NONLOC.REL 0-dlist ] > ].

three_arg_trans_subst := three_arg_subst & trans_subst.

;; DPF 2013-02-05 - Don't unify the --SLTOP of the second complement, which is
;; usually scopal.
;; DPF 2015-08-17 - Re 2013-02-05: See comment [DPF 2015-08-20] above on why
;; we have restored this identity.
;;
basic_three_arg_trans_subst := unsat_three_arg_subst & generic_three_arg &
			       trans_subst &
  [ LOCAL.ARG-S < [ NONLOC.SLASH [ LIST #smiddle2,
                                   LAST #slast ] ],
                  [ NONLOC.SLASH [ LIST #sfirst,
                                   LAST #smiddle1 ] ],
                  [ NONLOC.SLASH [ LIST #smiddle1,
                                   LAST #smiddle2 ] ] >,
    NONLOC.SLASH [ LIST #sfirst,
                   LAST #slast ] ].

three_arg_nontrans_subst := three_arg_subst & non_trans_subst.
basic_three_arg_nontrans_subst := basic_three_arg_subst & non_trans_subst.

three_arg_raising_subst := basic_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event ], ... > ].

; DPF 17-sept-07 - Restricted PP compl to be non-nmod, to disambiguate e.g.
; "to" as in "bring X to Y"

basic_prep_trans_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event ], 
                          synsem &
                          [ LOCAL [ CAT [ HEAD prep_or_modnp,
                                          VAL [ SPR *olist*,
                                                COMPS < > ],
                                          MC na ],
                                    CONJ cnil ] ] > ].
  
prep_trans_subst := basic_prep_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem &
                          [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD noun ]>] > ].

prep_non_trans_subst := three_arg_nontrans_subst & 
  [ LOCAL.CAT.VAL.COMPS < lex_synsem & [ LOCAL [ CAT nomp_cat_acc_min,
                                                 CONJ cnil ],
                                         --SIND index,
                                         LEX + ],
			  synsem &
			  [ LOCAL [ CAT basic_pp_cat,
				    CONJ cnil ] ] > ].
  
; DPF 15-Apr-02 - Maybe none of these obj_equi_prd verbs should passivize, 
; since the control of the predicative phrase is already the syntactic subject
; when the PrdP is just a VP modifier rather than a complement.  We'll try 
; making all of them prd_non_trans.
; DPF 11-sep-09 - Exclude gerunds as first complements, to avoid spurious
; analysis for e.g. "he likes going on vacation"
; DPF 14-may-10 - Re 11-sep-09: But this blocks "they got parsing right."
; so remove [ SORT entity ] constraint from first complement.
;; DPF 2013-02-06 - Add COMPS..MOD..HEAD noun to avoid ambig of preps like
;; `to' with double entries.
;; DPF 2018-03-18 - Make second comp NORM norm_rel to prevent noun-modifying
;; subord clauses, as in *we thought Kim before we arose*
;;
basic_prd_subst := unsat_three_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event,
                                     OPT - ], 
			  synsem & 
			  [ LOCAL [ CAT prd_cat &
                                        [ HEAD [ MOD < [ --MIN norm_rel,
							 LOCAL.CAT.HEAD noun,
							 OPT + ] >,
						 MINORS.NORM norm_rel ] ],
				    CONJ cnil ],
			    OPT - ], ... > ].

prd_trans_subst := basic_prd_subst & trans_subst.
; DPF 14-mar-05 - Constraining NP to be definite, to block annoying spurious
; parses for e.g. "I have a meeting on Tuesday".
; DPF 20-mar-05 - But this also blocks "I have a lot of mornings free" and
; "I'll get a room ready".  So it seems we have to pay this price with
; ambiguity. Sigh.
prd_non_trans_subst := basic_prd_subst & non_trans_subst & 
		       basic_three_arg_subst.

; Removed nonpro_rel from second NP, since we want to get "sell me this" and
; maybe even "sell me them" even if not "*sell Abrams it"
; DPF 2-Jun-02 - Put this back, since deictics no longer pron_rel.  We do give
; up "sell me them", but we really don't want "sell the customers it".
; DPF 21-may-04 - Changed nonpro_rel to nonpro_or_num_rel, consistent with
; recent treatment of number nouns.
; DPF 24-feb-05 - And then further generalized to nonpro_or_refl_or_num_rel,
; so we still get ditrans reading for "Abrams gave Browne himself"
;; DPF 2014-12-08 - Red 2-Jun-02: But blocking pronouns altogether means we
;; don't parse *the advice given him by his mentor*, and also not 
;; *she gave me them* which sounds okay in context.  So let's back off of
;; making this a sharp ungrammaticality divide, and assume that other more
;; graded principles of accessibility will deprecate pronouns as second NPs
;; in NP-NP datives.  Changed COMPS.REST.FIRST.--MIN to basic_nom_or_mnp_rel
;; from nonpro_or_refl_or_num_rel.
;;
basic_ditrans_subst := basic_three_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & 
                          [ LOCAL.CONJ cnil,
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist ], 
			  synsem & 
                          [ LOCAL.CONJ cnil,
                            --MIN basic_nom_or_mnp_rel,
                            --SIND basic_non_event ] > ].
  
;; DPF 18-feb-10 - We want to catch "She taught student the lesson", so
;; remove --BARE - from first daughter, and see what happens.
;; DPF 2016-05-02 - Also want to catch *can you give me a cheaper prices?*,
;; so would like to remove --BARE - from second dtr as well.  But then we
;; get wrong ranking for *should I show the train ticket*, so push this
;; 'default' down to the subtypes, and make special robust type for `give'.
;;
ditrans_subst := basic_ditrans_subst & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT nomp_cat_acc_min ],
                            [ LOCAL.CAT nomp_cat_acc_min ] >,

            CONT [ RELS <! #keyrel !>,
		   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel ].
  
; 'elected him president'
ditrans_np_nbar_subst := basic_ditrans_subst & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                            [ --MIN norm_nom_rel,
                              LOCAL [ CAT nbar_cat_min,
                                      CONT.HOOK [ LTOP #nhand,
                                                  INDEX #arg ] ],
                              NONLOC.SLASH 0-dlist ] >,
            CONT [ RELS <! relation, 
			   #altkeyrel &
                           [ PRED udef_q_rel,
                             ARG0 #arg & ref-ind,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].
                                           
  
; 'see picture, page 2'
ditrans_nbar_np_subst := basic_ditrans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT nbar_cat_min,
                                      CONT.HOOK [ LTOP #nhand,
                                                  INDEX #arg ] ],
                              NONLOC.SLASH 0-dlist ],
                            [ LOCAL.CAT nomp_cat_acc_min ] >,
            CONT [ RELS <! relation, 
			   #altkeyrel &
                           [ PRED udef_q_rel,
                             ARG0 #arg & ref-ind,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

  
; 'inform Kim that S'
basic_cp_trans_subst := basic_three_arg_trans_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event,
				       OPT - ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_unspec,
				      CONJ cnil ],
                              OPT - ] > ] ]. 
  
; Impose MC - on complement
cp_trans_subst := basic_cp_trans_subst &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_v_c ].

basic_pp_cp_subst := basic_three_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem &
			    [ LOCAL [ CAT basic_pp_cat,
				      CONJ cnil ] ],
			    #comp & synsem &
			    [ LOCAL [ CAT.MC bool,
				      CONJ cnil ],
                              OPT - ] > ] ].
  
pp_cp_subst := basic_pp_cp_subst &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_or_inf_unspec &
				 [ MC - ] ].
  
np_comp_subst := basic_three_arg_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					     CONJ cnil ],
                                     --SIND basic_non_event,
                                     OPT - ],
			  [ LOCAL.CAT [ HEAD prep,
                                        VAL.COMPS < > ],
                            OPT - ] > ].
; 'talk to Kim about Sandy'
double_pp_subst := three_arg_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT pp_cat,
                                    CONJ cnil ] ], 
			  synsem &
			  [ LOCAL [ CAT [ HEAD prep_or_modnp,
                                          VAL [ SPR *olist*,
                                                COMPS < > ],
                                          MC na ],
				    CONJ cnil ] ] > ].
  
np_trans_double_pp_subst := four_arg & trans_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
                          synsem &
                          [ --MIN #ocmin & selected_rel,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist ], 
                          synsem &
                          [ --MIN selected_rel,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist ] >,
	    CONT [ HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.--OCOMPKEY #ocmin ].
  
;; DPF 2019-08-16 - Removed COMPS.FIRST.--SIND.E.TENSE no_tense,
;; so we can have robust *He began to arose*.  CHECK to see why this constraint
;; was not redundant in standard grammar.
;;
basic_inf_or_prp_intrans_subst := valence_type &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat,
                                      CONJ cnil ],
                              OPT - ] > ] ].

inf_or_prp_intrans_subst := basic_inf_or_prp_intrans_subst & 
                            unsat_two_arg_subst.

;; DPF 2013-09-03 - Changed COMPS..CAT to vp_inf_cat so its SUBJ gets to be a
;; `synsem' and hence the VP compplement avoids undergoing extraction.
basic_inf_intrans_subst := basic_inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT vp_inf_cat ] > ].

inf_intrans_subst := basic_inf_intrans_subst & unsat_two_arg_subst.

inf_intrans_from_subst := basic_inf_or_prp_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD.VFORM inf_from,
					VAL.SUBJ < synsem > ] ] > ].

inf_intrans_particle_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
                      COMPS < abstr_lex_synsem &
                              [ --MIN selected_rel,
                                LOCAL [ CAT.HEAD a_or_p,
					CONT.HOOK.LTOP #hand ],
                                NONLOC [ SLASH 0-dlist,
					 REL 0-dlist,
					 QUE 0-dlist ] ],
                              #comp & synsem &
                              [ LOCAL [ CAT vp_inf_cat,
                                        CONT.HOOK.LTOP #hand,
                                        CONJ cnil ] ] > ] ] ].

; for "I will try and find it" - analysis following Pullum and Gazdar

inf_intrans_and_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_and,
					    VAL.SUBJ < synsem > ],
                                      CONJ cnil ] ] > ] ].

; for "couldn't help but notice"
inf_intrans_but_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM inf_but,
					    VAL.SUBJ < synsem > ],
                                      CONJ cnil ] ] > ] ].


for_inf_intrans_subst := two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem & 
			  [ LOCAL [ CAT s_cat_v_c &
					[ HEAD comp &
                                               [ VFORM inf ] ],
				    CONT.HOOK.INDEX.SF prop,
                                    CONJ cnil ],
                            OPT - ] > ].

;; DPF 2020-05-15 - Tempting to constrain second comp to be canonical_synsem, 
;; to block extraction, but even though we don't have the semantics figured out,
;; we treat with right-node raising (hence extraction) the analysis of
;; *she is [[equipped and trained] to handle this]*
;;
inf_trans_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < [ OPT - ], 
                            #comp &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil ],
                              OPT - ] > ] ].

inf_trans_from_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < [ OPT - ], 
                            #comp & synsem &
                            [ LOCAL [ CAT vp_cat &
                                          [ HEAD.VFORM inf_from,
					    VAL.SUBJ < synsem > ],
                                      CONJ cnil ],
                              OPT - ] > ] ].

;; DPF 2020-05-15 - Tempting to constrain second comp to be canonical_synsem, 
;; to block extraction, but we use right-node raising for e.g.
;; *This was presumed or proven to be wrong*, so need extraction.
;;
inf_trans_raising_subst := basic_three_arg_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp, 
		    COMPS < *top*, 
			    #comp &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ] ] > ] ].

prp_intrans_subst := inf_or_prp_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD.VFORM prp,
					VAL.SUBJ < synsem > ] ] > ].

bse_intrans_subst := unsat_two_arg_subst & basic_two_arg &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < #comp & synsem &
			    [ LOCAL [ CAT vp_cat &
					  [ HEAD.VFORM bse ],
                                      CONJ cnil ],
                              --SIND.E.TENSE no_tense,
                              OPT - ] > ] ].

; 'make, let, watch' don't passivize.  Some of these have an apparently
; corresponding passive, but with an ordinary 'to-VP' complement, not vform bse
bse_nontrans_raising_subst := three_arg_raising_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem &
			  [ LOCAL [ CAT vp_bse_cat,
				    CONJ cnil ],
                            OPT - ] > ].

; want (doesn't passivize)
basic_inf_non_trans_subst := unsat_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL.CAT nomp_cat_acc_min,
                                       --SIND index ],
                            #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

inf_non_trans_subst := basic_inf_non_trans_subst & basic_three_arg_subst.

prp_non_trans_subst := basic_three_arg_subst & non_trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL.CAT nomp_cat_acc_min,
                                       --SIND index,
                                       OPT - ],
			    #comp & synsem &
			    [ LOCAL [ CAT vp_prp_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

basic_pp_vp_subst := valence_type &
  [ LOCAL.CAT.VAL [ KCMP #comp,
                    COMPS < synsem &
                            [ --MIN selected_rel,
                              LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              PUNCT.LPUNCT no_punct ],
                            #comp & synsem &
                            [ LOCAL [ CAT vp_cat,
                                      CONJ cnil ],
                              PUNCT.LPUNCT no_punct,
                              OPT - ], ... > ] ].

basic_pp_inf_subst := basic_pp_vp_subst &
  [ LOCAL.CAT.VAL [ KCMP.LOCAL.CAT vp_inf_cat,
		    COMPS < [], [] > ] ].

pp_inf_subst := basic_pp_inf_subst & unsat_three_arg_subst.

; We treat raising as the identification of the CONT attribute of the SUBJ and
; the COMPS.SUBJ, rather than the whole synsem, in part to enable the 
; underspecification of the base/non3sg lex-entry for verbs, where otherwise
; CASE information would clash in examples like "Kim believes Sandy to be 
; ready."  In fact, we only identify the INDEX of the two subjects - see 
; comments by sor_inf_subst.
; 
; DPF 17-Nov-99 - The LTOP handle of the SUBJ must be identified with the
; KEY.LBL of the ssr_subst predicate, since contracted negation auxiliary
; verbs have the LTOP be the neg_rel's handle, but the subject as in 
; "I can't leave" should have its LBL identified with that of the
; can_rel, not the neg_rel.
;;
subj_control_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind & basic_non_event ] >,
                    COMPS < [ LOCAL [ CAT.VAL.COMPS < >,
                                      CONT.HOOK.XARG #sind ],
                              OPT - ], ... > ] ].

ssr_subst := subj_control_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #xarg ] >,
            CONT.HOOK.XARG #xarg ] ].

ssr_two_arg_subst := ssr_subst & basic_two_arg.

;; DPF 2018-05-31 - Block extraction of VP complement.
;;
ssr_inf_subst := ssr_subst & inf_intrans_subst &
  [ LOCAL.CAT.VAL.COMPS.FIRST canonical_synsem ].

ssr_pp_inf_subst :=  basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
	   [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                        INDEX #subj ] ] >,
	     COMPS < synsem &
		     [ --MIN _to_p_sel_rel,
                       LOCAL [ CAT basic_pp_cat & 
                                   [ HEAD.MOD < > ],
                               CONJ cnil ] ] ,
		     [ LOCAL [ CAT [ HEAD comp & [ VFORM inf ],
                                     VAL [ SUBJ < synsem >,
					   COMPS < > ] ],
                               CONT.HOOK.XARG #subj ],
                       OPT - ] > ],
            CONT.HOOK.LTOP #ltop ] ].

seq_prdp_pp_subst := basic_three_arg_subst &
  [ LOCAL [ CAT.VAL 
            [ COMPS < [ LOCAL 
			[ CAT [ HEAD [ PRD +,
				       TAM.TENSE no_tense,
				       MOD < [ LOCAL intersective_mod,
					       OPT + ] > ],
				VAL [ SUBJ *olist*,
				      SPR *olist*,
				      COMPS < > ],
				MC na ],
			  CONT.HOOK.XARG #xarg ],
			OPT - ],
		      synsem &
		      [ LOCAL [ CAT basic_pp_cat &
				    [ HEAD.MOD < > ],
				CONJ cnil ] ] > ],
	    CONT.HOOK.XARG #xarg ] ].

expl_pp_cp_subst :=  basic_three_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ] ], 
                            synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

expl_np_cp_subst :=  basic_three_arg_subst & trans_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < [ OPT - ], 
                            synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD verbal &
							[ VFORM fin_or_inf,
							  MOD *anti_list* ],
                                                   VAL [ SUBJ *anti_list*,
							 COMPS < > ] ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].

expl_cp_cp_subst :=  basic_three_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c &
					  [ HEAD comp &
						 [ TAM #tam,
						   --ADDIN [ ADDTAM #tam,
							     ADDPN #pn ] ],
					    VAL.COMPS < > ],
				      AGR.PNG.PN #pn,
				      CONJ cnil ],
			      OPT - ],
                            canonical_synsem & #keycomp &
			    [ LOCAL [ CAT s_cat_fin_v_c &
					  [ HEAD comp,
					    VAL.COMPS < > ],
				      CONJ cnil ],
			      OPT - ] >,
                    KCMP #keycomp ] ].

;; *it annoys him to shave himself*
;;
expl_np_vp_subst :=  basic_three_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ COMPS < [ OPT - ], 
                            synsem & #keycomp &
			           [ LOCAL [ CAT vp_cat & 
                                                 [ HEAD.VFORM inf,
                                                   VAL.SUBJ < synsem > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].

four_arg_subst := unsat_three_arg_subst & four_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem & [ --MIN #ocmin,
                                     NONLOC.REL 0-dlist ],
                          synsem, ... >,
    LKEYS.--OCOMPKEY #ocmin ].

; 'cost/take' - restrict first NP to non-measure-NP, and the second to MNP.
; But this is too strong for second argument, since "a couple of days" is not
; analyzed as a MNP.
expl_np_np_cp_subst :=  four_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min &
                                          [ VAL.SPEC < anti_synsem_min > ],
				      CONJ cnil ],
                              --SIND basic_non_event ], 
			    synsem &
			    [ LOCAL [ CAT [ HEAD supnoun &
                                                 [ POSS -,
                                                   MOD *anti_list* ],
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ],
                                            MC na_or_- ],
				      CONJ cnil ] ], 
			    synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].
                                                 
expl_np_np_cp_inf_subst := expl_np_np_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
                          synsem,
                          [ LOCAL.CAT.HEAD.VFORM inf ] > ].

; `it matters a lot to him that S'
; 'he called it to their attention that S'
np_prep_cp_subst :=  four_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min &
                                          [ VAL.SPEC < anti_synsem_min > ],
				      CONJ cnil ],
                              --SIND basic_non_event ], 
			    synsem &
                            [ LOCAL [ CAT.HEAD prep_or_modnp,
				      CONJ cnil ] ],
			    synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].

np_pp_cp_subst :=  np_prep_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  [ LOCAL.CAT basic_pp_cat ],
			  synsem > ].

np_ptcl_cp_subst :=  np_prep_cp_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  abstr_lex_synsem & 
			  [ --MIN selected_rel,
			    NONLOC non-local_none ],
			  synsem > ].

; `makes him angry that S'
expl_np_np_prdp_cp_subst :=  prd_trans_subst & four_arg_subst & 
			     cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem,
			    synsem,
			    synsem & #keycomp &
			           [ LOCAL [ CAT cat & 
                                                 [ HEAD comp,
                                                   VAL.COMPS < > ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].
                                                 
;; "It ticked him off that ..."
;; "It put Kim off/out that ..."
expl_np_np_ptcl_cp_subst :=  np_ptcl_cp_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem,
			    synsem,
			    synsem & #keycomp &
			           [ LOCAL [ CAT s_cat_unspec &
						 [ HEAD comp ],
                                             CONJ cnil ],
                                     OPT - ] >,
                    KCMP #keycomp ] ].

;; cost/take: *That book takes me a week to read*
tough_np_np_cp_subst :=  unsat_three_arg_subst & cp_addin_tam_pn &
			 basic_four_arg &
  [ LOCAL.CAT.VAL [ COMPS < synsem &
			    [ LOCAL [ CAT nomp_cat_acc_min &
                                          [ VAL.SPEC < anti_synsem_min > ],
				      CONJ cnil ],
                              --SIND basic_non_event ], 
			    synsem &
			    [ LOCAL [ CAT [ HEAD supnoun &
                                                 [ POSS -,
                                                   MOD *anti_list* ],
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ],
                                            MC na_or_- ],
				      CONJ cnil ],
			      NONLOC.REL 0-dlist,
			      OPT - ], 
			    synsem & #keycomp &
			    [ LOCAL [ CAT cat & 
					  [ HEAD comp,
					    VAL.COMPS < > ],
				      CONJ cnil ],
			      OPT - ] >,
                    KCMP #keycomp ] ].

expl_prtcl_cp_subst :=  basic_three_arg_subst & particle_subst &
			cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem, 
                            synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

;; DPF 2020-03-31 - Changed COMPS..HEAD comp to verbal, so we can get
;; *it follows he was wrong*
expl_cp_subst :=  norm_two_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem & #keycomp &
                            [ LOCAL [ CAT s_cat_fin_v_c & [ HEAD verbal ],
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

expl_vp_subst :=  norm_two_arg_subst &
  [ LOCAL.CAT.VAL [ COMPS < synsem & #keycomp &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil ],
                              OPT - ] >,
                    KCMP #keycomp ] ].

; Raising synsems have to identify the LOCAL value of the raised synsem with
; that of the VP's subject's synsem, rather than identifying the synsems
; themselves, due to our lexical threading of SLASH: if the raised complement
; is extracted, it will be of type gap, and therefore have a non-empty SLASH,
; but we don't want the lower VP complement's subject to also then have a
; non-empty SLASH.  But cf. note above for subj-subj raising, where maybe we
; even want to restrict the identity to CONT only.
;   Indeed, this seems necessary, since CASE blocks unification for
; 'Kim made him sleep' where our (dual-purpose) 'sleep' requires its subject
; to be [CASE nom] (in order to block the sentence "them sleep"), but when its
; subject is raised to object as with "make", there's a conflict with the
; [CASE acc] on the object of "make".  So here again, we make the raising
; identity hold only for CONT.
; DPF (30-Apr-99) In fact, we now have to further restrict the identity to
; only the INDEX, since if we identify all of CONT, we get the handles of the
; higher NP and the VP's subject being identified, but since we also want to 
; lexically identify a predicate's handle with that of its arguments (subject
; to classes of lexical exceptions like for entries with CP complements), we 
; get an unwanted identity of the handles of the higher and lower verbs through
; the identity of the two NPs.  So if we can't sustain this minimal 
; identification for equi and raising, we'll have to give up on identifying 
; the handles of lexical entries and their arguments.  Possible trouble spots 
; are locative inversions like "On the corner seemed to be an abandoned house".

sor_inf_subst := inf_trans_raising_subst & 
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ --SIND #subj,
                            OPT - ], 
			  [ LOCAL [ CONT.HOOK [ XARG #subj,
                                                INDEX.E.TENSE no_tense ] ],
				OPT - ] > ].

;; DPF 10-nov-09 - Added PRF - to VP complement, to block e.g.
;; "*They had him have arrived".
;;
sor_bse_subst := bse_nontrans_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj,
			    OPT - ], 
                          canonical_synsem &
			  [ LOCAL [ CAT [ HEAD.TAM.ASPECT.PRF -,
					  VAL.SUBJ 
					  < [ NONLOC [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ],
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_inf_non_trans_subst := inf_non_trans_subst & 
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj,
			    OPT - ],
			  [ LOCAL.CONT.HOOK.XARG #subj ]  > ].


sor_prd_subst := three_arg_raising_subst &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND #subj ], 
			  [ LOCAL [ CAT basic_prd_cat &
                                        [ HEAD [ TAM.TENSE untensed,
						 AUX - ] ],
				    CONJ cnil,
                                    CONT.HOOK.XARG #subj ],
                            OPT - ] > ].

sor_prd_trans_subst := sor_prd_subst & trans_subst.
sor_prd_nontrans_subst := sor_prd_subst & non_trans_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT prd_cat ] > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; DPF 20-jun-07 - Instead, make first comp be abstr_lex_synsem, rather than
; the hack we tried for awhile of requiring the RELS list to be <! !> - this
; sort of worked, but we don't want to depend on unification failure for
; features that we will sometimes restrict for efficiency, and it was ugly.

particle_subst := unsat_two_arg_subst &
  [ LOCAL.CAT.VAL.COMPS < abstr_lex_synsem &
                          [ --MIN selected_rel,
                            LOCAL.CAT.HEAD a_or_p & [ PRD - ],
                            NONLOC [ SLASH 0-dlist,
                                     REL 0-dlist,
                                     QUE 0-dlist ],
                            OPT - ], ... > ].


;; DPF (29-Jan-99) Modified particle_NP_subst to exclude pronominal NP objects,
;; to block *Kim looked up it"
; DPF 2-Sept-04 - Changed COMPS.REST.FIRST..CAT from nomp_cat_acc_min to
; nomp_cat_nonnom_min to allow np_cp's like "We wrote down who won".

basic_particle_NP_subst := particle_subst &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ PUNCT.RPUNCT dq_or_no_punct ],
			  synsem & 
                          [ LOCAL [ CAT nomp_cat_nonnom_min,
                                    CONJ cnil ],
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist,
                            OPT - ], ... > ].

particle_NP_subst := basic_particle_NP_subst &
  [ LOCAL.CAT.VAL.COMPS < [], [ --MIN nonpro_or_refl_or_num_rel ], ... > ].

; DPF 28-Oct-01 - Removed constraint on COMPS to be lex_synsem and LEX +, since
; this blocked lexical PPs from serving as particles, as in "He drew me away".
; Instead, identify single-word particles by constraint on RELS - a hack.
; DPF 2010-08-31 - Re 28-Oct-01: Removed this hack, instead constraining
; particle to be abstr_lex_synsem.

generic_NP_particle_subst := trans_subst & abstr_lex_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ],
			    abstr_lex_synsem &
			    [ --MIN #cmin & selected_rel,
			      LOCAL.CAT.HEAD a_or_p & [ PRD - ],
			      NONLOC [ SLASH 0-dlist,
				       REL 0-dlist,
				       QUE 0-dlist ],
			      OPT - ], ... > ],
    LEX +,
    LKEYS.--COMPKEY #cmin ].

NP_particle_subst := generic_NP_particle_subst & three_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

NP_particle_pp_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                          synsem,
                          synsem &
                          [ --MIN #ocmin,
                            LOCAL [ CAT basic_pp_cat,
                                    CONJ cnil ],
                            NONLOC.REL 0-dlist,
                            OPT - ] >,
	    CONT [ HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.--OCOMPKEY #ocmin ].

NP_particle_np_subst := generic_NP_particle_subst & four_arg &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
                          synsem,
                          synsem &
                          [ LOCAL [ CAT nomp_cat_acc_min,
                                    CONJ cnil ],
                            --SIND basic_non_event,
                            NONLOC.REL 0-dlist,
                            OPT - ] >,
	    CONT [ HCONS <! !>,
		   ICONS <! !> ] ] ].

NP_particle_cp_subst := generic_NP_particle_subst & four_arg & 
			      cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ COMPS < synsem, 
                            synsem,
                            synsem & #keycomp &
                            [ LOCAL [ CAT [ HEAD comp &
						 [ VFORM fin_or_inf,
						   MOD *anti_list* ],
					    VAL.COMPS < > ],
				      CONJ cnil ],
			      NONLOC.REL 0-dlist,
			      OPT - ] >,
		    KCMP #keycomp ] ].

particle_plus_subst := particle_subst & basic_three_arg_subst.

particle_prd_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL.COMPS < *top*, 
			  synsem & 
			  [ LOCAL [ CAT prd_cat,
				    CONJ cnil ],
                            NONLOC.REL 0-dlist,
                            OPT - ] > ].

; 'turn out to be'
particle_inf_subst := particle_plus_subst & 
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'keep on driving'
particle_prp_subst := particle_subst & basic_three_arg_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT vp_prp_cat,
				      CONJ cnil ],
			      OPT - ] > ] ].

particle_pp_subst := particle_plus_subst &
  [ LOCAL [ CAT.VAL.COMPS < *top*, 
                            synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist ] >,
            CONT [ HCONS <! !>,
		   ICONS <! !> ] ] ].

; 'find out that S'
particle_cp_subst := particle_plus_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'point out to Kim that S'
particle_pp_cp_subst := particle_subst & four_arg_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < *top*, 
			    synsem &
                            [ LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil ],
                              NONLOC.REL 0-dlist ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
                              OPT - ] > ] ].

particle_oeq_subst := particle_NP_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem, synsem,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

; 'leave it to Kim to find the answer'
expl_pp_inf_subst := four_arg_subst & trans_subst &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < [ OPT - ], 
			    synsem &
			    [ LOCAL [ CAT basic_pp_cat,
				      CONJ cnil ],
                              NONLOC.REL 0-dlist,
                              OPT - ] ,
			    #comp & synsem &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
                              OPT - ] > ] ].

;; 'bet Kim a fortune that Sandy would win'
;; DPF (19-Oct-98) Added hack to block extraction from the CP complement, since
;; don't know how to avoid topicalized imperative parse for "Abrams bet Browne
;; Chiang slept with subject of "slept" topicalized.

np_np_cp_subst := four_arg_subst & trans_subst & cp_addin_tam_pn &
  [ LOCAL.CAT.VAL [ KCMP #comp,
		    COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event ],
			    synsem & [ LOCAL [ CAT nomp_cat_acc_min,
					       CONJ cnil ],
                                       --SIND basic_non_event,
                                       NONLOC.REL 0-dlist ],
			    #comp & synsem &
			    [ LOCAL [ CAT s_cat_fin_v_c,
				      CONJ cnil ],
			      NONLOC.SLASH 0-dlist ] > ] ].

; E.g., "I'm not doing too badly"
; DPF 30-aug-04 - Changed COMPS..HEAD p_or_adv to just adv, since we were
; overgenerating "Kim did in Paris", and it's not clear why we wanted prep.

adv_subst := unsat_two_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD adv &
                                      [ MOD < [ LOCAL intersective_mod &
						[ CONT.HOOK.INDEX #event ]] > ],
				      VAL [ SPR *olist*,
                                            COMPS < > ],
				      POSTHD + ],
                                CONT.HOOK.LTOP #hand ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

np_adv_subst := trans_subst & three_arg_subst &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    synsem & 
			    [ LOCAL 
			      [ CAT [ HEAD adv &
                                       [ MOD < [ LOCAL intersective_mod ] > ],
                                      VAL [ SPR *olist*,
                                            COMPS < > ] ],
                                CONT.HOOK [ LTOP #hand,
                                            XARG #event ] ],
                              NONLOC.REL 0-dlist,
                              LEX + ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERB SYNSEMS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Verb synsems should inherit from one valence type and one linking type.
; The type verb_synsem is given a non-empty SPR value so VPs can be modified
; by PPs, but (hack) the synsem is of type anti_synsem_min to block unification, 
; to avoid ever picking up an actual specifier.
;   Added VIT links for the moment, to satisfy VIT requirements for visibility
; of TENSE and MOOD information.  (Actually, moved VITTENSE specification to
; the various inflectional affixes in lexrules.tdl, to accommodate the collapse
; of the base and fin-non3sg verb forms.
; DPF (8-Jul-98) Added QUE 0-dlist, REL 0-dlist to block pied piping in verb
; phrases (taking advantage of lexical amalgamation of these features, together
; with our treatment of subject-WH as extraction (where only local features are
; propagated in SLASH).
; DPF 8-dec-03 - Removed QUE 0-dlist, since we may now be ready for in-situ
; WH-questions.

basic_verb_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD verb & [ MOD < anti_synsem_min > ],
                  VAL [ SUBJ < synsem_min & #subj >,
			COMPS #comps,
			SPCMPS < > ] ],
	    ARG-S < #subj . #comps > ],
    LKEYS.KEYREL event_relation,
    NONLOC.REL 0-dlist,
    MODIFD notmod ].

norm_basic_verb_synsem := basic_verb_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN v_event_rel,
		VAL.SPR < anti_synsem_min > ],
    LKEYS.KEYREL.ARG0 non_conj_event ].

norm_verb_synsem := norm_basic_verb_synsem &
  [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.AGR.PNG #png ] >,
            AGR.PNG #png ] ].

verb_synsem := norm_verb_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD.TAM #tam,
            CONT.HOOK.INDEX.E #tam ] ].

; DPF 20-apr-09
; For output of lexical rules like re-prefixation, to prevent the output
; from undergoing other lexical rules which are constrained by synsem type.
; DPF 2010-10-23 - But we do want to allow (nominal) gerunds as in
; *the redecorating amazed Kim*.  So add subtype for this case.
;
derived_verb_synsem := basic_verb_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD.TAM #tam,
		  VAL.SUBJ < [ LOCAL.AGR.PNG #png ] > ],
            CONT.HOOK.INDEX #index & [ E #tam ],
            AGR.PNG #png ],
    LKEYS.KEYREL.ARG0 non_conj_event & #index ].

derived_trans_verb_synsem := derived_verb_synsem & trans_subst.

atrans_verb := verb_synsem & intrans_subst & atrans_lt &
  [ LOCAL [ CAT.HEAD.MINORS.MIN weather_v_rel,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel ].

onearg_verb := verb_synsem & intrans_subst & arg1_subj_lt &
  [ LOCAL.CONT.RELS <! #keyrel !>,
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].
unerg_verb := onearg_verb.
unerg_imp_verb := unerg_verb &
  [ LOCAL.CAT.HEAD.VFORM imp_vform ].
unerg_bse_verb := unerg_verb &
  [ LOCAL.CAT.HEAD [ VFORM bse_only,
		     TAM.TENSE future ] ].
unerg_prp_verb := unerg_verb &
  [ LOCAL [ CAT.HEAD.VFORM prp,
	    CONT [ RELS <! relation !>,
		   HCONS <! !>,
		   ICONS <! !> ] ] ].

twoarg_verb_synsem := verb_synsem & two_arg.
passive_or_unacc_synsem := unsat_subst.
unacc_verb := onearg_verb & passive_or_unacc_synsem.
  
; For at least main verb "have" (e.g, "Kim has some rice")
; DPF 04-sep-09 - Block gerund complements: "*Kim has hiring Abrams"
poss_verb := twoarg_verb_synsem & two_arg_subst & poss_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL [ CAT nomp_cat_acc &
						   [ HEAD noun_or_nomger ],
			        	       CONJ cnil ],
                                       --SIND index,
                                       NONLOC.REL 0-dlist,
				       OPT - ] >,
            CONT.RELS.LIST.FIRST #keyrel ],
    LKEYS.KEYREL #keyrel ].
  
poss_got_verb := poss_verb &
  [ LOCAL non_fin_verb &
	  [ CAT [ HEAD [ VFORM psp,
			 PRD - ],
		  VAL.COMPS < [ LOCAL.CAT.HEAD.MINORS.NORM no_rel ] >,
		  MC na ],
	    CONT.RELS <! relation !> ] ].

np_trans_verb := verb_synsem & np_trans_subst & trans_lt &
  [ LOCAL.CONT.RELS <! #keyrel !>,
    LKEYS.KEYREL #keyrel ].
  
np_trans_nfin_verb := np_trans_verb &
  [ LOCAL.CAT [ HEAD [ VFORM bse,
		       TAM [ TENSE present,
			     MOOD indicative ] ],
		VAL.COMPS < [ OPT + ] > ] ].


basic_np_non_trans_verb := twoarg_verb_synsem & np_non_trans_subst & trans_lt &
  [ LOCAL.CONT.RELS <! #keyrel !>,
    LKEYS.KEYREL #keyrel ].

np_non_trans_fin_bse_verb := basic_np_non_trans_verb &
  [ LOCAL bse_or_non3sg_verb & 
	  [ CAT.VAL.COMPS.FIRST.LOCAL.CAT nomp_cat_acc_min ] ].

np_non_trans_nb_verb := basic_np_non_trans_verb &
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem &
			  [ OPT -,
			    LOCAL.CAT nomp_cat_nonnom_min &
				[ VAL [ SPR < [ ] >,
					SPEC < anti_synsem_min > ] ] ] > ].

np_non_trans_verb := basic_np_non_trans_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT nomp_cat_acc_min ].

np_trans_refl_verb := twoarg_verb_synsem & np_trans_subst & trans_lt &
		      poss_idiom_lt &
  [ LOCAL [ CAT.VAL [ COMPS < #keycomp & [ OPT - ] >,
		      KCMP #keycomp ],
	    CONT [ HOOK.XARG #xarg,
		   RELS <! #keyrel,
			   #altkeyrel & [ ARG1 #xarg ] !> ] ],
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].

basic_do_be_verb := basic_verb_synsem & unsat_subst &
  [ LOCAL [ CAT [ HEAD [ MINORS.MIN _do_v_be_rel,
			 TAM #tam ],
		  VAL [ SUBJ < [ LOCAL.AGR.PNG #png,
				 NONLOC.SLASH 0-dlist ] >,
			SPR < anti_synsem_min > ] ],
	    AGR.PNG #png,
	    CONJ cnil,
	    CONT [ HOOK.INDEX non_conj_event & [ E #tam ],
		   RELS.LIST.FIRST #keyrel,
		   HCONS <! !> ] ],
    LEX +,
    PUNCT no_punctuation_min,
    NONLOC.QUE 0-dlist,
    LKEYS [ KEYREL #keyrel,
	    --+COMPKEY _be_v_do_rel ] ].

;; *the thing we did was hire a manager*
;;
do_be_verb := basic_do_be_verb & arg1_subj_lt &
  [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN role_rel,
		  VAL.COMPS < > ],
	    CONT [ HOOK [ LTOP #lbl,
			  XARG #xarg ],
		   RELS <! #keyrel & [ LBL #lbl ] !>,
		   ICONS <! !> ] ],
    NONLOC.SLASH 1-dlist & <! [ CAT [ HEAD basic_noun & [ MOD < > ],
				      VAL.SPR *olist* ],
				CONJ cnil,
				CONT.HOOK [ INDEX #cind &
						  [ SORT do-event ],
					    XARG #xarg ] ] !>,
    LKEYS.KEYREL #keyrel & [ ARG2 #cind ] ].

;; *the first thing that must be done is get ready*
do_be_verb_passive := basic_do_be_verb &
  [ LOCAL [ CAT [ HEAD [ VFORM pas,
			 MINORS.ALTMIN passive_rel ],
		  VAL [ COMPS *obliquecons* &
			     < synsem & 
			       [ --MIN _by_p_cm_rel,
				 LOCAL local &
				       [ CAT [ HEAD prep,
					       VAL [ SUBJ < >,
						     SPR *olist*,
						     COMPS < > ] ],
					 CONT.HOOK.INDEX #byind ],
				 NONLOC.REL 0-dlist,
				 OPT + ] > ] ],
	    CONT [ HOOK [ LTOP #lbl,
			  INDEX #event,
			  XARG #xarg & [ SORT do-event ] ],
		   RELS <! [ LBL #lbl ] !>,
		   HCONS <! !>,
		   ICONS <! topic & [ IARG1 #event,
				      IARG2 #xarg ] !> ] ],
    NONLOC.SLASH 0-dlist,
    LKEYS.KEYREL [ ARG1 #byind,
		   ARG2 #xarg ] ].

nbar_verb := verb_synsem & basic_two_arg & nbar_subst & basic_arg12_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
                                                INDEX #arg & basic_non_expl ],
			      OPT - ] >,
            CONT [ RELS <! relation,
			   #altkeyrel &
                           [ PRED udef_q_rel,
                             ARG0 #arg & ref-ind,
                             RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

basic_prep_intrans_verb := verb_synsem & prep_intrans_subst & basic_two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT basic_pp_cat ] > ].

;; come to
prep_intrans_verb := basic_prep_intrans_verb & prep_intrans_lt & two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT pp_cat ] > ].

;; fall into
;; DPF 2018-06-02 - Changed COMPS..MOD from noun to subst: *swings in*
;;
prep_intrans_unacc_verb := basic_prep_intrans_verb & prep_intrans_lt &
                           two_arg &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN dir_or_unsp_loc_rel,
			    OPT +,
                            LOCAL.CAT [ HEAD prep_or_modnp &
                                          [ MOD < [ LOCAL.CAT.HEAD subst ] > ],
                                        VAL [ SPR *olist*,
                                              COMPS < > ],
                                        MC na ] ] > ].

;; thanks (hack)
prep_intrans_nosubj_verb := basic_prep_intrans_verb & prep_intrans_nosubj_lt.

;; look for
;;
basic_empty_prep_intrans_verb := twoarg_verb_synsem & prep_intrans_subst &
			   empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
	    CONT.RELS.LIST.FIRST #keyrel ],
    LKEYS.KEYREL #keyrel ].

empty_prep_intrans_verb := basic_empty_prep_intrans_verb &
  [ LOCAL.CONT.RELS <! relation !> ].

empty_prep_intrans_bse_verb := empty_prep_intrans_verb &
  [ LOCAL.CAT.HEAD [ VFORM bse,
		     TAM [ TENSE present,
			   MOOD indicative ] ],
    LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin ] ].


empty_prep_intrans_idiom_verb := basic_empty_prep_intrans_verb &
				 poss_idiom_lt &
  [ LOCAL [ CAT.VAL [ COMPS.FIRST #kcmp,
		      KCMP #kcmp ],
	    CONT [ HOOK.XARG #xarg,
		   RELS <! relation,
			   #altkeyrel !> ] ],
    LKEYS.ALTKEYREL #altkeyrel & [ ARG1 #xarg ] ].

;; gave to 
;;
empty_prep_intrans_arg3_verb := twoarg_verb_synsem & prep_intrans_subst &
			        empty_prep_intrans_arg3_lt.

;; run for mayor
empty_prep_nospr_verb := verb_synsem & prep_intrans_subst & basic_two_arg & 
                         empty_prep_intrans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
                                                INDEX #nind ] ] >,
            CONT [ RELS <! relation & #keyrel,
			   #altkeyrel & [ PRED udef_q_rel,
					  ARG0 #nind & ref-ind,
					  RSTR #rhand ] !>,
		   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].


;; suggest on Tuesday
;;
prep_intrans_event_verb := twoarg_verb_synsem & prep_intrans_subst &
			   prep_intrans_event_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT pp_cat,
			    OPT - ] > ].

prep_intrans_gap_verb := prep_intrans_event_verb &
  [ LOCAL.CAT.VAL.COMPS < gap > ].

;; verbs of motion
;; DPF 2016-10-24 - The constraint [COMPS..MOD..HEAD noun] excludes desired
;; analysis for *he ran off* since *off* is not (normally) a noun modifier.
;; So let's generalize to `subst' and see if and when we overgenerate...  Well,
;; the trouble is the spurious ambiguity when we have dual lexial entries for
;; preps such as "to", one a noun modifier and the other not.  So let's try
;; restricting to `v_or_a_or_p'.
;; DPF 2018-02-13 - Made COMPS.FIRST..MOD.FIRST be expressed_synsem, to exclude
;; newer PP-PP copred analysis here.
;; DPF 2018-07-28 - We want to block extraction of directional PPs, because 
;; otherwise we get wrong identification of the ARG0s of the VP conjuncts in 
;; VP coordination with extraction, as in *from which city did she 
;; come __ and go __*.  One cost is that we don't parse *in she came* because
;; PP-in is only directional and the non-wh filler-head rule excludes 
;; directional PP fillers (to avoid a lot of unwanted ambiguity). See for
;; example sc03:6034220.  FIX soon.
;; DPF 2019-11-27 - Re 2018-07-28: Another possible cost is no RNR for dir PPs,
;; as in dubious *They sneaked or slipped into the room* or better
;; *They [drove or flew] to Paris*.
;;
prep_intrans_dir_verb := twoarg_verb_synsem & basic_prep_intrans_subst &
                         prep_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < canonical_or_unexpressed &
			  [ --MIN dir_or_unsp_loc_rel,
                            LOCAL.CAT [ HEAD prep_or_modnp &
                                         [ MOD < expressed_synsem &
						[LOCAL.CAT.HEAD v_or_a_or_p]>],
					VAL [ SPR *olist*,
                                              COMPS < > ],
                                        MC na ] ] > ].

;; put, move
;;
; DPF 17-sept-07 - Restricted PP compl to be non-nmod, to disambiguate e.g.
; "to" as in "bring X to Y"
; DPF 14-may-10 - Re 17-sept-07: But this excludes of-PPs, so try
; constraining to noun instead of v_or_a_or_p.
;
basic_prep_trans_verb := verb_synsem & prep_trans_subst & prep_trans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >]> ].

;; `put'
prep_trans_verb := basic_prep_trans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ OPT - ] > ].
  
prep_trans_dir_verb := prep_trans_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  [ LOCAL.CAT.HEAD.MINORS
				       [ MIN dir_or_state_nontemp_rel ] ] > ].

;; change one's mind about X (where 'about' is only noun-modifier)
prep_trans_verb_nmod := basic_prep_trans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ LOCAL.CAT.HEAD.PRD +,
                                       OPT - ] > ].
;; *we raced each other across the street*
prep_trans_dir_noprop_verb := verb_synsem & prep_trans_subst & trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ LOCAL [ CAT.HEAD.MINORS.MIN dir_rel,
				      CONT.HOOK [ LTOP #ltop,
						  XARG #event ] ],
			      OPT - ] >,
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #event ],
		   RELS <! #keyrel !>,
		   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel ].

;; remind-of
;;
empty_prep_trans_verb := verb_synsem & basic_prep_trans_subst & 
                         empty_prep_trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < synsem, 
			    [ LOCAL.CAT basic_pp_cat ] >,
            CONT [ HCONS <! !>,
		   ICONS <! !> ] ] ].

basic_empty_prep_trans_refl_idiom_verb := verb_synsem & poss_idiom_lt &
					  basic_prep_trans_subst & 
					  basic_empty_prep_trans_lt & 
  [ LOCAL [ CAT.VAL [ COMPS < #kcmp, 
			    [ LOCAL.CAT basic_pp_cat ] >,
		      KCMP #kcmp ],
            CONT [ HOOK.XARG #xarg,
		   RELS.LIST < relation, #altkeyrel, ... >,
		   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.ALTKEYREL #altkeyrel & [ ARG1 #xarg ] ].

empty_prep_trans_refl_idiom_verb := basic_empty_prep_trans_refl_idiom_verb &
  [ LOCAL.CONT.RELS <! relation, relation !> ].

empty_prep_trans_refl_refl_idm_verb := basic_empty_prep_trans_refl_idiom_verb &
  [ LOCAL [ CAT.VAL.COMPS < synsem,
			    [ LOCAL.CONT.HOOK.XARG #cxarg ] >,
	    CONT [ HOOK.XARG #xarg,
		   RELS <! [ LBL #lbl ],
			   relation, 
			   [ LBL #lbl,
			     PRED id_rel,
			     ARG1 #xarg & [ PNG #png ],
			     ARG2 #cxarg & [ PNG #png ] ] !> ] ] ].

;; interest him in X
;;
empty_prep_non_trans_verb := verb_synsem & prep_non_trans_subst & 
			     empty_prep_trans_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ OPT - ] >,
    LKEYS [ --OCOMPKEY #ocmin,
	    --+OCOMPKEY #ocmin ] ].


;; get-hold-of
;;
;empty_prep_nbar_verb := verb_synsem & prep_nbar_subst & 
;			     empty_prep_nbar_lt.


;; regard Kim as tall
np_as_verb := verb_synsem & np_comp_subst & basic_prd_comp_lt & 
	      obj_equi_inf_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          [ --MIN _as_p_sel_rel & #min,
			    --SIND event,
                            LOCAL.CAT.VAL.SUBJ *olist* ] >,
    LKEYS [ --OCOMPKEY #min,
            --+OCOMPKEY #min ] ].

;; strike Kim as tall
np_as_seq_verb := verb_synsem & np_comp_subst & basic_prd_comp_lt &
  [ LOCAL [ CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #index ] ],
                              #comp & 
                              [ --MIN _as_p_sel_rel & #min,
                                LOCAL.CONT.HOOK.XARG #sind ] >,
                      KCMP #comp ],
            CONT [ HOOK.XARG #sind,
                   HCONS <! [ HARG #arg2 ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL arg12_relation & [ LBL #lbl,
				      ARG1 #index,
                                      ARG2 #arg2 ],
            --OCOMPKEY #min,
            --+OCOMPKEY #min ] ].

; DPF 4-Jun-01 - Changed dative-to to be contentful "to", in order to sustain
; 'underspecified' semantics for "kim sent it to Sandy/Paris".  Verbs like 
; "hand" are now of type empty_to_trans_verb.
; DPF 3-May-03 - But since then we've altered our views again, and are now
; treating "send" as taking an empty to-PP, so we do the same for derived
; to-datives as well.
  
empty_to_trans_verb := empty_prep_trans_verb &
  [ LKEYS.--OCOMPKEY _to_p_sel_rel ].

ditrans_verb := verb_synsem & ditrans_subst & ditrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem_min, synsem > ].
  
ditrans_only_verb := verb_synsem & ditrans_subst & ditrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem > ].

; 'elect him president'
;; DPF 2017-03-01 - Removed last vestiges of SORT non-time-sort, generalizing
;; to basic-entity-or-event for first complement.
;;
ditrans_np_nbar_verb := verb_synsem & ditrans_np_nbar_subst & arg1_subj_lt &
  [ LOCAL.CAT.VAL.COMPS 
                  < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					INDEX #obj2ind & non_expl-ind &
					     [ SORT basic-entity-or-event ] ],
		      OPT - ],
		    [ LOCAL.CONT.HOOK [ INDEX #objind & non_expl-ind ],
		      OPT - ], ... >,
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG1 non_expl-ind,
				     ARG2 #objind,
                                     ARG3 #obj2ind ] ].

; 'see picture, page 2.'
;; DPF 2017-03-01 - Removed last vestiges of SORT non-time-sort, generalizing
;; to basic-entity-or-event for first complement.
;;
basic_ditrans_nbar_np_verb := verb_synsem & ditrans_nbar_np_subst & 
			      arg1_subj_lt &
  [ LOCAL.CAT [ VAL.COMPS 
                  < [ LOCAL.CONT.HOOK.INDEX #obj2ind & non_expl-ind &
					     [ SORT basic-entity-or-event ],
		      OPT - ],
		    [ LOCAL.CONT.HOOK 
				 [ LTOP #lbl,
				   INDEX #objind & non_expl-ind ] ], ... > ],
    LKEYS.KEYREL arg123_relation & [ LBL #lbl,
				     ARG1 non_expl-ind,
				     ARG2 #objind,
                                     ARG3 #obj2ind ] ].

ditrans_nbar_np_verb := basic_ditrans_nbar_np_verb &
  [ LOCAL.CAT [ HEAD.VFORM imp_vform,
		VAL.COMPS.FIRST.--MIN norm_nom_rel ] ].

; 'talk to Kim about Sandy'
; DPF 26-aug-04 - Counter-intuitively, constrain second complement to be
; noun-modifying PP, to avoid spurious ambiguity (at present) for e.g.
; 'they range from low prices to high prices'
double_pp_verb := verb_synsem & double_pp_subst & double_pp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD
                                   < [ LOCAL.CAT.HEAD verb ] > ],
                          [ LOCAL.CAT.HEAD.MOD
                                   < [ LOCAL.CAT.HEAD noun ] > ] > ].

; Unwanted type if freer order of obliques- 'pay with a check for it"
double_pp_empty_pp_verb := verb_synsem & double_pp_subst & 
                           double_pp_empty_pp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ OPT - ] > ].

; 'change the meeting from Tuesday to Wednesday'
; 'pay the money to Browne for the ticket'
np_trans_double_pp_verb := verb_synsem & np_trans_double_pp_subst & 
                           arg12_double_pp_lt &
  [ LOCAL.CAT [ HEAD.MINORS.MIN #ocmin,
		VAL.COMPS < [ ], [ OPT + ], [ OPT - ] > ],
    LKEYS.--+OCOMPKEY #ocmin ].

np_trans_double_ppto_verb := np_trans_double_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ ], [ ], 
			  [ LOCAL.CAT.HEAD.MINORS.MIN _to_p_sel_rel ] > ].

np_trans_double_ppfor_verb := np_trans_double_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], [ ], 
			  [ LOCAL.CAT.HEAD.MINORS.MIN _for_p_sel_rel ] > ].

; Raising verbs which take an infinitival complement restrict it to being
; [ MSG no_msg ], which ensures that the VP will be headed by the 
; non-propositional "to" complementizer, which identifies its handle with
; that of its VP complement.

ssr_verb := verb_synsem & ssr_inf_subst & basic_two_arg &
  [ LOCAL [ CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		      KCMP.LOCAL.CONT.HOOK [ LTOP #chand ] ],
	    CONT [ HOOK [ LTOP #ltop ],
		   RELS <! #keyrel !>,
		   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg1_relation & #keyrel & [ ARG1 handle & #arghand ] ].

ssr_noimp_verb := ssr_verb &
  [ LOCAL.CAT.HEAD.VFORM fin_or_non_fin ].

; 'It started raining'
;; DPF 2018-05-31 - Block extraction of VP complement.
;;
ssr_prp_verb := verb_synsem & ssr_subst & prp_intrans_subst &
  [ LOCAL [ CAT.VAL.KCMP canonical_synsem &
			 [ LOCAL.CONT.HOOK [ LTOP #chand ] ],
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq &
			   [ HARG #arghand,
			     LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg1_relation & #keyrel & [ ARG1 handle & #arghand ] ].

ssr_pp_inf_verb := verb_synsem & ssr_pp_inf_subst & ssr_expr_lt &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT + ].


; It became obvious that Kim had arrived.
ssr_prdp_verb := verb_synsem & ssr_subst & prd_comp_lt & basic_two_arg & 
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND it-ind ] >,
		      COMPS < synsem & #comp &
                              [ LOCAL [ CAT.HEAD v_or_a &
						 [ TAM [ TENSE no_tense,
							 ASPECT.PROGR - ] ],
                                        CONJ cnil ],
				OPT - ], ... >,
                      KCMP #comp ],
            CONT [ HCONS <! [ HARG #arghand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL.ARG2 handle & #arghand ] ].

seq_prdp_pp_verb := verb_synsem & seq_prdp_pp_subst & seq_prdp_expr_lt.

seq_ap_pp_verb := seq_prdp_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD basic_adj ], 
			  [ OPT + ] > ].

seq_pp_pp_verb := seq_prdp_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep ], 
			  [ OPT + ] >,
    LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin ] ].

;; DPF 2011-09-25 - This type, only for `seem', was too restrictive with
;; COMPS..HEAD a_or_p, since it excludes lexical passives, such as in
;; *that seemed overdone*, so generalize to v_or_a_or_p, but PROGR -, to
;; still exclude present participles: **he seemed laughing*
;; 
seq_aorp_pp_verb := seq_prdp_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD v_or_a_or_p & [ TAM.ASPECT.PROGR -] ],
			  [ OPT + ] > ].

seq_prdp_pp_about_verb := verb_synsem & seq_prdp_pp_subst & 
                          basic_seq_prdp_expr_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD  v_or_a_or_p & [ TAM.ASPECT.PROGR -] ], 
			  [ OPT + ] >,
    LKEYS.--OCOMPKEY _about_p_sel_rel ].

; DPF 13-may-09 - Restrict VP to be non-elliptical, to block spurious parse
; for "Kim was [shown to] herself.
;; DPF 2011-07-01 - Re 13-may-09: but this also blocks *he expects them to*.
;; And anyway, the parse with *shown to* is actually okay, given the raising
;; analysis of *shown*.
sor_verb := verb_synsem & sor_inf_subst & sor_lt.

sor_psv_verb := sor_verb &
  [ LOCAL verb_participle_affix &
	  [ CAT [ HEAD.VFORM pas,
		  VAL [ SUBJ < [ OPT - ] >,
			COMPS < [ OPT - ], ... > ] ],
	    CONT psoa & [ RELS <! relation !> ] ] ].

sorb_verb := verb_synsem & sor_bse_subst & sor_prop_lt.

sor_non_trans_verb := verb_synsem & sor_inf_non_trans_subst & sor_lt.

sor_pp_inf_verb := verb_synsem & pp_inf_subst & basic_three_arg_subst
                   & sor_lt.

sor_prd_verb := verb_synsem & sor_prd_trans_subst & sor_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
			    --SIND ref-ind ],
                          [ LOCAL.CAT prd_cat & [ HEAD v_or_a ] ] > ].

sor_prd_nontrans_verb := verb_synsem & sor_prd_nontrans_subst & sor_lt.

subj_equi_prp_verb := verb_synsem & prp_intrans_subst & 
                      subj_equi_prp_or_bse_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT [ HEAD verb,
                                        VAL.SUBJ < pro_ss > ] ].

subj_equi_bse_verb := verb_synsem & bse_intrans_subst &
                      subj_equi_prp_or_bse_lt.

; 'go'
subj_equi_bse_or_n3sg_verb := subj_equi_bse_verb &
  [ LOCAL bse_or_non3sg_verb ].

; 'You needn't stay'
subj_rais_bse_n3sg_verb := verb_synsem & bse_intrans_subst &
                           subj_rais_bse_n3sg_lt &
  [ LOCAL pres_verb & [ CAT.HEAD.VFORM fin ] ].

; `you need only attend'
subj_rais_bse_n3sg_adv_verb := verb_synsem & unsat_three_arg_subst &
			       basic_three_arg &
  [ LOCAL pres_verb & 
	  [ CAT [ HEAD [ VFORM fin,
			 TAM #tam,
			 AUX +,
			 MINORS [ MIN #min,
				  ALTMIN #altmin ] ],
		  VAL [ KCMP #comp,
			SUBJ.FIRST.--SIND #xarg,
			COMPS < [ LOCAL local &
			     [ CAT [ HEAD basic_lexadv &
                                     [ MOD < [ LOCAL scopal_mod &
						     [ CONT.HOOK.LTOP #vltop]]>,
				       TAM #tam ],
                                     VAL.COMPS < > ],
                               CONT.HOOK.LTOP #advltop ],
                              LEX +,
			      OPT - ],
			      #comp & synsem &
				[ LOCAL [ CAT vp_cat &
					      [ HEAD [ VFORM bse,
						       MINORS.ALTMIN #altmin ]],
					  CONT.HOOK [ LTOP #cltop,
						      XARG #xarg ],
					  CONJ cnil ],
				  --SIND.E.TENSE no_tense,
				  OPT - ] > ],
		  POSTHD + ],
	    CONT [ HOOK [ LTOP #advltop,
			  INDEX #event,
			  XARG #xarg ],
		   RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #harg, LARG #cltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #vltop,
			     PRED #min,
			     ARG0 #event,
			     ARG1 #harg ] ].

ssr_two_arg_verb := ssr_two_arg_subst & aux_verb.

; "K became quiet"
;; DPF 2013-02-06 - Add COMPS..MOD..HEAD noun to avoid ambig of preps like
;; `to' with double entries.
;;
subj_prd_verb := verb_synsem & subj_control_subst &
                 basic_prd_comp_lt &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL [ CAT.HEAD 
					    [ TAM [ TENSE no_tense,
						    ASPECT.PROGR - ],
					      MOD < [ LOCAL.CAT.HEAD noun ] > ],
					CONJ cnil ] ], ... >,
                      KCMP #comp ],
            CONT [ HCONS <! [ HARG #arghand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL.ARG2 handle & #arghand ] ].

subj_equi_prd_verb := subj_prd_verb & prd_comp_lt & basic_two_arg & 
                      subj_equi_lt &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT basic_prd_cat & [ HEAD.AUX - ] ] > ].

subj_equi_prd_adj_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < canonical_synsem &
                          [ OPT -,
                            LOCAL.CAT.HEAD adj,
			    --MIN norm_adj_rel ] > ].

subj_equi_prd_prep_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD prep ] > ].

; "K got hired"
; DPF 3-Jul-03 - Need to block "*Kim got hiring" - seems to be same need to
; distinguish passive from pres-participle - group passive with A and P.
subj_equi_prd_v_a_verb := subj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT -,
                            LOCAL.CAT.HEAD v_or_a ] > ].

; 'shows as empty'
subj_equi_empty_prep_verb := subj_prd_verb & s_equi_lt & basic_two_arg &
  [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #index ] >,
                    COMPS < [ OPT -,
                              --MIN selected_rel,
                              LOCAL [ CAT [ HEAD prep,
                                            VAL [ SUBJ *olist*,
                                                  SPR *olist*,
                                                  COMPS < > ] ],
                                      CONT.HOOK.INDEX #index ] ] > ] ].

; DPF 15-Apr-02 - Changed these to prd_non_trans_subst, since get spurious 
; ambiguity with alternate analysis of PrdP as adjunct, with right semantics in
; passive case.  
; DPF 13-Oct-03 - But that adjunct analysis gives the wrong semantics for
; "Kim was made angry" where we what result proposition, not state of Kim
; while she was made. So changing back to 

obj_equi_prd_verb := verb_synsem & prd_trans_subst & obj_equi_prd_lt &
		     basic_three_arg_subst.

obj_equi_prd_adj_verb := obj_equi_prd_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CAT.HEAD adj ] > ].

obj_equi_non_trans_prd_verb := verb_synsem & prd_non_trans_subst & 
			       obj_equi_prd_lt.

; 'I have X to get rid of'
; VFORM fin_or_non_fin prevents imperative "*Have Kim to get rid of." which
; led to spurious ambiguity.
obj_equi_vpslash_prd_verb := verb_synsem & basic_inf_non_trans_subst & 
                             tough_three_arg & arg1_subj_lt &
  [ LOCAL [ CAT [ HEAD.VFORM fin_or_non_fin,
                  VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
						  INDEX #ind & non_expl-ind ],
				OPT - ],
                              [ LOCAL.CONT [ HOOK [ LTOP #vltop,
                                                    XARG #xarg ] ],
                                NONLOC.SLASH <! [ CAT np_cat_nonnom_min &
                                                      [ HEAD.MOD < > ],
                                                CONT.HOOK.INDEX #ind ] !> ] >],
            CONT [ HOOK [ XARG #xarg ],
		   RELS <! #keyrel !>,
                   HCONS <! qeq & [ HARG #mltop,
                                    LARG #vltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ LBL #lbl,
					       ARG1 non_expl-ind,
					       ARG2 #ind,
					       ARG3 #mltop ] ].

obj_equi_vpslash_four_arg_verb := verb_synsem & tough_np_np_cp_subst & 
				  tough_four_arg &
  [ LOCAL 
    [ CAT 
      [ HEAD.VFORM fin_or_non_fin,
	VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #xarg ] >,
	      COMPS < [ LOCAL.CONT.HOOK [ LTOP #lbl,
					  INDEX #ind1 & non_expl-ind ] ],
		      [ LOCAL.CONT.HOOK [ LTOP #lbl,
					  INDEX #ind2 & non_expl-ind ] ],
		      [ LOCAL.CONT.HOOK [ LTOP #mltop,
					  XARG #ind1 ],
			NONLOC.SLASH <! [ CAT np_cat_nonnom_min &
					      [ HEAD.MOD < > ],
					  CONT.HOOK.INDEX #xarg ] !> ] > ] ],
      CONT [ HOOK.XARG #xarg,
	     RELS <! #keyrel !>,
	     HCONS <! qeq & [ HARG #vltop,
			      LARG #mltop ] !>,
	     ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ LBL #lbl,
					       ARG1 #vltop,
					       ARG2 #ind1,
					       ARG3 #ind2 ] ].

; ERB (07-10-96) I am working with the verb 'know' as a prototype for a verb
; that selects by the semantic type (for now expressed as a feature) of its
; sentential complement rather than by the value of CMP or some such hack.  In
; order to do so, I have changed the types around here.  In particular, I am
; adding a new type cp_prop+ques_intrans_verb that takes a sentential
; complement but doesn't care if its a proposition or a question (for verbs
; like 'know').  A further axis of variation is the VFORM of the complement
; (fin vs. inf).  Since my analysis of 'know' never makes use of the resolved
; subtypes (e.g., cp_prop_intrans_verb) I am not adding to the resolved
; subtypes, and just making the old ones inherit from the finite side of
; things for now.  The future inf_cp_prop_intrans_verb will probably be the
; type of subject equi verbs. A further future modification would involve the
; addition of cp_command_intrans_verb and cp_command+prop_intrans_verb for
; verbs like 'insist'.
;
; DPF (19-Jun-98) This type cannot itself simply add the complement CP's 
; (underspecified) message to its RELS, since the generation algorithm requires
; that no relation on RELS will ever get more specialized during parsing.  So 
; we make MSG be list-valued (the empty list for all but complementizers
; and clauses), and have the Head-Complement rule append the values of MSG
; from both of its daughters, since the msg comes from the head if it's a
; complementizer, and from the non-head if the head is a verb.

basic_cp_prop+ques_verb := norm_basic_verb_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ LOCAL.CAT.HEAD verbal,
                           OPT - ],
            CONT.RELS.LIST < relation, ... > ] ].

;; DPF 2011-jun-11 - For all but the base-subjunctive-CP-taking verbs, 
;; add in the agreement constraints to distinguish base from non3sg verbs.
;;
norm_cp_prop+ques_verb := basic_cp_prop+ques_verb & verb_synsem &
			  cp_addin_tam_pn.

cp_prop+ques_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.--SIND [ E.MOOD ind_or_modal_subj,
                                SF prop-or-ques ] ].

fin_cp_prop+ques_verb := cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT s_cat_fin_unspec ].

fin_cp_prop+ques_unspec_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT s_cat_unspec &
				   [ HEAD.VFORM fin_or_imp ],
			 --SIND.E.MOOD ind_or_modal_subj ] ].

fin_or_inf_cp_prop+ques_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT basic_s_cat_fin_or_inf_v_c ] ].

cp_like_verb := norm_cp_prop+ques_verb &
  [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT s_cat_fin_or_inf_unspec & 
				   [ HEAD comp & [ VFORM fin ] ],
                         --SIND.SF like-iforce ] ].

;; DPF 2011-jun-11 - Note that embedded filler-head clauses fail to parse as
;; complements of these verbs (*we demand that Kim, they admire*), since
;; the filler-head rule imposes the add-in constraints which preclude a
;; base-form VP.  To fix, would have to distinguish main-clause from
;; non-main-clause non-WH filler-heads (or abandon this collapsing of 
;; verb forms).  FIX someday?
;;
basic_bse_cp_verb := basic_cp_prop+ques_verb & verb_synsem &
  [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT s_cat_bse ] ].

bse_cp_verb := basic_bse_cp_verb &
  [ LOCAL.CAT.VAL.KCMP canonical_synsem ].

;; DPF 4/21/98 - Moved [ COMPS.FIRST.LOCAL.CAT.MC - ] from cp_ques_intrans_verb
;; to cp_intrans_verb, to block spurious parse for e.g. "Kim knows who left"
;; DPF 2020-03-31 - Changed parent from fin_cp_prop+ques_verb to
;; norm_cp_prop+ques_verb so we can allow instances of this type to also take
;; imperative complements, as in *Don't leave, he laughed*

basic_cp_intrans_verb := norm_cp_prop+ques_verb & cp_intrans_subst & 
			 basic_two_arg & arg12h_lt &
  [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT s_cat_unspec &
				   [ HEAD [ VFORM fin_or_imp,
			                    TAM indic_tam ] ],
			 --SIND.E.MOOD ind_or_modal_subj ] ].

cp_intrans_verb := basic_cp_intrans_verb.

cp_intrans_verb_comp := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp ] > ].

cp_like_intrans_verb := cp_like_verb & cp_intrans_subst & basic_two_arg &
                        arg12h_lt &
  [ LOCAL.CAT.VAL.COMPS 
                   < canonical_synsem &
                     [ --SIND.SF like-iforce ] > ].
; Type for inputs to cp_passive lexical rule
cp_passivable_verb := norm_basic_verb_synsem.

; Type for inputs to inverted_quote_lr for "Kim arrived, said Abrams"
cp_comp_verb := norm_basic_verb_synsem.

;; DPF 2016-07-26 - Make this type inherit from basic_basic_two_arg to avoid
;; identifying --SLTOP of its complement with its own, because the subtype
;; that takes a main-clause question-CP complement already necessarily has the 
;; complement's --SLTOP identified with that complement's LTOP.  So push the
;; --SLTOP identity (of complement and self) down to this type's subtypes that
;; do not allow main-clause complements.
;;
basic_cp_fin_inf_intrans_verb := fin_or_inf_cp_prop+ques_verb &
			   basic_cp_intrans_subst & basic_two_arg & 
			   arg12h_lt & cp_passivable_verb & cp_comp_verb &
  [ LOCAL.CAT.VAL.KCMP.--SIND.SF prop-or-ques ].

cp_fin_inf_intrans_verb := basic_cp_fin_inf_intrans_verb & cp_intrans_subst.

;; 'ask', allowing main clause question complements
;; FIX: generalize to other verbs, but still block extraction out of 
;; complement WH-clauses, as in *who did they ask arrived?*, while allowing
;; extraction of the whole clause, as in *who arrived, they asked?*
;;
basic_cp_ques_fin_inf_intrans_verb := basic_cp_fin_inf_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ *anti_list*,
                            --SIND.SF ques ] > ].

; 'wonder'
;; DPF 2020-03-25 - Removed COMPS..SLASH 0-dlist, since this prevents
;; *Who arrived, wondered Kim*.  
;; NOTE: with lexical threading, how do we impose an island on extraction from 
;; a complement while still allowing that complement itself to be extracted,
;; as with above?
#|
cp_ques_fin_inf_intrans_verb := basic_cp_ques_fin_inf_intrans_verb &
				cp_intrans_subst & 
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < >,
			    NONLOC.SLASH 0-dlist ] > ].
|#
cp_ques_fin_inf_intrans_verb := basic_cp_ques_fin_inf_intrans_verb &
				cp_intrans_subst & 
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < > ] > ].

;; `ask' as in *Kim asked, why is the sky blue?*
;; DPF 2020-03-24 - Remove canonical_synsem since it blocks 
;; *Who cares, Kim asked.*
;;
cp_ques_fin_inf_mc_verb := basic_cp_ques_fin_inf_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.INV + ].

cp_intrans_passivable_verb := cp_intrans_verb & cp_passivable_verb &
			      cp_comp_verb.

;; DPF 2018-09-13 - Exclude if-S as in **We believe if he would arrive.*
;; Note that this excludes *[[at Nissan][we arrive and we arise]][said Kim]*
;; using hd_xaj-crd-s_c rule.  FIX someday.
;; DPF 2020-03-31 - Generalized COMPS..SF basic-prop to prop-or-comm, so we
;; can also get *Don't forget, laughed Kim.*
;; DPF 2020-05-07 - Let's try restricting complement to MC -.
;;
cp_prop_intrans_verb := cp_intrans_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND.SF prop-or-comm,
			    LOCAL.CAT [ HEAD.CASE nom_or_obliq,
					MC - ] ] > ].

cp_prop_intrans_nfin_verb := cp_prop_intrans_verb & 
  [ LOCAL.CAT.HEAD [ VFORM bse,
		     TAM [ MOOD indicative ] ] ].

cp_only_prop_intrans_verb := cp_intrans_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp,
                            --SIND.SF basic-prop ] > ].

cp_ques_intrans_verb := cp_intrans_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < >,
                            --SIND.SF ques ] > ].

;; suppose
cp_prop_raise_key_verb := basic_cp_prop+ques_verb & cp_intrans_subst & 
                          basic_two_arg & arg12h_lt & cp_passivable_verb &
                          cp_comp_verb &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL [ KCMP.LOCAL.CAT s_cat_fin_unspec &
                                       [ HEAD.INV - ],
                        COMPS < [ --MIN #min,
                                  LOCAL [ CONT.HOOK.INDEX.SF basic-prop,
                                          AGR #agr ],
                                  OPT - ] > ] ],
            CONT.RELS <! relation !>,
            AGR #agr ] ].

cp_prop_raise_key_3sg_verb := cp_prop_raise_key_verb &
  [ LOCAL fin_verb & [ CAT [ HEAD.TAM indic_tam & 
				      [ TENSE nonpast,
					ASPECT no_aspect ],
			     VAL.SUBJ < [ LOCAL.AGR.PNG.PN 3s ] > ] ] ].

cp_prop_raise_key_n3sg_verb := cp_prop_raise_key_verb &
  [ LOCAL fin_verb & [ CAT [ HEAD.TAM indic_tam & 
				      [ TENSE nonpast,
					ASPECT no_aspect ],
			     VAL.SUBJ < [ LOCAL.AGR.PNG.PN -3s ] > ] ] ].

cp_prop_raise_key_pst_verb := cp_prop_raise_key_verb &
  [ LOCAL past_or_subj_verb ].

cp_prop_raise_key_prp_verb := cp_prop_raise_key_verb &
  [ LOCAL prp_verb ].

cp_prop_raise_key_psp_verb := cp_prop_raise_key_verb &
  [ LOCAL psp_verb ].

; Make lexical entries inflected (manual entries for each form, sigh) since 
; can't use inflectional rules to do it since they constrain AGR which is 
; here instead identified with complement's AGR.
v_cp_prop_raise_key_lexent := main_verb_sans_key & 
  [ INFLECTD +,
    SYNSEM cp_prop_raise_key_verb ].

;; tell Kim that/whether S
;; inform Kim that S
np_trans_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt.

;; DPF 2017-08-20 - Changed to allow imperative S-comp, as in 
;; *we told him, `jump!'.*
;;
np_trans_cp_fin_or_inf_verb := norm_cp_prop+ques_verb & cp_trans_subst & 
                               cp_trans_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT basic_s_cat_v_c &
				 [ HEAD [ VFORM fin_or_inf_or_imp,
					  TAM indic_tam ] ] ].

;; bet Kim ten cents that S
np_np_cp_verb := fin_cp_prop+ques_verb & np_np_cp_subst & tritrans_lt.

basic_pp_cp_fin_verb := fin_cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
                  cp_passivable_verb & cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind ],
                          synsem > ].

pp_cp_fin_prop_verb := basic_pp_cp_fin_verb &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT + ],
			    [ LOCAL.CAT.HEAD verbal,
			      --SIND.SF prop ] >,
	    CONT.RELS <! relation !> ] ].

pp_cp_fin_pq_verb := fin_cp_prop+ques_verb & basic_pp_cp_subst & pp_cp_lt &
                  cp_passivable_verb & cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind,
			    OPT + ],
			  synsem & [ LOCAL.CAT s_cat_fin_or_inf_unspec,
				     --SIND.SF prop-or-ques ] > ].

pp*_cp_fin_verb := basic_pp_cp_fin_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT + ].

pp_cp_fin_verb := basic_pp_cp_fin_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

pp_cp_fin_unspec_verb := fin_cp_prop+ques_unspec_verb & basic_pp_cp_subst & 
			 pp_cp_lt & cp_passivable_verb & cp_comp_verb &
  [ LOCAL [ CAT.VAL.COMPS.FIRST [ OPT +,
				  --SIND non_expl-ind ],
	    CONT.RELS <! relation !> ] ].

basic_pp_cp_inf_verb := cp_prop+ques_verb & pp_cp_subst & pp_cp_lt &
                  cp_passivable_verb & cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND non_expl-ind ],
                          [ LOCAL.CAT s_cat_inf_unspec ] > ].

pp*_cp_inf_verb := basic_pp_cp_inf_verb.

pp_cp_inf_verb := basic_pp_cp_inf_verb &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

pp_expl_cp_verb := fin_cp_prop+ques_verb & pp_cp_subst & basic_pp_cp_lt &
                   cp_passivable_verb &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
			    LOCAL.CONT.HOOK.XARG it-ind,
			    OPT - ], 
			  synsem > ].

;; *ask Kim "who did you admire"* with embedded inverted question.
;; Changed COMPS..SUBJ < > to SUBJ *antilist* to allow embedded inverted
;; clauses, as in *Kim asked, where are they*
;; DPF 2017-10-07 - Restrict CP complement to exclude pre-modif, seemingly not
;; needed, and because pre-S subord-CP modifiers lose the SF constraint (see
;; elsewhere for why).
;;
np_trans_cp_ques_verb := fin_cp_prop+ques_verb & basic_cp_trans_subst & 
			 cp_trans_lt & cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL [ CAT [ HEAD.INV +,
						  VAL.SUBJ *anti_list*,
						  MC + ],
                                            CONT.HOOK.INDEX.SF ques ] ] > ].

;; persuade Kim that S
np_trans_cp_prop_verb := fin_cp_prop+ques_verb & cp_trans_subst & cp_trans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, 
			  [ --SIND.SF basic-prop ] > ].

;; ask that Kim be released
cp_bse_intrans_verb := bse_cp_verb & basic_cp_intrans_subst & basic_two_arg &
                       arg12h_lt & cp_passivable_verb.

;; Sherlock: "That be the house ... remarked Mr. G"
cp_bse_intrans_xtra_verb := basic_bse_cp_verb & basic_cp_intrans_subst & 
		       basic_two_arg & arg12h_lt & cp_passivable_verb &
		       cp_comp_verb.

;; wish that he were here.
cp_sbjnct_intrans_verb := norm_cp_prop+ques_verb & cp_intrans_subst &
			  basic_two_arg & arg12h_lt & cp_passivable_verb &
  [ LOCAL.CAT.VAL.KCMP [ --SIND.E.MOOD subjunctive,
			 LOCAL.CAT.HEAD.VFORM fin ] ].

cp_frag_intrans_verb := verb_synsem & two_arg_subst & basic_two_arg & 
			arg12h_lt & cp_comp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD frag & [ MINORS.ALTMIN norm_rel,
						    CASE non_nom ],
			    NONLOC.REL 0-dlist,
			    OPT - ] > ].

;; try to
subj_equi_verb := cp_prop+ques_verb & inf_intrans_subst & basic_two_arg & 
                  subj_equi_inf_lt.

; refrain from Ving
subj_equi_from_verb := cp_prop+ques_verb & inf_intrans_from_subst & 
                       basic_two_arg & subj_equi_inf_lt.

;; try and find it
;; Allow "I/you/we/they try and find it" but block "*He tries and find it"
;; but allow "I/you/we/they/he will try and find it" and "Try and find it".
subj_equi_and_verb := cp_prop+ques_verb & inf_intrans_and_subst & 
                      basic_two_arg & subj_equi_inf_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
            CONT.HOOK.INDEX.E.ASPECT no_aspect ],
    LKEYS [ --COMPKEY #cmin,
            --+COMPKEY #cmin ] ].

subj_equi_and_fin_verb := subj_equi_and_verb &
  [ LOCAL [ CAT.HEAD [ VFORM fin,
                       TAM.TENSE nonpast ],
	    AGR.PNG.PN -3s ] ].

subj_equi_and_bse_verb := subj_equi_and_verb &
  [ LOCAL.CAT.HEAD.VFORM bse ].

;; couldn't help but notice
subj_equi_but_verb := cp_prop+ques_verb & inf_intrans_but_subst & 
                      basic_two_arg & subj_equi_inf_lt &
  [ LOCAL [ CAT [ HEAD.VFORM bse,
		  VAL.COMPS < [ OPT - ] > ],
            CONT.HOOK.INDEX.E.ASPECT no_aspect ],
    LKEYS [ --COMPKEY #cmin,
            --+COMPKEY #cmin ] ].

;; have yet to find it
ssr_particle_verb := verb_synsem & inf_intrans_particle_subst & 
  [ LOCAL [ CAT [ HEAD.MINORS.MIN v_event_rel,
                  VAL [ SUBJ < [ --SIND #sind ] >,
                        COMPS < [ OPT - ],
                                [ LOCAL [ CAT.HEAD verbal & [ INV - ],
                                          CONT.HOOK [ LTOP #cltop,
                                                      XARG #sind ] ],
                                  OPT - ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
			  INDEX #arg0,
                          XARG #sind ],
                   RELS <! #keyrel & 
			   [ LBL #ltop,
			     ARG0 #arg0 & non_conj_event,
                             ARG1 #argh ] !>,
                   HCONS <! qeq & [ HARG #argh,
                                    LARG #cltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel ].

;; tell, persuade
obj_equi_verb := cp_prop+ques_verb & inf_trans_subst & obj_equi_inf_lt.

;; get: 'Kim got abrams to stay'
obj_equi_non_trans_verb := cp_prop+ques_verb & inf_non_trans_subst & 
			   obj_equi_inf_lt &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

;; For the less common use of "promise", where the obj-equi reading is 
;; apparently only available if the VP is passive, as in
;; *the teacher promised the students to be allowed to play outside*
;; *the students were promised to be allowed to play*
;;
obj_equi_trans_psv_verb := cp_prop+ques_verb & inf_trans_subst & 
			       obj_equi_inf_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ],
			  [ LOCAL.CAT.HEAD.MINORS [ MIN be_v_prd_rel,
						    ALTMIN passive_rel ] ] > ].

;; help
obj_equi_bse_verb := verb_synsem & sor_bse_subst & obj_equi_bse_lt.


;; appeal, intend
oeq_pp_inf_verb := verb_synsem & pp_inf_subst & basic_three_arg & 
                   obj_equi_inf_lt & empty_prep_intrans_lt.

;; listened to him sing
oeq_pp_bse_verb := verb_synsem & basic_pp_vp_subst & basic_three_arg & 
		   unsat_three_arg_subst &
                   obj_equi_bse_lt & empty_prep_intrans_lt &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CAT vp_bse_cat ].


;; gear up the team to ...
particle_oeq_verb := cp_prop+ques_verb & particle_oeq_subst & four_arg &
                     particle_oeq_lt.

;; arrange with kim to meet
pp_inf_seq_verb := cp_prop+ques_verb & pp_inf_subst & basic_three_arg & 
                   pp_inf_seq_lt.

; promise
anom_equi_verb := cp_prop+ques_verb & inf_non_trans_subst & anom_equi_lt.

; use X to do Y
anom_equi_trans_verb := cp_prop+ques_verb & inf_trans_subst & anom_equi_lt &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

; ask X to be allowed to Y
anom_equi_psv_verb := cp_prop+ques_verb & inf_trans_subst & anom_equi_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ],
			  [ LOCAL.CAT.HEAD.MINORS [ MIN aux_event_rel,
						    ALTMIN passive_rel ] ] > ].

; take too long to do X
anom_equi_oblig_verb := anom_equi_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
                          [ --MIN non_ellipt_rel ] > ].

; have trouble sleeping
anom_equi_prp_verb := verb_synsem & prp_non_trans_subst & obj_equi_prp_lt.

; prevent X from Ving
obj_equi_from_verb := cp_prop+ques_verb & inf_trans_from_subst & 
                      obj_equi_inf_lt.

particle_inf_verb := cp_prop+ques_verb & particle_inf_subst & 
		     anom_equi_particle_lt.

particle_prp_verb := verb_synsem & particle_prp_subst & 
		     subj_equi_prp_or_bse_lt.

particle_cp_verb := fin_cp_prop+ques_verb & particle_cp_subst & 
		    particle_cp_lt & cp_passivable_verb.

particle_pp_cp_verb := fin_cp_prop+ques_verb & particle_pp_cp_subst & 
		       particle_pp_cp_lt & cp_passivable_verb.

basic_expl_it_subj_pp_cp_verb := norm_cp_prop+ques_verb & expl_pp_cp_subst & 
				 expl_it_subj_pp_cp_lt.

basic_expl_it_subj_ppto_cp_verb := basic_expl_it_subj_pp_cp_verb &
  [ LKEYS.--COMPKEY _to_p_sel_rel ].

expl_it_subj_pp*_cp_verb := basic_expl_it_subj_ppto_cp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], 
			  [ LOCAL.CONT.HOOK.INDEX.SF basic-prop ] > ].

expl_it_subj_pp_cp_verb := basic_expl_it_subj_ppto_cp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ LOCAL.CONT.HOOK.INDEX.SF prop-or-like ] > ].

expl_it_subj_pp_cp_like_verb := basic_expl_it_subj_ppto_cp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], 
			  [ LOCAL [ CAT.HEAD comp,
				    CONT.HOOK.INDEX.SF like-iforce ] ] > ].

expl_it_subj_pp_cp_unsp_verb := basic_expl_it_subj_ppto_cp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], 
			  [ LOCAL.CONT.HOOK.INDEX.SF prop-or-ques ] > ].

expl_it_subj_ppnoto_cp_verb := basic_expl_it_subj_pp_cp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ LOCAL.CONT.HOOK.INDEX.SF prop-or-like ] > ].

expl_it_subj_np_cp_verb := norm_cp_prop+ques_verb & expl_np_cp_subst & 
                           expl_it_subj_np_cp_lt &
  [ LOCAL.CONT [ HCONS <! qeq !>, ICONS <! !> ] ].

; To admit e.g. "That Kim lost suggests that Sandy won.", where CP-subjects
; normally come from VPs with a CP-gap and an expletive-it subject.
; 
expl_it_subj_cp_cp_verb := norm_cp_prop+ques_verb & expl_cp_cp_subst & 
                           expl_it_subj_cp_cp_lt.


;; *it annoys him to shave himself*
expl_it_subj_np_vp_verb := norm_cp_prop+ques_verb & expl_np_vp_subst & 
                           expl_it_subj_np_vp_lt &
  [ LOCAL.CONT [ HCONS <! qeq !>, ICONS <! !> ] ].


; 'It costs me ten dollars for you to enter'
expl_it_subj_np_np_cp_inf_verb := norm_cp_prop+ques_verb & 
                          expl_np_np_cp_inf_subst & expl_it_subj_np_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT + ], 
			  [ OPT + ],
			  [ LOCAL.CONT.HOOK.INDEX.SF prop-or-comm ] > ].

expl_it_subj_np_np_vp_inf_verb := norm_cp_prop+ques_verb & 
                          expl_np_np_cp_inf_subst & expl_it_subj_np_np_vp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ ], [ ], [ LOCAL.CONT.HOOK.INDEX.SF prop-or-comm ] > ].

; `it makes him angry that S'
expl_it_subj_np_prdp_cp_verb := norm_cp_prop+ques_verb & 
			 expl_np_np_prdp_cp_subst & expl_it_subj_np_prdp_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ OPT -,
			    LOCAL.CAT.HEAD adj ],
			  [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].


; `it makes him the winner that S'
expl_it_subj_np_np_cp_verb := norm_cp_prop+ques_verb & 
                          expl_np_np_cp_subst & expl_it_subj_np_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ OPT - ],
			  [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].


; `it matters a lot to him that S'
expl_it_subj_np_pp_cp_verb := norm_cp_prop+ques_verb & 
			 np_pp_cp_subst & expl_it_subj_np_np_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ OPT - ], 
			  [ OPT +,
			    --MIN _to_p_sel_rel ],
			  [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].

; He called it to their attention that S.
np_expl_pp_cp_verb := norm_cp_prop+ques_verb & 
		      np_pp_cp_subst & arg1_subj_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT -,
			      --SIND it-ind ], 
			    [ OPT -,
			      --MIN _to_p_sel_rel,
			      LOCAL.CONT.HOOK [ LTOP #lbl,
						INDEX #objind & non_expl-ind &
					         [ SORT entity-or-nomevent ]]],
			    [ LOCAL.CONT.HOOK [ LTOP #chand,
						INDEX.SF prop ] ] >,
	    CONT [ RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #mhand,
				    LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg123_relation & #keyrel & [ LBL #lbl,
					       ARG1 non_expl-ind,
					       ARG2 #objind,
					       ARG3 #mhand ] ].

;; DPF 2016-09-17
;; *it took them until Friday to arrive*
expl_it_subj_np_pp_cp_inf_verb := norm_cp_prop+ques_verb & 
				  np_pp_cp_subst & expl_it_subj_np_prdp_cp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ ], 
			  [ LOCAL.CAT.HEAD [ MINORS.MIN independent_rel,
					     MOD.FIRST.LOCAL 
							intersective_mod ] ],
			  [ LOCAL.CAT.HEAD comp & [ VFORM inf ],
			    OPT - ] > ].

;; "It ticked him off that S"
expl_it_subj_np_ptcl_cp_verb := norm_cp_prop+ques_verb & np_ptcl_cp_subst &
				expl_it_subj_np_ptcl_cp_lt.

expl_it_subj_prtcl_cp_verb := norm_cp_prop+ques_verb & expl_prtcl_cp_subst & 
                              expl_it_subj_prtcl_cp_lt.

expl_it_subj_cp_verb := norm_cp_prop+ques_verb & expl_cp_subst & 
                        expl_it_subj_cp_lt.

expl_it_subj_vp_verb := norm_cp_prop+ques_verb & expl_vp_subst & 
                        expl_it_subj_cp_lt.

expl_pp_inf_oeq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_oeq_lt.

expl_pp_inf_seq_verb := cp_prop+ques_verb & expl_pp_inf_subst & 
			expl_pp_inf_seq_lt.

atrans_inf_verb := cp_prop+ques_verb & inf_intrans_subst & basic_two_arg & 
		   atrans_inf_lt.

for_to_verb := verb_synsem & for_inf_intrans_subst & basic_two_arg & arg12h_lt.

particle_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < *top* >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].

; 'going on'
particle_3only_verb := verb_synsem & particle_subst & arg1_subj_lt & two_arg &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --SIND.PNG.PN 3 ] >,
		      COMPS < *top* > ],
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].

;; DPF 2016-10-28 - This type was identifying KCMP and COMPS.REST.FIRST, but
;; this is wrong for *make up his mind that S*, and anyway seems to be
;; unnecessary.  Monitor and FIX?
;;
generic_particle_NP_verb := verb_synsem & particle_NP_subst & particle_NP_lt.

basic_NP_particle_verb := verb_synsem & generic_NP_particle_subst & 
                          basic_NP_particle_lt.
generic_NP_particle_verb := basic_NP_particle_verb & NP_particle_lt.

NP_particle_verb := generic_NP_particle_verb & NP_particle_subst.

NP_particle_idiom_verb := basic_NP_particle_verb & NP_particle_subst &
			  poss_idiom_lt &
  [ LOCAL [ CAT.VAL [ COMPS.FIRST #kcmp,
		      KCMP #kcmp ],
	    CONT [ HOOK.XARG #xarg,
		   RELS <! relation, #altkeyrel !> ] ],
    LKEYS.ALTKEYREL #altkeyrel & [ ARG1 #xarg ] ].

; 'credit back the money to the account'
NP_particle_pp_verb := generic_NP_particle_verb & NP_particle_pp_subst &
                       NP_particle_pp_lt &
  [ LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin,
	    --OCOMPKEY #ocmin,
	    --+OCOMPKEY #ocmin ] ].

NP_particle_ppto_verb := NP_particle_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _to_p_sel_rel ]> ].

NP_particle_ppof_verb := NP_particle_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _of_p_sel_rel ]> ].

NP_particle_ppfor_verb := NP_particle_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _for_p_sel_rel ]> ].

NP_particle_ppfrom_verb := NP_particle_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _from_p_sel_rel ]> ].

NP_particle_ppin_verb := NP_particle_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _in_p_sel_rel ]> ].

NP_particle_ppon_verb := NP_particle_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _on_p_sel_rel ]> ].

NP_particle_ppas_verb := NP_particle_pp_verb &
  [ LOCAL.CAT.VAL.COMPS < synsem, synsem,
			  [ LOCAL.CAT.HEAD.MINORS.MIN _as_p_sel_rel ]> ].

; 'give him back his dog'
NP_particle_np_verb := generic_NP_particle_verb & NP_particle_np_subst &
                       NP_particle_np_lt.

; `make up her mind to leave'
; `make up her mind that she would leave'
;; DPF 2018-04-03 - Assume only for reflexive idioms, and add in id_rel
NP_particle_cp_verb := basic_NP_particle_verb & NP_particle_cp_subst &
                       NP_particle_cp_lt.

; 'make him out to be crazy'
NP_particle_vp_verb := basic_NP_particle_verb & NP_particle_cp_subst &
                       basic_NP_particle_cp_lt &
  [ LOCAL.CONT.RELS <! relation !> ].

particle_prd_verb := verb_synsem & particle_prd_subst & anom_equi_prd_lt.

particle_pp_verb := verb_synsem & particle_pp_subst & 
		    prep_particle_intrans_lt &
  [ LOCAL.CAT.VAL.COMPS < synsem, [ LOCAL.CAT pp_cat,
				    OPT - ] >,
    LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin,
	    --OCOMPKEY #ocmin,
	    --+OCOMPKEY #ocmin ] ].

particle_empty_pp_verb := verb_synsem & particle_pp_subst & 
                          empty_prep_particle_intrans_lt.

; prefer it if ...
expl_obj_cp_verb := fin_cp_prop+ques_verb & cp_trans_subst & expl_obj_cp_lt &
  [ LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

expl_obj_cpcmp_verb := expl_obj_cp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL [ CAT.HEAD comp,
					 CONT.HOOK.INDEX.SF prop ] ] >,
    LKEYS [ --COMPKEY #cmin,
	    --+COMPKEY #cmin ] ].

expl_obj_cpprop_verb := expl_obj_cp_verb &
  [ LOCAL.CAT.VAL.COMPS < [ ], [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].


; make it clear that ...
; This type should be redundant with the sor_prd_verb type, but CP-taking
; adjs constrain their MOD..HEAD to be no_head (for some doubtless good
; reason), so they won't unify with the prd_cat constraint on the second
; complement of sor_prd_verbs.  FIX? ...

expl_obj_prd_verb := verb_synsem & sor_prd_trans_subst & expl_obj_prdp_lt &
  [ LOCAL.CAT.VAL.COMPS < [ --SIND it-ind,
                            OPT - ], 
                          [ LOCAL.CAT.HEAD adj ] > ].

; 'i am doing fine/badly/well', but also 'how are you doing?'
adv_verb := verb_synsem & adv_subst & arg1_subj_lt & two_arg &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ] >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel & [ ARG1 non_expl-ind ] ].

; 'he put it very well'
np_adv_verb := verb_synsem & np_adv_subst & trans_lt &
  [ LOCAL [ CAT.VAL.COMPS < [ OPT - ], [ OPT - ] >,
	    CONT.RELS <! #keyrel !> ],
    LKEYS.KEYREL #keyrel ].

; Inverted verbs of saying: "Kim left, said Sandy"
; DPF 2011-jan-07 - Added constraint [POSTHD -] to block these inverted 
; sentences from being admitted as that-less relatives, as in
; **the [cats [said Kim purred]] arrived* (contrast with *the cats Kim said 
; purred arrived* 
;; DPF 2014-05-20 - Changed SPR < > to SPR *anti_list* so we can get post
;; modification of the inverted phrase, as in *we arrived, said Kim yesterday*
;; DPF 2015-03-12 - And changed SUBJ from *anti_list*, so we can also get
;; *we arrived, said Kim happily*.  
;; DPF 2016-10-31 - Re 2011-jan-07: But this runs afoul of the constraint
;; added on 26-aug-07 to head_adj_int_phrase, to block attachment to
;; attributive adjectives, apparently.  Instead of rethinking that hack,
;; we constrain the MOD value to be HEAD no_head, preventing these from
;; undergoing the relative clause rule.
;;
quoting_verb_inv_synsem := basic_two_arg &
  [ LOCAL [ CAT [ HEAD verb & 
                       [ VFORM fin,
                         TAM #tam,
			 MOD.FIRST.LOCAL.CAT.HEAD no_head ],
                  VAL [ SUBJ *anti_list*,
			SPR *anti_list* ] ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX #event & [ E #tam ] ],
                   RELS.LIST < #keyrel, ... > ],
            CONJ cnil ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     ARG0 #event ] ].

; DPF 13-May-02 - Made passive_synsem inherit from basic_verb_synsem rather
; than verb_synsem since we don't want it to be subtype of lex_synsem, since
; simple passives can be post-nominal modifiers, as in "the price quoted is
; too high"
; DPF 04-sep-09 - Make SUBJ synsem instead of synsem_min, to distinguish
; passive VPs from CPs.
;; DPF 2016-11-22 - Added anti_synsem_min to end of SPR list, to be like
;; adjectives in allowing post-head modifiers after the normal spr is picked
;; up, as in *Kim is well-known for ideas* like *Kim is very happy here*.
;;
basic_passive_synsem := basic_verb_synsem & passive_or_unacc_synsem & 
                        lex_synsem &
  [ LOCAL [ CAT [ HEAD [ AUX -,
                         VFORM pas,
			 MINORS [ MIN v_event_rel,
				  ALTMIN passive_rel ] ],
                  VAL [ SUBJ < synsem &
                               [ LOCAL [ CAT nomp_cat_min,
					 CONT.HOOK.INDEX #ind,
                                         CONJ cnil,
					 AGR.PNG #png ],
                                 --SIND #ind & basic_non_event ] >,
			SPR < synsem_min &
			      [ --MIN more_this_deg_rel,
				LOCAL [ CAT [ HEAD adv,
					      VAL [ SPR *olist*,
						    COMPS < >,
						    SPEC < [ LOCAL.CAT.HS-LEX 
								     #hslex ]>],
					      MC na ],
					CONT.HOOK [ LTOP #ltop,
						    XARG #arg0 ] ],
				NONLOC.SLASH 0-dlist,
				OPT + ], 
			      anti_synsem_min > ],
                  HS-LEX #hslex ],
	    AGR.PNG #png,
            CONJ cnil ],
    LKEYS.KEYREL [ LBL #ltop,
		   ARG0 #arg0 & non_conj_event ] ].

;; DPF 2020-03-24 - Pushed COMPS..--MIN and OPT down to subtypes as per trunk.
passive_synsem := basic_passive_synsem &
  [ LOCAL.CAT.VAL.COMPS *obliquecons* &
                        < synsem & 
                          [ LOCAL local &
                                  [ CAT [ HEAD prep,
                                          VAL [ SUBJ < >,
                                                SPR *olist*,
                                                COMPS < > ] ] ],
                            NONLOC.REL 0-dlist ], ... > ].

;; DPF 2020-05-23 - Removed parent atrans_lt since it has --+ARGIND it-ind,
;; but this derived type for *that she would win was expected by all* cannot
;; impose that requirement.
;;
passive_atrans_synsem := passive_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN no_role_rel,
		  VAL [ SUBJ < synsem &
			       [ --SIND it-ind & #subjind ] >,
			COMPS.FIRST [ --MIN _by_p_cm_rel,
				      OPT + ] ] ],
            CONT.HOOK.XARG #subjind ] ].

basic_passive_unerg_synsem := passive_synsem & basic_two_arg &
  [ LOCAL [ CAT.VAL [ SUBJ < [ --MIN nom_or_mnp_rel,
                               --SIND #sindex & basic_non_expl ] >,
                      COMPS < [ --SIND #cindex ] > ],
            CONT [ HOOK [ INDEX #index,
                          XARG #sindex ],
                   RELS.LIST < #keyrel &
			       [ ARG0 #index,
                                 ARG1 #cindex,
                                 ARG2 #sindex ], ... >,
		   ICONS <! topic & [ IARG1 #index,
				      IARG2 #sindex ] !> ] ],
    LKEYS.KEYREL #keyrel ].

; born
passive_unerg_synsem := basic_passive_unerg_synsem &
  [ LOCAL [ CAT.VAL.COMPS.FIRST [ --MIN _by_p_cm_rel,
				  OPT + ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! [ LBL #ltop ] !>,
		   HCONS <! !> ] ] ].

;; DPF 2020-03-24 - Added type as per trunk.
; surrounded with
passive_unerg_with_synsem := basic_passive_unerg_synsem &
  [ LOCAL [ CAT.VAL.COMPS.FIRST [ --MIN _with_p_sel_rel,
				  OPT - ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! [ LBL #ltop ] !>,
		   HCONS <! !> ] ] ].

; unevaluated
passive_unerg_neg_synsem := basic_passive_unerg_synsem &
  [ LOCAL [ CAT [ MC na,
		  VAL.COMPS.FIRST [ --MIN _by_p_cm_rel,
				    OPT + ] ],
            CONT [ HOOK.LTOP #ltop,
                   RELS <! [ LBL #lbl ], 
			   #altkeyrel &
                           [ PRED neg_rel,
                             LBL #ltop,
                             ARG0.E.TENSE no_tense,
                             ARG1 #arg ] !>,
                   HCONS <! qeq & [ HARG #arg,
                                    LARG #lbl ] !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

; 'Kim was referred to often'
;; DPF 2016-10-08 - We can't make this inherit from basic_three_arg, since
;; we also want it to apply to `make' in *was made up of X* which is four-arg.
;; So instead have to make sure the nonloc values are correclty linked up from
;; dtr to mother in the lexical rules that use this type.
;; DPF 17-03-01 - Removed parent particle_subst, since we want the passive for
;; verbs with contentful prep PP complements, as in *Kim was spoken to* and
;; *Kim was lied to*.  Note that while we still have separate prep entries
;; for *to* as noun-mod and non-noun-mod, we're getting spurious ambiguity
;; for *Kim was lied to*, but live with it for now, and hope to conflate those
;; two *to*s soon.  FIX?
;; 
prep_passive_synsem := basic_passive_synsem &
  [ LOCAL.CAT.VAL.COMPS *obliquecons* &
                        < abstr_lex_synsem &
			  [ LOCAL.CAT.HEAD prep,
                            NONLOC non-local_none,
			    OPT - ],
			  synsem & 
                          [ --MIN _by_p_cm_rel,
                            LOCAL local &
                                  [ CAT [ HEAD prep,
                                          VAL [ SUBJ < >,
                                                SPR *olist*,
                                                COMPS < > ] ] ],
                            OPT + ], ... > ].

ptcl_prep_passive_synsem := basic_passive_synsem & particle_subst &
  [ LOCAL.CAT.VAL.COMPS *obliquecons* &
                        < abstr_lex_synsem & [ LOCAL.CAT.HEAD prep ],
			  synsem & [ LOCAL.CAT [ HEAD prep,
						 VAL.COMPS *cons* ] ],
			  synsem & 
                          [ --MIN _by_p_cm_rel,
                            LOCAL local &
                                  [ CAT [ HEAD prep,
                                          VAL [ SUBJ < >,
                                                SPR *olist*,
                                                COMPS < > ] ] ],
                            NONLOC.REL 0-dlist,
                            OPT + ], ... > ].

;; *was made an example of*
np_prep_passive_synsem := basic_passive_synsem & generic_np_particle_subst &
			  four_arg &
  [ LOCAL.CAT.VAL.COMPS < synsem,
			  synsem & [ LOCAL.CAT [ HEAD prep,
						 VAL.COMPS *cons* ] ],
			  synsem & 
                          [ --MIN _by_p_cm_rel,
                            LOCAL local &
                                  [ CAT [ HEAD prep,
                                          VAL [ SUBJ < >,
                                                SPR *olist*,
                                                COMPS < > ] ] ],
                            NONLOC.REL 0-dlist,
                            OPT + ], ... > ].

ssr_particle_v_lexent := nonc-hm &
  [ INFLECTD -,
    SYNSEM ssr_particle_verb &
           [ LOCAL.CAT.HEAD verb & [ AUX -,
                                     INV - ],
	     LKEYS.KEYREL.ARG0 non_conj_event ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modifier synsems
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; When changing, remember to also modify verb_participle_affix in lexrules.tdl
;; DPF 2012-08-29 - Mysteriously, this type imposes REL 0-dlist, but that can't
;; be right since we want e.g. *the cat whose long tail twitched*.  What were
;; we thinking?  Let's see if anything goes awry when we remove this constraint.
;; DPF 2018-06-28 - Added reentrancy of HOOK.INDEX and KEYREL.ARG0, since this
;; should hold for all intersective modifiers, including adverbs (which were
;; missing a reentrancy for HOOK.INDEX).
;;
isect_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
	    CONT.HOOK [ LTOP #hand,
			INDEX #index ] ],
    LKEYS.KEYREL [ LBL #hand,
		   ARG0 #index ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The semantics of a main verb consists of the "main" handel for the sentence
; and a list of relations.  A pointer to the main or head relation in the list
; is kept in the LKEYS.KEYREL attribute.
;
; DPF 26-Jan-01 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.
;; DPF 2019-11-18 - Moved INV - down to subtypes, since the generic passive
;; verb inherits from this type, and we currently exclude *being arriving* via
;; the hack of stamping INV - on present participles but not passives.

basic_main_verb_sans_key := basic_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ AUX -,
					 TAM [ TENSE #tense,
					       ASPECT #aspect,
					       MOOD ind_or_subj ] ],
			   HC-LEX - ],
                     CONT [ HOOK.INDEX #index & [ E [ TENSE #tense,
                                                      ASPECT #aspect ] ],
                            RELS.LIST < relation & #keyrel, ... > ],
		     CONJ cnil ],
             PUNCT no_punctuation_min,
             LKEYS.KEYREL #keyrel & [ ARG0 #index ] ] ].

main_verb_sans_key := basic_main_verb_sans_key &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS [ MIN v_event_rel,
					 ALTMIN role_rel ],
				INV - ],
		     CONT.HOOK.LTOP #ltop ],
             LKEYS.KEYREL.LBL #ltop ] ].

basic_main_verb := main_verb_sans_key &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN nonaux_event_rel,
		       MC na ] ].

norm_basic_main_verb := basic_main_verb & nonc-h.

main_verb_newltop := basic_main_verb_sans_key & nonc-h &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD [ MINORS [ MIN v_event_rel,
				     ALTMIN role_rel ],
			    INV - ] ].

main_verb := norm_basic_main_verb &
  [ INFLECTD - ].

main_verb_mliszt := basic_main_verb & nonc-h &
  [ INFLECTD - ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; AUXILIARY VERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Auxiliary verbs are subject-to-subject raising verbs which also raise the 
; content of the VP complement, possibly tacking an additional relation on the
; end.  They also raise the context of the VP complement, for now at least to
; propagate tense information.
; AUX verbs are further classified by the type of VP complement they 
; select for.  Also, AUX verbs optionally take a neg (post-head) specifier.

;; DPF 2016-10-19 - We don't want to make itcleft_verb_synsem be AUX + because
;; we want ti to take modifiers, as in *in Paris it was Kim who slept*, but we
;; still want it to undergo the adv-addition lexical rule for negation, so we
;; can also get *it was not in Paris that Kim slept*.  So add a supertype for
;; that lexical rule to use.
;;
auxverb_or_itcleft_synsem := lex_synsem.

basic_aux_verb := basic_verb_synsem & auxverb_or_itcleft_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN v_event_rel,
		  VAL [ SUBJ < [ LOCAL.AGR.PNG #png ] >,
			SPR < anti_synsem_min > ] ],
	    AGR.PNG #png ] ].
		
aux_verb := basic_aux_verb &
  [ LOCAL [ CAT.HEAD.TAM #tam,
	    CONT.HOOK.INDEX.E #tam ] ].

aux_verb_ssr_subst := aux_verb & ssr_subst.

aux_verb_ssr := aux_verb_ssr_subst & basic_two_arg &
  [ LOCAL.CAT [ HEAD.MINORS [ MIN #min,
                              ALTMIN #altmin ],
                VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
		      KCMP #comp & [ LOCAL.CAT.HEAD.MINORS.ALTMIN #altmin ],
                      COMPS < #comp > ] ],
    LKEYS.KEYREL [ LBL #ltop,
		   PRED #min ] ].

aux_verb_ellip := aux_verb &
  [ LOCAL.CAT.VAL.COMPS < > ].

aux_verb_word_super := nonc-hm.

aux_verb_word := aux_verb_word_super &
  [ SYNSEM aux_verb_ssr &
           [ LOCAL.CAT [ HEAD.AUX +,
                         POSTHD + ] ] ].

bse_aux_verb_ssr := aux_verb_ssr &
  [ LOCAL.CAT [ POSTHD +,
		VAL.COMPS < synsem &
			    [ LOCAL [ CAT vp_bse_unspec_cat,
				      CONJ cnil ],
			      OPT - ] > ] ].

bse_aux_verb_word := aux_verb_word &
  [ SYNSEM bse_aux_verb_ssr ].

;; DPF 2016-12-02 - Generalized COMPS.FIRST from canonical_synsem to
;; canonical_or_unexpressed, so ellipsis rule can require unexpressed
;;
inf_aux_verb_ssr := aux_verb_ssr &
  [ LOCAL.CAT [ POSTHD +,
		VAL.COMPS < canonical_or_unexpressed &
			    [ LOCAL [ CAT vp_inf_cat,
				      CONJ cnil ],
			      --SIND.SF basic-prop,
			      OPT - ] > ] ].
;; ought, going
inf_aux_verb_word := aux_verb_word_super &
  [ INFLECTD +,
    SYNSEM inf_aux_verb_ssr,
    ALTS.VPELLIP - ].

psp_aux_verb_ssr := aux_verb_ssr &
  [ LOCAL.CAT.VAL.COMPS < synsem &
			  [ LOCAL [ CAT vp_cat &
					[ HEAD verb &
					       [ VFORM psp ] ],
				    CONJ cnil ],
			    OPT - ] > ].

;; Only for auxiliary "have" and "should+of"
psp_aux_verb_word := aux_verb_word &
  [ SYNSEM psp_aux_verb_ssr ].

; Only for the copula
; DPF 29-Nov-02 - Predicative copula has to identify COMPS..MOD..INDEX with
; COMPS..XARG since predicative PPs cannot lexically identify XARG with their
; KEY.ARG1, because PPs acting as modifiers of VPs have to project the XARG
; of the VP.
; DPF 20-Nov-03 - But now identifying INDEX of PP with its event, not its XARG.
; DPF 30-aug-05 - Note that we can't make the complement be REL 0-dlist since
; we use the relative clause for the purposive "Kim is to stay."
; DPF 01-Dec-06 - To avoid circularity in generator for e.g. "We could have
; been hiring Browne.", we depend on hack which makes "have" be POSTHD -,
; while other auxiliaries are POSTHD +, to block "been having been ..." 
; FIX?
;; DPF 2017-09-16 - To avoid spurious ambig for *issues were unchanged*,
;; propagate the prdP complement's MOD..--MIN constraint to the verb's subject.
;;
prd_aux_verb_ssr := aux_verb_ssr &
  [ LOCAL [ CAT [ HEAD [ AUX +, 
			 MINORS.MIN be_v_prd-or-id_rel ],
		  POSTHD +,
		  VAL [ SUBJ.FIRST.LOCAL [ CAT.HEAD.MINORS.MIN #modmin,
					   CONT.HOOK.LTOP #ltop ],
			COMPS 
		       < [ LOCAL [ CAT basic_prd_cat &
				       [ HEAD [ MINORS [ MIN independent_rel,
							 NORM norm_rel ],
						MOD.FIRST.--MIN #modmin ],
					 VAL.SUBJ *olist*,
					 POSTHD + ],
				   CONT.HOOK [ LTOP #ltop,
					       INDEX #index &
						     [ E.TENSE tense ],
					       XARG #ind ] ],
			   --SIND #index,
			   NONLOC.REL 0-dlist,
			   OPT - ] > ] ],
	    CONT.HOOK [ INDEX #index,
			XARG #ind ],
	    ARG-S < [ NONLOC [ SLASH [ LIST #smiddle,
				       LAST #slast ],
			       REL #rel,
			       QUE [ LIST #qmiddle,
				     LAST #qlast ] ] ],
		    [ NONLOC [ SLASH [ LIST #sfirst,
				       LAST #smiddle ],
			       QUE [ LIST #qfirst,
				     LAST #qmiddle ] ] ] > ],
    LKEYS.KEYREL.LBL #ltop,
    NONLOC [ SLASH [ LIST #sfirst,
		     LAST #slast ],
	     REL #rel,
	     QUE [ LIST #qfirst,
		   LAST #qlast ] ] ].

prd_aux_verb_word := aux_verb_word_super &
  [ SYNSEM prd_aux_verb_ssr ].

raise_cont := word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                       INDEX #index ] ], ... >,
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index ],
			  RELS <! !> ] ] ].

add_cont := word &
  [ SYNSEM [ LOCAL.CONT.RELS.LIST < relation & #keyrel, ... >,
             LKEYS.KEYREL #keyrel ] ].
		   
; Real modal verbs are auxiliary verbs which select a base form complement.
; They only exist in finite forms.
; DPF 2-Oct-01 - Removed [KCMP..INDEX.E.TENSE no_tense] since this
; prevented low attachment of "when" in "when can Kim arrive"
;; DPF 2018-10-21 - Re 2-Oct-01: It seems that this change didn't stick,
;; but now that we treat it-clefts without an additional EP, the INDEX of the
;; verbal complement in *would be Kim who won* is no longer E.TENSE no_tense,
;; at least not for now, so let's remove it again, and monitor.
;;
generic_modal_verb_super_synsem := aux_verb_ssr &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CAT.HEAD basic_noun,
	    CONT [ HOOK.INDEX #event,
		   HCONS.LIST < qeq &
				[ HARG #arghand ], ... >,
		   ICONS <! !> ] ],
    LKEYS.KEYREL arg1_relation &
	  [ ARG0 #event & non_conj_event,
	    ARG1 handle & #arghand ] ].

generic_modal_verb_word_super := aux_verb_word_super &
  [ SYNSEM generic_modal_verb_super_synsem ].

generic_modal_verb_synsem := generic_modal_verb_super_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
	    CONT.HCONS.LIST < [ LARG #chand ], ... > ] ].

generic_modal_verb_word := generic_modal_verb_word_super &
  [ SYNSEM generic_modal_verb_synsem ].

;; DPF 2017-11-08 - Constraining modals' subject to be an NP here means we can't get
;; locative inversion as in *in the corner might be a broom*, unless we also have a
;; lexical rule to create loc-inv modals.  It seems like we should instead be identifying
;; the controlled complement's subject's CAT with the modal's subject's CAT, in addition 
;; to the already controlled semantic index.  FIX in one of these two ways.
;;
fin_modal_verb_synsem := generic_modal_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ PRD -,
			 VFORM fin,
			 TAM.ASPECT #aspect ],
		  POSTHD +,
		  VAL [ SUBJ < synsem & [ LOCAL 
					      [ CAT nomp_cat_nom_min,
						CONJ cnil ],
					--SIND basic_non_event,
					OPT - ] >,
			KCMP.LOCAL.CAT.HEAD.TAM.ASPECT #aspect ] ],
	    CONT psoa ] ].

fin_modal_verb_word := generic_modal_verb_word &
  [ SYNSEM fin_modal_verb_synsem ].

;; DPF 2016-12-02 - Generalized COMPS.FIRST from canonical_synsem to
;; canonical_or_unexpressed, so ellipsis rule can require unexpressed
;;
ought_verb_synsem := fin_modal_verb_synsem & inf_aux_verb_ssr &
  [ LOCAL.CAT [ HEAD [ AUX -,
		       TAM [ TENSE present,
			     ASPECT no_aspect ] ],
		VAL.COMPS.FIRST canonical_or_unexpressed &
		     [ LOCAL.CAT.HEAD.TAM.TENSE no_tense ] ] ].

ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ SYNSEM ought_verb_synsem,
    ALTS.CSAI - ].

; Assume for now that all modals have simple present tense semantics,
; ignoring the habitual past readings possible for "would" and "could" -
; these will have to be separate lexical entries.
; DPF 26-Jun-03 - Changed this to allow underspecification of tense for at
; least 'could'

modal_verb_synsem := fin_modal_verb_synsem & bse_aux_verb_ssr &
  [ LOCAL.CAT.VAL [ SUBJ < [ OPT - ] >,
		    COMPS.FIRST [ LOCAL.CAT vp_bse_cat,
				  --SIND.SF prop-or-comm ] ] ].

modal_verb_word := fin_modal_verb_word & bse_aux_verb_word &
  [ SYNSEM modal_verb_synsem ].

;; DPF 2016-12-02 - Generalized COMPS.FIRST from canonical_synsem to
;; canonical_or_unexpressed, so ellipsis rule can require unexpressed
;;
pos_modal_verb_synsem := modal_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ AUX +,
			 TAM indic_tam ],
		  VAL.COMPS.FIRST canonical_or_unexpressed ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel & [ PRED modal_rel,
			     LBL #ltop ] ].

modal_pos_lex_ent := modal_verb_word & add_cont &
  [ SYNSEM pos_modal_verb_synsem ].

modal_pos_indic_lexent := modal_pos_lex_ent &
  [ SYNSEM.LOCAL.CAT.HEAD.TAM.MOOD indicative ].

pos_ought_verb_synsem := ought_verb_synsem &
  [ LOCAL.CONT [ HOOK.LTOP #ltop,
		 RELS <! #keyrel !>,
		 HCONS <! qeq !> ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

pos_ought_verb_word := ought_verb_word &
  [ SYNSEM pos_ought_verb_synsem ].

past_ought_verb_synsem := inf_aux_verb_ssr & fin_modal_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ AUX -,
			 TAM [ TENSE past,
			       ASPECT no_aspect ] ],
		  VAL.COMPS < [ MODIFD notmod_or_rmod ] > ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

; 'used (to)' - Exclude modifiers intervening before VP-inf complement.
;
past_ought_verb_word := fin_modal_verb_word & inf_aux_verb_word &
  [ ALTS.ADVADD -,
    SYNSEM past_ought_verb_synsem ].

;; DPF 2016-12-02 - Generalized COMPS.FIRST from canonical_synsem to
;; canonical_or_unexpressed, so ellipsis rule can require unexpressed
;; DPF 2019-10-01 - Note that we resist the temptation to treat "going to" like
;; "will", semantically empty with [TENSE future], because it's difficult to see
;; what the semantics of "was going to" would be.
;; DPF 2020-03-24 - Added COMPS..SUBJ..OPT - as per trunk.
;;
basic_quasimodal_verb_synsem := generic_modal_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ MINORS.MIN _going+to_v_qmodal_rel,
			 TAM.TENSE real_tense ],
		  VAL [ COMPS.FIRST #comp & canonical_or_unexpressed &
				    [ LOCAL.CAT.VAL.SUBJ.FIRST.OPT - ],
			KCMP #comp ] ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     PRED will_modal_rel ] ].

;; DPF 24-Jun-03 ***FIX?:  [ HEAD.MOD < anti_synsem_min >,
basic_quasimodal_verb_word := generic_modal_verb_word &
  [ INFLECTD +,
    SYNSEM basic_quasimodal_verb_synsem,
    ALTS.CSAI - ].

quasimodal_verb_synsem := basic_quasimodal_verb_synsem & inf_aux_verb_ssr &
  [ LOCAL.CAT.HEAD [ AUX +,
		     TAM.ASPECT.PROGR + ] ].

quasimodal_word := basic_quasimodal_verb_word & inf_aux_verb_word &
  [ SYNSEM quasimodal_verb_synsem ].

quasimodal_psp_synsem := inf_aux_verb_ssr & generic_modal_verb_synsem &
  [ LOCAL [ CAT.HEAD [ VFORM psp,
		       TAM.TENSE present,
		       AUX -,
		       PRD - ],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel &
	  [ LBL #ltop ] ].

quasimodal_psp_word := inf_aux_verb_word & generic_modal_verb_word &
  [ SYNSEM quasimodal_psp_synsem,
    ALTS.CSAI - ].

quasimodal_psp_bse_synsem := generic_modal_verb_synsem & bse_aux_verb_ssr &
  [ LOCAL [ CAT.HEAD [ VFORM psp,
		       TAM.TENSE present,
		       PRD -],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel &
	  [ LBL #ltop ] ].

; "we've *gotta* win"
quasimodal_psp_bse_word := generic_modal_verb_word & bse_aux_verb_word &
  [ INFLECTD +,
    SYNSEM quasimodal_psp_bse_synsem,
    ALTS.CSAI - ].

quasimodal_bse_synsem := basic_quasimodal_verb_synsem & bse_aux_verb_ssr &
  [ LOCAL.CAT [ HEAD [ VFORM prp,
		       PRD + ],
		VAL.COMPS < [ LOCAL.CAT vp_bse_cat,
			      --SIND.SF basic-prop ] > ] ].

quasimodal_bse_word := basic_quasimodal_verb_word & bse_aux_verb_word &
  [ SYNSEM quasimodal_bse_synsem ].

;; DPF 2016-12-02 - Generalized COMPS.FIRST from canonical_synsem to
;; canonical_or_unexpressed, so ellipsis rule can require unexpressed
;;
nonfin_modal_verb_synsem := generic_modal_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ PRD -,
			 VFORM bse,
			 AUX -,
			 TAM [ TENSE past,
			       ASPECT [ PRF -,
					PROGR - ] ] ],
		  VAL.COMPS < canonical_or_unexpressed &
			      [ LOCAL.CAT vp_inf_cat,
				--SIND.SF basic-prop ] >],
	    CONT [ HOOK.LTOP #ltop,
		   RELS <! #keyrel !>,
		   HCONS <! qeq !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

; 'didn't he used to sing?'
nonfin_modal_word := generic_modal_verb_word &
  [ INFLECTD +,
    SYNSEM nonfin_modal_verb_synsem ].

; DPF 09-Jan-00 - Removed SLASH 0-dlist from COMPS.FIRST, since it was blocking
; e.g. "When's he leaving"
; DPF 13-apr-05 - Instead, make COMPS.FIRST be expressed_synsem.  Also seems
; to make ALTS.VPELLIP - unnecessary.
; DPF 18-aug-09 - Re 13-apr-05: But expressed_synsem isn't quite right, since
; this still unifies with 'gap', so change to canonical_synsem.
; DPF 06-apr-10 - Re 18-aug-09: But we want gaps, as in "where's Kim?", so
; revert to expressed_synsem.  Sigh.
;; DPF 2015-03-31-- Re 06-apr-10: Okay, we want gaps for inverted contracted
;; aux, but we want to block **Here, Kim's* when the aux is not inverted.
;; Not easy to get this asymmetry for parsing, but for generation, at least,
;; impose GENRE nonformal on the noninverted form, and changed the SAI lexical 
;; rule to not preserve the GENRE constraint, so we can generate the inverted
;; contraction extraction, but not non-inverted one, as long as we use
;; root_strict for generation.  FIX someday.
;; DPF 2015-04-16 - Re 2015-03-31: Let's try making these INFLECTD na, and 
;; adding a rule that produces the noninverted INFLECTD + forms that constrain
;; the COMPS.FIRST to be canonical_synsem.
;;
contracted_aux_word := word &
  [ INFLECTD na,
    ALTS [ VPELLIP -,
           SQPNCT -,
	   CSAI - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST expressed_synsem,
    GENRE nonformal ].

; copula, 'exists'
; DPF 12-Apr-02 - The second (predicative) complement was being blocked by
; MIN no_rel - avoided unwanted ambiguity, but now prevents e.g. "where is
; there a problem" since we now want to avoid spurious adjunct extraction.
; So removed no_rel, and instead require this second complement to be 
; non_canonical - allows extraction, but not the spuriosity of in-situ PrdPs.
; DPF 01-Feb-03 - Since we're now allowing adjunct extraction for independent
; reasons, let's try abandoning that second complement of the 'there'-copula
; altogether.  Then we avoid the awkward semantic composition problem of
; having to find the LBL of the noun_rel inside the first complement - does
; violence to our semantic algebra.
; DPF 28-oct-03 - Restored the three-arg there-copula since we need it at
; least for extractions like "what is there to do" (& "there is nothing to do")
; where the last complement has a non-empty rel (to avoid spurious ambig).
; Since the optional second complement will be RELS non-empty, can't use the
; default appending of non-local feats, so have to do cumbersome repeat here,
; to avoid propagating that non-empty RELS.  But don't want to say explicitly
; here that it's non-empty, since then constraint on *olist* not satisfied.
; DPF 28-jun-07 - Constrain second complement to be non-extracted, to avoid
; spurious ambiguity for "In Berlin, there are cats"

; there-copula and it-cleft copula

expl_verb_synsem := unsat_three_arg_subst & norm_verb_synsem & norel_three_arg &
  [ LOCAL [ CAT [ VAL [ SUBJ < [ --SIND expl-ind & #subjind ] >,
                        COMPS < synsem &
			    [ LOCAL [ AGR non_expl,
				      CONJ cnil ],
                              --SIND #cind,
                              NONLOC.REL 0-dlist,
                              OPT - ],
			    [ LOCAL local &
				    [ CAT [ HEAD 
                                             [ MOD < synsem &
                                                     [ --SIND #cind ]> ],
                                            VAL [ SPR *olist*,
                                                  SUBJ *olist*,
						  COMPS < > ],
					    MC na ],
                                      CONT.HOOK.XARG #cind ],
                              NONLOC.SLASH 0-dlist ] > ] ],
            CONT.HOOK.XARG #subjind ],
    LKEYS.KEYREL arg1_relation &
          [ ARG1 #cind & non_expl ] ].

; DPF 25-oct-05 - Removed second comp's [PRD -] since PP's need to be + (see 
; note (same date) for p_reg_lexent), while (most) relative clauses are [PRD -]
;; DPF 2017-10-03 - Removed COMPS.FIRST..GEN neut since we want to be able to
;; get *there was a girl* even if we assign GEN fem.  And more immediately,
;; for paraphrase generation, we want e.g. "mouse" in a story to be GEN fem,
;; and still get *there is a mouse*.
;; DPF 2018-06-02 - Dropped constraint on second comp's MOD's HEAD, so we can
;; get *there is a road all the way in*
;;
there_verb_synsem := expl_verb_synsem & 
  [ LOCAL [ CAT [ HEAD [ TAM #tam,
			 MINORS.ALTMIN role_rel ],
		  VAL [ SUBJ < [ --SIND there-ind & #sind &
                                      [ PNG [ PN #pn,
                                              GEN no_gend_there ] ],
			     LOCAL [ AGR.PNG.PN #pn,
				     CONT.HOOK.INDEX #sind ] ] >,
		      COMPS < [ --MIN nonpro_or_refl_or_num_rel & #min ,
                              LOCAL [ CAT np_cat_acc_min & 
					  [ HEAD noun_or_nomger ],
				      CONT.HOOK.INDEX.SORT 
					  basic-entity-or-event,
                                      AGR.PNG.PN #pn ] ],
                            [ LOCAL [ CAT [ HEAD v_or_a_or_p &
                                            [ MOD < [ LOCAL intersective_mod,
                                                      --MIN #min ] > ],
                                            MC na,
                                            POSTHD + ],
                                      CONT.HOOK [ LTOP #lbl,
                                                  INDEX.E.TENSE no_tense ],
                                      CONJ cnil ],
                              LEX -,
                              OPT + ] > ] ],
	    CONT.HOOK.INDEX.E #tam ],
    LKEYS.KEYREL.LBL #lbl ].

there_verb_nohc_synsem := there_verb_synsem &
  [ LOCAL.CONT [ RELS <! #keyrel !>,
		 HCONS <! !>,
		 ICONS <! !> ],
    LKEYS.KEYREL #keyrel ].

; DPF 19-jan-08 - Try removing AUX + so we can parse e.g. "In Paris it
; was Kim who laughed."
;; DPF 2011-08-01 - Constrained first COMP to be --MIN independent_rel, to
;; exclude selected-for PPs (spurious ambig), since these are no longer [PRD -].
;; DPF 2015-03-17 - Changed INDEX from being reentrant with the second comp's
;; index to be the ARG0 of the main predication, since the old way was
;; blocking *it would be Kim who arose* where the INDEX's tense did not match
;; what the model requires.
;; DPF 2017-09-14 - Re 2011-08-01: But we need selected PPs, as in
;; *it was on Kim that we relied for our news*.  So remove this constraint,
;; and check to see if the extra ambiguity is tolerable.
;; DPF 2018-10-21 - Now that we use ICONS for topic/focus, this entry does not
;; introduce its own EP, so needs to identify its hook with that of the verbal
;; complement.  This presents a puzzle for how to express the following contrast
;; since we have no obvious place to record contrasting TAM values in (a):
;; (a) It is Kim who won.
;; (b) It was Kim who won.
;; FIX somehow - Maybe reference time would help?
;;
itcleft_verb_synsem := expl_verb_synsem & auxverb_or_itcleft_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN be_v_it_rel,
		  VAL [ SUBJ < [ --SIND it-ind & [ PNG.GEN no_gend_it ],
				 LOCAL.AGR.PNG #png ] >,
			COMPS < synsem & [ LOCAL [ CAT [ HEAD n_or_p &
                                                            [ POSS -,
                                                              PRD + ],
                                                       VAL [ SUBJ *olist*,
                                                             SPR *olist*,
                                                             COMPS < > ],
                                                       MC na_or_- ],
						   CONT.HOOK.LTOP #ltop ],
					   --MIN #min,
					   NONLOC non-local_none ],
				canonical_synsem &
				[ LOCAL 
                                     [ CAT [ HEAD verb & 
					      [ VFORM fin,
						MOD < [ LOCAL.CAT.HEAD supnoun,
							--MIN norm_rel ] >,
						MINORS.NORM #min ],
					     VAL.SUBJ *olist*,
					     MC na ],
				       CONT.HOOK [ LTOP #ltop,
						   INDEX #index ] ],
				  OPT - ] > ] ],
	    CONT.HOOK [ LTOP #ltop,
			INDEX #index & event ],
	    AGR.PNG #png ],
    LKEYS.--+ARGIND it-ind ].

; 'In the corner is a chair'
; 'Especially popular is Rondane'
; POSTHD - is hack to prevent these from undergoing adjunct extraction
; DPF 12-nov-05 - Generalized subj to be v_or_a_or_p (from just a_or_p)
; to get e.g. "Also contributing to their success was ..."
; Also prevent spurious gapping of complements
; DPF 09-may-06 - SUBJ..ALTMIN blocks np_adv_c phrases, to avoid spurious
; ambiguity for e.g. "There is Kim."
; DPF 06-jul-06 - But this also blocks "Here is Kim." and "There stood Kim".
; So instead constrain NORM, but only for the copula.
; DPF 10-sept-07 - Changed COMPS..--MIN from nonpro_rel to reg_or_temp_nom_rel
; to avoid unwanted analyses with gerunds, as in "...in the tree is arising..."
; DPF 13-may-09 - Restrict SUBJ to be MOD anti_synsem, to exclude infinitival
; relatives, which otherwise look much like e.g. passive VPs
;; DPF 2011-09-30 - Added SUBJ..NORM no_rel to block non-depictives like *so*
;; as in *so was Browne*
;; DPF 2017-09-16 - Removed SUBJ canonical_synsem since we want these in
;; relative clauses such as *the door behind which stood the broom* where the
;; VP *stood the broom* needs to under subj-extraction.
;; DPF 2018-02-12 - Added SLASH.LIST *arglist* to subject, to avoid spurious 
;; ambig for e.g. *near him in Paris is the Eiffel Tower.* while still allowing
;; extraction of the whole subject (see 2017-09-16 above).
;; DPF 2018-05-25 - Re DPF 2011-09-30: But now we want lexical PPs to be
;; NORM norm_rel to block them in v_mod, and anyway *so is Kim* is now otherwise
;; blocked, so remove this NORM no_rel constraint on the subj.
;;
basic_loc_inv_verb_word := nonc-hm &
  [ SYNSEM twoarg_verb_synsem & 
     [ LOCAL [ CAT [ HEAD [ AUX -, 
                            INV -,
                            MINORS.MIN aux_arg1_rel ],
                     VAL [ SUBJ < synsem &
				  [ --MIN independent_rel,
                                    LOCAL
                                    [ CAT basic_prd_cat &
                                          [ HEAD v_or_a_or_p &
                                                 [ MOD < anti_synsem &
							 [ --SIND #sind ] >,
						   AUX - ],
                                            VAL.SUBJ *olist* ],
                                      CONT.HOOK 
                                          [ INDEX event,
                                            XARG #sind & individual_min ] ],
				    NONLOC.SLASH.LIST *arglist*,
                                    OPT - ] >,
                           COMPS < synsem_min & 
                                   [ LOCAL [ CAT nomp_cat_min &
				                 [ HEAD.CASE nom ],
                                             AGR #agr,
                                             CONJ cnil ],
                                     --SIND ref-ind,
				     NONLOC.SLASH 0-dlist,
                                     OPT - ] > ] ],
               AGR #agr,
               CONT.HOOK [ LTOP #ltop,
			   INDEX.--TPC + ] ],
       NONLOC [ REL 0-dlist,
		QUE 0-dlist ],
       LKEYS.KEYREL.LBL #ltop ],
    ALTS.NGER - ].

loc_inv_verb_word := basic_loc_inv_verb_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.--MIN reg_or_temp_nom_rel ].

;; DPF 2017-10-06 - Prevent subject gap, to avoid spurious analysis of
;; **we know where is the restaurant is*
;; DPF 2017-11-08 - But this blocks relative clauses like *prominent among 
;; which is Paris* so instead constrain SF to prop, to allow relative clauses 
;; but not questions.
;;
loc_inv_be_synsem := twoarg_verb_synsem &
  [ LOCAL [ CAT [ HEAD [ PRD -,
			 TAM.MOOD indicative,
			 MINORS.ALTMIN role_rel ],
		  VAL [ SUBJ < [ LOCAL.CONT.HOOK [ LTOP #ltop,
						   INDEX #ind &
							[ E.TENSE tense ],
						   XARG #xarg ] ] >,
			COMPS < [ --SIND #xarg ] > ],
		  POSTHD - ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #ind & non_conj_event & [ SF prop ],
			  XARG #xarg ],
		   RELS <! !> ] ],
    LKEYS.KEYREL.PRED no_rel ].

basic_loc_inv_be_word := loc_inv_verb_word &
  [ INFLECTD +,
    SYNSEM loc_inv_be_synsem ].

loc_inv_be_word := basic_loc_inv_be_word &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin ].

loc_inv_mv_synsem := twoarg_verb_synsem &
  [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK [ LTOP #ltop,
						   INDEX #xarg,
						   XARG #index ] ]] >,
		      COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
						  INDEX #cind ] ] > ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #index,
			  XARG #xarg ],
		   RELS <! #keyrel !> ] ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     ARG0 #index,
			     ARG1 #cind ] ].

; 'lie, stand'
; DPF 20-apr-08 - Added identity of SUBJ..INDEX and own XARG, to block
; spurious analysis of "Kim would ride the horse."
loc_inv_mv_word := loc_inv_verb_word &
  [ INFLECTD -,
    SYNSEM loc_inv_mv_synsem ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NOUNS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;       TYPE                 ISA                what's it for?
;       nominal_synsem       lex_synsem         all nouns
;       xpro_synsem          nominal_synsem     pro v. non-pro dimension
;       xref_synsem          nominal_synsem     ref v. non-ref dimension
;       pronominal_synsem    xpro_synsem        all pronouns
;       nonpronominal_synsem xpro_synsem        all non-pronominal nouns
;       ref_synsem           xref_synsem        personal pro's & nouns
;       non_ref_synsem       xref_synsem        it, there, wh-pronouns
;       ref_pro_synsem       pronominal_synsem  personal pronouns
;                            & ref_synsem
;       non_ref_pro_synsem   pronominal_synsem  it, there, wh-pronouns
;                            & non_ref_synsem
;       noun_synsem          nonpronominal_synsem all non-pro nouns
;                            & ref_synsem 

; The "default" statement that most nouns identify their AGR and INDEX
; will live on noun_synsem and non_ref_pro_synsem, and then be restated for
; personal pronouns other than my special 'they'.  (All this because I can't
; be bothered now to set up a special default type...) 

; DPF 3-May-03 - Why can't we make [MODIFD notmod] true for all nouns, rather
; than stipulating it on (almost) all subtypes?  Who wants to stay unmarked?
; Answer: day-of-month nouns like "tenth", which can combine with the simple
; determiner "the" and still be modifiers: "He arrived the tenth" but "*He
; arrived the week"

nominal_synsem := basic_lex_synsem & 
  [ LOCAL [ CAT [ HEAD.POSS -,
		  VAL.SPCMPS < > ],
	    CONT nom-obj ] ].

xpro_synsem := nominal_synsem.
xref_synsem := nominal_synsem.

; DPF 23-Jul-99 - Add missing MOD < >.

pronominal_synsem := xpro_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD partn,
		  VAL.SUBJ < > ] ] ].

nonpronominal_synsem := xpro_synsem.

; AAC - added following types for verbal_gerund, poss_clitic etc

nonpro_nomod_synsem := nomod_synsem & nonpronominal_synsem.
nomod_onearg_synsem := nomod_synsem & one_arg.
nonpro_nomod_onearg_synsem := nonpro_nomod_synsem & basic_one_arg.

;; DPF 2018-03-09 - Constrain ARG0 to nonconj_ref-ind, since some rules such
;; as n-hdn_cpd-pl-mnp_c need to distinguish conjoined from nonjoined nominals
;;
ref_synsem := xref_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN basic_nom_rel,
                  VAL.SPEC < anti_synsem_min > ],
            CONT [ HOOK.INDEX #inst,
                   RELS.LIST < #keyrel & 
                               [ ARG0 #inst & nonconj_ref-ind ], ... > ] ],
    LKEYS.KEYREL #keyrel ].

non_ref_synsem := xref_synsem & nomod_synsem & zero_arg &
  [ LOCAL.CAT.VAL [ SPR < >,
		    COMPS < >,
                    SPEC < anti_synsem_min > ] ].

ref_pro_synsem := pronominal_synsem & ref_synsem & nomod_synsem.

non_ref_pro_synsem := pronominal_synsem & non_ref_synsem &
  [ LOCAL [ AGR #agr,
	    CAT.HEAD.MOD < >,
	    CONT.HOOK.INDEX #agr ] ].

basic_noun_synsem := nonpronominal_synsem & ref_synsem &
  [ LOCAL.CAT.HEAD noun_or_ttl ].

noun_synsem := basic_noun_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD noun,
            AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

mass_or_count_synsem := basic_noun_synsem.
count_noun_synsem := mass_or_count_synsem &
  [ LOCAL.CONT.HOOK.INDEX.IND + ]. 

;;
;; Common nouns
;;
;; DPF 16-Nov-00 - Added SPR.NONLOC.SLASH 0-dlist - don't know how we did
;; without this up to now.
;; DPF 14-Jul-01 - Well, we don't actually want SPR..SLASH 0-dlist since it
;; blocks free relative det constructions like "whichever person you hired"
;; where the "whichever" has a non-empty SLASH value.  Don't know what
;; motivated the above addition of 0-dlist, but I'm sure we'll soon see.
; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).
; DPF 8-Jun-03 - Removed SPR..COMPS *olist* since want to allow discontinuous
; analysis for e.g. "a week and a half"
; DPF 8-Jun-03 - Try requiring sprs of nouns to be LEX +, to block "*a and a
; half week" while enabling "a week and a half".  May want to consider making
; the head-spec rule impose this constraint on all specifiers, given similar
; need for allowing "kim is as tall as Sandy" but blocking "*Kim is as as 
; Sandy tall"

basic_unsp_common_noun_synsem := basic_noun_synsem & lex_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
	    CAT [ HEAD.MINORS.ALTMIN #spmin,
                  VAL [ SPR < #spr & synsem &
                              [ --MIN #spmin & quant_rel,
                                LOCAL.CAT [ HEAD det,
                                            VAL [ SUBJ < >,
                                                  SPR *olist* ] ],
                                LEX +,
				OPT - ] >,
                        COMPS #comps,
                        SPEC < anti_synsem_min > ] ] ] ].

unsp_common_noun_synsem := basic_unsp_common_noun_synsem &
  [ LOCAL.CAT.HS-LEX - ].

basic_common_noun_synsem := unsp_common_noun_synsem & noun_synsem.

basic_count_noun_synsem := basic_common_noun_synsem & count_noun_synsem.
common_noun_synsem := basic_count_noun_synsem.

unsp_noun_nocomp_synsem := unsp_common_noun_synsem &
                                 basic_one_arg & nonpro_nomod_synsem &
  [ LOCAL [ CAT [ HEAD noun & [ MINORS.MIN norm_nom_rel ],
		  VAL.COMPS < > ],
	    CONT [ RELS <! nom_relation !>,
		   HCONS <! !>,
		   ICONS <! !> ],
	    AGR.PNG.PN 3 ],
    MODIFD notmod ].

unsp_count_noun_nocomp_synsem := unsp_noun_nocomp_synsem & count_noun_synsem.
unsp_mass_noun_nocomp_synsem := unsp_noun_nocomp_synsem & one_arg &
				basic_basic_mass_noun_synsem &
  [ LOCAL.CONT.HOOK.INDEX [ DIV +, IND - ] ].

common_noun_nocomp_synsem := basic_count_noun_synsem & basic_one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

unsp_mass_or_count_synsem := unsp_common_noun_synsem & 
			     nonpro_nomod_synsem & mass_or_count_synsem.

; For nouns which will remain underspecified for mass/count.
basic_mass_or_count_synsem := unsp_mass_or_count_synsem.

basic_mass_or_count_nocomp_synsem := basic_mass_or_count_synsem & one_arg &
  [ LOCAL.CONT.RELS <! relation !> ].

mass_or_count_nocomp_synsem := basic_mass_or_count_nocomp_synsem & 
                               basic_common_noun_synsem.

noun_nocomp_synsem := common_noun_nocomp_synsem & nonpro_nomod_onearg_synsem.

noun_nonpro_nomod_synsem := basic_common_noun_synsem & nonpro_nomod_synsem.
noun_two_arg_nomod_synsem := noun_nonpro_nomod_synsem & basic_two_arg.

; DPF 22-Jul-03 - Constraint on COMPS < expressed_synsem, ... > ensures that
; this complement is either realized or discharged via hdn_optcmp_c, to avoid
; spurious ambiguity.
;; DPF 2011-08-29 - Re 22-Jul-03: But this discharging is independently ensured,
;; and insisting on expressed_synsem blocks measure_np rule applying to
;; *an* in *an hour and a half*, so remove constraint here.
;; DPF 2019-06-26 - Removed identification of LTOP for head and comp, since
;; the comp is always a selected rel, so its LTOP must stay free, or else in
;; right-node raising, we wrongly identify the labels of the conjoined nouns.
;; DPF 2020-03-24 - Added COMPS..--MIN selected_rel as per trunk.
;;
unsp_noun_ppcomp_synsem := unsp_common_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN #cmin & selected_rel,
                            LOCAL.CAT [ HEAD prep & [ PRD - ],
					VAL.COMPS < > ],
                            PUNCT.LPUNCT no_punct ], ... >,
    LKEYS.--COMPKEY #cmin ].

basic_noun_ppcomp_synsem := unsp_noun_ppcomp_synsem & basic_common_noun_synsem.

noun_nondeverb_ppcomp_synsem := basic_noun_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #index ] >,
    LKEYS.KEYREL.ARG1 #index ].

unsp_ppcomp_two_arg_synsem := unsp_noun_ppcomp_synsem & basic_two_arg &
                              nonpro_nomod_synsem & count_noun_synsem.

unsp_ppcomp_two_arg_mass_synsem := unsp_noun_ppcomp_synsem & basic_two_arg &
				   basic_basic_mass_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
		  VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #index ] > ],
	    CONT.HOOK.INDEX [ DIV +, IND - ] ],
    LKEYS.KEYREL.ARG1 #index ].

noun_ppcomp_two_arg_synsem := unsp_ppcomp_two_arg_synsem &
                              basic_noun_ppcomp_synsem & common_noun_synsem.

noun_ppcomp_three_arg_synsem := basic_noun_ppcomp_synsem & three_arg &
                                nonpro_nomod_synsem & common_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem,
                          synsem &
                          [ --MIN #ocmin,
                            LOCAL [ CAT [ HEAD prep & [ PRD - ],
                                          VAL.COMPS < > ],
                                    CONT.HOOK.LTOP #hand ],
                            PUNCT.LPUNCT no_punct ] >,
    MODIFD.LPERIPH na,
    LKEYS [ KEYREL.LBL #hand,
            --OCOMPKEY #ocmin ] ].

; DPF 25-mar-05 - Added MODIFD notmod to avoid spurious ambig with adjN rules.
; DPF 26-mar-05 - But this conflicts with the constraint in the NP-ADV rule
; which distinguishes "we arrived the week before" from "*we arrived the week"
; since we also want "We arrived Tuesday".  So try just excluding lmod value.

temp_noun_comp_two_arg_synsem := basic_two_arg & count_noun_synsem & 
                                 nonpro_nomod_synsem & 
  [ LOCAL [ CAT [ HEAD noun & [ MINORS.MIN temp_abstr_rel ], 
                  VAL [ SUBJ < >,
                        SPR < [ OPT - ] >,
                        SPEC < anti_synsem_min > ] ],
	    CONT.HOOK.INDEX.SORT time ] ].

temp_noun_ppcomp_two_arg_synsem := temp_noun_comp_two_arg_synsem &
                                   basic_noun_ppcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
			    LOCAL.CONT.HOOK.INDEX #index & non_expl-ind ] >,
    LKEYS.KEYREL.ARG1 #index,
    MODIFD notmod_or_rmod ].

; For e.g. "hotel" as in "the hotel Marriott" or "the Marriott hotel Hannover"c
;; DPF 2019-09-26 - Prevent the NP complement from being extracted
;; 
abstr_noun_nomcomp_synsem := unsp_common_noun_synsem & nonpro_nomod_synsem &
  [ LOCAL [ CAT.VAL.KCMP canonical_synsem &
                         [ OPT -,
			   LOCAL.CONJ cnil ],
	    AGR #agr,
            CONT [ HOOK [ LTOP #hand,
			  INDEX #agr ],
		   RELS.LIST < relation, ... > ] ],
    LKEYS.KEYREL.LBL #hand ].

basic_noun_nomcomp_synsem := abstr_noun_nomcomp_synsem & 
			     noun_nonpro_nomod_synsem.

;; DPF 2018-03-29 - Constraint KCMP..HEAD noun to prevent free relatives, and
;; SORT entity to prevent WH-clause NPs: *in the hotel what we liked best were*
;;
abstr_noun_npcomp_synsem := abstr_noun_nomcomp_synsem &
  [ LOCAL [ CAT.VAL.KCMP [ LOCAL [ CAT nomp_cat_acc_min & [ HEAD noun ],
                                   CONT.HOOK [ LTOP #hand,
                                               INDEX index ] ],
       			   --SIND #cindex ],
            CONT [ HOOK [ LTOP #hand,
			  INDEX #index ],
                   RELS <! relation & [ CFROM #cfrom, CTO #cto ],
			   prep_notense_relation & 
                                     [ PRED compound_rel,
				       LBL #hand,
				       ARG1 #index,
				       ARG2 #cindex,
				       CFROM #cfrom, CTO #cto ] !>,
                   HCONS <! !>,
		   ICONS <! !> ] ] ].

basic_noun_npcomp_synsem := basic_noun_nomcomp_synsem &
			    abstr_noun_npcomp_synsem &
  [ LOCAL.CAT.VAL.KCMP.LOCAL.CONT.HOOK.INDEX.SORT entity ].

basic_common_noun_npcomp_synsem := basic_noun_npcomp_synsem & basic_two_arg &
                                   count_noun_synsem &
  [ LOCAL.CAT.VAL [ COMPS < #comp & [ PUNCT.LPUNCT no_punct ] >,
                    KCMP #comp ] ].

common_noun_npcomp_synsem := basic_common_noun_npcomp_synsem &
  [ LKEYS.KEYREL reg_diadic_nom_relation ].

; 'kinda' as in "what kinda chair is that"
;; DPF 2016-10-21 - Generalize COMP..HEAD from noun to basic_noun, so we can
;; also get pronouns here, as in *the word he* or *the pronoun it*
;; DPF 2018-06-10 - Re 2016-10-21: But since pronoun lexical entries already
;; introduce a pron_q_rel binding the ARG0, letting them in here results in
;; two quantifiers binding that variable.  So make two subtypes, with one just
;; for the word "pronoun" which does not introduce a quant_rel.
;; 
basic_common_noun_nbarcomp_synsem := basic_noun_nomcomp_synsem & basic_two_arg &
				     count_noun_synsem &
  [ LOCAL [ CAT.VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                      COMPS < #comp & abstr_lex_synsem &
                              [ LOCAL [ CAT nbar_cat_min & [ HEAD basic_noun ],
                                        CONT.HOOK.INDEX #arg ],
                                NONLOC.SLASH 0-dlist ] >,
                      KCMP #comp ],
            CONT [ RELS.LIST < [ ARG1 #arg ], ... >,
		   ICONS <! !> ] ],
    LKEYS.KEYREL reg_diadic_nom_relation ].

common_noun_nbarcomp_synsem := basic_common_noun_nbarcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD noun,
				      CONT.HOOK.LTOP #nhand ] ] >,
	    CONT [ RELS <! [ ARG1 #arg ],
			   #alt2keyrel &
			   [ PRED udef_q_rel,
			     ARG0 #arg & ref-ind,
			     RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !> ] ],
    LKEYS.ALT2KEYREL #alt2keyrel ].

common_noun_procomp_synsem := basic_common_noun_nbarcomp_synsem &
  [ LOCAL [ CAT [ HEAD [ MINORS.MIN norm_nom_rel,
				--BARE - ],
		  VAL.COMPS < [ LOCAL.CAT.HEAD partn &
					     [ MINORS.MIN pron_rel,
					       --BARE - ],
				PUNCT [ LPUNCT pair_or_no_punct,
					RPUNCT comma_or_pair_or_no_punct ],
				OPT -] >,
		  HC-LEX + ],
	    CONT [ RELS <! relation !>,
                   HCONS <! !> ] ],
    MODIFD notmod ].

; DPF 08-apr-08 - Added NORM norm_rel to prevent these from heading appositive
;; DPF 2012-08-29 - Changed this type (for *$*) to have an anti_synsem 
;; complement, to avoid seeing this dependent lexical entry as a stand-alone
;; phrase, to avoid massive spurious ambiguity.  Concede that one does see
;; *We need $ to live* in informal writing, but we'll undergenerate for now,
;; in the interest of efficiency.  FIX someday?
;;
common_noun_numcomp_synsem := basic_count_noun_synsem & 
			      nonpro_nomod_synsem &
  [ LOCAL.CAT.HEAD [ MINORS [ MIN mnp_symb_rel,
			      NORM norm_rel ],
                     PRD + ] ].

; ERB (14-12-97) It might be cleaner in some sense for pro_ss to have that
; pron_rel as its MIN and then have this construction and others like it
; take the value of that MIN and put it on their RELS.  Also, if we
; ever move to lexical amalgamation of relations, the pron_rel should get
; incorporated automatically. ... So I'm going to try to do it that way.

; ERB (14-12-97) We just decided that there shouldn't be a pron_rel here.
; The feature PT is enough to distinguish the instance introduced
; by the pro_ss as one that doesn't have to be bound.
;; DPF 2020-05-17 - Pushed DIV +, IND - down to subtypes, so we can leave 
;; mass `time' underspecified, to get *a long time (ago)*
;;
; ERB (21-01-98) The pro_ss should be unslashed.
;;
basic_basic_mass_noun_synsem := unsp_mass_or_count_synsem &
  [ LOCAL.CONT.HOOK.INDEX.PNG png & [ PN 3s ] ].

basic_mass_noun_synsem := basic_basic_mass_noun_synsem & noun_synsem &
  [ LOCAL.CONT.HOOK.INDEX [ DIV +, IND - ] ].

basic_scoping_noun_synsem := noun_nonpro_nomod_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #ltop,
	    CONT [ HCONS.LIST < qeq & [ HARG #arg1, LARG #ltop ], ... >,
		   ICONS <! !> ] ],
    MODIFD.LPERIPH na,
    LKEYS.KEYREL basic_hcomp_nom_relation & [ ARG1 handle & #arg1 ] ].

scoping_noun_synsem := basic_scoping_noun_synsem & noun_two_arg_nomod_synsem &
  [ LOCAL.CAT.VAL.KCMP.NONLOC.SLASH 0-dlist ].

;; a way to meet
;; DPF 2018-04-30 - Should remove COMPS..--MIN non_ellipt_rel so we can get
;; *she didn't make any move to* if the extra ambiguity is tolerable.  FIX.

basic_noun_vpcomp_synsem := basic_scoping_noun_synsem & 
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp &
			      [ LOCAL [ CAT vp_inf_cat,
                                        CONT.HOOK.INDEX.SF basic-prop,
                                        CONJ cnil ],
				--MIN non_ellipt_rel,
				PUNCT.LPUNCT no_punct,
				OPT - ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! qeq !>,
		   ICONS <! !> ] ] ].

basic_common_noun_vpcomp_synsem := basic_noun_vpcomp_synsem &
                                   common_noun_synsem.
common_noun_vpcomp_synsem := basic_common_noun_vpcomp_synsem & 
                             scoping_noun_synsem.
mass_noun_vpcomp_synsem := basic_noun_vpcomp_synsem & scoping_noun_synsem &
                           basic_mass_noun_synsem.
mass_count_noun_vpcomp_synsem := basic_noun_vpcomp_synsem & scoping_noun_synsem
                                 & basic_mass_or_count_synsem.

; pleasure: "it is a pleasure to visit Abrams"

; It is a pleasure to visit abrams.
common_noun_vpcomp_expl_synsem := common_noun_vpcomp_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
                        COMPS < [ NONLOC.SLASH 0-dlist,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG it-ind ],
    MODIFD notmod,
    LKEYS.--+ARGIND it-ind ].

; It is sheer drudgery to visit abrams.
mass_noun_vpcomp_expl_synsem := basic_noun_vpcomp_synsem &
                                basic_mass_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ --MIN implicit_q_rel ] >,
                        COMPS < [ NONLOC.SLASH 0-dlist,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG it-ind ],
    MODIFD notmod,
    LKEYS.--+ARGIND it-ind ].

; Abrams is a pleasure to visit.
common_noun_vpcomp_slash_synsem := basic_common_noun_vpcomp_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN prednom_rel,
                  VAL [ SPR < [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
                        COMPS < [ NONLOC.SLASH 1-dlist & 
                                         <! [ CAT nomp_cat_min,
                                              CONT.HOOK.INDEX #xarg &
                                                  index ] !>,
                                  OPT - ] > ] ],
            CONT.HOOK.XARG #xarg ],
    NONLOC.SLASH 0-dlist,
    MODIFD notmod ].

;; DPF 2018-09-13 - Prevent *information if he arrived*
;;
basic_common_noun_cpcomp_synsem := scoping_noun_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
		      COMPS < #comp & synsem &
			    [ LOCAL [ CAT s_cat_unspec &
					  [ HEAD.CASE nom_or_obliq ],
				      CONJ cnil ],
                              NONLOC.SLASH 0-dlist,
			      LEX -,
			      OPT - ] > ],
	    CONT [ RELS <! relation !>,
                   HCONS <! qeq !>,
		   ICONS <! !> ] ] ].

basic_count_noun_cpcomp_synsem := basic_common_noun_cpcomp_synsem & 
                                  count_noun_synsem &
				  cp_addin_tam_pn.

common_noun_cpcomp_synsem := basic_count_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comp,
			    PUNCT.LPUNCT no_punct,
			    LEX - ] >,
    LKEYS.KEYREL basic_hcomp_nom_relation ].

common_noun_cpcomp_fin_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ].

common_noun_cpcomp_inf_synsem := common_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_inf_v_c ] > ].

common_noun_cpcomp_bse_synsem := basic_common_noun_cpcomp_synsem &
				 count_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_bse & [ HEAD comp ],
			    PUNCT.LPUNCT no_punct,
			    LEX - ] >,
    LKEYS.KEYREL hcomp_nom_relation ].

basic_mass_count_noun_cpcomp_fin_synsem := basic_common_noun_cpcomp_synsem &
					   basic_mass_or_count_synsem &
					   cp_addin_tam_pn &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT basic_s_cat_v_c,
			      PUNCT.LPUNCT no_punct ] >,
            CONT.RELS <! relation !> ],
    LKEYS.KEYREL hcomp_nom_relation ].

mass_count_noun_cpcomp_fin_synsem := basic_mass_count_noun_cpcomp_fin_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c & [ HEAD comp ] ] > ].

;; DPF 2012-12-21 - Removed [HEAD comp] to allow thatless S-comp.
;;
mass_noun_cpcomp_synsem := basic_common_noun_cpcomp_synsem &
                           basic_mass_noun_synsem & cp_addin_tam_pn &
  [ LOCAL [ CAT.VAL.COMPS < [ PUNCT.LPUNCT no_punct ] >,
            CONT.RELS <! relation !> ],
    LKEYS.KEYREL hcomp_nom_relation ].

mass_noun_cpcomp_fin_synsem := mass_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ].

mass_count_noun_cpcomp_inf_synsem := basic_common_noun_cpcomp_synsem &
					   basic_mass_or_count_synsem &
					   cp_addin_tam_pn &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT s_cat_inf_v_c & [ HEAD comp ],
			      PUNCT.LPUNCT no_punct ] >,
            CONT.RELS <! relation !> ],
    LKEYS.KEYREL hcomp_nom_relation ].

mass_noun_cpcomp_inf_synsem := mass_noun_cpcomp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_inf_v_c ] > ].

mass_noun_onearg_synsem := basic_mass_noun_synsem & one_arg &
  [ LOCAL.CAT.VAL.COMPS < > ].

mass_noun_synsem := mass_noun_onearg_synsem &
  [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
            CONT.RELS <! reg_nom_relation !> ] ].

;; DPF 2020-03-24 - Added LPERIPH na as per trunk.
basic_mass_noun_ppcomp_synsem := basic_mass_noun_synsem & basic_two_arg &
                                 noun_nondeverb_ppcomp_synsem &
  [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
    MODIFD.LPERIPH na ].

mass_noun_ppcomp_synsem := basic_mass_noun_ppcomp_synsem & two_arg &
  [ LOCAL.CONT.RELS <! reg_diadic_nom_relation !> ].

mass_noun_ppcomp_nospr_synsem := basic_mass_noun_synsem & basic_two_arg &
				 basic_common_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
		  VAL.COMPS < [ --MIN #cmin,
				LOCAL [ CAT [ HEAD prep & [ PRD - ],
					      VAL.COMPS < > ],
					CONT.HOOK [ LTOP #nhand,
						    INDEX #nind ] ],
				PUNCT.LPUNCT no_punct ] > ],
            CONT [ RELS <! [ ARG1 #nind ],
			   #altkeyrel & [ PRED udef_q_rel,
					  ARG0 #nind & ref-ind,
					  RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    --COMPKEY #cmin ] ].

;; DPF 2020-30-24 - Pushed MIN diadic_nom_rel down as per trunk.
basic_mass_or_count_ppcomp_synsem := basic_mass_or_count_synsem & two_arg &
                                     noun_nondeverb_ppcomp_synsem & 
  [ LOCAL.CONT.RELS <! relation !>,
    LKEYS.KEYREL diadic_nom_relation ].

mass_or_count_ppcomp_synsem := basic_mass_or_count_ppcomp_synsem &
  [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
    LKEYS.KEYREL reg_diadic_nom_relation,
    MODIFD.LPERIPH na ].

;; This type has much in common with mass_noun_ppcomp_nospr_synsem, and with
;; basic_noun_ppcomp_synsem.  FIX someday.
;;
mass_or_count_ppcomp_nospr_synsem := basic_mass_or_count_synsem & 
				     basic_two_arg & basic_common_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
		  VAL.COMPS < [ --MIN #cmin,
				LOCAL [ CAT [ HEAD prep & [ PRD - ],
					      VAL.COMPS < > ],
					CONT.HOOK [ LTOP #nhand,
						    INDEX #nind ] ],
				PUNCT.LPUNCT no_punct ] > ],
            CONT [ RELS <! [ ARG1 #nind ],
			   #altkeyrel & [ PRED udef_q_rel,
					  ARG0 #nind & ref-ind,
					  RSTR #rhand ] !>,
                   HCONS <! qeq & [ HARG #rhand,
                                    LARG #nhand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    --COMPKEY #cmin ] ].

mass_noun_npcomp_synsem := basic_mass_noun_synsem & basic_noun_npcomp_synsem &
                           basic_two_arg &
  [ LOCAL.CAT.VAL [ COMPS < #comp &
                            [ PUNCT.LPUNCT no_punct,
			      --SIND #cind ] >,
                    KCMP #comp ],
    LKEYS.KEYREL reg_diadic_nom_relation &
		  [ ARG1 #cind ] ].

; PRD feature used as a hack to avoid partitives in noun-noun compounds,
; pending a better analysis.
; DPF 9-Sept-99 - Changed N-N block to be based on non-empty ALTMIN, rather 
; than PRD. The handle of the of-NP should probably be an argument of the 
; part_of relation, as the value of a feature SET.  But for now we simply 
; identify the handles of the part_of and the of_NP.
; DPF 17-Apr-03 - Changed set-up so the MIN of partitives will be the MIN of
; the of-PP's NP if there is a complement and an underspecified nom_rel as
; the default.
; DPF 2-May-03 - Changed SPR..MIN from degree_rel to just_only_very_deg_rel
; to block a lot of overgeneration, but still leaving a little (e.g. 
; "very all chairs arrived").  We'll fix this once we move to relation names
; as values of PRED feature in relation.
; DPF 27-Jul-03 - Removed SPR..MIN, since it needs to preserve the constraints
; from the non-partitive determiner (the input to the lexical rule for which
; this type is the output), as in "too much of the rice was spilled".
; DPF 31-Oct-03 - But need some SPR..MIN constraint since not all partitives
; are constructed via that lexical rule, and they need some kind of 
; restriction.  So added this constraint to n_part_lexent below.
; DPF 13-Nov-03 - Removed SPR..COMPS *olist* since want these to be able to
; take comparative degree specifiers (which have a non-empty COMPS list), 
; like in "kim hired as many as sandy"
; DPF 22-feb-04 - Identified INDEX and AGR, as with noun_synsem -- was there
; a reason this wasn't done earlier?  It's needed to get the right agreement
; for e.g. "we climbed peaks all of which are tall".
; DPF 09-may-04 - Changed SPEC < > to SPEC < anti_synsem_min > so partitives can
; appear as complements of empty-preps, as in "kim relied on all the chairs"

partitive_noun_synsem := nonpronominal_synsem & xref_synsem &
  [ LOCAL [ CAT [ HEAD partn &
                       [ MOD < >,
                         MINORS [ MIN basic_nom_rel,
				  ALTMIN abstract_q_rel & #altmin ] ],
                  VAL [ SUBJ < >,
                        SPR < synsem &
                              [ LOCAL 
				[ CAT [ HEAD.MINORS.MIN #min & 
							just_only_deg_rel,
					VAL.SPR  *olist* ],
				  CONT.HOOK.LTOP #althand ],
				NONLOC [ QUE 0-dlist,
					 REL 0-dlist ],
				--MIN #min ],
			      anti_synsem_min & [ OPT - ] >,
			SPEC < anti_synsem_min >,
                        KCMP [ --MIN #cmin & _of_p_sel_rel,
			       --SIND.SORT #sort,
                               LOCAL.CAT [ HEAD prep & 
                                                [ PRD -,
                                                  TAM.TENSE nontense ],
                                           VAL.COMPS < > ],
                               OPT - ] ],
		  HS-LEX - ],
            CONT [ HOOK [ LTOP #nhand,
                          INDEX #index & overt_non_expl-ind &
			       [ SORT #sort ] ],
		   HCONS.LIST < qeq & [ HARG #phand,
                                        LARG #nhand ], ... >,
		   ICONS <! !> ],
	    AGR #index ],
    LKEYS [ KEYREL instance_relation &
                   [ LBL #nhand,
                     ARG0 #index ],
            ALTKEYREL abstract_quant_relation &
                        [ PRED #altmin,
                          LBL #althand,
                          ARG0 #index,
                          RSTR #phand ],
            --COMPKEY #cmin ] ].

; DPF 17-Apr-03 - Identify MIN relation with the of-PP's complement's ALTMIN,
; (the MIN of that PP's NP complement) to maintain visibility of that NP's
; relation, for example to block "*Kim arrives one of these chairs" but allow
; "Kim arrives one of these days".
; DPF 17-dec-03 - Changed KEYREL from reg_diadic_nom_relation to just
; diadic_nom_relation to avoid [SORT entity] constraint, so we can get e.g.
; "hiring sandy is (only) some of the challenge".

basic_partitive_noun_ppof_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL.KCMP [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #min,
                                     CONT.HOOK [ LTOP #lbl,
						 INDEX #arg ] ],
                             NONLOC [ REL #rel,
				      SLASH #slash ],
                             PUNCT.LPUNCT no_punct ] ] ],
    NONLOC [ REL #rel,
	     SLASH #slash ],
    LKEYS.KEYREL basic_diadic_nom_relation &
          [ PRED part_of_rel,
	    LBL #lbl,
            ARG1 #arg & basic_non_expl-ind ] ].

partitive_noun_ppof_synsem := basic_partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL [ KCMP #comp,
                      COMPS < #comp > ],
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel ].

partitive_noun_ppof_agr_synsem := partitive_noun_ppof_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.AGR [ PNG.PN #pn,
                                          DIV #div ],
	    CONT.HOOK.INDEX basic_non_expl-ind,
            AGR [ PNG.PN #pn,
                  DIV #div ] ] ].

;  [ LOCAL.CONT.HOOK.INDEX nonconj_indiv ].
partitive_noun_ppof_noagr_synsem := partitive_noun_ppof_synsem &
  [ LOCAL.CONT.HOOK.INDEX nonconj_overt-ind ].

; all the books, half your salary
; DPF 11-Sept-01 - Added COMPS..ALTMIN norm_non_conj_rel to block e.g.
; 'both Abrams or Browne arrived'
; DPF 1-Oct-01 - Replaced the above with ALTMIN explicit_q_rel to avoid
; spurious parse for "All books".  Maybe no longer need norm_non_conj_rel.
; DPF 25-apr-04 - Deleted the spurious of_p_sel_rel from RELS.
;; DPF 2020-08-13 - Changed COMPS..CAT from nomp_cat_acc_min to
;; nomp_cat_nonnom_min so we get "half what we bought"
;;
basic_partitive_noun_NP_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                  VAL.COMPS < synsem & 
                            [ LOCAL [ CAT nomp_cat_nonnom_min &
                                      [ HEAD.MINORS [ MIN #min,
                                                      ALTMIN explicit_q_rel ]],
                                      CONT.HOOK [ LTOP #lbl,
						  INDEX index ],
                                      CONJ cnil ],
                              NONLOC non-local_none,
                              --SIND #arg,
                              OPT -,
                              PUNCT.LPUNCT no_punct ] > ],
            CONT [ HOOK.INDEX basic_non_expl-ind,
		   RELS.LIST < reg_diadic_nom_relation & #keyrel &
                         [ PRED part_of_rel,
			   LBL #lbl,
                           ARG1 #arg & non_expl-ind ],
                         relation & #altkeyrel, ... > ] ],
    NONLOC [ REL 0-dlist,
	     SLASH 0-dlist ],
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].

partitive_noun_NP_synsem := basic_partitive_noun_NP_synsem &
  [ LOCAL.CONT.RELS <! relation, relation !> ].

; DPF 18-aug-09 - Exclude pronouns: "*All us arrived"
; DPF 2010-11-09 - But generalize nonpro_rel to basic_nonpro_rel so we
; can accept *all that*
;; DPF 2018-02-15 - Also constrain to exclude *"all nobody* and **all a group*
;; DPF 2018-02-17 - But we're also using this type for *half a day*, so push the
;; COMPS.ALTMIN constraint down to distinct le types.
; 
partitive_noun_NP_agr_synsem := partitive_noun_NP_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ AGR [ PNG.PN #pn,
					    DIV #div ],
				      CAT.HEAD.MINORS 
					  [ MIN basic_nonpro_rel,
					    ALTMIN existential_q_rel ] ] ] >,
	    AGR [ PNG.PN #pn,
                  DIV #div ] ],
    LKEYS.ALTKEYREL.PRED explicit_quant_agr_q_rel ].

; both
partitive_noun_NP_noagr_synsem := partitive_noun_NP_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN 3p ] > ].

; not all
partitive_noun_NP_neg_synsem := basic_partitive_noun_NP_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR [ PNG.PN #pn,
                                          DIV #div ] ] >,
            AGR [ PNG.PN #pn,
                  DIV #div ],
	    CONT.RELS <! relation, 
		       [ LBL #lbl,
			 CFROM #cfrom, CTO #cto ],
		       [ PRED "not_x_deg_rel",
			 LBL #lbl,
			 ARG0 event,
			 ARG1 semarg,
			 CFROM #cfrom, CTO #cto ] !> ] ].

; DPF 03-Dec-03 - Added LPERIPH na to prevent these from appearing as heads
; of appositive phrases: "both abrams"
; DPF 06-dec-03 - Moved COMPS < > to le-type using this synsem, so the lexrule
; for partitives with no of-PP can still propagate any other comps of that
; det, in particular for free-rels like "whichever".
; DPF 11-dec-03 - Made MIN part_of_rel so these fit with constraint on "than"
; as in "Kim has more (of the chairs) to offer than Kim"
; DPF 26-aug-07 - Added NORM norm_rel to prevent these from appearing in
; appositives, blocking spurious ambiguity for e.g. "all the cats"
;; DPF 2012-07-22 - Added [SORT basic-entity-or-event] to prevent spurious 
;; do-be as in **some he does is arise*
;
partitive_noun_nocomp_synsem := partitive_noun_synsem &
  [ LOCAL [ CAT.HEAD.MINORS [ MIN part_of_rel,
                              NORM norm_rel ],
            CONT.HOOK.INDEX basic_non_expl-ind &
			    [ PNG.PN 3,
			      SORT basic-entity-or-event ] ],
    MODIFD.LPERIPH na,
    NONLOC [ REL 0-dlist,
	     SLASH 0-dlist ],
    LKEYS.KEYREL.PRED generic_entity_rel ].

basic_noun_word := word &
  [ SYNSEM.PUNCT no_punctuation_min ] .

basic_noun_noaffix_word := nonc-hm-nab & basic_noun_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

basic_pronoun_word := basic_noun_word.

noun_word := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

norm_noun_word := noun_word &
  [ SYNSEM.MODIFD notmod & [ LPERIPH na ] ].

;; DPF 2020-03-24 - Changed parent type as per trunk
basic_basic_intr_noun_word := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM common_noun_nocomp_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #ltop,
			  RELS <! relation !>,
                          HCONS <! !>,
			  ICONS <! !> ],
             LKEYS.KEYREL.LBL #ltop ] ].

basic_intr_noun_word := basic_basic_intr_noun_word & noun_word.

norm_intr_lex_entry := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	  [ LOCAL.CAT.VAL.SPR < [ --MIN abstract_q_rel ] >,
            MODIFD notmod ] ].

;; DPF 2018-03-10 - Added LPERIPH na to prevent spurious compound analysis of
;; *house wine list* using noun_adjn compound rule.
;;
basic_intr_lex_entry := norm_intr_lex_entry &
  [ SYNSEM.MODIFD.LPERIPH na ].

n_intr_lex_entry := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_c_le := n_intr_lex_entry
"""
Intransitive count noun (icn)    
<ex>The dog barked.
"""
.

;; DPF 2020-03-24 - Added type as per trunk.
n_-_c-maycap_le := basic_basic_intr_noun_word &
"""
Intransitive count noun (icn), possibly capitalized
<ex>The British Empire grew.
"""
  [ SYNSEM noun_nocomp_synsem & 
	  [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
			VAL.SPR < [ --MIN abstract_q_rel ] > ],
	    LKEYS.KEYREL reg_nom_relation,
            MODIFD notmod & [ LPERIPH na ] ] ].

n_-_m-maycap_le := nonc-hm & basic_noun_word &
"""
Intransitive mass noun, possibly capitalized
<ex>CCTV is popular.
"""
  [ INFLECTD -,
    SYNSEM mass_noun_synsem & 
	  [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
			  VAL.SPR < [ --MIN abstract_q_rel ] > ],
		    CONT.HOOK.LTOP #ltop ],
	    LKEYS.KEYREL reg_nom_relation & [ LBL #ltop ],
            MODIFD notmod & [ LPERIPH na ] ] ].

n_-_c-ed_le := basic_intr_lex_entry &
"""
Icn, okay for derived adj        
<ex>C is a long-eared cat.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN n-ed_rel,
	     LKEYS.KEYREL reg_nom_relation ] ].

n_-_c-ed-nocnh_le := basic_intr_lex_entry &
"""
Icn, ok drvd adj, no nonhd cmpnd 
<ex>C is a strong-willed cat.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN n-ed_rel,
				     NORM norm_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

;; DPF 2011-10-24 - Added LPERIPH na_or_+ to prevent *Abrams will* as cmpnd.
;;
n_-_mc-ed-nocnh_le := noun_word &
"""
mass noun, ok drvd adj, no nonhd cmpnd 
<ex>C is a strong-willed cat.
"""
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH na_or_+ ],
             LOCAL.CAT.HEAD.MINORS [ MIN n-ed_rel,
				     NORM norm_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

;; DPF 2012-12-15 - Note that `point' should also have MIN be subtype of
;; temp_abstr_rel, in order to admit *from that point on*.  But this would
;; complicate the type hierarchy noticeably.  FIX someday?
;;
; 'end'
n_-_c-ed-ns_le := basic_intr_lex_entry &
"""
Icn, ok drvd adj, unspec sort    
<ex>It is a wide-ended valley.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN n-ed_rel,
		   CONT.HOOK.INDEX.SORT entity-or-qevent ] ].

; 'handheld'
; DPF 06-sept-07 - Let's try adding the hack --BARE - here to prevent these
; from undergoing the robust bare-singular rule.  May be too sweeping, but
; avoids a lot of unwanted ambiguity, e.g. for 'remove'
;; DPF 13-03-13 - Re 06-sept-07: Yes, too sweeping.  We want to correct e.g.
;; *we admire certain individual*.  So remove here, and let's try entry by
;; entry for the problematic ones.
;;
; n_-_c-nocnh_lexent := basic_intr_lex_entry &
;; DPF 2020-03-24 - Added type as per trunk
basic_n_-_c-nocnh_lexent := basic_basic_intr_noun_word &
  [ SYNSEM [ MODIFD notmod,
             LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                       NORM norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

n_-_c-nocnh_lexent := basic_n_-_c-nocnh_lexent & basic_intr_lex_entry.

n_-_c-nocnh_le := n_-_c-nocnh_lexent
"""
Icn, excl nonhd in n-n, non capitalized
<ex>B bought a classic.
"""
.

;; DPF 2020-03-24 - Added type as per trunk
n_-_c-nocnh-cap_le := basic_n_-_c-nocnh_lexent &
"""
Icn, excl nonhd in n-n, capitalized
<ex>B met an American.
"""
  [ SYNSEM noun_nocomp_synsem & 
	  [ LOCAL.CAT.VAL.SPR < [ --MIN abstract_q_rel ] >,
            MODIFD notmod & [ LPERIPH na ] ],
    TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized ].

n_-_c-nocnh-msc_le := n_-_c-nocnh_lexent &
"""
Icn, excl nonhd in n-n, masculine gender
<ex>Mr. B bought a car.
"""
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN masc ].

n_-_c-nocnh-fem_le := n_-_c-nocnh_lexent &
"""
Icn, excl nonhd in n-n, feminine gender
<ex>Mr. B bought a car.
"""
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEN fem ].

; e.g. 'other' as in "the other will be ready soon" but "*the chair other"
n_-_c-nocpd_le := basic_intr_noun_word &
"""
Icn, excl head and nonhd in n-n            
<ex>The other arrived.
"""
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD notmod & [ LPERIPH bool ],
             LOCAL [ CAT [ HEAD [ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  --BARE - ],
			   VAL.SPR < [ --MIN abstract_q_rel ] >],
                     CONT.RELS <! relation !> ] ] ].

;; DPF 2019-09-25 - Removed MODIFD lmod because this prevented adj-N for these
;; nouns, and the LPERIPH + is already enough to block N-N compounds.
;;
n_-_c-nochd_lexent := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD.LPERIPH +,
             LOCAL [ CAT [ HEAD [ MINORS.MIN norm_nom_rel,
				  --BARE - ],
			   VAL.SPR < [ --MIN abstract_q_rel ] >],
                     CONT.RELS <! relation !> ] ] ].

; e.g. 'join'
n_-_c-nochd_le := n_-_c-nochd_lexent
"""
Exclude as head in compounds.
<ex>The join complexity increased
"""
.

n_-_c-nochd-msc_le := n_-_c-nochd_lexent &
"""
Title nouns, excl nonhd in n-n, and head everywhere, masc gender
<ex>The young Mr. Browne arrived.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.NORM norm_rel,
		   CONT.HOOK.INDEX.PNG.GEN masc ] ].

n_-_c-nochd-fem_le := n_-_c-nochd_lexent &
"""
Title nouns, excl nonhd in n-n, and head everywhere, fem gender
<ex>The young Ms. Browne arrived.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.NORM norm_rel,
		   CONT.HOOK.INDEX.PNG.GEN fem ] ].

; Block some frequently occurring nouns from appearing in title constructions
; ("no title compound")
n_-_c-ntc_le := n_intr_lex_entry &
"""
Icn, no title compound           
<ex>The well is empty.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM no_rel ].

;; Maybe only for the British noun "over", which we need to exclude in various
;; compounds.
;;
n_-_c-ncmp-nttl_le := basic_intr_noun_word &
"""
Count, excl hd and nonhd in n-n and excl nonhd in np_title cmpnd
<ex>The overs [Br.E.] were unexpected.
"""
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD rmod & [ LPERIPH na ],
             LOCAL [ CAT [ HEAD [ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  --BARE - ],
			    VAL.SPR < [ --MIN abstract_q_rel ] > ],
                     CONT.RELS <! reg_nom_relation !> ],
	     LKEYS.KEYREL reg_nom_relation ] ].

; phone (like number, order)
; No constraint on ARG0.SORT, so can appear in identity copula constructions
; or conjunctions with verbal projections; e.g. "the idea is to win."
;; DPF 2012-02-01 - The constraint [SORT non-time-sort] prevents
;; *the morning is the best part of the day*.  FIX throughout for *-ns* types.
;; DPF 2016-12-10 - Re 2012-02-01: It seems this constraint was not removed
;; after all, but it blocks *Monday is the best plan*, so now removing, and
;; similarly for the other "*-ns*" le types.
;
n_-_c-ns_le := basic_intr_lex_entry &
"""
Icn, underspec ARG0.SORT         
<ex>The goal was to win.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.HOOK.INDEX.SORT entity-or-qevent ] ].

n_-_c-ns-nocnh_le := basic_intr_lex_entry &
"""
Icn, underspec ARG0.SORT, no non-hd of compound
<ex>The goal was to win.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
				     NORM norm_rel ],
		   CONT.HOOK.INDEX.SORT entity-or-qevent ] ].

n_-_c-upcase_le := n_intr_lex_entry &
"""
Intransitive count noun, all caps
<ex>His CO retired.
"""
  [ TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized+upper ].

n_-_c-downcase_le := n_intr_lex_entry &
"""
Intransitive count noun, lowercase
<ex>We looked for the john.
"""
  [ TOKENS.+LIST.FIRST.+CLASS.+CASE non_capitalized ].

; For determinerless-PPs: 'within range'
; DPF 25-apr-04 - Added ALTMIN abstract_q_rel to prevent these from
; appearing as left members of N-N compounds.
; DPF 17-may-05 - But now using NORM to block compounding
;; DPF 2017-11-24 - Block these as candidate subject NPs, since we think they
;; can only appear as objects.
;;
basic_n_bare_lex_entry := noun_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS [ MIN bare_nom_rel,
					   NORM norm_rel ],
				  CASE non_nom ],
                           VAL.SPR < unexpressed > ],
                     AGR.PNG.PN 3s ] ],
    IDIOM + ].

intr_n_bare_lex_entry := basic_n_bare_lex_entry & basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	  [ LOCAL.CAT.VAL.SPR < [ --MIN abstract_q_rel ] >,
            MODIFD notmod,
	    LKEYS.KEYREL reg_nom_relation ] ].

n_bare_lex_entry := intr_n_bare_lex_entry &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE obliq ].

; 'in (family/open) court'
n_-_c-br_le := n_bare_lex_entry
"""
Icn, no det, free mod            
<ex>We spoke in order.
"""
.

; 'at eye level' ('*at level')
n_-_c-brn_le := n_bare_lex_entry &
"""
Icn, no det, obl mod by n        
<ex>B was at eye level.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_nmod_rel,
             MODIFD.LPERIPH na ] ].

; 'on (summer) vacation' ('*on long vacation')
n_-_c-brn*_le := n_bare_lex_entry &
"""
Icn, no det, opt mod by n        
<ex>B was on vacation.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bare_n_nmod_rel ].

; 'at close range' ('*at range')
n_-_c-brj_le := n_bare_lex_entry &
"""
Icn, no det, obl mod by adj      
<ex>B was on course.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_jmod_rel,
             MODIFD.LPERIPH - ] ].

; 'in (sharp) contrast'
; 'at (long) last'
n_-_c-brj*_le := n_bare_lex_entry &
"""
Icn, no det, opt mod by adj      
<ex>B was in view.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_jmod_rel,
             MODIFD.LPERIPH bool ] ].

; 'at (considerable/company) expense' ('*at expense')
n_-_c-brnj_le := n_bare_lex_entry &
"""
Icn, no det, obl mod by n,j      
<ex>B went at great expense.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_nom_rel,
             MODIFD.LPERIPH na_or_- ] ].

; 'on top', 'of course'
n_-_c-brno_le := n_bare_lex_entry &
"""
Icn, no det, no mod              
<ex>B was in line.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bare_n_nomod_rel ].

n_pp_c-brno-of_le := basic_n_bare_lex_entry & noun_empty_ppcomp_word &
"""
Icn, PP-of comp, no det, no mod  
<ex>B was on top of the hill.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN bare_n_nomod_rel,
			   VAL [ SPR < [ --MIN abstract_q_rel ] >,
				 COMPS < [ --MIN _of_p_sel_rel ] > ] ],
		     CONT [ RELS <! relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     MODIFD notmod ] ].

;; DPF 2018-03-12 - Added AGR..PT real_pron to block *own Kim* as a title 
;; compound.
;; DPF 2018-09-18 - But this conflicts with educ constraints.  So instead
;; constrain SPR to be expressed_synsem.
;;
; his own
n_-_c-poss_le := basic_intr_noun_word &
"""
Icn, oblig poss det ('own')      
<ex>Our own won.
"""
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT [ HEAD.MINORS [ MIN norm_nom_rel,
					 ALTMIN def_explicit_q_rel,
					 NORM norm_rel ],
			   VAL.SPR < expressed_synsem &
				     [ --MIN abstract_q_rel,
				       LOCAL.CAT.HEAD.POSS + ] > ] ],
	     MODIFD notmod & [ LPERIPH - ],
             LKEYS [ KEYREL reg_nom_relation,
		     ALTKEYREL relation ] ] ].

; Idiom nouns: e.g.
; ahold: 'I got ahold of sandy'
; part: 'I took part in the meeting'

n_-_c-br-idm_le := intr_n_bare_lex_entry &
"""
Icn, no det, idiomatic           
<ex>B took part.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN bare_n_nomod_rel,
                              CASE non_nom ] ] ].

n_-_c-brj-idm_le := intr_n_bare_lex_entry &
"""
Icn, no det, idiomatic, modifiable by adj
<ex>B took unfair advantage of C.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN bare_n_jmod_rel,
                              CASE non_nom ] ] ].

;; DPF 2020-03-24 - Added type as per trunk
basic_basic_n_intr_temp_lexent := basic_basic_intr_noun_word & 
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel,
                           VAL.SPR < [ --MIN abstract_q_rel ] > ],
                     CONT.HOOK.INDEX.SORT time ] ] ].

basic_n_intr_temp_lexent := basic_basic_n_intr_temp_lexent & noun_word.

n_intr_temp_lexent := basic_n_intr_temp_lexent &
  [ SYNSEM.MODIFD notmod ].

n_-_c-day_le := n_intr_temp_lexent &
"""
Temporal noun - day              
<ex>B won on a weekday.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN unnamed_day_rel ].

n_-_c-ssn_le := n_intr_temp_lexent &
"""
Temporal noun - season           
<ex>B will sing this season.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN season_rel,
             LKEYS.KEYREL.PRED season_rel ] ].

n_-_c-sg_lexent := basic_intr_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
				     ALTMIN abstract_q_rel ],
             LKEYS.KEYREL.ARG0.PNG.PN 3s ] ].

; 'grasp, dearth'
n_-_c-sg_le := n_-_c-sg_lexent &
"""
Icn, singular only               
<ex>B's grasp was strong.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! reg_nom_relation !> ].

; 'divine'
n_-_c-sg-nocnh_le := n_-_c-sg_lexent &
"""
Icn, singular only, excl nonhd in n-n
<ex>The divine is inaccessible.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.NORM norm_rel,
		   CONT.RELS <! reg_nom_relation !> ] ].

; 'impetus'
n_-_c-sg-ns_le := n_-_c-sg_lexent &
"""
Icn, singular only, unspec sort
<ex>The main impetus was that Kim arrived.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT [ HOOK.INDEX.SORT entity-or-qevent,
			  RELS <! relation !> ] ] ].

; 'the DFKI'

basic_n_intr_named_lexent := nonc-hm &
  [ INFLECTD -,
    SYNSEM 
     [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                     VAL.SPR < [ --MIN abstract_q_rel ] >],
               CONT [ HOOK [ LTOP #ltop,
			     INDEX.IND + ],
                      RELS <! relation !>,
                      HCONS <! !>,
		      ICONS <! !> ],
               CONJ cnil ],
       MODIFD notmod,
       LKEYS.KEYREL named_nom_relation &
             [ LBL #ltop,
               PRED named_n_rel ] ] ].

n_intr_named_lexent := basic_n_intr_named_lexent &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CAT.VAL.SPR < [ OPT - ] > ] ].

;; DPF 2014-07-08 - To avoid spurious ambiguity with e.g. *house*, constrain
;; this to be capitalized.
;;
n_-_c-nm_le := n_intr_named_lexent &
"""
Icn, named                       
<ex>B read the Iliad.
"""
  [ SYNSEM.PUNCT no_punctuation_min,
    TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized ].

n_-_c-nm-upcase_le := n_intr_named_lexent &
"""
Icn, named, all upper                       
<ex>B visited the US
"""
  [ SYNSEM.PUNCT no_punctuation_min,
    TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized+upper ].

; 'the Alps'
n_-_c-nm-pl_le := n_intr_named_lexent &
"""
Icn, named, plural only          
<ex>B visited the Alps.
"""
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.PNG.PN 3p,
             PUNCT no_punctuation_min ] ].

;; DPF 2014-07-08 - Consrrain these to singular only, to avoid spurious
;; ambiguity with plural
; For period-final names like "u.s."
n_-_c-nm-pd_le := n_intr_named_lexent &
"""
Icn, named, end in period        
<ex>B visited the U.S.
"""
  [ SYNSEM.PUNCT [ LPUNCT no_punct,
                   RPUNCT clause_or_no_punct ] ].

; For robust period-final names like "u.s." lacking specifier
n_-_c-nm-pd-nf_le := basic_n_intr_named_lexent &
"""
Icn, named, end in period, nonformal
<ex>U.S. and France argued.
"""
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.NORM norm_rel,
			 VAL.SPR < unexpressed > ],
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT clause_or_no_punct ] ],
    GENRE nonformal ].


n_-_c-nm-gen_le := n_intr_named_lexent & basic_generic_lex_entry &
"""
Icn, named                       
<ex>B read the Iliad.
"""
  [ SYNSEM [ PUNCT no_punctuation_min,
	     LKEYS.KEYREL.CARG #carg ],
    TOKENS.+LIST.FIRST [ +CLASS.+CASE capitalized,
			 +CARG #carg ] ].

n_-_c-gen_le := basic_intr_lex_entry & basic_generic_lex_entry &
"""
Icn, generic                     
<ex>C is a generic-noun.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation &
			  [ PRED generic_nom_rel ],
	     PHON.ONSET unk_onset ] ].

basic_noun_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem ].

;; DPF 2020-03-24 - Commented out this two types as per trunk.
#|
norm_noun_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ --MIN independent_rel,
                                       LOCAL.CONT.HOOK.XARG #index ] >,
                     CONT [ RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
	     MODIFD notmod & [ LPERIPH na ],
             LKEYS.KEYREL.ARG1 #index ] ].
|#

noun_empty_ppcomp_word := basic_noun_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ --MIN selected_rel,
                                     --SIND #index & non_expl-ind ] >,
             LKEYS.KEYREL.ARG1 #index & non_expl ] ].

norm_noun_empty_ppcomp_word := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CONT [ RELS <! relation !>,
			  HCONS <! !>,
			  ICONS <! !> ],
	     MODIFD notmod & [ LPERIPH na ] ] ].

;; DPF 2020-03-24 - Commented out this type as per trunk
#|
noun_ppcomp_word := norm_noun_ppcomp_word &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN unspec_diadic_nom_rel ].
|#

n_ppcomp_lexent := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
	     MODIFD notmod & [ LPERIPH na ],
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

n_pp_c_le := n_ppcomp_lexent &
"""
Common noun with PP complement   
<ex>B has an incentive to win.
"""
  [ SYNSEM.LOCAL.CONT [ RELS <! relation !>,
                        HCONS <! !>,
			ICONS <! !> ] ].

;; DPF 2012-12-17 - Changed LPERIPH from - to na_or_- in order to admit
;; *a two-mile stretch of highway*
;;
n_ppcomp_nbar_lexent := noun_word &
  [ SYNSEM noun_ppcomp_j_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN diadic_nom_rel,
			   VAL.COMPS < [ OPT -,
					 LOCAL [ CAT [ HEAD prep & [ PRD - ],
						       VAL.COMPS < > ] ],
					 PUNCT.LPUNCT no_punct,
					 --MIN #cmin & selected_rel,
					 --SIND #index & non_expl-ind ] > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             MODIFD notmod & [ LPERIPH na_or_- ],
             LKEYS [ KEYREL reg_diadic_nom_relation &
			    [ ARG1 #index & non_expl ],
		     --COMPKEY #cmin ] ] ].

n_pp_c-of-brn_le := n_ppcomp_nbar_lexent &
"""
Cn with detless of-PP            
<ex>That kind of horse wins.
"""
  [ SYNSEM.LKEYS.--COMPKEY _of_p_nbar_rel ].

n_pp_c-for-brn_le := n_ppcomp_nbar_lexent &
"""
Cn with detless for-PP            
<ex>The election for class president was rigged.
"""
  [ SYNSEM.LKEYS.--COMPKEY _for_p_trgt_rel ].

; 'thing about X'
;
n_pp_c-obl_le := norm_noun_empty_ppcomp_word &
"""
Cn with oblig PP comp            
<ex>B has a policy on dogs.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN diadic_nom_rel,
			 VAL.COMPS < [ OPT - ] > ],
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

n_pp_c-ns-obl_lexent := noun_empty_ppcomp_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN modable_nom_rel,
			 VAL.COMPS < [ OPT - ] > ],
		   CONT [ HOOK.INDEX.SORT entity-or-qevent,
			  RELS <! relation !>,
			  HCONS <! !>,
			  ICONS <! !> ] ] ].

; 'rest': modable, same number as in PP complement
; 'rest of X': "I am here the rest of the day"
; 
n_pp_c-ns-obl-agr_le := n_pp_c-ns-obl_lexent &
"""
Cn, oblig PP, unmarked sort      
<ex>The rest of it arrived.
<nex>The rest of the carrots is old.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.AGR.PNG.PN #pn ] >,
		   AGR.PNG.PN #pn ] ].

n_pp_c-ns-obl_le := n_pp_c-ns-obl_lexent &
"""
Cn, oblig PP, unmarked sort      
<ex>His point of view surprised us..
"""
  [ SYNSEM.MODIFD notmod & [ LPERIPH na ] ].

n_pp_c-of_le := norm_noun_empty_ppcomp_word &
"""
Cn, PP-of                        
<ex>B's the winner of the race
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

;; DPF 2016-02-17 - Removed SORT non-time-sort because we want e.g.
;; *the morning is the best part of the day*
;;
n_pp_c-ns-of_le := norm_noun_empty_ppcomp_word &
"""
Cn, PP-of, unmarked sort         
<ex>The network of sites won.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.HOOK.INDEX.SORT entity-or-qevent ],
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_pp_c-nt-of_le := norm_noun_empty_ppcomp_word &
"""
Cn, PP-of, non-temporal          
<ex>We got a meeting of chiefs
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; DPF 10-sept-07 - Type for e.g. 'thing' which we don't want as left member
; of compounds.
;; DPF 2016-08-10 - Removed SORT non-time-sort because we want to accept
;; *the only thing I have open is the afternoon*
;;
;; DPF 2020-30-24 - Added this type as per trunk
n_pp_c-nsnc-of_lexent := noun_empty_ppcomp_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
				       NORM norm_rel ],
		     CONT [ HOOK.INDEX.SORT entity-or-qevent,
			    RELS <! relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     MODIFD notmod,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_pp_c-nsnc-of_le := n_pp_c-nsnc-of_lexent &
"""
Cn, PP-of, unmrkd sort, no cmpnd 
<ex>That is the thing of it.
"""
  [ SYNSEM.MODIFD.LPERIPH na ].

;; DPF 2016-11-08 - Removed SORT non-time-sort since this blocked
;; *the alternative was 90 days in Paris*
;;
n_pp_c-ns-nocnh_le := norm_noun_empty_ppcomp_word &
"""
Cn, PP, unmrkd sort, no cmpnd 
<ex>That is the thing of it.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
				     NORM norm_rel ],
		   CONT.HOOK.INDEX.SORT entity-or-qevent ] ].

n_pp_c-of-obl_le := norm_noun_empty_ppcomp_word &
"""
Cn, oblig PP-of                  
<ex>B used a myriad of colors.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         VAL.COMPS < [ OPT - ] > ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; Since partitive rule already applies to measure NPs to produce
; "ten feet of rope", remove the pp-of complement here to avoid spurious
; ambiguity.
; DPF 13-nov-05 - Make NORM quantity_rel so it won't undergo n-n-cmpnd
; rule, but also won't undergo relcl to avoid silly "' huts were"
; DPF 23-apr-09 - Added SPR expressed_synsem to prevent these from being
; bare plurals, as in **% succeed*
; DPF 20-aug-09 - Re 23-apr-09: But this is wrong, blocking "many gallons"
; which is determiner-less.
;; DPF 2020-04-15 - Added second argument to KEYREL, since one of the 
;; meas-np rules adds a pp-of complement, to enable pied piping as in
;; *these accounts, ten percent of which are overdrawn*.
;;
;
n_-_c-meas_le := norm_intr_lex_entry &
"""
Icn, measure noun                
<ex>Ten meters is enough.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN meas_nom_rel,
				       NORM quantity_rel ],
		     CONT.HOOK.XARG #xarg ],
	     LKEYS.KEYREL.ARG1 #xarg ] ].

n_np_c-meas_le := n_np_c_lexent &
"""
Measure noun with optional NP complement
<ex>One level teaspoon water was added.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS [ MIN meas_nom_rel,
				     NORM quantity_rel ],
		   CONT.HOOK.INDEX.SORT entity ] ].


;; DPF 2012-09-14 - Added type of measure noun that does not normally appear
;; as a bare NP, such as **the price fell dollars* or *?Kim is dollars richer*
;; DPF 2012-10-16 - Changed LPERIPH from + to na_or_+ to still allow these
;; as heads in N-N compounds, as in "U.S. dollars"
;;
n_-_c-meas-nb_lexent := basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT [ HEAD [ MINORS [ MIN meas_nom_rel,
					   NORM quantity_rel ] ],
			   VAL.SPR < [ --MIN abstract_q_rel ] > ],
		     CONT.HOOK [ INDEX.SORT entity,
				 XARG #xarg ] ],
	     LKEYS.KEYREL.ARG1 #xarg ] ].

;; DPF 2017-07-08 - Re 2012-10-16 on n_-_c-meas-nb_lexent: But num-det wants 
;; its head noun to be LPERIPH -, as in *ten shares were sold*. So let's 
;; remove this constraint, and possibly FIX?
n_-_c-meas-nb_le := n_-_c-meas-nb_lexent &
"""
Icn, measure noun, not bare,
<ex>.
<nex>The price rises dollars.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.CASE real_case ].

;; For *prices rose 0.3 point* whree we 
;;
n_-_c-meas-noagr_le := basic_n_intr_infl_lex_entry &
"""
Icn, measure noun with decimal adj, no spr
<ex> The price rises 0.3 point.
"""
  [ INFLECTD +,
    SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT [ HEAD [ MINORS [ MIN meas_nom_rel,
					   NORM quantity_rel ],
				  CASE real_case ],
			   VAL.SPR < expressed_synsem & 
				     [ --MIN abstract_q_rel ] > ] ],
	     LKEYS.KEYREL reg_nom_relation ] ].

n_-_c-meas-frct_le := n_-_c-meas-nb_lexent &
"""
Icn, measure noun, not bare,
<ex>.
<nex>Two thirds of the cats arose.
"""
  [ SYNSEM [ MODIFD rmod,
	     LOCAL [ CAT.HEAD [ CASE real_case,
				MINORS.ALTMIN udef_q_rel ],
		     CONT.HOOK.XARG #xarg ],
	     LKEYS.KEYREL.ARG1 #xarg ] ].


;; DPF 2013-09-24 - Make spr obligatory, to avoid spurious analysis of 
;; *1.5/cm* with plural NP *cm*
;; DPF 2013-09-26 - Also added MODIFD rmod to prevent these from being
;; heads of noun compounds.
;;
n_-_c-meas-abb_le := basic_intr_noun_word &
"""
Icn, measure noun: block as head of N-N compound
<ex>Ten meters is enough.
"""
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS [ MIN meas_nom_rel,
					 NORM quantity_rel ],
			   VAL.SPR < expressed_synsem &
				     [ --MIN abstract_q_rel ] > ],
		     CONT.HOOK [ INDEX.SORT entity,
				 XARG #xarg ] ],
	     MODIFD rmod,
	     LKEYS.KEYREL.ARG1 #xarg ],
    GENRE written ].

;; DPF 2012-09-27 - Add PRD + to prevent the percent sign from being the 
;; solitary left member of an N-N compound (spurious ambiguity)
;;
n_-_c-meas-spr_le := basic_intr_noun_word &
"""
Icn, measure noun, only in meas-NP phrases (no overt spr), 
no hd of n-n cmpnd
<ex>Ten % is enough.
"""
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL.CAT [ HEAD [ MINORS [ MIN meas_nom_rel,
					 ALTMIN udef_q_rel,
					 NORM quantity_rel ],
				PRD + ],
			 VAL.SPR < expressed_synsem > ],
	     MODIFD rmod,
	     LKEYS.KEYREL reg_nom_relation ] ].

; For unusual measure nouns incl. 'some' of 'fifty some feet' and 'plus' of
; 'fifty plus floors'.
;;
n_-_c-meas-nocnh_lexent := noun_word &
  [ SYNSEM count_noun_synsem &
       [ LOCAL [ CAT [ HEAD [ MINORS [ MIN meas_nom_rel,
				       NORM quantity_rel ],
			      MOD < > ],
		       VAL [ SPR < #spr & canonical_synsem &
				   [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
			     SUBJ < >,
			     COMPS < >,
			     SPEC < anti_synsem_min > ] ],
                 CONT [ HOOK.INDEX.DIV +,
			RELS <! relation !>,
			HCONS <! !>,
			ICONS <! !> ],
		 ARG-S < #spr > ],
         MODIFD rmod,
         LKEYS.KEYREL reg_nom_relation ] ].

;; DPF 2018-03-30 - Make these singular, to avoid *300°C are too high*
;; DPF 2020-03-25 - But that blocks *Kim is 10' tall*, so undo.
;;
n_-_c-meas-nocnh_le := n_-_c-meas-nocnh_lexent
"""
Icn, measure, excl nonhd in n-n  
<ex>300 °C is enough.
"""
.

n_-_c-approx_le := n_-_c-meas-nocnh_lexent
"""
Icn, measure, excl nonhd in n-n  
<ex>Ten some is enough.
"""
.

n_pp_c-plc-of_le := norm_noun_empty_ppcomp_word &
"""
Cn, PP-of, place noun            
<ex>This is a place of study.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN _place_n_1_rel,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

;; DPF 2016-11-08 - Removed SORT non-time-sort since this blocked
;; *the alternative was 90 days in Paris*
;;
; answer
n_pp_c-ns_le := norm_noun_empty_ppcomp_word &
"""
Cn, PP comp, no sort             
<ex>The answer to us was that he would leave.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.HOOK.INDEX.SORT entity-or-qevent ],
             LKEYS.KEYREL diadic_nom_relation ] ].

; 'way': modable and nosort
;
n_pp_c-mod-of_le := noun_empty_ppcomp_word &
"""
Cn, PP-of, can modify            
<ex>B fell that way.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN modable_nom_rel,
		     CONT [ RELS <! relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

; For abbrev "no." and similarly for "north, south, east, west"

;; Added RPERIPH - to prevent spurious *make synthesized* in n-v-cmpnd

;; DPF 2014-05-07 - This formerly had RPERIPH na_or_+, but that prevented any
;; modification by thatless-relatives, which have MOD..RPERIPH - in order to
;; avoid stacking of a full relative followed by a thatless relative.  So let's
;; remove the constraint, and see what work it was doing.
;; Note that without that RPERIPH constraint, we can collapse this type with the
;; following one, which currently has only a single instance.
;;
n_pp_c-nocnh-of_le := norm_noun_empty_ppcomp_word &
"""
Cn, PP-of, excl nonhd in n-n     
<ex>This make of cars is good.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM norm_rel ],
	     MODIFD.RPERIPH na_or_+,
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_c-nocnh_le := norm_noun_empty_ppcomp_word &
"""
Cn, PP, excl nonhd in n-n     
<ex>One alternate to Kim is Browne.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM norm_rel ],
             LKEYS.KEYREL reg_diadic_nom_relation ] ].

noun_ppcomp_j_synsem := basic_two_arg & nonpro_nomod_synsem & 
			common_noun_synsem.

;; For `opposite of happy'
n_pp_c-ofj_le := noun_word &
"""
Cn, PP-of-AP, excl nonhd in n-n     
<ex>B is the opposite of happy.
"""
  [ SYNSEM noun_ppcomp_j_synsem &
	   [ MODIFD notmod & [ LPERIPH na ],
             LOCAL [ CAT [ HEAD.MINORS.MIN diadic_nom_rel,
			   VAL.COMPS < expressed_synsem &
				       [ OPT -,
					 --MIN #cmin,
					 LOCAL [ CAT [ HEAD prep & [ PRD - ],
						       VAL.COMPS < > ],
						 CONT.HOOK.LTOP #cltop ],
					 PUNCT.LPUNCT no_punct ] > ],
		     CONT [ RELS <! relation !>,
			    HCONS <! qeq & [ HARG #arg1, LARG #cltop ] !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL basic_diadic_nom_relation &
			    [ ARG1 #arg1 ],
                     --COMPKEY #cmin & _of_p_comp_rel ] ] ].

noun_double_ppcomp_word := noun_word &
  [ SYNSEM noun_ppcomp_three_arg_synsem &
         [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         VAL.COMPS < [ --MIN selected_rel,
                                       --SIND #index1 & non_expl-ind ],
                                     [ --MIN selected_rel,
                                       --SIND #index2 & non_expl-ind ] > ],
                   CONT.RELS <! relation !> ],
           LKEYS.KEYREL reg_triadic_nom_relation &
                        [ ARG1 #index1,
                          ARG2 #index2 ] ] ].

n_pp-pp_c_le := noun_double_ppcomp_word
"""
Cn, two PP comps                 
<ex>Gifts of B to C are rare.
"""
.

basic_n_temp_ppcomp_lexent := noun_word &
  [ SYNSEM temp_noun_ppcomp_two_arg_synsem ].

norm_n_temp_ppcomp_lexent := basic_n_temp_ppcomp_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --MIN _of_p_sel_rel ] >,
		   CONT [ RELS <! relation !>,
			  HCONS <! !>,
			  ICONS <! !> ] ] ].

; DPF 22-May-02 - Note that we have to have two entries for the word "time",
; one which must take a determiner, and which can appear in a temp-mod phrase;
; and the other which denotes a temporal chunk and can't appear as temp-mod:
; "He'll stay this time" but "*He stayed time for a meeting" (Cf. "Do you 
; have time for a meeting.")

; DPF 05-dec-03 - Added NORM as hack to prevent these from appearing as 
; left members of n-n-cmpnds like 'afternoon Monday' though maybe actually OK.
; DPF 06-dec-03 - Removed of-PP complement since possessive of-PP now does the
; work, and we avoid spurious ambiguity.
; DPF 22-sept-04 - Changed SPR from expressed_synsem to synsem so these will
; undergo the hdn_bnp_c rule, which requires the SPR to be 'unexpressed'.

n_temp_lexent := n_intr_temp_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < synsem > ].

n_pp_c-day_le := norm_n_temp_ppcomp_lexent &
"""
Temporal noun - day, PP comp     
<ex>B arrived the day C won.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN unnamed_day_rel,
             MODIFD notmod ] ].

n_pp_c-nday_le := norm_n_temp_ppcomp_lexent &
"""
Temporal noun - not day: term
<ex>B slept the whole first term of the school year.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN nonday_n_rel,
             MODIFD notmod ] ].

;; DPF 2015-04-17 - Removed spurious quantifier for the PP complement's N-bar,
;; since the N-bar-taking "of" already supplies it.
;; DPF 2020-05-16 - With the changes to measure-NPs, add CASE real_case here
;; to prevent these from undergoing np_adv-mnp rule.
;;
n_pp_c-t-of-nb_le := basic_n_temp_ppcomp_lexent &
"""
Temporal noun, detless PP-of     
<ex>The time of day was clear.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN non_day_time_rel,
				  CASE real_case ],
			   VAL.COMPS < [ OPT -,
					 --MIN _of_p_nbar_rel ]> ],
		     CONT [ RELS <! relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     MODIFD notmod & [ LPERIPH - ] ] ].

n_-_c-min_le := n_temp_lexent &
"""
Temp noun - minute               
<ex>B arrives in ten minutes.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN _minute_n_1_rel ].

n_-_c-nday_le := n_temp_lexent & 
"""
Temporal noun - nonday           
<ex>B won in the first week.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN nonday_n_rel ].

n_-_c-nday-pl_le := n_temp_lexent &
"""
Temporal noun - nonday, plural   
<ex>B won in the first two weeks
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN nonday_n_rel,
                   CONT.HOOK.INDEX.PNG.PN 3p ] ].

n_-_c-week_le := n_temp_lexent & 
"""
Temporal noun - only *week*
<ex>B arrived in/on the first week.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN _week_n_1_rel ].

n_-_c-hour_le := n_temp_lexent &
"""
Temporal noun - only hour? - with either at, in, on
<ex>B won in the first hour.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS [ MIN hour_or_time_rel,
				   ALTMIN impl_or_expl_q_rel ] ].

n_-_c-year_le := n_temp_lexent &
"""
Temporal noun - year             
<ex>B won in that year.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN year_n_rel ].

n_-_c-year-pl_le := n_temp_lexent &
"""
Temporal noun - year, plural     
<ex>B was two yrs. old.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN year_n_rel,
                   CONT.HOOK.INDEX.PNG.PN 3p ] ].

;; DPF 2010-10-02 - Added NORM norm_rel to block spurious compound analysis
;; for *Friday morning*
n_-_c-day_lexent := basic_basic_n_intr_temp_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN dofw_rel,
                                       ALTMIN abstract_q_rel,
				       NORM norm_rel ],
                         VAL.SPR < synsem > ],
             LKEYS.ALTKEYREL.PRED abstract_q_rel ] ].

n_-_c-dow_le := n_-_c-day_lexent &
"""
Temporal noun - day of week      
<ex>B won on Monday.
"""
  [ SYNSEM [ LKEYS.KEYREL.PRED dofw_rel,
             MODIFD notmod_or_rmod ] ].

n_-_day-crd-gen_le := n_-_c-day_lexent & generic_ne_lex_entry &
"""
Temporal noun - day, generic     
<ex>B won on generic-noun.
<native> n_-_c-day_le & [ SYNSEM.LKEYS.KEYREL.PRED dofm_rel ]
"""
  [ SYNSEM [ LOCAL.CAT.VAL.SPR.FIRST unexpressed,
	     LKEYS.KEYREL.PRED dofm_rel,
	     MODIFD lmod & [ LPERIPH + ],
	     PHON.ONSET unk_onset ] ].

; DPF 13-May-02 - Added LPERIPH + to prevent these from appearing as heads of
; noun-noun compounds.
; DPF 22-May-02 - But this also blocks "rainy April" - try again.
; DPF 22-May-02 - Changed ALTMIN from basic_nom_rel to abstract_q_rel to be 
; consistent with constraints on relative clause modifiees.
; DPF 26-jun-09 - Added NORM norm_rel to enable blocking of spurious
; noun-n-cmpnd for "January meeting" (want np-n-cmpnd instead).
;; DPF 2011-10-22 - Re 26-jun-09: the [LPERIPH -] constraint prevented
;; analysis of *January meeting* as np-n-cmpnd, so changed to LPERIPH bool,
;; and we'll see why it was here.
;; DPF 2020-03-24 - Added type as per trunk.
;; DPF 2020-05-16 - With the changes to measure-NPs, add CASE real_case here
;; to prevent these from undergoing np_adv-mnp rule.
;
n_np_c-month_lexent := noun_hclex_word &
  [ SYNSEM common_noun_synsem &
	   [ LOCAL [ CAT [ HEAD [ MOD < >,
				  MINORS [ MIN mofy_rel,
					   ALTMIN quant_rel,
					   NORM norm_rel ],
				  CASE real_case ],
			   HC-LEX +,
			   VAL.COMPS < [ --MIN yofc_rel,
					 LOCAL [ CAT nomp_cat_acc_min,
						 CONT.HOOK.INDEX #cind ] ] > ],
		     CONT [ HOOK.INDEX.SORT time,
			    RELS <! #keyrel !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL generic_named_nom_relation & #keyrel &
			    [ PRED mofy_rel,
			      ARG1 #cind ],
                     ALTKEYREL.PRED abstract_q_rel ],
             MODIFD notmod & [ LPERIPH bool ] ] ].

n_np_c-month_le := n_np_c-month_lexent
"""
Temporal noun - month, optional year complement
<ex>B won in January.
"""
.

; "way" as in "find a way to do that" -- was used in VM, but analysis changed
; so this type not currently in use.  Its semrel.tdl entry was as follows:
;   _way_rel := hcomp_nom_rel &
;     [ ARG0.SORT entity ].

n_vp_c_le := noun_word &
"""
Cn, VP comp                      
<ex>B has the ability to win.
"""
  [ SYNSEM common_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; 'permission'
n_vp_m_le := noun_word &
"""
Mass noun, VP comp               
<ex>B has permission to stay.
"""
  [ SYNSEM mass_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; 'clearance(s)'
n_vp_mc_le := noun_word &
"""
Mass-count, VP comp              
<ex>B has clearance to stay.
"""
  [ SYNSEM mass_count_noun_vpcomp_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; 'reason' - The reason Kim left bothered sandy"
n_cpcomp_optthat_lexent := noun_word &
  [ SYNSEM basic_count_noun_cpcomp_synsem & 
	   [ LOCAL.CAT.VAL.KCMP [ LOCAL.CAT [ HEAD [ VFORM fin,
						     TAM indic_tam,
						     INV - ],
					      VAL.SPR *olist* ] ],
	     MODIFD notmod ] ].

n_cp_c-optc_le := n_cpcomp_optthat_lexent &
"""
Cn, finite CP comp, opt cmplzer  
<ex>B has a feeling C fell.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
		       VAL.COMPS < [ LOCAL.CAT s_cat_fin_v_c ] > ] ].

;; DPF 2012-03-09 - Maybe we don't need this type after all, since at least
;; for `question' it's an issue of polarity: 
;; *there is no question that Kim arrived*

; 'way': modable
n_cp_c-mod_le := n_cpcomp_optthat_lexent &
"""
Cn, cp comp, can modify          
<ex>B fell the way C did.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN modable_nom_rel,
		       VAL.COMPS < [ LOCAL.CAT.MC - ] > ] ].

; 'request'
n_cp_c-bse_le := noun_word &
"""
Cn, base form CP comp            
<ex>B's wish that C be in irks
"""
  [ SYNSEM common_noun_cpcomp_bse_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; procedure
;; DPF 2018-18-17 - Added MIN norm_nom_rel like neighboring types.  Check to
;; see if its absence was deliberate.
;;
n_cp_c-inf_le := noun_word &
"""
Cn, inf CP comp                  
<ex>Procedures for C to go won
""" 
  [ SYNSEM common_noun_cpcomp_inf_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; news
n_cp_m-optc_le := noun_word &
"""
Mass, fin CP comp          
<ex>B got news that C won.
"""
  [ SYNSEM mass_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; permission
n_cp_m-inf_le := noun_word &
"""
Mass, fin CP comp          
<ex>B gave permission for C to arise
"""
  [ SYNSEM mass_noun_cpcomp_inf_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

n_cp_mc-inf_le := noun_word &
"""
Mass or count, inf CP comp          
<ex>B gave a small encouragement for Kim to arise.
"""
  [ SYNSEM mass_count_noun_cpcomp_inf_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

n_cp_mc-optc_lexent := noun_word &
  [ SYNSEM basic_mass_count_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ].

; chance
n_cp_mc-optc_le := n_cp_mc-optc_lexent &
"""
Mass-count, fin CP or S comp
<ex>There is little chance he'll win.
"""
  [ SYNSEM basic_mass_count_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
			 VAL.COMPS.FIRST.LOCAL.CAT s_cat_fin_v_c ] ] ].

; question
n_cp_mc-q_le := n_cp_mc-optc_lexent &
"""
Mass-count, fin CP question complement
<ex>There is little question who will win.
"""
  [ SYNSEM basic_mass_count_noun_cpcomp_fin_synsem &
	   [ MODIFD notmod,
             LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
			 VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM fin_or_inf ] ] ].

; build head_complement structure which is still words (with 
; [ SYNSEM lex_synsem ].

noun_hclex_word := noncqrs-m & basic_noun_word &
  [ INFLECTD -,
    SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL.LBL #ltop ] ].

n_np_c_lexent := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM basic_common_noun_npcomp_synsem &
	   [ LOCAL.CAT [ HC-LEX + ],
	     MODIFD notmod ] ].

n_np_c_le := n_np_c_lexent &
"""
Cn, NP comp                      
<ex>The hotel B collapsed.
"""
  [ SYNSEM common_noun_npcomp_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ] ]. 

n_nb_c_le := noun_hclex_word &
"""
Cn, nbar comp ('term')           
<ex>B knew the term ace.
"""
  [ INFLECTD -,
    SYNSEM common_noun_nbarcomp_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.MIN norm_nom_rel,
                         HC-LEX + ],
	     MODIFD notmod ] ].

; 'the word "chair"', 'the term "whippletree"'
;
n_nb_c-qt_le := noun_hclex_word &
"""
Cn, nbar quoted ('term')         
<ex>B knew the term "ace".
"""
  [ INFLECTD -,
    SYNSEM common_noun_nbarcomp_synsem &
	   [ LOCAL.CAT [ HEAD [ MINORS.MIN norm_nom_rel,
				--BARE - ],
                         VAL.KCMP [ PUNCT [ LPUNCT pair_or_no_punct,
                                            RPUNCT comma_or_pair_or_no_punct ],
                                    OPT -,
				    LOCAL.CAT.HEAD.--BARE - ],
                         HC-LEX + ],
	     MODIFD notmod & [ RPERIPH bool ] ] ].

n_nb_c-pro_le := noun_hclex_word &
"""
Cn, pro comp ('pronoun')           
<ex>B used the pronoun it.
"""
  [ INFLECTD -,
    SYNSEM common_noun_procomp_synsem ].

; Use special inflectional rule to produce plural inflected form without 's'
;; DPF 18-jul-2010 - Added constraint on --BARE as hack to prevent appositive
;; analysis of *$ ten million*.  FIX?
;; DPF 2020-05-23 - Make this MODIFD hasmod, to prevent bare-degadv *$*
;;
n_numcomp_lexent := nonc-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM common_noun_numcomp_synsem &
	   [ LOCAL [ CAT.HEAD.--BARE +,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL.LBL #ltop,
             MODIFD hasmod ] ].

n_-_c-cur_le := n_numcomp_lexent &
"""
Icn, currency                    
<ex>The price was $100.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < anti_synsem_min >,
		   AGR.PNG png-unsp ] ].

n_-_m_le := norm_noun_word &
"""
Intransitive mass noun (imn)     
<ex>Dignity is desirable.
"""
  [ SYNSEM mass_noun_synsem ].

n_-_m-ns_le := norm_noun_word &
"""
Intransitive mass noun, unspecified sort
<ex>Losing is no fun.
"""
  [ SYNSEM mass_noun_onearg_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT [ HOOK.INDEX.SORT entity-or-qevent,
			    RELS <! nom_relation !> ] ] ] ].

n_-_m-nomod_le := noun_word &
"""
Intransitive mass noun, unmodified and no det, but N-N cmpd okay
<ex>School is finished at three.
<ex>Boarding school can be challenging.
<nex>We went to big school.
"""
  [ SYNSEM mass_noun_onearg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS [ MIN norm_nom_rel,
					 NORM norm_rel ],
			   VAL.SPR.FIRST unexpressed ],
		     CONT.RELS <! reg_nom_relation !> ],
	     MODIFD lmod & [ LPERIPH na_or_+,
			     RPERIPH + ] ] ].

;; DPF 2016-09-28 - Worked hard to set up MIN time_nomod_rel just for this
;; mass noun `time', but it's wrong: *the amount of time we waited*.  So
;; change to non_day_time_rel, and maybe revisit whatever ambiguity we were 
;; trying to block with this special entry.
;; DPF 2017-08-18 - Having only this mass-noun entry for `time' prevents us
;; from getting *we spent money on TV time*, but adding lexical ambiguity isn't
;; very appealing, so we'll add spend-on lexical entry, and sidestep this issue
;; for now.  FIX someday.
;;
mass_time_synsem := basic_basic_mass_noun_synsem & noun_synsem & one_arg.
n_-_m-time_le := noun_word &
"""
Intransitive mass noun, only for `time'
<ex>We arrived at breakfast time.
<ex>We stayed a long time.
"""
  [ SYNSEM mass_time_synsem &
	   [ LOCAL [ CAT [ HEAD [ MINORS.MIN non_day_time_rel,
				  --BARE - ],
			   VAL.COMPS < > ],
		     CONT.RELS <! relation !> ],
	     MODIFD notmod ] ].

n_-_m-ed_le := norm_noun_word &
"""
Mass, okay for derived adj       
<ex>C is a good-natured cat.
"""
  [ SYNSEM mass_noun_onearg_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN n-ed_rel,
                     CONT.RELS <! reg_nom_relation !> ] ] ].

n_-_m-def_lexent := norm_noun_word &
  [ SYNSEM mass_noun_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.NORM norm_rel,
			 VAL.SPR < expressed_synsem &
				   [ --MIN def_q_rel ] > ],
	     LKEYS.KEYREL reg_nom_relation ] ].

; The inevitable
n_-_m-def_le := n_-_m-def_lexent
"""
Mass, definite det               
<ex>The inevitable happened.
"""
.

; *on the cheap, on the sly*
n_-_m-idm_le := n_-_m-def_lexent &
"""
Mass, definite det, idiomatic
<ex>We arrived on the sly.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.--MIN _the_q_rel,
    IDIOM + ].

;; Removed LPERIPH na because it prevents these from heading NP-N cmpnds.
;; Prevent mal-det and mal-adj (e.g. "all") from spurious robust analyses
;;
n_-_mc_le := norm_noun_word &
"""
Intrans noun, underspec mss-cnt  
<ex>B feared disaster.
"""
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ LOCAL.CAT.HEAD [ MINORS.MIN norm_nom_rel,
			      --BARE - ],
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_mc-ntc_le := norm_noun_word &
"""
Intrans noun, underspec mss-cnt, not title compounds
<ex>B had his say.
"""
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
				     NORM no_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

; For e.g. `dinner' to avoid spurious appositive for 
n_-_mc-time_le := norm_noun_word &
"""
Intrans noun, SORT time
<ex>Dinner follows lunch.
"""
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.HOOK.INDEX.SORT time ],
             LKEYS.KEYREL nom_relation ] ].

n_-_mc-ns_lexent := norm_noun_word &
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.HOOK.INDEX.SORT entity-or-qevent ],
             LKEYS.KEYREL nom_relation ] ].

; Removed LPERIPH na because it prevents these from heading NP-N cmpnds.
n_-_mc-ns_le := n_-_mc-ns_lexent
"""
Intr mc, no sort                 
<ex>B's intent was that C won.
"""
.

; For "_guess_" unknown-noun entry
n_-_mc-ns-g_le := n_-_mc-ns_lexent & generic_lex_entry &
"""
Intr mc, 'guessed' noun (obs?)   
<ex>The _guess_ was happy.
<native> n_-_mc-ns_le
"""
  [ SYNSEM [ LKEYS.KEYREL.PRED string,
	     PHON.ONSET unk_onset ] ].

n_-_mc-nocnh_le := norm_noun_word &
"""
Intr mc, no non-hd compound      
<ex>B's potential was high.
"""
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ LOCAL.CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                     NORM norm_rel ],
             LKEYS.KEYREL reg_nom_relation ] ].

; 'time': modable
; LPERIPH is na_or_- so it can be head of N-N-cmpnd rule as in "work times"
; DPF 16-aug-09 - Block as non-head in N-N-cmpnd, to avoid spurious ambig with
; n_-_m_le variant
;; DPF 2015-03-26 - For some reason, recently added CASE real_case, but this
;; blocks *we arose five times*, since the np_adv-mnp_c rule imposes no_case.
;; So remove, and try to be reminded of what that addition was supposed to do.
;; DPF 2020-05-16 - With the changes to measure-NPs, tempting to add 
;; CASE real_case here to prevent this from undergoing np_adv-mnp rule, but
;; that constraint is also used for mnp_degadv rule, so then tried adding
;; NORM norm_or_no_rel, but that blocks measure-NP itself.  Sigh.
;; DPF 2020-05-17 - Changed MODIFD from notmod to hasmod to block bare-degadv
;;
n_-_c-time_le := noun_word &
"""
Intr mc, temporal                
<ex>B fell that time.
"""
  [ SYNSEM noun_nocomp_synsem &
	   [ MODIFD hasmod & [ LPERIPH na_or_- ],
             LOCAL [ CAT.HEAD.MINORS.MIN non_day_time_rel,
		     CONT [ HOOK.INDEX nonconj_ref-ind & [ SORT time ],
                            RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ] ] ] ].


n_-_c-pl-mod_le := basic_n_plur_lexent &
"""
Intr count, plural, modable: maybe only *fold*
<ex>B fell four-fold
"""
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN non_day_modable_rel,
			   VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
						 DIV + ] ] > ],
		     CONT.RELS <! relation !> ],
	     MODIFD notmod ] ].

n_-_m-mod_le := noun_word &
"""
Intr mass, modable: maybe only *beyond*
<ex>B took the road to the (great) beyond
"""
  [ SYNSEM mass_noun_onearg_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS [ MIN non_day_modable_rel,
                                       NORM norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ],
	     MODIFD notmod ] ].

n_-_mc-ed_le := norm_noun_word &
"""
Mass-count, okay for derived adj 
<ex>C is a high-powered cat.
"""
  [ SYNSEM mass_or_count_nocomp_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.MIN n-ed_rel,
             LKEYS.KEYREL reg_nom_relation ] ].

;; DPF 2020-03-24 - Added type as per trunk.
n_-_c-cpd_lexent := basic_basic_intr_noun_word &
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                           VAL.SPR < [ LOCAL.AGR.PNG.PN 3p,
				       --MIN abstract_q_rel ] > ],
                     CONT.HOOK.INDEX [ PNG png & [ PN 3s ],
                                       DIV - ] ],
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_c-cpd_le := n_-_c-cpd_lexent & noun_word &
"""
Intransitive count noun, left member of compounds only
<ex>The Abrams Co. president won.
"""
  [ SYNSEM.MODIFD notmod & [ LPERIPH na ] ].

n_pp_m_le := norm_noun_word &
"""
Mass, PP comp                    
<ex>Love of candy is common.
"""
  [ SYNSEM mass_noun_ppcomp_synsem ].

n_pp_m-obl_le := norm_noun_word &
"""
Mass, oblig PP comp              
<ex>Love for candy is common.
"""
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

n_pp_m-nocnh_le := norm_noun_word &
"""
Mass, PP comp, no nonhd compound
<ex>Generation of sentences continued.
"""
  [ SYNSEM mass_noun_ppcomp_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel ] ].

; 'home of X' - avoid spurious ambiguity with 'the home of X'
n_pp_m-brn_le := norm_noun_word &
"""
Mass, detless PP comp            
<ex>B has status as leader.
"""
  [ SYNSEM mass_noun_ppcomp_nospr_synsem &
	   [ LOCAL.CAT.VAL [ SPR < unexpressed >,
                             COMPS < [ OPT - ] > ] ] ].

; 'transfer of X'
n_pp_mc-brn_le := norm_noun_word &
"""
Mass or count, detless PP comp            
<ex>B arranged for transfer of title.
"""
  [ SYNSEM mass_noun_ppcomp_nospr_synsem &
	   [ LOCAL.CAT.VAL [ SPR < unexpressed >,
                             COMPS < [ OPT - ] > ] ] ].

n_pp_mc_le := norm_noun_word &
"""
Mass-count (mc), PP comp         
<ex>B has a desire for candy.
"""
  [ SYNSEM mass_or_count_ppcomp_synsem ].

n_pp_mc-ns_le := norm_noun_word &
"""
Mass-count (mc), PP comp         
<ex>B has a desire for candy.
"""
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
		     CONT.HOOK.INDEX.SORT entity-or-qevent ],
	     MODIFD.LPERIPH na ] ].

n_pp_mc-obl_le := norm_noun_word &
"""
Mc, oblig PP comp                
<ex>B has experience with cats
"""
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

n_pp_mc-of_le := norm_noun_word &
"""
Mc, PP-of comp                   
<ex>Loss of memory is common.
"""
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ LKEYS.--COMPKEY _of_p_sel_rel ] ].

;; DPF 2020-03-24 - Added type as per trunk.
;; *the direction he was headed*
;; *flourished all their lives*
n_pp_mc-mod-of_le := norm_noun_word &
"""
Mc, PP-of comp, modable, no sort
<ex>We admire the direction he was headed.
"""
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.MIN modable_nom_rel,
	     MODIFD.LPERIPH na,
             LKEYS [ KEYREL diadic_nom_relation,
		     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_mc-nocnh-of_le := norm_noun_word &
"""
Mc, PP-of comp, no nonhd cmpnd   
<ex>That make of car is rare.
"""
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ LOCAL.CAT.HEAD.MINORS [ MIN diadic_nom_rel,
                                     NORM norm_rel ],
             LKEYS [ KEYREL reg_diadic_nom_relation,
                     --COMPKEY _of_p_sel_rel ] ] ].

;; For "order" as in "my order, number 12345" where appositive rule 
;; requires compatibility of sorts.
;; DPF 2016-12-09 - Mysteriously, this type had SORT non-time-sort in 
;; spite of its description, and this blocked 
;; *Monday is a good possibility*.  Removed.
;;
n_pp_mc-of-ns_le := norm_noun_word &
"""
Mc, PP-of comp, no sort          
<ex>Invention of ice was easy.
"""
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
           [ LOCAL [ CAT.HEAD.MINORS.MIN reg_diadic_nom_rel,
		     CONT.HOOK.INDEX.SORT entity-or-qevent ],
	     MODIFD.LPERIPH na,
             LKEYS.--COMPKEY _of_p_sel_rel ] ].

n_pp_mc-for_le := norm_noun_word &
"""
Mc, PP-for comp                  
<ex>B found reasons for cats.
"""
  [ SYNSEM basic_mass_or_count_ppcomp_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN diadic_nom_rel,
	     LKEYS.--COMPKEY _for_p_sel_rel,
	     MODIFD.LPERIPH na ] ].

n_pp_mc-to_le := norm_noun_word &
"""
Mc, PP-to comp                   
<ex>Shipment to China is easy.
"""
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS.--COMPKEY _to_p_sel_rel ] ].

n_pp_mc-in_le := norm_noun_word &
"""
Mc, PP-in comp                   
<ex>Interest in cats is rare.
"""
  [ SYNSEM mass_or_count_ppcomp_synsem &
           [ LKEYS.--COMPKEY _in_p_sel_rel ] ].

n_pp_mc-of-lhc_lexent := basic_noun_word & nonconj & mcna &
  [ INFLECTD na_or_-,
    SYNSEM mass_or_count_ppcomp_synsem &
	   [ LOCAL [ CAT.HC-LEX +,
		     CONT.HOOK.LTOP #ltop ],
	     MODIFD notmod & [ LPERIPH na ],
             LKEYS [ KEYREL.LBL #ltop,
		     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_mc-of-lhc_le := n_pp_mc-of-lhc_lexent
"""
mc, PP-of comp, HC-LEX +
<ex>The University of Washington professor arrives.
"""
.

n_pp_mc-of-lhc-sg_le := n_pp_mc-of-lhc_lexent &
"""
mc, PP-of comp, HC-LEX +, singular only
<ex>The Washington U professor arrives.
<nex>Kim admired Us.
"""
  [ SYNSEM mass_or_count_ppcomp_synsem &
	   [ LOCAL.AGR.PNG.PN 3s ] ].

n_pp_c-of-lhc_le := basic_noun_word & nonconj & mcna &
"""
count noun, PP-of comp, HC-LEX +
<ex>The Secretary of Education office called.
"""
  [ INFLECTD na_or_-,
    SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
			   HC-LEX +,
			   VAL.COMPS < [ --MIN selected_rel,
					 --SIND #index & non_expl-ind ] > ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
	     MODIFD notmod & [ LPERIPH na ],
             LKEYS [ KEYREL [ LBL #ltop,
			      ARG1 #index & non_expl ],
		     --COMPKEY _of_p_sel_rel ] ] ].

n_pp_c-of-idm_le := norm_noun_word &
"""
c, PP-of comp, possessive idioms
<ex>He gave them a _taste_ of their own medicine.
"""
  [ SYNSEM noun_ppcomp_two_arg_synsem & 
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN non_temp_nonpro_rel,
			   VAL [ COMPS < #kcmp &
					 [ --MIN selected_rel,
					   --SIND #index & non_expl-ind,
					   OPT - ] >,
				 KCMP #kcmp &
				       [ LOCAL.CONT.HOOK.XARG #cxarg ] ] ],
		     CONT [ HOOK [ LTOP #ltop,
				   XARG #xarg ],
			    RELS <! relation, #altkeyrel !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL [ LBL #ltop,
			      ARG1 #index & non_expl ],
		     ALTKEYREL #altkeyrel & 
			    [ LBL #ltop, PRED id_rel,
			      ARG1 #xarg & [ PNG #png ], 
			      ARG2 #cxarg & [ PNG #png ] ],
		     --COMPKEY _of_p_sel_rel ] ],
  IDIOM + ].



; Don't appear as left or right members of compounds: e.g. 'last'
basic_n_mass_no_cmpnd_lexent := noun_word &
  [ SYNSEM mass_noun_onearg_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
                                       NORM norm_rel ],
                     CONT.RELS <! reg_nom_relation !> ] ] ].

n_mass_no_cmpnd_lexent := basic_n_mass_no_cmpnd_lexent &
  [ SYNSEM.MODIFD notmod & [ LPERIPH na ] ].

n_-_m-nocnh_le := n_mass_no_cmpnd_lexent
"""
Mass, excl nonhd in n-n          
<ex>Some slack would be nice.
"""
.

n_-_m-nocnh-nspr_le := n_mass_no_cmpnd_lexent &
"""
Mass, excl nonhd in n-n, and unexpr spr
<ex>Length is not measured.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST unexpressed ].

;; DPF 2020-05-20 - Added LOCAL mass_noun to prevent these in compounds where
;; the non-hd must be uninflected, as in title-cmpnd for **next September*
;;
n_-_m-nochd_le := basic_n_mass_no_cmpnd_lexent &
"""
Mass, excl head and non-head in n-n          
<ex>The next is Kim.
"""
  [ SYNSEM [ MODIFD notmod & [ LPERIPH + ],
	     LOCAL mass_noun & [ CAT.VAL.SPR < expressed_synsem > ] ] ].

;; 2020-05-22  Added MODIFD rmod to prevent these as head of compounds
;;
n_-_m-ncmp-nttl_le := basic_n_mass_no_cmpnd_lexent &
"""
Mass, excl nonhd in n-n and excl nonhd in np_title cmpnd
<ex>The above illustrates the point.
"""
  [ SYNSEM [ LOCAL mass_noun,
	     MODIFD rmod & [ LPERIPH na ] ] ].

; 'they hunted bear.'  Prevent from compounds, from and subject position,
; but can't easily prevent ambiguity for "bear hunting was popular"), 
; with 'bear' as subject of verbal gerund.  Also prevent specifier,
; to avoid spurious ambiguity for "the bear has four legs." - here, rather
; want underspecification, probably.

n_-_m-kind_le := n_mass_no_cmpnd_lexent &
"""
Mass, kind                       
<ex>B hunted bear.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE non_nom,
                       VAL.SPR < unexpressed_reg > ] ].

; 'red', 'blue' - don't appear as left members of compounds, but can
; appear as either mass or count.
; DPF 15-jan-08 - Added hack PRD + to these, and removed [NORM norm_rel],
; since we want "orange-encrusted" but still want to block n-n compound
; for "orange cat".  Maybe FIX?
; DPF 31-dec-08 - No longer treating colors as adjs derived from nouns,
; but rather treating adj as basic, and deriving color noun from it.
;; DPF 2012-02-06 - Added NORM no_rel to block spurious ambiguity with copula,
;; as in *The city is northwest*.
;; DPF 2012-11-10 - Re 15-jan-08: Since this type is now only used for
;; directional nouns, and we want *north wall*, remove PRD +, and change
;; HEAD from noun_adjable to just noun.
;; DPF 2016-11-29 - Re 2012-02-06: But now that we treat directional words
;; such as *west* as nouns, not adjectives, we need to admit *west Texas* via
;; the title-NP compound rule, which requires the non-hd to be NORM norm_rel.
;; So let's see remove this no_rel constraint, since it turns out it is no
;; longer needed to block unwanted combination with the copula.
;;
noun_mc_ntoj_lexent := norm_noun_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD noun &
                              [ MINORS [ MIN norm_nom_rel ] ],
		     AGR #agr,
                     CONT [ HOOK.INDEX #agr,
                            RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL nom_relation ] ].

n_pp_c-dir_le := noun_mc_ntoj_lexent &
"""
Icn, directional                 
<ex>The north is often cold.
"""
  [ SYNSEM unsp_ppcomp_two_arg_synsem &
           [ LOCAL.CAT.VAL.COMPS.FIRST.--SIND #ind & non_expl-ind,
	     MODIFD.LPERIPH na_or_+,
	     LKEYS [ KEYREL.ARG1 #ind,
		     --COMPKEY _of_p_sel_rel ] ] ].

basic_n_plur_lexent := noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL.CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                          HCONS <! !>,
			  ICONS <! !> ] ] ].

n_plur_lexent := basic_n_plur_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
						 DIV + ] ] >,
		     CONT.RELS <! relation !> ],
	     MODIFD notmod & [ LPERIPH na ] ] ].

; Bi-partite nouns like "scissors" or "sunglasses".  The basic entry is
; unmarked for INDEX.IND, but constrained to be GENRE nonformal, so we will
; parse "many sunglasses were cracked".  But there is a lexical rule which
; stamps [GENRE prescrip] and [IND -] on these entries, so the generator
; can be constrained to only generate "many pairs of sunglasses" (using
; a semantically empty classifier noun "pair").

n_-_bipart_le := noun_word &
"""
Mc, bipartite                    
<ex>These scissors are sharp.
"""
  [ SYNSEM basic_mass_or_count_nocomp_synsem &
           [ LOCAL [ CAT.HEAD noun &
                              [ MINORS.MIN norm_nom_rel,
				PRD - ],
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            HCONS <! !>,
			    ICONS <! !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ],
    GENRE nonformal ].

; 'systems analyst' - 'systems' is uninflected, and the constraint on the
; SPR is a hack to prevent it from undergoing plural inflectional rule.
; Maybe a better constraint would be to make SPR < anti-synsem >, but
; this would require adjusting the hierarchy of noun synsems - FIX.
;; DPF 2012-10-24 - Changed hack to use [LOCAL noninfl_noun_local]
;; to block inflectional rule (avoiding *the systemsses arose* etc.

n_-_c-pl-cpd_le := basic_n_plur_lexent &
"""
Icn, plur, compound non-hd only  
<ex>B hired a systems analyst.
"""
  [ SYNSEM [ LOCAL noninfl_noun_local &
		   [ CAT [ HEAD.MINORS.MIN norm_nom_rel ],
                     CONT.RELS <! relation !> ],
             MODIFD notmod & [ LPERIPH na ],
             LKEYS.KEYREL reg_nom_relation ] ].

; DPF 28-jun-07 - Constrained SPR to be expressed_synsem, to avoid e.g.
; spurious analysis for "many arrived".  Note that this fails to block
; nbar coordination without a determiner as in "proud and domestic animals"
; since the coord rule cannot propagate the whole unified synsems from the
; two dtrs (because of unwanted resulting circularity in feature structure).
; FIX.
; DPF 20-aug-09 - Added LPERIPH - to prevent these in NP-title compounds,
; such as the spurious analysis of "many cats"
;; DPF 2014-03-17 - Changed this type to inflected, since these can't appear
;; as non-heads in compounds (where they would have to be uninflected), and
;; since we can't use the irregs machinery for multi-words as in
;; *the well-to-do*
;
; 'the few', 'the proud'
n_-_c-pl-def_le := basic_n_intr_infl_lex_entry &
"""
Icn, plur, definite det          
<ex>The poor are numerous.
"""
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN norm_nom_rel,
					 NORM norm_rel ],
			   VAL.SPR < expressed_synsem &
				     [ --MIN def_q_rel,
				       LOCAL.AGR [ PNG.PN 3p,
						   DIV + ] ] > ],
		     CONT [ HOOK.INDEX.PNG.PN 3p,
			    HCONS <! !>,
			    ICONS <! !> ] ],
             MODIFD notmod & [ LPERIPH - ] ] ].

n_-_c-pl-idm_le := n_plur_lexent &
"""
Icn, plur, idiom                 
<ex>B kept tabs on C.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
             LKEYS.KEYREL reg_nom_relation ],
    IDIOM + ].

; "euro's" which the preprocessor turns into "euro 's"
n_plur_mwe_lexent := nonc-hm & basic_noun_word &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                               DIV + ] ] >,
                     CONT [ HOOK [ LTOP #ltop,
				   INDEX.PNG png & [ PN 3p ] ],
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     MODIFD notmod & [ LPERIPH na ],
	     LKEYS.KEYREL.LBL #ltop ] ].

n_-_c-pl-mwe_le := n_plur_mwe_lexent & nonc-hm-nab &
"""
Icn, plur, multi-word            
<ex>B spent many euro's.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		     CONT.RELS <! relation !> ],
             LKEYS.KEYREL reg_nom_relation ] ].

n_-_c-pl-one_le := basic_n_plur_lexent &
"""
Icn, plur, ones                  
<ex>The ones B supported won.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN _one_n_1_rel,
                           VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                                   DIV + ] ] > ],
                     CONT.RELS <! [ LBL #lbl,
                                    PRED generic_entity_rel,
                                    ARG0 #arg0 ],
				  #altkeyrel &
				  [ LBL #lbl,
				    PRED card_rel,
				    ARG0 event & [ E [ TENSE no_tense,
						       ASPECT no_aspect ] ],
				    ARG1 #arg0,
				    CARG "2+" ] !> ],
             MODIFD notmod_or_rmod & [ LPERIPH na ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; For plurals like "sixties" which can directly undergo the npadv_mod rule.
; DPF 8-nov-03 - Can't see why we want "sixties" under npadv_mod rule, so
; changed gen_numval_rel to not inherit from modable_rel.
;; DPF 2012-09-12 - Also added MODIFD notmod to prevent spurious analysis of
;; *$10 million* with noun_adjn compound rule.

n_-_c-pl-num_lexent := n_plur_mwe_lexent &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN gen_numval_rel,
				PRD + ],
		     CONT.RELS <! [ LBL #lbl,
				    PRED generic_entity_rel,
				    ARG0 #index ],
			        #altkeyrel & const_relation &
			        [ LBL #lbl,
				  PRED card_rel,
				  ARG0 event & [ E [ TENSE no_tense,
						     ASPECT no_aspect ] ],
				  ARG1 #index ] !> ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

n_-_c-pl-num_le := n_-_c-pl-num_lexent &
"""
Icn, plur, numbers               
<ex>Millions arrived.
"""
  [ INFLECTD - ].

;; DPF 2020-04-22 - We want to allow lexical plurals as left members of
;; compounds such as *earnings-related*, while still blocking productive
;; plurals, so change mother to INFLECTD na_or_+.
;;
basic_n_intr_infl_lex_entry := nonc-hm & basic_noun_word &
  [ INFLECTD na_or_+,
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL noun_local &
		   [ CAT [ VAL.SPR < [ --MIN abstract_q_rel ] > ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     LKEYS.KEYREL reg_nom_relation & [ LBL #ltop ] ] ].

n_intr_infl_lex_entry := basic_n_intr_infl_lex_entry &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel,
	     MODIFD notmod & [ LPERIPH na ] ] ].


; For singular nouns which are already inflected
n_-_c-sg-ifl_le := n_intr_infl_lex_entry &
"""
Icn, singular, already inflected
<ex>A strange being appeared.
"""
  [ INFLECTD +,
    SYNSEM.LOCAL [ CAT [ VAL.SPR < [ LOCAL.AGR [ PNG.PN 3s,
						 DIV - ] ] >,
			 HEAD.--BARE - ],
		   CONT.HOOK.INDEX [ PNG.PN 3s,
				     DIV - ] ] ].

; For singular nouns which are already inflected, no post-modif.
;; DPF 2018-03-10 - Constrained MIN to reg_nom_rel, to prevent these from
;; undergoing the num_np rule.
;; DPF 2018-09-13 - Changed MIN reg_nom_rel to norm_nom_rel.
;;
n_-_c-sg-ifl-nmd_lexent := basic_n_intr_infl_lex_entry &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN norm_nom_rel,
					 NORM no_rel ],
			   VAL.SPR < expressed_synsem &
				     [ LOCAL.AGR [ PNG.PN 3s,
						   DIV - ] ] > ],
		     CONT.HOOK.INDEX [ PNG.PN 3s,
				       DIV - ] ],
	     MODIFD notmod & 
		    [ LPERIPH bool,
		      RPERIPH + ] ] ].

n_-_c-sg-ifl-nmd_le := n_-_c-sg-ifl-nmd_lexent &
"""
Icn, singular, already inflected, no post-modif
<ex>They stayed for a long while.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN some_q_rel ].

n_-_c-sg-cpd_le := n_-_c-sg_lexent &
"""
Icn, singular, compound non-hd only  
<ex>B arrived in A.D. 1066.
"""
  [ SYNSEM [ LOCAL [ CAT [ VAL.SPR < unexpressed & [ OPT - ]  > ],
                     CONT.RELS <! relation !> ],
             LKEYS.KEYREL reg_nom_relation ] ].

; For plural nouns which are already inflected
n_-_c-pl_lexent := n_intr_infl_lex_entry &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
					       DIV + ] ] >,
		   CONT.HOOK.INDEX [ PNG.PN 3p,
				     DIV + ] ] ].

;; DPF 2020-04-22 - Added LOCAL plur_noun to block spurious ambig for these
;; in N-N compounds.
;;
n_-_c-pl_le := n_-_c-pl_lexent &
"""
Icn, plur, inflected    
<ex>These beings have disappeared.
"""
  [ SYNSEM.LOCAL plur_noun ].

;; DPF 2020-04-15 - Removed SPR expressed_synsem since we also want to get
;; *The number of Chinese who visit France has risen*
n_-_c-pl-nocnh_le := n_-_c-pl_lexent &
"""
Icn, plur, inflected, no non-head in N-N cpds
<ex>The Spanish are arriving.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM norm_rel ].

;; DPF 2016-09-28 - Well, we want to allow *Japanese visit often* unlike
;; **French visit often*, so make a variant of the above which still blocks
;; non-hd compound use, but leaves spr optional.
;;
n_-_c-pl-nocnh-ospr_le := n_-_c-pl_lexent &
"""
Icn, plur, inflected, no non-head in N-N cpds, optional spr
<ex>Japanese are arriving.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM norm_rel ].

;; 20-04-22 - Since "future" can be both adj and noun, we exclude the singular
;; as non-head in compound, and have lexical plural for *futures contracts*
;; and *futures-related*.  To avoid spurious ambiguity for *their futures were
;; unclear*, exclude these as heads.
;; NB: Here are some of the compounding variants to keep track of for N-N:
;;  *stock report*
;;  *earnings report*
;;  *futures report*
;;  *three dog night*
;;  *stock and futures contract*
;;  *ten meter fence*
;;
n_-_c-pl-nohd_le := n_-_c-pl_lexent &
"""
Icn, plur, inflected, non-head only
<ex>The futures prices dropped.
"""
  [ SYNSEM.LOCAL plur_noun &
		 [ CAT.HEAD.CASE no_case ] ].

;; DPF 2014-06-12 - The terms *percent* and *%* create unwanted ambiguity if
;; allowed to combine without of-PP complements, so add plural-only nominative
;; case entry to admit *ten percent arise* while limiting ambiguity.
;;
n_-_c-pl-nom_le := basic_n_intr_infl_lex_entry &
"""
Icn, plur, inflected, nominative case - maybe only "percent"
<ex>Ten percent have disappeared.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN norm_nom_rel,
				  CASE nom ],
			   VAL.SPR < expressed_synsem &
				     [ LOCAL.AGR [ PNG.PN 3p,
						   DIV + ] ] > ],
		     CONT.HOOK.INDEX [ PNG.PN 3p,
				       DIV + ] ],
	     MODIFD rmod ] ].

n_plur_ppcomp_lexent := norm_noun_word &
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ VAL [ COMPS < [ --SIND #index ] >,
				 SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                                     DIV + ] ] > ] ],
                     CONT [ HOOK.INDEX.PNG png & [ PN 3p ],
                            RELS.LIST.FIRST diadic_nom_relation,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL.ARG1 #index ] ].

n_pp_c-pl_le := n_plur_ppcomp_lexent &
"""
Cn, plr, PP cmp                  
<ex>The people of Spain sang.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN norm_nom_rel,
		   CONT.RELS <! reg_diadic_nom_relation !> ] ].

; 'millions of ...'
n_pp_c-pl-crd_le := n_plur_ppcomp_lexent &
"""
Cn, plr, PP cmp, card            
<ex>Millions of birds flew.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
			   VAL.COMPS < [ OPT -,
					 LOCAL [ CAT.HEAD.MINORS.ALTMIN #min,
						 CONT.HOOK.INDEX.SORT #sort]]>],
		     CONT.RELS <! [ LBL #lbl,
				    PRED generic_entity_rel,
				    ARG0 #index & [ SORT #sort ] ],
				  #altkeyrel & const_relation &
				  [ LBL #lbl,
				    PRED card_rel,
				    ARG1 #index ] !> ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; 'others of you'
n_pp_c-pl-obl_le := n_plur_ppcomp_lexent &
"""
Cn, plr, oblig PP comp           
<ex>Others of them swam.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
			 VAL.COMPS < [ OPT - ] > ],
		   CONT.RELS <! reg_diadic_nom_relation !> ] ].

; "kind"
n_pp_c-pl-sg_le := basic_noun_noaffix_word &
"""
Cn, plr-sing, PP comp            
<ex>This kind of birds fly.
"""
  [ SYNSEM noun_ppcomp_two_arg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                           VAL.COMPS < [ --SIND #index ] > ],
                     AGR.DIV -,
                     CONT [ HOOK.INDEX nonconj_ref-ind &
				       [ PNG png & [ PN 3p ] ],
                            RELS <! reg_diadic_nom_relation !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
	     MODIFD notmod & [ LPERIPH na ],
             LKEYS.KEYREL.ARG1 #index ] ].

; 'bunch', 'lot', 'number'
; DPF 30-sept-06 - Replaced MIN norm_nom_rel with nonpro_rel, and
; unify with COMPS..MIN, to admit e.g. "We arose a number of times."  Also
; removed MODIFD notmod.
; DPF 05-oct-06 - But this blocks "group of us', so generalize to nom_rel.
; DPF 08-mar-10 - Changed relation type from reg_diadic_nom_relation to just
; diadic_nom_relation, to relax constraint on SORT, to allow e.g.
; `singing is a lot of work'.
; DPF 2010-10-31 - Re 05-oct-06: MODIFD notmod prevents spurious ambiguity
; for "the big range of mountains appeared" (avoiding aj-hdn_adj_c).  So
; why did we remove it?  Let's try again...
;; DPF 2017-01-30 - Re 05-oct-06: Constrain a little further, to 
;; non_temp_nom_rel, so we don't allow group nouns to undergo lexical rules for
;; time expressions, such as the hour_np_lr.
;; DPF 2017-12-22 - Constrain SPR to agree in number with noun, to block
;; *two group of students*.  Also removed --BARE -, so we can signal mismatch
;; in number for *two group of students* when handling mal-input.
;; DPF 2018-10-03 - Re 2017-01-30: But this blocks *a lot of times*, so go back
;; to nom_rel, and block e.g. hour_np_lr applic instead via AGR, requiring 3s
;; for hour_np_lr dtr.
;; DPF 2020-04-30 - Push COMPS..OPT - and AGR..PN 3p down to subtypes, so we
;; can get *a minimum of five cats sleep* and *the minimum is five*
;;
basic_n_group_ppof_lexent := norm_noun_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun &
				[ MINORS.MIN nom_rel & #min ],
			   VAL [ COMPS < synsem &
					 [ LOCAL.CAT.HEAD.MINORS.ALTMIN #min,
					   --SIND #ind ] > ] ],
		     CONT [ RELS <! diadic_nom_relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     LKEYS [ KEYREL.ARG1 #ind,
		     --COMPKEY _of_p_sel_rel ] ] ].

n_group_ppof_lexent := basic_n_group_ppof_lexent &
  [ SYNSEM unsp_ppcomp_two_arg_synsem &
    [ LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.AGR.PNG.PN #pn,
	      CONT.HOOK.INDEX.PNG.PN #pn ] ] ].

n_group_ppof_mass_lexent := basic_n_group_ppof_lexent &
  [ SYNSEM unsp_ppcomp_two_arg_mass_synsem &
	   [ LOCAL [ CAT.VAL.COMPS.FIRST.OPT -,
		     AGR.PNG.PN 3p ] ] ].

; DPF 28-jun-07 - Restrict to nominative case, to avoid spurious ambig with 
; ordinary n_pp_c_of.
; DPF 07-nov-07 - But this blocks e.g. "there are the majority of houses..."
; since the number mismatch with "are" forces the group noun, but "are" wants
; the complement to be [CASE acc].  FIX...
; DPF 19-jan-08 - Removed that CASE nom restriction, since it now blocks
; 'We hired a group of citizens.'

; 'the row of houses are ...'
n_pp_c-gr-of_le := n_group_ppof_lexent &
"""
Cn, group, PP-of comp            
<ex>A lot of birds fly.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.OPT -,
		   AGR [ PNG.PN 3p,
			 DIV - ] ] ].

; 'plenty of'
n_pp_m-gr-of_le := n_group_ppof_mass_lexent &
"""
Mass, group, PP-of               
<ex>Plenty of birds fly.
"""
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < unexpressed_reg >,
                             COMPS < [ LOCAL.AGR.PNG.PN #pn ] > ],
                   AGR [ PNG.PN #pn,
                         DIV + ] ] ].

; 'piece of', 'pair of'
n_pp_c-gr-of-ns_le := n_group_ppof_lexent &
"""
Cn, group, PP-of comp, unsp sort 
<ex>A piece of cake fell.
"""
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS.FIRST.OPT -,
		     CONT.HOOK.INDEX.SORT entity-or-qevent,
		     AGR.PNG.PN 3p ],
	     LKEYS.KEYREL.PRED quantum_n_of_rel ] ].
		   
;; DPF 2020-04-30 - Added type for nouns such as minimum/maximum/minority
;; that have corresponding adjectives, so don't want these in N-N compounds
;;
n_pp_c-gr-nocnh_le := n_group_ppof_lexent &
"""
Cn, group, PP-of comp, no nonhd in compound
<ex>A minimum of ten birds fly.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS.NORM norm_rel,
			 VAL.COMPS.FIRST.LOCAL.AGR.PNG.PN #pn ],
		   AGR [ PNG.PN #pn,
			 DIV - ] ] ].

;;; DPF 13-feb-08 - Block "number" from undergoing n-adj rule: Add HEAD noun

n_group_nocomp_lexent := noun_word &
  [ SYNSEM unsp_count_noun_nocomp_synsem &
	   [ MODIFD notmod ] ].

n_group_mass_nocomp_lexent := norm_noun_word &
  [ SYNSEM unsp_mass_noun_nocomp_synsem ].

n_-_c-gr_le := n_group_nocomp_lexent &
"""
Icn, group                       
<ex>A long series ensued.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.--BARE - ].

n_-_c-gr-nocnh_le := n_group_nocomp_lexent &
"""
Icn, group, no non-hd in compound
<ex>A third are left.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD [ --BARE -,
				MINORS.NORM norm_rel ],
			 VAL.SPR.FIRST expressed_synsem ],
	     MODIFD.RPERIPH + ] ].

n_-_c-gr-nom_le := n_group_nocomp_lexent &
"""
Icn, group, no non-hd in compound, nominative case only
<ex>A third are left.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD [ --BARE -,
				MINORS.NORM norm_rel,
				CASE nom ],
			 VAL.SPR.FIRST expressed_synsem ],
	     MODIFD.RPERIPH + ] ].

n_-_m-gr_le := n_group_mass_nocomp_lexent &
"""
Mass, group                      
<ex>Plenty happened.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < unexpressed_reg >,
		   CONT.HOOK.INDEX.PNG.PN 3s,
                   AGR.DIV + ] ].

;; DPF 2020-05-16 - With the changes to measure-NPs, add CASE real_case here
;; to prevent these from undergoing np_adv-mnp rule.
;;
n_part_lexent := basic_noun_noaffix_word &
  [ SYNSEM partitive_noun_synsem &
	   [ LOCAL [ CAT [ HEAD.CASE real_case,
			   VAL.SPR.FIRST [ LOCAL.CAT [ HEAD adv,
						     VAL.SPR *unexplist* ],
					 --MIN just_only_deg_rel ] ],
                     CONT [ RELS.LIST < #keyrel, #altkeyrel, ... >,
                            HCONS <! qeq !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ],
             NONLOC.QUE 0-dlist ] ].

n_pp_mc-a-of_le := n_part_lexent &
"""
Partitive, agr w/PP-of           
<ex>Half of the birds fly.
"""
  [ SYNSEM partitive_noun_ppof_agr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !>,
             LKEYS.ALTKEYREL.PRED explicit_quant_agr_q_rel ] ].

n_pp_mc-pl-of_le := n_part_lexent &
"""
Partitive, plural w/PP-of, informal
<ex>The both of the birds fly.
"""
  [ SYNSEM partitive_noun_ppof_agr_synsem &
           [ LOCAL [ CONT.RELS <! relation, relation !>,
                     AGR.PNG.PN 3p ] ],
    GENRE nonformal ].

n_pp_mc-na-of_le := n_part_lexent &
"""
Partitive, no agr w/PP-of        
<ex>None of the birds flies.
"""
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL.CONT.RELS <! relation, relation !> ] ].

n_pp_mc-pl-na-of_le := n_part_lexent &
"""
Partitive, no agr w/PP-of        
<ex>Neither one of them flies.
"""
  [ SYNSEM partitive_noun_ppof_noagr_synsem &
           [ LOCAL [ CONT.RELS <! relation, relation !>,
                     AGR.PNG.PN 3p ] ] ].

n_np_mc-a_le := n_part_lexent &
"""
Partitive, agr w/NP comp         
<ex>B bought all the food.
"""
 [ SYNSEM partitive_noun_np_agr_synsem &
  [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN def_or_demon_q_rel]].

n_np_mc-indef_le := n_part_lexent &
"""
Partitive, agr w/NP comp, including indefinite
<ex>B bought half a loaf.
"""
  [ SYNSEM partitive_noun_np_agr_synsem ].

n_np_mc-a-def_le := n_part_lexent &
"""
Partitive, agr w/NP comp, must be definite
<ex>B paid twice the price.
"""
  [ SYNSEM partitive_noun_np_agr_synsem &
    [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN 
						  def_or_udef_or_demon_q_rel]].

n_np_mc-na_le := n_part_lexent &
"""
Partitive, no agr w/NP comp      
<ex>Both the birds flew.
"""
  [ SYNSEM partitive_noun_np_noagr_synsem ].

n_-_mc-prt_le := n_part_lexent &
"""
Partitive, no comp               
<ex>None flew.
"""
  [ SYNSEM partitive_noun_nocomp_synsem &
           [ LOCAL [ CAT.VAL.COMPS < >,
                     CONT.RELS <! #keyrel, relation !> ],
             MODIFD notmod,
             LKEYS.KEYREL #keyrel ] ].

n_np_mc-neg_le := n_part_lexent &
"""
Partitive, negated               
<ex>Not all the cats jumped.
"""
  [ SYNSEM partitive_noun_np_neg_synsem ].

; pleasure
n_vp_c-it_le := noun_word &
"""
Cn, VP comp, it-subj             
<ex>It's a pleasure to sleep.
"""
  [ SYNSEM common_noun_vpcomp_expl_synsem ].

; drudgery
n_vp_m-it_le := noun_word &
"""
Mass, VP comp it-subj 'drudgery' 
<ex>It is drudgery to do that.
"""
  [ SYNSEM mass_noun_vpcomp_expl_synsem ].

; pleasure to VP/NP
n_vpslnp_c_le := noun_word &
"""
Cn, VP/NP comp                   
<ex>Kim is a pleasure to mmet.
"""
  [ SYNSEM common_noun_vpcomp_slash_synsem ].

noun_one_arg_synsem := basic_noun_synsem & one_arg.

;; Use AGR hack of incompatible values for PN and DIV to exclude all normally
;; inflected nouns.
;;
n_pred_lexent := nonc-hm & basic_noun_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD noun &
				[ MINORS [ MIN norm_nom_rel,
					   NORM norm_rel ],
				  MOD < anti_synsem_min >,
				  CASE nom ],
			   VAL [ SPR < unexpressed_reg &
				       [ LOCAL.CAT.HEAD det,
					 OPT - ] > ] ],
		     AGR [ PNG.PN 3p,
			   DIV - ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! nom_relation &
				    [ LBL #ltop ] !> ] ],
	     MODIFD notmod & [ LPERIPH na ],
	     NONLOC [ REL 0-dlist,
		      QUE 0-dlist ] ] ].

n_pred_nocomp_lexent := n_pred_lexent &
   [ SYNSEM noun_one_arg_synsem &
	   [ LOCAL.CAT.VAL.COMPS < >,
	     NONLOC.SLASH 0-dlist ] ].

n_-_c-prd_le := n_pred_nocomp_lexent &
"""
Cn, predicative complement of id-cop
<ex>Kim is partner already.
"""
  [ SYNSEM.LKEYS.KEYREL reg_nom_relation ].

;; *we wish the whole day was morning*
n_-_c-prd-tmp_le := n_pred_nocomp_lexent &
"""
Cn, temporal, predicative complement of id-cop
<ex>We wish the whole day was morning.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT time ].

pred_ppcomp_two_arg_synsem := unsp_noun_ppcomp_synsem & two_arg &
			      count_noun_synsem &
  [ LOCAL.CAT.VAL.COMPS.FIRST.--SIND #cind,
    LKEYS.KEYREL.ARG1 #cind ].
	    
;; *president of the company*
n_pred_comp_lexent := n_pred_lexent &
   [ SYNSEM pred_ppcomp_two_arg_synsem ].

n_pp_c-prd-of_le := n_pred_comp_lexent &
"""
Cn, PP complement, predicative complement of id-cop
<ex>B is president of the company.
"""
  [ SYNSEM.LKEYS [ KEYREL reg_diadic_nom_relation,
		   --COMPKEY _of_p_sel_rel ] ].


;; For nouns heading subject NP in do-be construction, such as `thing'
;; DPF 2017-02-03 - Changed SUBJ *unexplist* to *anti_null* since now have
;; relative clauses always have this value for SUBJ, but push down to subtypes
;; since the one for *what is easiest to do* has non-empty SUBJ.
;;
noun_do_be_synsem := nonpro_nomod_onearg_synsem &
  [ LOCAL 
    [ CAT [ HEAD basic_noun,
	    VAL [ COMPS < synsem &
			  [ LOCAL [ CAT [ HEAD verbal & 
					       [ MOD < [ --SIND #modind &
							    [ SORT do-event ],
							 LOCAL.CONT.HOOK.XARG 
								#xarg ] >,
						 INV -,
						 VFORM fin_or_inf ],
					  VAL.COMPS < >,
					  MC na ],
				    CONT.HOOK [ LTOP #ltop,
						XARG #modind ],
				    CONJ cnil ],
			    NONLOC.SLASH 0-dlist,
			    OPT - ] >,
		  SPEC < anti_synsem_min > ] ],
      CONT [ HOOK [ LTOP #ltop,
		    INDEX #modind & do-index,
		    XARG #xarg ],
		   RELS.LIST < #keyrel, ... > ] ],
    NONLOC non-local_none,
    MODIFD notmod & [ LPERIPH na ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     ARG0 #modind ] ].

noun_do_be_spr_synsem := noun_do_be_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS [ MIN norm_nom_rel,
				ALTMIN #spmin ],
		  VAL [ SPR < synsem &
			      [ --MIN #spmin & quant_rel,
				LOCAL.CAT [ HEAD det,
					    VAL [ SUBJ < >,
						  SPR *olist* ] ],
				LEX +,
				OPT - ] >,
			SUBJ *anti_null*,
			COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ] ],
	    CONT [ HCONS <! !>,
		   ICONS <! !> ] ] ].

noun_do_be_thing_synsem := noun_do_be_spr_synsem &
  [ LOCAL.CONT.RELS <! relation !> ].

; For `thing'
n_cp_do-be-th-sg_lexent := basic_noun_word & nonc-hm &
  [ INFLECTD +,
    SYNSEM noun_do_be_thing_synsem &
	   [ LOCAL [ CAT.VAL.SPR < [ LOCAL.AGR [ PNG.PN #pn,
						 DIV #div ] ] >,
		     CONT.HOOK.INDEX [ PNG.PN #pn,
				       DIV #div ] ] ] ].

n_cp_do-be-th-sg_le := n_cp_do-be-th-sg_lexent &
"""
Do-be `thing' singular
<ex>The one thing he did was compete.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.SPR.FIRST expressed_synsem,
		   CONT.HOOK.INDEX.PNG.PN 3s ] ].

n_cp_do-be-th-pl_le := n_cp_do-be-th-sg_lexent &
"""
Do-be `things' plural
<ex>The two things he did were compete and persevere.
"""
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.PN 3s,
				   DIV + ] ].

; For `best, worst, most, least'
noun_do_be_sup_synsem := noun_do_be_spr_synsem &
  [ LOCAL [ CAT.VAL.SPR < expressed_synsem &
			      [ --MIN _the_q_rel ] >,
	    CONT.RELS <! [ LBL #hand,
			 PRED generic_entity_rel,
			 ARG0 #index,
			 CFROM #cfrom, CTO #cto ],
		       #altkeyrel &
		       [ LBL #hand,
			 ARG0 #event,
			 ARG1 #index ],
		       [ LBL #hand,
			 PRED superl_rel,
			 ARG1 #event,
			 CFROM #cfrom, CTO #cto ] !> ],
    LKEYS.ALTKEYREL #altkeyrel ].

n_cp_do-be-sup_le := basic_noun_word & nonc-hm &
"""
Do-be superlative (best, worst, most, least)
<ex>The best she could do was make the team.
"""
  [ INFLECTD +,
    SYNSEM noun_do_be_sup_synsem ].

noun_do_be_something_synsem := noun_do_be_synsem &
  [ LOCAL [ CAT [ HEAD partn &
		       [ MINORS [ MIN norm_nom_rel,
				  ALTMIN #spmin ] ],
		  VAL [ SPR < >,
			SUBJ *anti_null*,
			COMPS < [ LOCAL.CAT.HEAD.MOD < synsem > ] > ] ],
	    CONT [ RELS <! [ LBL #nhand,
			     ARG0 #ind & [ PNG.PN 3s ],
			     CFROM #cfrom, CTO #cto ],
			   [ PRED _some_q_rel & #spmin,
			     ARG0 #ind,
			     RSTR #rhand,
			     CFROM #cfrom, CTO #cto ] !>,
		   HCONS <! qeq & [ HARG #rhand,
				    LARG #nhand ] !>,
		   ICONS <! !> ] ] ].

;; *something we could do is hire a consultant*
n_cp_do-be-sth_le := basic_noun_word & nonc-hm &
"""
Do-be `something'
<ex>Something he can do is compete aggressively.
"""
  [ INFLECTD +,
    SYNSEM noun_do_be_something_synsem ].

noun_do_be_part_synsem := noun_do_be_synsem &
  [ LOCAL [ CAT [ HEAD partn &
		       [ MINORS [ MIN part_of_rel,
				  ALTMIN #qpred,
				  NORM norm_rel ] ],
		  VAL [ SPR < anti_synsem &
			      [ LOCAL.CONT.HOOK.LTOP #qlbl,
				OPT - ] >,
			COMPS < [ LOCAL.CAT.HEAD.VFORM fin ] > ] ],
	    CONT [ RELS <! [ PRED generic_entity_rel,
			     LBL #nlbl,
			     ARG0 #arg0 ],
			   #altkeyrel &
			   [ LBL #qlbl,
			     PRED #qpred,
			     ARG0 #arg0,
			     RSTR #rstr ] !>,
		   HCONS <! qeq & [ HARG #rstr,
				    LARG #nlbl ] !>,
		   ICONS <! !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

n_cp_do-be-part_lexent := basic_noun_word & nonc-hm &
  [ INFLECTD +,
    SYNSEM noun_do_be_part_synsem &
	   [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD.MOD < synsem >,
						 VAL.SUBJ *anti_null* ] ] > ] ].

;; For *what is easiest to do is leave the room*
n_vp_do-be-part_lexent := basic_noun_word & nonc-hm &
  [ INFLECTD +,
    SYNSEM noun_do_be_part_synsem &
      [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD.MOD < anti_synsem >,
					      VAL.SUBJ < [ LEX + ] > ],
					CONT.HOOK.INDEX.SORT do-event ] ] > ] ].

;; *all (that) we did*
;;
n_cp_do-be-all_le := n_cp_do-be-part_lexent
"""
Do-be `all'
<ex>All he did was compete.
"""
.

;; Exclude overt relative pronoun for `what': **what that we did*
;; Take advantage of non-wh rel-cl being distinguished from filler-head rel-cl
;; in the constraint on MODIFD.RPERIPH.  
;; 
n_cp_do-be-what_le := n_cp_do-be-part_lexent &
"""
Do-be `what' with clausal complement
<ex>What he did was compete.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ MODIFD.RPERIPH - ] > ].

n_vp_do-be-what_le := n_vp_do-be-part_lexent
"""
Do-be `what' with VP complement
<ex>What is easiest to do is buy flowers.
"""
.

;;
;; Lexical NPs
;;
;;   (proper names, pronouns, names of weekdays, ...)

basic_np_synsem := ref_synsem &
  [ LOCAL.CAT [ HEAD basic_noun &
                     [ MINORS.ALTMIN def_q_rel ],
                VAL.SUBJ < > ] ].

basic_np_word := noncrs-m-nab & basic_noun_word &
  [ SYNSEM basic_np_synsem ].

basic_non_affixed_np := noncqrs-m-nab & basic_noun_word &
  [ SYNSEM.MODIFD notmod ].

non_affixed_np := basic_non_affixed_np & hc-to-phr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

np_word := basic_np_word & basic_non_affixed_np & hc-to-phr &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < > ].

;np_synsem := noun_synsem & nomod_synsem.
np_synsem := nonpronominal_synsem & ref_synsem & nomod_synsem &
  [ LOCAL [ CAT.HEAD basic_noun,
	    AGR #agr,
	    CONT.HOOK.INDEX #agr ] ].

basic_np_sing_synsem := basic_np_synsem &
  [ LOCAL.CONT [ RELS.LIST < nom_relation &
                             [ PRED basic_nom_rel,
                               ARG0 #ind ],
			     #altkeyrel &
                             [ PRED quant_rel,
                               ARG0 #ind,
                               RSTR #rhand ], ... >,
                 HCONS <! qeq & [ HARG #rhand,
                                  LARG #keyhand ] !>,
		 ICONS <! !> ],
    LKEYS [ KEYREL.LBL #keyhand,
	    ALTKEYREL #altkeyrel ] ].

basic_np_sing_word := basic_np_word & hc-to-phr &
  [ SYNSEM basic_np_sing_synsem ].

np_sing_synsem := basic_np_sing_synsem & np_synsem &
  [ LOCAL [ CAT.VAL [ SPR < >,
                      COMPS < > ],
            CONT.RELS <! relation, [ PRED proper_q_rel ] !> ],
    MODIFD notmod ].

; DPF 10-Apr-02 - Changed ALTMIN from basic_nom_rel to implicit_q_rel so
; proper names can form compounds like in "the Kim Browne story"

; DPF 15-May-02 - Changed proper names so they now inflect, allowing plural
; forms as in "they hired two Chiangs"
; DPF 5-Sep-03 - Changed ALTMIN from implicit_q_rel to proper_q_rel to
; block compound "the Browne hired Chiang".  Later changed.
; DPF 7-may-04 - Removed nonque supertype, since we want to allow e.g.
; "which Elvis did you see"
; DPF 24-aug-04 - Added RPERIPH + to enable blocking of red-rel analysis
; of "Abrams hired" while still allowing "people hired"
; PDF 19-apr-08 - Added INDEX nonconj_ref-ind to block spurious analysis
; of uninflected "sunny Pittsburgh" as proper_np_conj.
;
; noncrs-hm &
basic_n_proper_lexent := nonrs-hm &
  [ SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS [ MIN named_np_rel,
                                       ALTMIN abstract_q_rel ],
                           VAL [ SPR < [ --MIN abstract_q_rel,
                                         NONLOC.QUE #que ] >,
                                 COMPS < > ] ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #index & nonconj_ref-ind ],
                            RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ],
	             CONJ cnil,
                     AGR #index ],
             NONLOC.QUE #que,
             LKEYS [ KEYREL named_nom_relation &
                            [ PRED named_np_rel,
                              LBL #ltop ],
                     ALTKEYREL.PRED implicit_q_rel ] ] ].

reg_n_proper_lexent := basic_n_proper_lexent & basic_noun_word &
  [ SYNSEM.MODIFD notmod ].

norm_n_proper_lexent := reg_n_proper_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED named_rel,
    INFLECTD - ].

; Distinguish ordinary proper names like "Kim" from city proper names like
; "Paris", which allow a following comma as in "Paris, France".
;; DPF 2012-09-10 - But this does not scale well, since any proper name
;; can be used as the name of a city.  So accept the modest additional
;; ambiguity, and collapse this distinction.
;;
n_proper_lexent := norm_n_proper_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN named_np_rel ].

; DPF 26-Mar-01 - Added MODIFD.LPERIPH + to prevent (restrictive) post-nom
; modifiers of bare proper names, as in "*Abrams by Browne arrived." though
; this will also block "Abrams from New York just called".  Not clear what
; the contrast is due to.
; DPF 1-Jun-02 - But this was too strong, so relaxed the reduced-rel rule
; but keep this constraint here, since it still serves to prevent proper names
; from appearing as heads of n-n compounds, blocking "interview Sandy"
; DPF 2011-02-08 - This [LPERIPH +] constraint was preventing "two Kims", so
; since the unwanted N-N construction is independently blocked by the value
; for MINORS.MIN, removed the constraint.
;
n_-_pn_le := n_proper_lexent
"""
Proper noun (pn)                 
<ex>Abrams arrived.
"""
.


n_-_pn-fem_le := n_proper_lexent &
"""
Pn - feminine                    
<ex>Sara arrived.
"""
  [ SYNSEM.LOCAL.AGR.PNG.GEN fem,
    TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized ].

n_-_pn-msc_le := n_proper_lexent &
"""
Pn - masculine                   
<ex>John arrived.
"""
  [ SYNSEM.LOCAL.AGR.PNG.GEN masc,
    TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized ].

n_-_pn-neut_le := n_proper_lexent &
"""
Pn - neuter 
<ex>IBM arrived.
"""
  [ SYNSEM.LOCAL.AGR.PNG.GEN neut,
    TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized ].

; For "i", which we don't want as plural "is"
n_-_pn-sg_le := n_proper_lexent &
"""
Pn - singular only               
<ex>B speaks Norwegian.
"""
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s ].

; Restrict plurals to nominative case, for 'ersatz' names like "OSCARCOMPOUND"
n_-_pn-pl-nom_le := reg_n_proper_lexent &
"""
Pn - plural only, nominative case
<ex><ipa/> are vowels.
"""
  [ INFLECTD +,
    SYNSEM [ LKEYS.KEYREL.PRED named_rel,
	     LOCAL plur_noun & [ CAT.HEAD [ MINORS [ MIN named_rel,
						     NORM no_rel ],
					    CASE nom ] ] ] ].

n_-_pn-pl-def_le := reg_n_proper_lexent &
"""
Pn - plural and definite only                 
<ex>The Giants play today.
"""
  [ INFLECTD +,
    SYNSEM [ LKEYS.KEYREL.PRED named_rel,
	     LOCAL plur_noun & [ CAT [ HEAD.MINORS.MIN named_rel,
				       VAL.SPR.FIRST expressed_synsem ] ] ] ].

n_-_pn-nonom_le := n_proper_lexent &
"""
Proper noun (pn), non-inflecting, only for *I* noun in cmpnds
<ex>The I and J columns are filled
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.CASE non_nom,
		     AGR [ PNG.PN 3s,
			   DIV - ] ],
	     MODIFD [ LPERIPH +,
		      RPERIPH + ] ] ].

n_-_pn-upcase_le := n_proper_lexent &
"""
Proper noun (pn), all uppercase, not S-initial.
<ex>Group A arrived.
<ex>We flew in on ANA.
"""
  [ SYNSEM.LOCAL.AGR.PNG.PN 3s,
    TOKENS.+LIST.FIRST.+CLASS [ +CASE capitalized+upper,
				+INITIAL - ] ].

n_-_pn-cap_le := n_proper_lexent &
"""
Proper noun (pn), first letter capitalized
<ex>We admire Per Roger.
"""
  [ TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized ].

n_-_pn-nounif_le := basic_n_proper_lexent & basic_noun_word &
"""
Non-unifying, to block generic proper NP for e.g. *Mr.*
<nex>Mr. Mr. Browne
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CASE non_nom,
				  MINORS [ MIN named_np_rel,
					   NORM no_rel ] ],
			   VAL.SPR.FIRST.--MIN implicit_q_rel ],
		     AGR [ PNG.PN 3p,
			   DIV - ] ],
	     MODIFD lmod & [ LPERIPH +,
			     RPERIPH + ],
	     LKEYS.KEYREL.PRED named_rel ],
    INFLECTD - ].

; DPF 19-sept-08 - Can we collapse the following two entries?  Why is CARG
; set in the pn-unk type but not in the pn-gen one?
;
; DPF 04-jan-2010 - Changed MIN named_rel to named_np_rel in order to allow
; for unknown city names as in "Ottawa, Canada"
;
;; DPF 2017-05-22 - The LPERIPH + constraint prevents *troubled NBI Inc.*, so
;; let's at least remind ourselves what its motivation is.  FIX?

n_-_pn-gen_le := reg_n_proper_lexent & generic_ne_lex_entry &
"""
Pn - generic                     
<ex>Genericpn arrived.
<native> n_-_pn_le
"""
  [ INFLECTD -,
    SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN named_np_rel,
	     LKEYS.KEYREL [ PRED named_rel ],
	     PHON.ONSET unk_onset ] ].

;; DPF 2020-04-29 - Generalized LPERIPH from + to na_or_+ to get *old P&G*
;;
n_-_pn-unk_le := reg_n_proper_lexent & basic_unknown_word &
"""
Pn - unknowns                    
<ex>Literalpn arrived.
<native> n_-_pn_le
"""
  [ INFLECTD -,
    SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN named_rel,
	     MODIFD.LPERIPH na_or_+,
	     LKEYS.KEYREL [ PRED named_rel,
			    CARG #carg ],
	     PHON.ONSET unk_onset ],
    TOKENS.+LIST < [ +CARG #carg ] > ].


n_-_pn-pl-unk_le := reg_n_proper_lexent & basic_unknown_word &
"""
Pn - unknowns, plural
<ex>Literalpn arrived.
<native> n_-_pn-pl_le
"""
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN named_rel,
		     AGR [ PNG.PN 3p, DIV + ] ],
	     MODIFD.LPERIPH +,
	     LKEYS.KEYREL [ PRED named_rel,
			    CARG #carg ],
	     PHON.ONSET unk_onset ],
    TOKENS.+LIST < [ +CARG #carg ] > ].

;; DPF 2018-07-25 - Tempting to add NORM no_rel to block these in left position
;; of noun-noun compounds, but it also blocks compound names such as "MS Gjende"
;; and anyway, nothing wrong with *the D.C. airport*
;;
n_-_pn-abb_le := basic_n_proper_lexent &
"""
Pn - abbrev.                     
<ex>B lives in NY.
"""
  [ INFLECTD -,
    SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN named_abb_rel,
                                     ALTMIN proper_q_rel ],
             MODIFD notmod,				    
             LKEYS.KEYREL [ PRED named_rel,
                            ARG0.PNG.PN 3s ],
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT comma_or_clause_or_no_punct,
		     RCLSTR [ RPAREN -,
			      RFP - ] ] ],
    ORTH.CLASS.+CASE capitalized ].

; Block left quote on name of letter "s" to avoid spurious ambig for "'s"
; while we still tokenize with an added space preceding "s".
;; DPF 2020-04-29 - Generalize LPERIPH + to na_or_+ to still get *long S*
;;
n_-_pn-nq_le := n_proper_lexent &
"""
Pn - no left quote: *S*          
<ex>We saw S after R.
"""
  [ SYNSEM.MODIFD.LPERIPH na_or_+,
    ALTS.SQPNCT - ].

; "here, there" as in "get out of here/there" 
; Make SYNSEM pronominal_synsem to block N-N cmpnds like "the there meeting"
; Added PRD + so appositives with left member np_adv won't join in N-N-cmpnds.
; DPF 23-Oct-00 - Since pronominal_synsem no longer constrains left member of
; noun-noun compounds, use alternate hack of making ALTMIN not unify with
; the [ALTMIN no_rel] constraint in the n-n-cmpnd rule.

basic_np_adv_synsem := basic_np_sing_synsem & pronominal_synsem &
  [ LOCAL [ CAT [ HEAD [ MINORS [ MIN #min,
				  ALTMIN def_explicit_q_rel,
				  NORM never_unify_rel ] ],
		  NEGPOL - ],
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL [ LBL #ltop,
                     PRED #min ],
            ALTKEYREL relation,
            ALT2KEYREL relation ] ].

; DPF 24-apr-09 - Recently added anti_synsem to SPR list, but don't recall
; what the motivation is.  Note that it's convenient in blocking these as
; heads in appositives, so don't discard lightly.

np_adv_synsem := basic_np_adv_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.VAL [ SPR *olist*,
                                          SPEC < synsem_min > ] ],
			anti_synsem_min & [ OPT - ] > ].

basic_np_adv_word := basic_np_sing_word &
  [ SYNSEM basic_np_adv_synsem &
	   [ LOCAL [ CONT [ HOOK.INDEX #ind & [ PNG png & [ PN 3s ] ],
                            RELS.LIST < relation, #altkeyrel, ... > ],
		     AGR #ind ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

basic_np_adv_lexent := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
		     CONT.RELS.LIST < relation & [ LBL #hand,
						   ARG0 #inst ], 
				      [ PRED def_implicit_q_rel ],
				      #alt2key & [ LBL #hand,
						   ARG0 event & 
						       [ E [ TENSE untensed,
							     ASPECT no_aspect]],
						   ARG1 #inst ], ... > ],
	     LKEYS.ALT2KEYREL #alt2key ] ].

; 6-jun-04 - Changed SPR..HEAD from adv to n_or_adv to allow measure NPs
; as specifiers, as in "two weeks early"
np_adv_lexent := basic_np_adv_lexent &
  [ SYNSEM np_adv_synsem &
           [ LOCAL.CAT.VAL.SPR.FIRST [ LOCAL [ CAT.HEAD n_or_adv,
					       CONT.HOOK [ LTOP #ltop,
							   XARG #arg0 ] ],
				       NONLOC.QUE #que ],
	     NONLOC.QUE #que,
	     LKEYS.ALT2KEYREL [ LBL #ltop,
                                ARG0 #arg0 ] ] ].

norm_np_adv_lexent := np_adv_lexent &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < >,
			 VAL.SPR.FIRST.LOCAL.CAT.HEAD.MINORS
					[ MIN just_only_much_deg_rel,
					  ALTMIN basic_adv_rel ] ],
		   CONT.RELS <! relation, relation, relation !> ] ].

; DPF 9-oct-05 - Try making these [CASE obliq] to block them from ordinary
; direct objects, as in the object-extraction reading of "Here kim plunged t
; into the water"

n_-_ad-pl_le := norm_np_adv_lexent &
"""
N, can modify, locative (place)
<ex>B lives overseas.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
                              CASE obliq ],
                   CONT.HOOK.INDEX.SORT place ] ].

n_-_ad-pl-nomod_le := norm_np_adv_lexent &
"""
N, can modify, locative (place), blocks modifiers of self
<ex>B stayed home
<nex> B went from home in Paris to home in London
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN place_n_rel,
				CASE obliq,
				--BARE - ],
		     CONT.HOOK.INDEX [ SORT place,
				       PNG.GEN neut ] ],
	     MODIFD.RPERIPH + ] ].

;; DPF 2020-03-24 - Changed MIN to temp_abstr_rel from time_n_rel as per trunk.
;;
n_-_ad-time_le := norm_np_adv_lexent &
"""
N, can modify, temporal          
<ex>B arrives today.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN temp_abstr_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

; e.g. 'early', which allows "too/so early", unlike 'now', 'then'
n_-_ad-time-ns_le := np_adv_lexent &
"""
N, can modify, temp, no sort     
<ex>B stayed until early today
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MOD < >,
				MINORS.MIN time_n_rel ],
                         VAL.SPR.FIRST [ --MIN very_this_that_rel ] ],
                   CONT [ HOOK.INDEX.SORT time,
			  RELS <! relation, relation, relation !> ] ] ].

n_adv_event_lexent := norm_np_adv_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN place_n_rel,
             LKEYS.ALT2KEYREL.ARG0 [ E [ TENSE no_tense,
                                         ASPECT no_aspect ],
                                     SORT place ] ] ].

n_-_ad-loc_le := n_adv_event_lexent
"""
N, can modify, location          
<ex>B slid downward.
"""
.

; 'there'
n_-_ad-acc_le := norm_np_adv_lexent &
"""
N, can modify, acc case only     
<ex>B slept there.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD [ CASE acc,
                              MINORS.MIN place_n_rel ],
                   CONT.HOOK.INDEX.SORT place ] ].

; 'north' etc, which take degree specifiers like "far" or "ten miles",
; and an optional of-PP complement.
n_pp_ad-dir_le := basic_np_adv_word &
"""
N, can modify, directional       
<ex>B went west.
"""
  [ SYNSEM np_adv_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < >,
				  MINORS.MIN place_n_rel ],
                           VAL [ SPR.FIRST [ --MIN much_deg_rel,
					     LOCAL [ CAT.HEAD n_or_adv,
						     CONT.HOOK [ LTOP #ltop,
								 XARG #arg0 ]],
					     NONLOC.QUE #que ],
				 COMPS < [ --MIN _of_p_sel_rel,
                                           LOCAL
                                           [ CAT [ HEAD prep & [ PRD - ],
                                                   VAL.COMPS < > ],
                                             CONT.HOOK [ LTOP #hand,
                                                         INDEX #ppind ] ],
                                           NONLOC [ SLASH #slash,
                                                    REL #rel,
                                                    QUE 0-dlist ],
                                           PUNCT.LPUNCT no_punct ] > ] ],
                     CONT [ HOOK.INDEX.SORT place,
                            RELS <! relation & [ LBL #hand,
                                                 ARG0 #inst ], 
                                  [ PRED def_implicit_q_rel ],
                                  #alt2key & [ LBL #hand,
                                               ARG1 #inst ] !> ] ],
             NONLOC [ SLASH #slash,
                      QUE #que,
                      REL #rel ],
             LKEYS.ALT2KEYREL #alt2key &
                              [ LBL #ltop,
                                ARG0 #arg0,
                                ARG2 #ppind ] ] ].

; 'then' -- to block "then Kim left" as N+RelClause.  Hack, since this
; also blocks "right then".
; [ACTIVATED -] prevents "then" from being topicalized, to avoid filler-head
; reading for "then kim arrived"
n_-_ad-br_le := basic_np_adv_lexent &
"""
N, can modify, no spr            
<ex>B arrived then.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < >,
				  MINORS.MIN time_n_rel ],
                           VAL.SPR < anti_synsem_min & [ OPT - ] > ],
                     CONT [ HOOK.INDEX.SORT time,
			    RELS <! relation, relation, relation !> ],
                     CTXT.ACTIVATED - ],
             NONLOC.QUE 0-dlist ] ].

; 'long' as in 'Kim stayed for too long', 'Kim stayed too long', and
; 'it took too long to finish'

basic_n_adv_gradable_lexent := np_adv_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN time_n_rel ],
                           VAL.SPR.FIRST [ --MIN degree_rel,
					   LEX + ] ],
                     CONT.HOOK [ LTOP #lbl,
                                 INDEX.SORT time ] ],
             LKEYS.KEYREL.LBL #lbl ] ].

;; DPF 2011-09-24 - Re 07-may-04 (on n_-_ad-gr-nm_le): But we also want 
;; to block *soon arose* with `soon' as subject, so constrain MOD to 
;; be < anti_synsem_min >.

norm_n_adv_gradable_lexent := basic_n_adv_gradable_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < anti_synsem_min > ].

n_-_ad-gr_le := basic_n_adv_gradable_lexent &
"""
N, can modify, gradable          
<ex>B stayed late.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD grad_n & [ MOD < > ],
			 VAL.SPR.FIRST [ --MIN very_this_that_rel ] ],
		   CONT.RELS <! relation, relation, relation !> ] ].

; longer
n_-_ad-gr-cmp_le := norm_n_adv_gradable_lexent &
"""
N, can modify, grad, compar      
<ex>B stayed longer.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD grad_n,
			 VAL.SPR.FIRST [ --MIN much_deg_rel ] ],
		   CONT.RELS <! relation, relation, 
			        [ LBL #lbl,
				  ARG0 #arg0,
				  CFROM #cfrom, CTO #cto ],
			        [ LBL #lbl,
				  PRED more_comp_rel,
				  ARG1 #arg0,
				  CFROM #cfrom, CTO #cto ] !> ] ].

; soon
; DPF 07-may-04 - Added CASE nom as hack to prevent e.g. 'until soon'
;; DPF 2011-09-24 - Re 07-may-04: But we also want to block *soon arose* with
;; `soon' as subject, so constrain MOD to be < anti_synsem_min >.
n_-_ad-gr-nm_le := norm_n_adv_gradable_lexent &
"""
N, can modify, grad, nom case    
<ex>B leaves soon.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD.CASE nom,
			 VAL.SPR.FIRST.--MIN very_this_that_rel ],
		   CONT.RELS <! relation, relation, relation !> ] ].
;sooner
n_-_ad-gr-cmp-nm_le := norm_n_adv_gradable_lexent &
"""
N, can modify, grad, comp, nom   
<ex>B left sooner.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD.CASE nom,
			 VAL.SPR.FIRST [ --MIN much_deg_rel ] ],
		   CONT.RELS <! relation, relation,
			        [ LBL #lbl,
				  ARG0 #arg0,
				  CFROM #cfrom, CTO #cto ],
			        [ LBL #lbl,
				  PRED more_comp_rel,
				  ARG1 #arg0,
				  CFROM #cfrom, CTO #cto ] !> ] ].

; 'awhile'
; DPF 4-Apr-01 - Made ALTMIN be def_explicit_q_rel to block these guys as left 
; members of compounds as in "*the there books"
; DPF 11-Mar-02 - Changed SPR from anti_synsem_min to [MIN just_only_very_deg_rel]
; to allow "kim arrived just yesterday".
; DPF 04-Feb-03 - Can't make this [PRD -] because hadj rule now wants [PRD +]
; adjunct, but this means we overgenerate "the event awhile" since there's no
; way to say that "awhile" once turned into a modifier doesn't want to modify
; a nominal phrase.

n_-_ad-time-acc_le := basic_np_adv_word &
"""
N, can modify, temp, acc case    
<ex>B stayed awhile.
"""
  [ SYNSEM np_adv_synsem &
	   [ LOCAL [ CAT [ HEAD [ CASE acc,
				  MOD < >,
                                  MINORS.MIN time_n_rel ],
                           VAL [ SPR.FIRST [ --MIN just_only_very_deg_rel,
					     LOCAL [ CAT.HEAD adv,
						     CONT.HOOK [ LTOP #ltop,
								 XARG #arg0 ]]],
				 COMPS < > ] ],
                     CONT [ HOOK.INDEX.SORT time,
                            RELS <! relation, relation !> ] ],
             NONLOC.QUE 0-dlist,
             LKEYS [ ALTKEYREL [ LBL #ltop,
				 PRED def_explicit_q_rel ],
                     ALT2KEYREL.ARG0 #arg0 ] ] ].

; later (in the day)
n_-_ad-cmp_le := basic_np_adv_word &
"""
N, can modify, comparative       
<ex>B left earlier.
"""
  [ SYNSEM np_adv_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < >,
			   VAL [ SPR.FIRST [ --MIN just_only_very_deg_rel,
					     LOCAL [ CAT.HEAD n_or_adv,
						     CONT.HOOK [ LTOP #hand,
								 XARG #carg0]]],
				 COMPS < > ] ],
                     CONT [ RELS <! [ LBL #hand, 
                                      PRED modable_rel,
                                      ARG0 #inst,
				      CFROM #cfrom,
				      CTO #cto ],
                                  [ PRED def_explicit_q_rel ],
                                  arg1_relation & #alt2key &
                                  [ LBL #hand,
				    ARG0 #arg0 &
					[ E [ TENSE no_tense,
					      ASPECT no_aspect ] ],
				    ARG1 #inst ],
                                  [ LBL #hand,
                                    PRED more_comp_rel,
				    ARG0 #carg0 & [ E [ TENSE no_tense,
                                                        ASPECT no_aspect ] ],
                                    ARG1 #arg0,
				    CFROM #cfrom,
				    CTO #cto ] !> ] ],
	     NONLOC.QUE 0-dlist,
	     LKEYS.ALT2KEYREL #alt2key ] ].

; DPF 27-Apr-00 - Added [CASE acc] to block spurious parse for "where is kim"
; DPF 19-Oct-02 - But this unfortunately also blocks "when would be a good 
; time to meet", and besides, "where would be a good place to meet" is okay.
; DPF 9-Jun-03 - Still, what's worse? extra parses for "where does kim work?"
; or no parse for "where would please sandy"?  Maybe we treat the latter as
; the result of robust parsing with relaxation of the CASE constraint, and
; exclude it as strictly grammatical (and likewise for "when would be a good
; time?").

n_wh_adv_lexent := basic_np_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CASE acc,
				  MOD < > ],
                           VAL [ SPR < anti_synsem_min & [ OPT - ] >,
                                 COMPS 
                                   < [ OPT +,
                                       --MIN wh_the_hell_rel,
                                       LOCAL [ CAT.HEAD wh_adv,
                                               CONJ cnil  ],
                                       NONLOC.SLASH 0-dlist ] > ] ],
                     CONT.RELS <! relation, [ PRED which_q_rel ] !> ],
             NONLOC.QUE 1-dlist &
		         [ LIST < param > ] ] ].

n_-_ad-wh-pl_le := n_wh_adv_lexent &
"""
N, can modify, WH-place          
<ex>B wondered where C lived.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN place_n_rel,
                   CONT.HOOK.INDEX.SORT place ] ].

n_-_ad-wh-tm_le := n_wh_adv_lexent &
"""
N, can modify, WH-time           
<ex>B wondered when C left.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN time_n_rel,
                   CONT.HOOK.INDEX.SORT time ] ].

; For "the town where we come from"
n_rel_np_lexent := basic_noun_word & noncqs-hm-nab &
  [ SYNSEM nomod_synsem &
           [ LOCAL [ CAT [ HEAD noun &
                                [ MINORS.ALTMIN def_q_rel,
                                  CASE obliq ],
                           VAL [ SPR < anti_synsem_min >,
                                 SPEC < >,
                                 COMPS < > ] ],
                     CONT [ HOOK.INDEX #ind,
                            RELS <! !>,
                            HCONS <! !>,
			    ICONS <! !> ],
                     AGR #ind ],
             MODIFD notmod,
             NONLOC.REL 1-dlist & [ LIST < [ INDEX #ind ] > ],
	     LKEYS.KEYREL.PRED no_rel ] ].
    
; Lexical NP plurals - maybe only in British English? ("IBM are hiring again.")
;
np_pl_word := np_word &
  [ SYNSEM np_synsem &
	   [ LOCAL.CAT.VAL.COMPS < >,
             --SIND.PNG png & [ PN 3p ] ] ].

; DPF 25-May-03 - Added MOD..LTOP so "o'clock" and "fifteen" can both be
; combined with hour-words the same way, by getting at the MOD..LTOP value
; of the complement phrase (necessary since intersective adjectives do not
; lexically bind their LTOP to their key's LBL).
np_ersatz_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < anti_synsem_min & 
                               [ LOCAL.CONT.HOOK.LTOP #hand ] >,
                         MINORS.ALTMIN no_rel ],
                  VAL [ SPR < >,
			SUBJ < >,
			COMPS < >,
                        SPEC < > ] ],
	    CONT nom-obj &
		[ RELS.LIST < #keyrel, ... > ] ],
    MODIFD.LPERIPH -,
    LKEYS.KEYREL #keyrel & [ LBL #hand ] ].

np_word_no_aff := non_affixed_np &
  [ SYNSEM np_ersatz_synsem ].

ref_pro_np_synsem := basic_np_synsem & ref_pro_synsem.

; DPF 19-dec-04 - Added non-empty specifier to allow restrictive relatives 
; with pronouns: "He who saves...", "you who have...", and "that which you
; did will be rewarded".  But want to restrict this to nominative pronouns,
; to avoid spurious structures: "Kim hired [them in Paris]". So push SPR
; constraint down to various subtypes.
; DPF 03-jul-08 - Re 19-dec-04: Pull back up to pers_pro_synsem, since we
; now use this non-empty SPR property to force application of bare_np_q.
; Distinguish "we in Paris" from "*them in Paris" by further constraining
; the --MIN of the SPR.

; CONT.HOOK.INDEX.IND +
pers_pro_synsem := ref_pro_np_synsem &
  [ LOCAL [ CAT.VAL.SPR < anti_synsem & 
	  		  [ LOCAL.CONT.HOOK.LTOP #ltop,
			    OPT - ] > ],
    LKEYS.ALTKEYREL.LBL #ltop ].

; For 'them all' as in 'we read them all', but not "*they hired me all"
;
pro_wcomps_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                     < [ LOCAL [ CAT [ HEAD partn &
                                            [ MINORS [ MIN nonpro_rel,
						       ALTMIN both_all_q_rel]],
                                       VAL [ SPR *olist*,
					     COMPS < > ] ],
                                 CONT.HOOK.INDEX #cind ],
                         NONLOC non-local_none,
                         OPT -,
                         LEX +,
                         PUNCT.LPUNCT no_punct ] > ],
            CONT [ HOOK.INDEX #ind,
                   RELS <! [ LBL #lbl ], relation & #altkeyrel, 
			   #alt2keyrel & [ LBL #lbl,
					   PRED id_rel,
					   ARG0.E.TENSE no_tense,
					   ARG1 #ind,
					   ARG2 #cind ] !> ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].

; For 'we/us/you humans' but not '*they/them humans' (and not '*he/she humans')
; DPF 12-Oct-06 - Re-use the general referential-identity pred 'appos_rel' 
; rather than the idiosyncratic 'id_rel' used in tag questions.
;;
basic_pro_wcomps_synsem := pers_pro_synsem &
  [ LOCAL [ CAT.VAL [ COMPS 
                      < [ LOCAL [ CAT [ HEAD basic_noun & 
                                        [ MINORS 
					    [ MIN nonpro_rel,
					      ALTMIN both_all_udef_q_rel ] ],
					VAL [ SUBJ < >,
					      COMPS < >,
					      SPEC < anti_synsem_min > ] ],
				  CONT.HOOK.INDEX #cind & nonconj_ref-ind ],
			  NONLOC non-local_none,
			  OPT - ] > ],
            CONT [ HOOK.INDEX #ind & [ IND + ],
                   RELS.LIST < [ LBL #lbl ], relation & #altkeyrel,
			   #alt2keyrel & [ LBL #lbl,
					   PRED appos_rel,
					   ARG0.E.TENSE no_tense,
					   ARG1 #ind,
					   ARG2 #cind ], ... > ] ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].

pro_wcomps_plur_synsem := basic_pro_wcomps_synsem &
  [ LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ AGR.PNG.PN pl,
					CAT.VAL.SPR *olist* ],
	    CONT [ RELS <! relation, relation, relation !>,
		   HCONS <! qeq !> ] ] ].

;; DPF 2018-02-23 - Added type for vocative in *Move, you scoundrel!*, but
;; let's restrict this for now to nbars without post-modifier, to avoid fragment
;; NP reading for e.g. *You hire a programmer!*.  Impose CASE no_case to
;; prevent e.g. *[You can] arise*
;;
pro_wcomps_nbar_synsem := basic_pro_wcomps_synsem &
  [ LOCAL [ CAT [ HEAD.CASE no_case,
		  VAL.COMPS.FIRST [ LOCAL [ AGR.PNG.PN sg,
					    CAT [HEAD.MINORS.MIN non_proper_rel,
						 VAL.SPR.FIRST.OPT - ],
					    CONT.HOOK [ LTOP #nhand,
							INDEX #nind ] ],
				    MODIFD notmod_or_lmod ] ],
	    CONT [ RELS <! relation, relation, relation,
			   [ PRED udef_q_rel,
			     ARG0 #nind,
			     RSTR #rhand ] !>,
		   HCONS <! qeq, qeq &
                           [ HARG #rhand,
                             LARG #nhand ] !> ] ] ].

basic_personal_pro := basic_np_word & basic_pronoun_word & 
                      basic_non_affixed_np &
  [ SYNSEM pers_pro_synsem &
	   [ LOCAL.CONT [ HOOK.LTOP #prohand,
                          RELS.LIST < [ LBL #prohand,
                                        PRED pron_rel,
                                        ARG0 #inst ],
                                      #altkeyrel &
                                      [ PRED pronoun_q_rel,
                                        RSTR #rhand,
                                        ARG0 #inst ], ... >,
                          HCONS.LIST < qeq & [ HARG #rhand,
					       LARG #prohand ], ... >,
			  ICONS <! !> ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

personal_pro := basic_personal_pro & hc-to-phr &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ HOOK.INDEX.IND +,
			  RELS <! relation, relation !>,
			  HCONS <! qeq !> ] ] ].

n_-_pr-na_le := personal_pro &
"""
Pronoun, no agreement            
<ex>Someone sings, don't they
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE nom,
                                MINORS.MIN pron_rel ],
                     AGR.PNG png & [ PN 3p ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                             GEN andro ],
				 DIV -,
                                 SORT entity,
                                 PT std ] ] ].
 
basic_n_pers_pro_lexent := basic_personal_pro & 
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                   AGR #agr,
		   CONT.HOOK.INDEX #agr &
			        [ PT std ] ] ].

norm_n_pers_pro_lexent := basic_n_pers_pro_lexent & hc-to-phr &
  [ SYNSEM.LOCAL.CONT.HCONS <! qeq !> ].

n_pers_pro_lexent := norm_n_pers_pro_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ HOOK.INDEX [ SORT entity, IND + ],
                          RELS <! relation, relation !> ] ] ].

n_pers_pro_nom_lexent := n_pers_pro_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom ].

;; DPF 2020-03-24 - Added type as per trunk.
;;
basic_n_pers_pro_acc_lexent := n_pers_pro_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE non_nom,
		       VAL.SPR < [ --MIN no_rel ] > ] ].

n_pers_pro_acc_lexent := basic_n_pers_pro_acc_lexent.

n_-_pr-he_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN masc ],
			       DIV -,
                               PT std ] ].

n_-_pr-he_le := n_-_pr-he_lexent
"""
Pronoun 'he'                     
<ex>He arrived.
"""
.

n_-_pr-he_le_rbst := n_-_pr-he_lexent &
"""
Pronoun 'he', robust                     
<ex>He - he arrived.
"""
  [ GENRE robust ].

n_-_pr-she_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN fem ],
			       DIV -,
                               PT std ] ].

n_-_pr-she_le := n_-_pr-she_lexent
"""
Pronoun 'she'                    
<ex>She arrived.
"""
.

n_-_pr-she_le_rbst := n_-_pr-she_lexent &
"""
Pronoun 'she', robust                    
<ex>She she arrived.
"""
  [ GENRE robust ].

n_-_pr-she-he_le := n_pers_pro_nom_lexent &
"""
Pronoun 's/he'                    
<ex>"S/he" hired him.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN animate ],
			       DIV -,
                               PT std ] ].

;; DPF 2020-03-24 - Added type as per trunk.
n_-_pr-her_lexent := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN fem ],
			       DIV -,
                               PT std ] ].

n_-_pr-her_le := n_-_pr-her_lexent
"""
Pronoun 'her'                    
<ex>B hired her.
"""
.

;; DPF 2020-03-24 - Added type as per trunk.
;;
n_-_pr-her_le_rbst := n_-_pr-her_lexent &
"""
Pronoun 'her', robust                    
<ex>B hired her - her.
"""
  [ GENRE robust ].

;; DPF 2020-03-24 - Added type as per trunk.
;;
n_-_pr-him_lexent := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN masc ],
			       DIV -,
                               PT std ] ].

n_-_pr-him_le := n_-_pr-him_lexent
"""
Pronoun 'him'                    
<ex>B hired him.
"""
.

;; DPF 2020-30-24 - Added type as per trunk.
;;
n_-_pr-him_le_rbst := n_-_pr-him_lexent &
"""
Pronoun 'him', robust                    
<ex>B hired him - him.
"""
  [ GENRE robust ].

n_-_pr-him-her_le := n_pers_pro_acc_lexent &
"""
Pronoun 'him/her'                    
<ex>B hired him/her.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN animate ],
			       DIV -,
                               PT std ] ].

n_-_pr-i_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
			       DIV -,
                               PT std ] ].

n_-_pr-i_le := n_-_pr-i_lexent
"""
Pronoun 'i'                      
<ex>I arrived.
"""
.

n_-_pr-i_le_rbst := n_-_pr-i_lexent &
"""
Pronoun 'i', robust
<ex>I I arrived.
"""
  [ GENRE robust ].

n_-_pr-me_lexent := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
			       DIV -,
                               PT std ] ].

n_-_pr-me_le := n_-_pr-me_lexent
"""
Pronoun 'me'                     
<ex>B hired me.
"""
.

n_-_pr-me_le_rbst := n_-_pr-me_lexent &
"""
Pronoun 'me', robust                     
<ex>B hired me - me.
"""
  [ GENRE robust ].

n_-_pr-you_lexent := n_pers_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
			       PT std,
			       SORT entity ] ].

n_-_pr-you_le := n_-_pr-you_lexent
"""
Pronoun 'you'                    
<ex>You arrived.
"""
.

n_-_pr-you_le_rbst := n_-_pr-you_lexent &
"""
Pronoun 'you', robust
<ex>You you arrived.
"""
  [ GENRE robust ].

; DPF 7-Dec-02 - ACTIVATED is here experimentally, and at present only prevents
; "it" from being topicalized as in "*It I like".

n_-_pr-it_lexent := norm_n_pers_pro_lexent &
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR < [ --MIN no_rel ] >,
			       COMPS < > ],
                     CONT.RELS <! relation, relation !>,
                     CTXT.ACTIVATED - ],
	     MODIFD.RPERIPH +,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                             GEN neut ],
                                 PT std ] ] ].

n_-_pr-it_le := n_-_pr-it_lexent
"""
Pronoun 'it'                     
<ex>It arrived.
"""
.

n_-_pr-it_le_rbst := n_-_pr-it_lexent &
"""
Pronoun 'it', robust                     
<ex>It - it arrived.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.DIV -,
    GENRE robust ].

n_-_pr-we_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                               PT std,
                               SORT entity ] ].
n_-_pr-we_le := n_-_pr-we_lexent
"""
Pronoun 'we'                     
<ex>We arrived.
"""
.

n_-_pr-we_le_rbst := n_-_pr-we_lexent &
"""
Pronoun 'we', robust                     
<ex>We - we arrived.
"""
  [ GENRE robust ].

n_-_pr-us_lexent := n_pers_pro_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.CASE non_nom,
	     LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
				 PT std,
				 SORT entity ] ] ].

n_-_pr-us_le := n_-_pr-us_lexent
"""
Pronoun 'us'                     
<ex>B hired us.
"""
.

n_-_pr-us_le_rbst := n_-_pr-us_lexent &
"""
Pronoun 'us', robust
<ex>B hired us - us.
"""
  [ GENRE robust ].

n_-_pr-they_lexent := n_pers_pro_nom_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                               PT std ] ].

n_-_pr-they_le := n_-_pr-they_lexent
"""
Pronoun 'they'                   
<ex>They arrived.
"""
.

n_-_pr-they_le_rbst := n_-_pr-they_lexent &
"""
Pronoun 'they', robust
<ex>They they arrived.
"""
  [ GENRE robust ].

n_-_pr-them_lexent := n_pers_pro_acc_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                               PT std ] ].

n_-_pr-them_le := n_-_pr-them_lexent
"""
Pronoun 'them'                   
<ex>B hired them.
"""
.

n_-_pr-them_le_rbst := n_-_pr-them_lexent &
"""
Pronoun 'them', robust
<ex>B hired them - them.
"""
  [ GENRE robust ].

n_-_pr-thou_le := n_pers_pro_nom_lexent &
"""
Pronoun 'thou'                   
<ex>Thou must sleep.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                               PT std,
                               SORT entity ] ].

n_-_pr-thee_le := n_pers_pro_acc_lexent &
"""
Pronoun 'thee                    
<ex>B hired thee.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                               PT std,
                               SORT entity ] ].
; 'yours truly'
n_-_pr-1sg-na_le := personal_pro &
"""
Pronoun 'yours truly'            
<ex>Yours truly arrived.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     AGR.PNG png & [ PN 3s ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1s ],
				 DIV -,
                                 PT std ] ] ].

n_np_pr-us_le := norm_n_pers_pro_lexent &
"""
Pro with plur NP comp 'us'       
<ex>B saw us players.
"""
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL [ CAT [ HEAD.CASE non_nom,
			   VAL.SPR < [ --MIN no_rel ] > ],
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                                 PT std ] ] ].
            
n_np_pr-we_le := norm_n_pers_pro_lexent &
"""
Pro with plur NP comp 'we'       
<ex>We players arrived.
"""
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL [ CAT.HEAD.CASE nom,
                     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 1p ],
                                 PT std ] ] ].

n_np_pr-you_le := basic_n_pers_pro_lexent &
"""
Pro with plur NP comp 'you'      
<ex>You players arrived.
"""
  [ SYNSEM pro_wcomps_plur_synsem &
           [ LOCAL.CONT.HOOK.INDEX.SORT entity,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                                 PT std ] ] ].

n_nb_pr-you_le := basic_n_pers_pro_lexent &
"""
Pro with singular nbar comp 'you'      
<ex>Move, you scoundrel!
"""
  [ SYNSEM pro_wcomps_nbar_synsem &
           [ LOCAL.CONT.HOOK.INDEX.SORT entity,
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 2 ],
                                 PT std ] ] ].

n_np_pr-it_le := norm_n_pers_pro_lexent &
"""
Pro with NP comp 'it'            
<ex>It all was good.
"""
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.VAL.SPR < [ --MIN no_rel ]  >,
		     CONT.HOOK.INDEX.SORT entity ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s ],
				 DIV -,
                                 PT std ] ] ].
            
n_np_pr-they_lexent := norm_n_pers_pro_lexent &
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT.HEAD.CASE nom,
                     CONT.HOOK.INDEX [ SORT entity, IND + ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                                 PT std ] ] ].

n_np_pr-they_le := n_np_pr-they_lexent
"""
Pro with NP comp 'they'          
<ex>They all left.
"""
.
            
n_np_pr-them_le := norm_n_pers_pro_lexent &
"""
Pro with NP comp 'them'          
<ex>We hired them both.
"""
  [ SYNSEM pro_wcomps_synsem &
           [ LOCAL [ CAT [ HEAD.CASE non_nom,
			   VAL.SPR < [ --MIN no_rel ] > ],
                     CONT.HOOK.INDEX [ SORT entity, IND + ] ],
             LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3p ],
                                 PT std ] ] ].
            
basic_n_refl_pro_lexent := personal_pro &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE non_nom,
				MINORS.MIN refl_pron_rel ],
		     AGR #agr,
                     CONT.HOOK.INDEX #agr ],
             LKEYS.KEYREL [ PRED pron_rel,
                            ARG0 [ PT refl ] ] ] ].

n_refl_pro_lexent := basic_n_refl_pro_lexent &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT entity ].

n_-_pr-herself_le := n_refl_pro_lexent &
"""
Reflexive pro 'herself'          
<ex>She saw herself.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN fem ] ].

n_-_pr-himself_le := n_refl_pro_lexent &
"""
Reflexive pro 'himself'          
<ex>He saw himself.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN masc ] ].

n_-_pr-self_le := n_refl_pro_lexent &
"""
Reflexive pro 'him/herself'
<ex>Each student saw him/herself.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN animate ] ].

n_-_pr-itself_le := basic_n_refl_pro_lexent &
"""
Reflexive pro 'itself'           
<ex>It saw itself.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN neut ] ].

n_-_pr-myself_le := n_refl_pro_lexent &
"""
Reflexive pro 'myself'           
<ex>I saw myself.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 1s ] ].

n_-_pr-ourslves_le := n_refl_pro_lexent &
"""
Reflexive pro 'ourselves'        
<ex>We saw ourselves
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 1p ] ].

n_-_pr-themslves_le := n_refl_pro_lexent &
"""
Reflexive pro 'themselves'       
<ex>They saw themselves.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].

n_-_pr-themself_le := n_refl_pro_lexent &
"""
Reflexive pro 'themself': singular, masc/fem
<ex>Someone shaved themself..
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s,
                                         GEN andro ] ].

n_-_pr-yourself_le := n_refl_pro_lexent &
"""
Reflexive pro 'yourself'         
<ex>You saw yourself.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 2s ] ].

n_-_pr-yourslves_le := n_refl_pro_lexent &
"""
Reflexive pro 'yourselves'       
<ex>You saw yourselves.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 2p ] ].

n_-_pr-oneself_le := n_refl_pro_lexent &
"""
Reflexive pro 'oneself'          
<ex>One saw oneself.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s, GEN andro ] ].

; 'see it yourself!'
; DPF 25-aug-07 - Restricted MOD..HEAD to AUX - to avoid spurious ambiguity 
; for e.g. "He was hired himself."
;; DPF 2014-01-31 - The MOD..XARG ref-ind constraint is an imperfect attempt
;; to block obvious errors like **she tried to arrive himself*, but it is
;; overly strong in blocking *In Paris himself, Joe tasted the coffee*.  FIX
;; DPF 2015-03-12 - Changed MOD..SUBJ *synlist* to MOD..SPR < synsem_min, ...>,
;; in order to admit *we arose, said Kim happily*.  The problem was that 
;; adverbs demanded that the MOD target be [SUBJ *synlist*], while filler-hd 
;; required hd-dtr to be [SUBJ *anti_list*].
;; DPF 2020-04-15 - Re 25-aug-07: But this blocks 
;; *the cat, which itself was content, slept.* So remove.
;;
basic_adv_refl_pro_lexent := noncrs-hm &
  [ INFLECTD +,
    SYNSEM basic_int_adverb_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT adverbee_cat &
                                                 [ VAL [ SPR < synsem_min, ...>,
                                                         COMPS < > ] ],
						CONT.HOOK.XARG ref-ind &
						    [ PNG #png ] ],
                                        MODIFD.RPERIPH na_or_- ] >,
                           VAL [ SPR < anti_synsem >,
				 COMPS < > ] ],
                     CONT [ RELS <! #keyrel & 
				    [ PRED refl_mod_rel,
                                      ARG2 #inst ],
                                    #altkeyrel &
                                    [ LBL #prohand, 
                                      PRED pron_rel,
                                      ARG0 #inst & [ PT refl,
                                                     SORT entity,
						     PNG #png ] ],
				    #alt2keyrel &
                                    [ PRED pronoun_q_rel,
                                      RSTR #rhand,
                                      ARG0 #inst & ref-ind ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !>,
			    ICONS <! !> ] ],
	     LKEYS [ KEYREL #keyrel,
		     ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

adv_refl_pro_lexent := basic_adv_refl_pro_lexent &
  [ SYNSEM.LOCAL.CAT.POSTHD + ].

av_-_pr-herself_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>She did it herself.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN fem ] ].

av_-_pr-himself_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>He did it himself.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN masc ] ].

av_-_pr-self_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP, animate
<ex>Each one did it him/herself.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN animate ] ].

av_-_pr-itself_le := basic_adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>It did it itself.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN neut ] ].

av_-_pr-myself_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>I did it myself.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 1s ] ].

av_-_pr-ourslvs_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>We did it ourselves.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 1p ] ].

av_-_pr-thmslvs_le := basic_adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>They did it themselves.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3p ] ].

av_-_pr-themself_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>Someone did it themself.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s,
                                            GEN andro ] ].

av_-_pr-yrself_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>You did it yourself.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 2s ] ].

av_-_pr-yrslvs_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>You did it yourselves.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 2p ] ].

av_-_pr-oneself_le := adv_refl_pro_lexent &
"""
Refl pro modifier of VP          
<ex>One did it oneself.
"""
  [ SYNSEM.LKEYS.ALTKEYREL.ARG0.PNG png & [ PN 3s, GEN andro ] ].

n_-_pr-recip_le := np_word &
"""
Reciprocal pronoun               
<ex>We saw each other.
"""
  [ SYNSEM ref_pro_np_synsem &
	   [ LOCAL [ CAT [ HEAD [ CASE non_nom,
                                  MINORS.MIN recip_pro_rel ],
                           VAL.COMPS < > ],
                     AGR #ind,
                     CONT [ HOOK.INDEX #ind,
			    RELS <! [ LBL #prohand,
                                      PRED recip_pro_rel,
                                      ARG0.PT recip ],
				    #altkeyrel &
                                    [ PRED pronoun_q_rel,
                                      ARG0 #ind,
                                      RSTR #rhand ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL.ARG0.PNG png & [ PN pl ],
		     ALTKEYREL #altkeyrel ] ] ].

; 'yours'
; DPF 15-Apr-00 = Changed MIN to be pron_rel rather than pronoun_q_rel, since
; e.g. prepositions want a non_temp_nom_rel as their argument.
;; DPF 2014-04-10 - Changed MIN to from pron_rel to pron_nonlocal_rel so we
;; can get "We gave Kim ours."

n_poss_pro_lexent := noncrs-hm-nab & basic_pronoun_word &
  [ SYNSEM nomod_synsem &
	   [ LOCAL [ CAT [ HEAD partn & [ MINORS [ MIN pron_nonlocal_rel,
						   ALTMIN poss_rel ] ],
                           VAL [ COMPS < >,
				 SPR < anti_synsem_min & [ OPT - ] >,
				 SPEC < anti_synsem_min > ] ],
                     AGR #index,
		     CONT [ HOOK.INDEX #index,
			    RELS <! #keyrel & 
				     [ LBL #prohand,
                                       PRED pron_rel,
                                       ARG0 #pind & ref-ind &
                                           [ PT std,
                                             SORT entity ],
				       CFROM #from,
				       CTO #to ],
                                     [ PRED pronoun_q_rel,
                                       ARG0 #pind,
				       RSTR #rhand,
				       CFROM #from,
				       CTO #to ],
				     #alt2keyrel &
				     [ PRED def_implicit_q_rel,
                                       ARG0 #index & ref-ind,
				       RSTR #phand ],
                                     nom_relation &
                                     [ LBL #nhand,
                                       PRED generic_entity_rel,
                                       ARG0 #index,
				       CFROM #from,
				       CTO #to ],
                                     #altkeyrel & prep_relation &
				     [ LBL #nhand,
                                       PRED poss_rel,
                                       ARG0.E [ TENSE no_tense,
                                                ASPECT no_aspect ],
				       ARG1 #index,
				       ARG2 #pind ] !>,
			    HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ],
                                      qeq & [ HARG #phand,
                                              LARG #nhand ] !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel,
                     ALT2KEYREL #alt2keyrel ],
             NONLOC.QUE <! !>,
	     MODIFD notmod ] ].

n_-_pr-hers_le := n_poss_pro_lexent &
"""
Possessive pro 'hers'            
<ex>Hers arrived.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
                                                       GEN fem ] ].
n_-_pr-his_le := n_poss_pro_lexent &
"""
Possessive pro 'his'             
<ex>His arrived.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
                                                       GEN masc ] ].

n_-_pr-hers-his_le := n_poss_pro_lexent &
"""
Possessive pro 'hers/his'            
<ex>Hers/his arrived.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
                                                       GEN animate ] ].

;; DPF 24-apr-09 - Removed pronominal *its* since it is of dubious use and
;; leads to unwanted ambiguity.  FIX someday?
;;n_-_pr-its_le := n_poss_pro_lexent &
;; """
;; Possessive pro 'its'             
;; <ex>Its has arrived.
;; """
;;  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3s,
;;                                                       GEN neut ] ].

n_-_pr-mine_le := n_poss_pro_lexent &
"""
Possessive pro 'mine'            
<ex>Mine arrived.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1s ] ].

n_-_pr-ours_le := n_poss_pro_lexent &
"""
Possessive pro 'ours'            
<ex>Ours arrived.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 1p ] ].

n_-_pr-theirs_le := n_poss_pro_lexent &
"""
Possessive pro 'theirs'          
<ex>Theirs arrived.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 3p ] ].

n_-_pr-yours_le := n_poss_pro_lexent &
"""
Possessive pro 'yours'           
<ex>Yours arrived.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0.PNG png & [ PN 2 ] ].

; Expletive pronouns "there" and "it"
; DPF 3-Jul-02 - Changed MIN from no_rel to pron_rel, to allow simpler
; generalization about subjects of tag-phrases.  Still have empty RELS

norm_pronoun_word := noncqrs-m-nab & basic_pronoun_word.

n_-_pr-it-x_le := norm_pronoun_word &
"""
Expletive pro 'it'               
<ex>It rained.
"""
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     CONT [ HOOK.INDEX it-ind,
                            RELS <! !> ] ],
             LKEYS.KEYREL.PRED pron_rel,
	     MODIFD notmod ] ].

n_-_pr-there-x_le := norm_pronoun_word &
"""
Expletive pro 'there'            
<ex>There are cats here.
"""
  [ SYNSEM non_ref_pro_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN pron_rel,
                     CONT [ HOOK.INDEX there-ind,
                            RELS <! !> ] ],
             LKEYS.KEYREL.PRED pron_rel,
	     MODIFD notmod ] ].
			  

; ERB (31-10-96) A hack:  I want the wh_interrogs to be able to
; get their hands on the which_q_rel so they can put it on the PARAMS
; list, but QSTORE isn't working yet.  So I am making the QUE value
; of wh_pro_word, wh_adverb_word, and wh_poss_word be the handle of
; the which_q_rel, so that this gets passed up in such a way that I can see it.

; DPF (3-May-99) We can't just put the handle of the which_q_rel in QUE, since
; in coordinate structures like "which book and which record did sandy buy?"
; we want to unify the NONLOCs of "which book" and "which record", but this
; would mean that the handles of the two which_q_rel's would be wrongly 
; identified. 
; So for now I'm just putting in an unbound handle - we'll have to sort out
; with Ivan what the right solution is.
; DPF 16-jan-08 - Tried changing MIN from norm_nom_rel to pron_rel in order
; to block "*Who's cat", but this runs afoul of constraint on ditransitives
; like "show" to avoid "*he showed Browne it."  So find a better solution...
; FIX
; DPF 2010-08-31 - Changed [SPR anti_synsem_min]  to unexpressed since this 
; was blocking e.g. *who in this town ...*.  But note "Exactly who won?", so
; FIX to allow some limited range of specifiers.

; 'who, what'
n_wh_pro_lexent := que_word & basic_pronoun_word &
  [ SYNSEM ref_pro_synsem &
	 [ LOCAL [ CAT [ HEAD.MINORS.MIN pron_nonlocal_rel,
                         VAL [ SPR < unexpressed & 
				     [ OPT -,
				       --MIN deg_rel ] >,
			       COMPS < [ OPT +,
                                         --MIN wh_the_hell_rel,
                                         LOCAL [ CAT.HEAD wh_adv,
                                                 CONJ cnil ],
                                         PUNCT.LPUNCT no_punct ] > ] ],
                   AGR #index,
                   CONT [ HOOK [ INDEX #index,
                                 XARG #nhand ],
                          RELS <! [ LBL #nhand ],
				  #altkeyrel &
                                  [ PRED which_q_rel,
                                    ARG0 #index,
                                    RSTR #rhand ] !>,
			  HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !>,
			  ICONS <! !> ] ],
	   NONLOC.QUE 1-dlist &
		         [ LIST < param > ],
	   MODIFD notmod,
	   LKEYS.ALTKEYREL #altkeyrel ] ].

n_-_pr-wh_le := n_wh_pro_lexent &
"""
WH pro                           
<ex>B wondered what arrived.
"""
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT nominal-sort ].

n_-_pr-who_le := n_wh_pro_lexent &
"""
WH pro, singular                 
<ex>B wondered who arrives.
"""
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.PN 3s,
				   SORT human ] ].

n_-_pr-wh-acc_le := n_wh_pro_lexent &
"""
WH pro, acc case                 
<ex>B wondered whom to hire.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE non_nom,
		   CONT.HOOK.INDEX [ PNG.PN 3s,
				     SORT human ] ] ].

; DPF 2010-09-17 - Since n-adj-redrel rule now requires that the head have
; SPR value `synsem', change the SPR value here from anti_synsem_min to 
; unexpressed.
;; DPF 2013-10-16 - Added MODIFD lmod to prevent e.g. *blue which*
;; DPF 2014-04-03 - Re 2013-10-16: But this blocks *which on Tuesday arose*

basic_n_rel_pro_lexent := noncqs-hm & basic_pronoun_word & 
  [ SYNSEM pronominal_synsem &
	 [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN pronoun_q_rel,
			 VAL [ SUBJ < >,
			       SPR < unexpressed & 
				     [ OPT - ] >,
			       COMPS < > ] ],
                   AGR #index,
		   CONT [ HOOK [ LTOP #hand,
                                 INDEX #index & basic_non_expl,
                                 XARG #xarg ],
			  RELS <! !>,
			  HCONS <! !>,
			  ICONS <! !> ] ],
	   MODIFD.LPERIPH +,
           LKEYS [ KEYREL [ LBL #hand,
                            PRED no_rel ],
                   ALTKEYREL relation ],
           NONLOC.REL 1-dlist &
		         [ LIST < [ LTOP #hand,
				    INDEX #index,
                                    XARG #xarg ] > ] ] ].

n_rel_pro_lexent := basic_n_rel_pro_lexent &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN pron_nonlocal_rel,
			    MOD < > ] ].

n_-_pr-rel-who_le := n_rel_pro_lexent &
"""
Relative pro 'who'               
<ex>Kids who sang danced.
"""
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.SORT human ] ].

n_-_pr-rel-what_le := n_rel_pro_lexent &
"""
Relative pro 'what'              
<ex>Things what fell broke.
"""
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.SORT nominal-sort ] ].

; Not notmod to let us get "the day that I arrived"/"*the day which i arrived"

n_-_pr-rel-acc_le := n_rel_pro_lexent &
"""
Relative pro, acc case           
<ex>Kids to whom B spoke sang.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.CASE non_nom,
                     CONT.HOOK.INDEX.SORT human ] ] ].

n_-_pr-rel-pl_le := n_rel_pro_lexent &
"""
Relative pro, place NP           
<ex>the city from where we left
"""
  [ SYNSEM.LOCAL.CAT.HEAD.CASE non_nom ].

; Unmarked for MODIFD, so can undergo temp_np rule to get "the day that I
; arrived"  But to get this, also need to make SPR be non-empty, since the
; extracted-adj-temp rule only allows n-bar slashed elements.
; DPF 19-dec-03 - In fact, need two entries for 'that', since we want to
; allow "the place that Kim stood" but not "*the car that Kim stood" (cf
; "the car where Kim stood".  The one entry is the nbar-filler for the gap
; for the np_adv_c.
;; DPF 2012-03-14 - Should remind ourselves of where the [INFLECTD na] move
;; helps, since it means the rule for reduced-relatives has to allow the
;; head-dtr to be na_or_+, to get *the cat that on Tuesday was sick is happy*
;; DPF 2012-08-29 - Added LPERIPH + to avoid *true that* with aj-hdn_adjn_c rule
;; now that we have removed the spurious REL 0-dlist from isect_synsem.
;; DPF 2017-09-14 - Let's remove NORM no_rel for the moment, since it conflicts
;; with the mechanism for propagating the selected rel constraint needed in
;; *it was on Kim that we relied*.  FIX?
;;
n_-_pr-rel-nwh_le := basic_n_rel_pro_lexent &
"""
Relative pro, non-WH, only `that'
<ex>Things that fell broke.
"""
  [ INFLECTD na,
    SYNSEM.LOCAL [ CAT.HEAD [ MINORS [ MIN pron_nonlocal_rel ],
			      PRD -,
			      MOD < > ],
		   CONT.HOOK.INDEX.SORT nominal-sort ] ].

; DPF 28-Aug-99 - SPR..MIN no_rel prevents these from undergoing hdn_bnp_c rule
; DPF 09-Jan-00 - In fact, can now eliminate bogus SPR, since picking up
; post-head adjuncts as complements.
; DPF 06-May-03 - Removed COMPS..HEAD adj* restriction, since we need to have
; these guys pick up post-head PPs as complements so "anytime after three"
; can still be compatible with the npadv_mod rule's requirement that the dtr
; be [HODIFIED lmod], in order to get the desired analysis for "Kim arrived
; sometime after three".
; DPF 03-Dec-03 - But now getting posthead PPs as modifiers, so go back to
; only allowing adjectival complements.
; DPF 03-Dec-06 - Since also get modifier analysis for all phrases, restrict
; this complement to LEX +, to allow "anyone tall" which would not parse 
; with a modifier analysis.
;; DPF 2014-11-26 - Generalized ALTMIN nondef_explicit_q_rel to 
;; indef_or_udef_rel in order to also admit *nothing more*.
;; DPF 2018-03-17 - Re 2014-11-26: In face, identify ALTMIN with the quant_rel
;; of the altkeyrel.
;;
generic_pro_adv_word := que_word & basic_pronoun_word &
  [ SYNSEM np_synsem &
     [ LOCAL 
        [ CAT [ HEAD #head & 
                     [ MINORS.ALTMIN #altmin ],
                VAL [ SPR < [ --MIN degree_rel,
                              LOCAL [ CAT [ HEAD adv,
					    VAL.SPR *unexplist* ],
				      CONT.HOOK [ LTOP #khand,
						  XARG #inst ] ],
                              NONLOC [ QUE 0-dlist,
                                       REL 0-dlist ] ],
			    anti_synsem_min & [ OPT - ] >,
                      COMPS < [ OPT +,
                                LEX +,
                                LOCAL 
                                 [ CAT prd_cat & 
                                       [ HEAD v_or_a &
                                         [ MOD < synsem &
						 [ LOCAL.CAT.HEAD #head ] > ]],
                                   CONJ cnil,
                                   CONT.HOOK [ LTOP #nhand,
                                               XARG #inst ] ],
                                NONLOC non-local_none,
                                PUNCT.LPUNCT no_punct ] > ] ],
          CONT [ HOOK.LTOP #nhand,
                 RELS <! relation,
                         #altkeyrel & [ PRED quant_rel ] !>,
                 HCONS <! qeq &
                        [ HARG #rhand,
                          LARG #nhand ] !>,
		 ICONS <! !> ] ],
       LKEYS [ KEYREL [ LBL #nhand,
                        ARG0 #inst & [ PNG png & [ PN 3s ] ] ],
               ALTKEYREL #altkeyrel & 
                      [ LBL #khand,
			PRED #altmin,
                        ARG0 #inst,
                        RSTR #rhand ] ],
       NONLOC.QUE 0-dlist ] ].

;; DPF 2020-05-16 - With the changes to measure-NPs, add CASE real_case here
;; to prevent these from undergoing np_adv-mnp rule.
;;
n_-_pr-ad_le := generic_pro_adv_word &
"""
Lexical det-n, can modify        
<ex>B lives somewhere.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN modable_rel,
			      CASE real_case ],
		   CONT.HOOK.INDEX.SORT location ] ].

;; DPF 2017-03-01 - Removed last vestiges of SORT non-time-sort, generalizing
;; to basic-entity-or-event.
;;
n_generic_pro_lexent := generic_pro_adv_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.SORT basic-entity-or-event,
             MODIFD notmod ] ].

n_-_pr_le := n_generic_pro_lexent &
"""
Lexical det-n                    
<ex>Something fell.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_nom_rel ].
                     
; 'one'
; DPF 23-sept-04 - Curious note: If we don't make COMPS < anti_synsem_min >,
; then we get an asymmetry in how PET and the LKB process "one should": PET
; allows "one" to undergo hd_optcmp_c rule in addition to hdn_optcmp_c rule, even
; though hd_optcmp_c says head is MIN event_rel while 'one' says MIN is not
; (obviously) a subtype of event_rel.  FIX...
;; DPF 2011-08-29 - Re 23-sept-04: This asymmetry no longer appears, so 
;; removed this hack, to be consistent with treatment of optional nominal
;; complements.
;;
n_-_pr-one_le := n_generic_pro_lexent &
"""
Pronoun 'one'                    
<ex>One should sleep.
"""
  [ SYNSEM.LOCAL 
           [ CAT [ HEAD.MINORS.MIN norm_nom_rel,
                   VAL [ SPR.FIRST [ --MIN just_only_deg_rel ] ] ],
             CONT.HOOK.INDEX [ PNG.GEN andro,
			       SORT entity ] ] ].

n_deictic_pro_lexent := norm_pronoun_word &
  [ SYNSEM ref_pro_synsem &
    [ LOCAL 
      [ CAT [ HEAD.MINORS [ MIN generic_nom_rel,
                            ALTMIN demonstrative_q_rel ],
              VAL [ SPR < [ --MIN just_only_deg_rel,
                            LOCAL [ CAT.VAL.SPR *unexplist*,
				    CONT.HOOK.LTOP #khand ],
                            NONLOC [ QUE 0-dlist,
                                     REL 0-dlist ] ],
			  anti_synsem_min & [ OPT - ] >,
                    COMPS < [ LOCAL.CAT 
                             [ HEAD partn &
                                    [ MINORS [ MIN part_of_rel,
					       ALTMIN both_all_q_rel ] ],
                               VAL [ SPR < synsem &
					   [ LOCAL.CAT.HEAD adv ] >,
                                     COMPS < unexpressed &
                                             [ LOCAL 
                                               [ CAT nomp_cat_min,
                                                 CONT.HOOK.INDEX index,
                                                 AGR #index ],
					       OPT +,
                                               --SIND #index ] > ] ],
                              OPT +,
                              LEX +,
                              PUNCT.LPUNCT no_punct ] > ] ],
        CONT [ HOOK [ LTOP #nhand,
                      INDEX #index,
                      XARG #nhand ],
               RELS <! [ LBL #nhand,
                         PRED generic_entity_rel ], 
                     #altkeyrel &
                     [ LBL #khand,
                       PRED demonstrative_q_rel,
                       ARG0 #ind,
                       RSTR #rhand ] !>,
               HCONS <! qeq &
                      [ HARG #rhand,
                        LARG #hand ] !>,
	       ICONS <! !> ],
        AGR #index ],
      LKEYS [ KEYREL [ LBL #hand,
                       ARG0 #ind ],
              ALTKEYREL #altkeyrel ],
      MODIFD notmod ] ].

; 'those of us who ...'
n_pp_pr-dei-3pl_le := noncqrs-m-nab & basic_pronoun_word &
"""
Deictic pro, 'those of us who'   
<ex>Those of us who sang won.
"""
  [ SYNSEM ref_pro_synsem &
    [ LOCAL [ CAT [ HEAD.MINORS [ MIN generic_nom_rel,
                                  ALTMIN demonstrative_q_rel ],
                    VAL [ SPR < [ --MIN just_only_deg_rel,
                                  LOCAL [ CAT.VAL.SPR *unexplist*,
					  CONT.HOOK.LTOP #dhand ],
                                  NONLOC [ QUE 0-dlist,
                                           REL 0-dlist ] ],
				anti_synsem_min & [ OPT - ] >,
                          COMPS < [ --MIN _of_p_sel_rel,
                                    LOCAL [ CAT [ HEAD prep & 
                                                       [ PRD -,
                                                         TAM.TENSE nontense ],
                                                  VAL.COMPS < > ],
                                            CONT.HOOK.INDEX #pind ],
                                    OPT -,
                                    PUNCT.LPUNCT no_punct ] > ] ],
              CONT [ HOOK [ LTOP #hand,
                            INDEX #ind & [ PNG.PN 3p ],
                            XARG #hand ],
                     RELS <! #keyrel & 
                             [ LBL #hand,
                               PRED part_of_rel,
                               ARG0 #ind,
                               ARG1 #pind & non_expl-ind ], 
                             #altkeyrel &
                             [ LBL #dhand,
                               PRED _those_q_dem_rel,
                               ARG0 #ind,
                               RSTR #rhand ] !>,
                     HCONS <! qeq &
                              [ HARG #rhand,
                                LARG #hand ] !>,
		     ICONS <! !> ],
              AGR #ind ],
      LKEYS [ KEYREL #keyrel,
              ALTKEYREL #altkeyrel ],
      MODIFD notmod ] ].

; DPF 16-oct-03 - Added NORM norm_rel to prevent singular deictics from
; being modified, to get contrast of "*that he bought yesterday arrived" vs
; "those he bought yesterday arrived".
; DPF 19-dec-04 - But this also rules out relative clauses with "which", as
; in 'that which you need will be provided'.  Not clear how to exclude the
; thatless-relatives for singular deictics: odd constraint.  For now, remove
; the old constraint, and overgenerate the first example above.
; DFP 25-oct-05 - Since this overgeneration continues to be costly, we 
; distinguish singular from plural deictics in NORM, and constrain the
; fin_non_wh_rel_cl rule to require its MOD to be NORM norm_rel, so we
; block "*This he bought was nice" but admit "Those he bought were nice".

n_-_pr-dei-sg_le := n_deictic_pro_lexent &
"""
Deictic pro, sing                
<ex>This works.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM deictic_sg_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3s,
                                           GEN neut ] ] ].

n_-_pr-dei-pl_le := n_deictic_pro_lexent &
"""
Deictic pro, plur                
<ex>Those work.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Synsems for Auxiliary verb lexical rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ERB (05-10-97) Making this specific to question auxes.  See notes near sai
; in syntax.tdl.
; DPF 26-Jan-01 - Changed HEAD.INV + to HEAD.INV +* to allow for coordination
; of inverted and non-inverted sentences.  Prevent yes-no question rule from
; applying to main verbs by making inverted auxiliaries [MC na], so they have
; to undergo the yes-no rule.
; ERB (2003-10-13) Need a supertype to allow mal_sai_synsem: making
; basic_sai_synsem.

basic_sai_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD verb & [ INV +,
                                PRD - ],
                  VAL [ COMPS #comps & < [ NONLOC.SLASH 0-dlist ], ... >,
			SPCMPS < > ] ],
	    CONT.HOOK.INDEX event,
	    ARG-S #comps ] ].

sai_synsem := basic_sai_synsem &
  [ LOCAL.CAT [ HEAD [ AUX +,
		       TAM indic_tam,
		       MOD < [ --MIN no_rel,
			       LOCAL intersective_mod &
				     [ CAT.VAL.SPR *cons* ] ] > ],
		MC na,
		POSTHD + ] ].

; DPF 3-Jul-02 Changed to COMPS..MIN pron_rel from COMPS..ALTMIN no_rel,
; since common nouns are often unmarked for ALTMIN, and it was a hack.
; DPF 19-Oct-02 - Were using hack of SPEC < > to keep poss-pronouns like
; "mine" out of COMPS, but this also blocked "than mine", so instead use
; difference in ALTMIN for "she" and "hers".
; DPF 9-Feb-03 Changed HEAD value from 'verb' to 'tagaux' so bare tag
; questions don't show up as root clauses (we can't just make them MC -,
; since the MC of a head-mod phrase comes from the modifier daughter).
; DPF 20-apr-05 Since we now make lexical NPs by default have an ALTMIN
; of def_q_rel (but don't (yet) for possessive pronouns like 'mine'),
; changed ALTMIN on complement to def_q_rel.
;; DPF 2018-06-02 - Added LPERIPH na to prevent these from being modified by
;; vocatives, as in *he is [Browne isn't he]*
;;
tag_synsem := lex_synsem &
  [ LOCAL [ CAT [ HEAD tagaux &
		       [ AUX -,
			 INV -,
			 TAM indic_tam &
                             [ TENSE #tense ],
			 MOD < [ --MIN #min,
                                 LOCAL scopal_mod &
				       [ CAT s_cat_fin &
					     [ HEAD [ TAM.TENSE #tense,
						      INV - ],
                                               MC - ],
					 AGR.PNG #png & png,
					 CONT.HOOK.INDEX.E.TENSE real_tense ],
				 NONLOC [ SLASH 0-dlist,
                                          REL 0-dlist,
                                          QUE 0-dlist ],
                                 PUNCT.RPUNCT comma_or_no_punct ] >,
                         MINORS.MIN #min ],
		  POSTHD +,
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < [ OPT -,
				  LOCAL [ CAT.HEAD.MINORS 
                                                 [ MIN pron_rel,
                                                   ALTMIN def_q_rel ],
                                          AGR #tagagr ],
                                  --SIND.PNG #png,
                                  PUNCT.RPUNCT clause_or_no_punct & 
                                               [ PSF #sf ] ] >,
			SPCMPS < > ],
                  MC + ],
            CONT.HOOK.INDEX.SF #sf & prop-or-ques,
            AGR #tagagr ],
    MODIFD.LPERIPH na ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADJECTIVES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (See prep_synsem definition for discussion of ARG1 attribute.)

; Predicative adjectives used to introduce an ARG0 attribute in a separate 
; support relation, as did predicative PPs, but now each introduces its own
; ARG0 attribute directly in the MIN relation.

; Assume that if adjectives have a specifier, it will be either a measure-NP,
; as in "two feet tall', 'a week later"; or a degree_adverb like "very".

; Since most adjectives are underspecified for being predicative, we have to be
; sure that when they act as modifiers, the unexpressed subject's SLASH value 
; gets terminated (given lexical SLASH amalgamation).  We can't just make the
; adjective's SUBJ be 'unexpressed' since it must unify with the real subject
; in a raising construction.  So we identify the SLASH of the MOD value with
; that of the SUBJ - only one of the two will be realized syntactically.

; Most but not all adjectives can be modifiers, so the most basic adj_synsem
; type does not introduce the MOD feature, to allow for adjectives like
; "impossible" as in "it is impossible to find Kim".

;; DPF 3-Feb-01 - Removed SPR..COMPS *olist* to allow for equatives like
;; "as tall as you" where first "as" combines with "tall" and passes up its
;; as-complement.
;; DPF 5-Apr-01 - Added [LPERIPH na] to interact correctly with adj-head rule 
;; and noun-noun-cmpnd rule, to block "*towel rusty rack" - the adj-head rule 
;; makes its LPERIPH value that of the adjunct dtr, and the n-n-cmpnd rule 
;; blocks all but [LPERIPH -] head-dtr.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so adjs can
;; coordinate with VPs (which are necessarily SPR anti_synsem_min).

;; DPF 25-Sep-01 - Added AGR reentrancy with SUBJ's AGR, like with verbs, to
;; make sure modification works right in no_copula constructions as in "skies
;; light becoming dark.  But for now must also hardwire link between SUBJ's
;; AGR and INDEX, since the bare-np rule necessarily breaks this link to get
;; DIV right.  Sigh - this will break a few tag questions, as in
;; "Someone is happy, aren't they?"
;; DPF 14-Oct-03 - Changed LPERIPH value from na to + since we want "same day"
;; to be LPERIPH +, not na.  Needed in particular for tempnp rule as in
;; 'Kim arrived the same day' since it requires the NP to be modified and
;; LPERIPH +.
;; DPF 22-Nov-03 - But now make LPERIPH bool since we need "annual report"
;; to be compatible with LPERIPH na_or_- in order to get "IBM annual report"
;; DPF 24-aug-06 - Moved LPERIPH bool down to subtypes, since want to make
;; comparative "more" be LPERIPH na, to prevent further modification as in
;; "*happy more cats"
;; DPF 2010-08-21 - Added INDEX non_conj_sement to ensure that right-node-raise
;; rule does not apply to non-conjoined adjectives.  (Without this constraint,
;; RNR applied in *sequences are the same in every person*).

basic_adj_synsem_lex_or_phrase := canonical_lex_or_phrase_synsem &
  [ LOCAL [ AGR #agr,
            CAT [ HEAD [ MINORS.MIN basic_adj_rel ],
		  VAL [ SUBJ < >,
			SPCMPS < > ] ],
            CONT.HOOK [ INDEX non_conj_sement,
			XARG #agr ] ] ].

; CSY 13-8-2020 - add in this new type of synsem which does not have the SUBJ < > feature
; this should allow the adjective to take subjects for adj headed sentences
basic_nocop_adj_synsem_lex_or_phrase := canonical_lex_or_phrase_synsem &
  [ LOCAL [ AGR #agr,
            CAT [ HEAD [ MINORS.MIN basic_adj_rel ],
		  VAL [ SPCMPS < > ] ],
            CONT.HOOK [ INDEX non_conj_sement,
			XARG #agr ] ] ].


; DPF 2-Jun-02 - Added HS-LEX -* since now want to distinguish head-spec
; phrases like det-n (which are phrasal) from deg-adj ones (still lexical).
; DPF 8-Jun-03 -Added SPR..LEX + to block "Kim is as as Sandy tall" but allow
; "Kim is as tall as Sandy"
; DPF 11-Sep-03 - But this prevents measure-phrase specifiers, so remove, and
; look for an alternative to block above.  **FIX**
; DPF 21-oct-03 - Fixed, since MNPs are now LEX +.
; DPF 19-aug-04 - But then we block "the structures forty feet tall" (along
; with "*the structures very tall").  So we'll try making the HS-LEX value
; be constrained by the specifier, and adjust the relevant head_spec rule
; accordingly.
; DPF 03-sept-09 - Added surprising anti_synsem_min to SPR list, since we want
; PPs to modify N-bars (but not NPs) as well as VPs and APs, and this Nbar-NP
; contrast is made by requiring the SPR to be non-empty.  But after an adj
; has picked up a degree specifier, as in "too angry", we have to make sure it
; still has a non-empty SPR, in order to get e.g. "Kim was too angry in Paris"

basic_adj_abstr_lex_synsem := basic_adj_synsem_lex_or_phrase & 
                              abstr_lex_synsem.

basic_adj_lex_synsem := basic_adj_abstr_lex_synsem &
"""
CSY 21-8-2020 - removed MC na, to have it underspec
"""
  [ LOCAL [ ARG-S < #spr . #comps >,
            CAT [ HEAD adj_or_intadj,
                  VAL [ SPR 
                        < #spr & synsem_min &
                          [ --MIN degree_rel,
                            LOCAL
                            [ CAT [ VAL [ SPR *olist*,
                                          SPEC < [ LOCAL.CAT.HS-LEX #hslex ]>]],
                              CONT.HOOK.LTOP #ltop ],
                            NONLOC.SLASH 0-dlist ],
			  anti_synsem_min &
			  [ --MIN degree_rel ] >,
                        COMPS #comps ],
                  HS-LEX #hslex ],
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

; CSY 13-9-2020 - version that does not inherit SUBJ < >
; CSY 16-9-2020 - removed the SPR portion (trial) to try to solve sb-hd_mc_c 
basic_nocop_adj_lex_synsem := basic_nocop_adj_synsem_lex_or_phrase & abstr_lex_synsem &
  [ LOCAL [ ARG-S < #spr . #comps >,
            CAT [ HEAD adj_or_intadj,
                  VAL [ SPR < #spr >,
			COMPS #comps ],
                  HS-LEX #hslex ],
            CONT.RELS.LIST < #keyrel, ... > ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop ] ].

basic_adj_synsem := basic_adj_lex_synsem &
  [ MODIFD.LPERIPH bool,
    LOCAL [ CAT [ HEAD adj_or_intadj &
		       [ MINORS.ALTMIN #altmin,
			 TAM #tam ],
		  VAL.SPR.FIRST [ LOCAL.CAT.HEAD.MINORS.ALTMIN #altmin ] ],
	    CONT.HOOK.INDEX.E #tam ] ].

;CSY 13-9-2020 - does not inherit SUBJ < >
basic_nocop_adj_synsem := basic_nocop_adj_lex_synsem &
  [ MODIFD.LPERIPH bool,
    LOCAL [ CAT [ HEAD adj_or_intadj &
		       [ MINORS.ALTMIN #altmin,
			 TAM #tam ],
		  VAL.SPR.FIRST [ LOCAL.CAT.HEAD.MINORS.ALTMIN #altmin ] ],
	    CONT.HOOK.INDEX.E #tam ] ].

norm_adj_lex_synsem := basic_adj_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adj,
                  VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #arg0 ],
            CONT.HOOK.INDEX #arg0 ],
    LKEYS.KEYREL.ARG0 #arg0 & non_conj_event ].

;; DPF 2015-09-02 - Analogous to the introduction of the derived_verb_synsem,
;; add this one to avoid spurious interaction among derivational lexical rules
;; for adjectives, such as *un-* prefix rule plus attributive-adj rule.
;; DPF 2016-02-15 - Added ALTMIN no_rel to block applic of partitive rule for
;; integers/comparatives, to avoid *unchanged arose*
;; DPF 2016-02-29 - But this blocks degree specification as in *very unhappy*,
;; So instead specialize HEAD value from basic_adj to adj, excluding intadj
;; so the partitive rule cannot apply (as should have been done in the first
;; place).
;;
derived_adj_synsem := norm_adj_lex_synsem & adj_synsem_lex_or_phrase &
  [ LOCAL [ CAT.HEAD adj & [ TAM #tam,
			     MOD.FIRST.LOCAL intersective_mod ],
	    CONT.HOOK.INDEX.E #tam ] ].

;; We assume for now, counterfactually, that all modifying adjectives are
;; intersective.

;; ERB (03-02-98) Maybe should add MOD < [ LOCAL.SPR.OPT ] > - to keep 
;; adjectives from modifying partitives.

;; DPF (16-Feb-98) Made XARG be 'ref-ind' rather than non_expl-ind,
;; to ensure that it gets discourse-bound if the adjective is used in a 
;; fragment.

;; DPF (12-Jul-98) Constrain adjectives to only modify nominals with obligatory
;; specifiers (which distinguishes "common" from "proper" nominals).
;; DPF 9-oct-05 - Try constraining the MOD..MIN to nonpro_rel to block
;; modification of number-nouns ("*old one arrives"), analogous to blocking
;; in n-n compounds.
;; DPF 5-oct-06 - But this conflicts now with making 'group' nouns propagate
;; the MIN of their complement's NP.  And the combination of adj+numnoun is
;; not really out: "Unlucky 13 is often avoided".  So let's take the hit in
;; added ambiguity.
;; DPF 31-jul-07 - Removed mysterious [MOD..OPT -], which was surely not right.
;; DPF 2014-04-03 - Re 5-oct-06: But we still don't want *blue which*, so let's
;; try excluding pronoun_q_rel on the MOD.
;;
adj_synsem_lex_or_phrase := basic_adj_synsem_lex_or_phrase &
"""
CSY 21-8-2020 - removed MC na to allow for adj to head sentence
"""
  [ LOCAL [ CAT.HEAD.MOD
             < synsem_min &
               [ LOCAL [ CAT [ HEAD basic_nom_or_ttl &
                                    [ POSS -,
				      MINORS.ALTMIN non_pronoun_q_or_no_rel ],
                               VAL [ SUBJ < >,
                                     SPR.FIRST synsem & 
					  [ --MIN quant_or_deg_rel ],
                                     COMPS < > ]],
                         CONJ cnil ],
                 --SIND #ind ] >,
            CONT.HOOK.XARG #ind ] ].

;CSY 13-9-2020 - does not inherit SUBJ < >
adj_nocop_synsem_lex_or_phrase := basic_nocop_adj_synsem_lex_or_phrase &
"""
CSY 21-8-2020 - removed MC na to allow for adj to head sentence
"""
  [ LOCAL [ CAT.HEAD.MOD
             < synsem_min &
               [ LOCAL [ CAT [ HEAD basic_nom_or_ttl &
                                    [ POSS -,
				      MINORS.ALTMIN non_pronoun_q_or_no_rel ],
                               VAL [ SUBJ < >,
                                     SPR.FIRST synsem & 
					  [ --MIN quant_or_deg_rel ],
                                     COMPS < > ],
			       MC + ],
                         CONJ cnil ],
                 --SIND #ind ] >,
            CONT.HOOK.XARG #ind ] ].


norm_adj_synsem := adj_synsem_lex_or_phrase &
  [ LOCAL [ CAT.HEAD.TAM #tam,
	    CONT.HOOK [ INDEX non_conj_event & [ E #tam ],
			XARG basic_non_expl ] ] ].

;CSY 13-9-2020 - does not inherit SUBJ < >
norm_nocop_adj_synsem := adj_nocop_synsem_lex_or_phrase &
  [ LOCAL [ CAT.HEAD.TAM #tam,
	    CONT.HOOK [ INDEX non_conj_event & [ E #tam ],
			XARG basic_non_expl ] ] ].


adj_synsem := norm_adj_lex_synsem & norm_adj_synsem & isect_synsem.
adj_onearg_lex_synsem := norm_adj_lex_synsem & isect_synsem & one_arg &
  [ LOCAL.CONT.HOOK.XARG basic_non_event ].
adj_twoarg_lex_synsem := norm_adj_lex_synsem & isect_synsem & two_arg.
basic_adj_onearg_synsem := basic_adj_synsem & one_arg &
  [ LOCAL.CAT [ HEAD adj,
                VAL.COMPS < > ] ].
adj_twoarg_synsem := adj_synsem & two_arg.

; For comparatives and other semantically complex adjectives with new INDEX
basic_adj_unsp_ind_synsem := basic_adj_lex_synsem &
			     adj_synsem_lex_or_phrase & isect_synsem.

adj_unsp_ind_synsem := basic_adj_unsp_ind_synsem & lex_synsem.

adj_unsp_ind_onearg_synsem := adj_unsp_ind_synsem & one_arg &
  [ LOCAL.CAT [ VAL.COMPS < > ] ].
adj_unsp_ind_twoarg_synsem := adj_unsp_ind_synsem & two_arg.

;; DPF 2015-09-16 - Generalized SPR's MIN to allow `much' alongside 'very'
;; for deverbal adjectives, so we can admit *the much admired cat* alongside
;; *the very respected teacher*.
;; DPF 2016-10-06 - Removed the requirement that the MOD element be of type
;; `synsem' since this runs afoul of the constraint added 29-apr-07 to the
;; type `extracted_adj_int_vp_phrase', which wants its MOD to be compatible
;; with *anti_list*.  Should be okay, but monitor and maybe FIX?
;;
basic_adj_synsem_constr := norm_adj_synsem &
  [ LOCAL [ CAT [ HEAD adj &
		       [ MOD < [ LOCAL intersective_mod,
				 NONLOC.REL 0-dlist ] >,
			 MINORS [ MIN norm_adj_rel,
				  NORM norm_rel ] ],
		  VAL [ SPR < [ --MIN much_or_more_or_very_deg_rel,
				LOCAL [ CAT [ HS-LEX #hslx,
					      VAL.SPR *unexplist* ] ],
				LEX + ], 
			      anti_synsem_min >,
			SPEC < > ],
		  HS-LEX #hslx ] ],
    NONLOC non-local_none ].

adj_synsem_constr := basic_adj_synsem_constr &
  [ LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK [ LTOP #hand,
						XARG #index ],
	    CONT [ HOOK [ LTOP #hand,
			  INDEX #index ],
		   RELS.LIST.FIRST.LBL #hand ] ] ].

adj_synsem_lex_constr := basic_adj_synsem_constr & basic_adj_synsem &
			 basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adj,
                  VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #arg0 ],
            CONT.HOOK.INDEX #arg0 ],
    LKEYS.KEYREL.ARG0 #arg0 & non_conj_event ].

adj_synsem_lex_rule := basic_adj_synsem_constr & abstr_lex_synsem.

; 'cat-like', `two-dimensional'
;
adj_synsem_n_spr := basic_adj_abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD adj &
		       [ MOD < synsem &
			       [ LOCAL intersective_mod &
				       [ AGR #ind,
					 CAT [ HEAD basic_nom_or_ttl &
						    [ POSS - ],
					       VAL [ SUBJ < >,
						     SPR < synsem & 
						       [ --MIN 
							 quant_or_deg_rel ] >,
						     COMPS < >,
						     SPCMPS < > ],
					       MC na ] ],
				 NONLOC.REL 0-dlist,
				 --SIND #ind ] >,
			 TAM #tam,
			 MINORS [ MIN norm_adj_rel,
				  NORM norm_rel ] ],
		  VAL [ SPR < [ LOCAL [ CAT [ HEAD noun,
					      VAL [ SPR < synsem_min >,
						    COMPS < > ] ],
					CONT.HOOK [ LTOP #nhand,
						    INDEX #nind ] ],
				PUNCT.RPUNCT hyphen_sgl_or_no_punct,
				MODIFD notmod,
				OPT -,
				LEX + ],
			      [ --MIN more_or_very_deg_rel,
				LOCAL [ CAT [ VAL [ SPR *olist*,
						    SPEC < [ LOCAL.CAT.HS-LEX 
							 	     #hslex ] >,
						    COMPS < > ],
					      MC na ],
					CONT.HOOK.LTOP #hand ],
				NONLOC.SLASH 0-dlist,
				OPT + ] >,
			COMPS < >,
			SPEC < > ],
		  HS-LEX #hslex ],
	    CONT [ HOOK [ LTOP #hand,
			  INDEX.E #tam,
			  XARG #ind ],
		   RELS <! #keyrel &
			   [ LBL #hand,
			     ARG1 #ind,
			     ARG2 #nind ],
			   #altkeyrel &
			   [ PRED udef_q_rel,
			     ARG0 #nind & ref-ind,
			     RSTR #rhand ] !>,
		   HCONS <! qeq &
                           [ HARG #rhand,
                             LARG #nhand ] !>,
		   ICONS <! !> ] ],
    NONLOC non-local_none,
    MODIFD notmod,
    LKEYS [ KEYREL #keyrel,
	    ALTKEYREL #altkeyrel ] ].

;nomod_adj_synsem := norm_adj_lex_synsem &
;  [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD no_head ] > ].

nomod_adj_synsem := norm_adj_lex_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL intersective_mod &
				 [ CAT.HEAD noun &
					    [ MINORS.MIN no_rel ] ] ] > ].

nonprd_synsem := lex_synsem &
  [ LOCAL.CAT.HEAD.PRD - ].

prd_synsem := lex_synsem &
  [ LOCAL [ CAT.HEAD.PRD + ] ].

intrans_adj_synsem := adj_synsem & one_arg &
  [ LOCAL.CAT [ HEAD.MINORS.MIN abstr_adj_rel,
                VAL.COMPS < > ] ].

;; DPF 2017-08-20 - To avoid spurious order of application of attr-adj rule and
;; adj prefix rules (as for *unconscious*), this type should not unify with
;; abstr_lex_synsem -- see comment 2016-10-11 for adj_prefix_rule.  So remove,
;; but then need to ensure that LKEYS is still available -- see comment
;; 2016-11-07 for basic_lex_rule_supermost
;;
attr_adj_constr_synsem := adj_synsem_lex_or_phrase & one_arg & 
			  abstr_lex_or_deriv_synsem &
  [ LOCAL 
    [ CAT [ HEAD adj_or_intadj &
		 [ MINORS [ MIN abstr_adj_rel,
			    ALTMIN #altmin ],
		   TAM #tam,
		   PRD -,
		   MOD < [ LOCAL intersective_mod ] > ],
	    VAL [ COMPS < >,
		  SPR < #spr & 
			[ LOCAL 
			  [ CAT [ HEAD.MINORS.ALTMIN #altmin,
				  VAL [ SPR *olist*,
					SPEC < [ LOCAL.CAT.HS-LEX #hslex ] > ],
				  MC na ],
			    CONT.HOOK.LTOP #ltop ],
			  NONLOC.SLASH 0-dlist,
			  OPT + ],
			anti_synsem_min & [ --MIN degree_rel ] >,
		  COMPS #comps ],
	    HS-LEX #hslex,
	    POSTHD - ],
      CONT [ HOOK [ LTOP #ltop,
		    INDEX.E #tam,
		    XARG basic_non_expl ],
	     RELS.LIST < [ LBL #ltop ], ... > ],
      ARG-S < #spr . #comps > ],
    MODIFD.LPERIPH bool,
    NONLOC.REL 0-dlist ].

basic_attr_adj_synsem := intrans_adj_synsem & nonprd_synsem &
  [ LOCAL.CAT.POSTHD -,
    NONLOC.REL 0-dlist ].

; DPF 27-nov-04 - Block SPR for these, to avoid e.g. "*a very mere child"
attr_adj_synsem := basic_attr_adj_synsem &
  [ LOCAL [ CAT [ HEAD adj & [ MOD < [ --SIND #ind ] > ],
                  VAL.SPR.FIRST anti_synsem_min ],
            CONT.HOOK.XARG #ind ],
    NONLOC.QUE 0-dlist,
    LKEYS.KEYREL.ARG1 #ind & basic_non_expl-ind ].

;; DPF 2016-10-22 - Pushed identity of SPR..XARG and CONT..INDEX down to
;; subtypes, since one of them (trans_adj_pred_three_arg_synsem) is used in
;; comparative adjectives, and identfiies SPR..XARG with something other than 
;; CONT..INDEX, in order to get the desired semantics for 
;; *much closer (to X) (than Y)*,  where the much_deg takes as its argument 
;; the comp_rel's ARG0, not that of _close_j_rel.
;;
basic_pred_adj_synsem := basic_adj_unsp_ind_synsem &

  [ LOCAL [ CAT [ HEAD adj &
		       [ MINORS.ALTMIN #altmin,
			 PRD + ],
		  VAL.SPR.FIRST.LOCAL [ CAT.HEAD.MINORS.ALTMIN #altmin ],
		  POSTHD + ] ],
    MODIFD.LPERIPH bool ].

pred_adj_synsem := basic_pred_adj_synsem & adj_unsp_ind_synsem & prd_synsem.

; Not marked for LEX
;; DPF 2017-08-20 - Removed SPR..ALTMIN abstr_meas_nom_rel because it blocks
;; *most exciting* and we're reluctant to add this type as a supertype of
;; comp_or_superl_rel (already did add it for comp_rel, but undoing this too,
;; since demanding that the spr's ALTMIN be a subtype of nom_rel seems wrong.
;; Let's remind ourselves what work this was doing, and maybe FIX.
;;
intrans_pred_adj_synsem := basic_adj_synsem & one_arg & isect_synsem &
                           norm_adj_synsem & basic_lex_synsem &
"""
CSY 31-08-2020 - added in MC +
because predicative adjectives inherit from it
CSY 19-9-2020 - removed MC + because it does not help it head sentences
"""
  [ LOCAL [ CAT [ HEAD adj &
                       [ PRD +,
                         MOD < [ --SIND #ind & non_expl-ind ] >,
                         MINORS.MIN adj_rel ],
                  VAL [ SPR.FIRST.LOCAL [ CAT.HEAD n_or_adv,
					  CONT.HOOK.XARG #arg0 ],
			COMPS < > ] ],
            CONT [ HOOK [ INDEX #arg0,
			  XARG #ind ],
                   RELS <! relation !> ] ],
    LKEYS.KEYREL.ARG1 #ind ].

; CSY 13-08-2020 - to try to get find the source of the SUBJ dagify error
; changed PRED to -
intrans_nocop_pred_adj_synsem := basic_nocop_adj_synsem & one_arg & isect_synsem &
                            norm_nocop_adj_synsem & basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD adj &
                       [ PRD -,
                         MOD < [ --SIND #ind & non_expl-ind ] >,
                         MINORS.MIN adj_rel ],
                  VAL [ SPR.FIRST.LOCAL [ CAT.HEAD n_or_adv,
					  CONT.HOOK.XARG #arg0 ],
			COMPS < > ] ],
            CONT [ HOOK [ INDEX #arg0,
			  XARG #ind ],
                   RELS <! relation !> ] ],
    LKEYS.KEYREL.ARG1 #ind ].

;;; We should have a trans_adj_attr_synsem too, for 'easy' and the likes ...

pred_adj_two_arg_synsem := pred_adj_synsem & two_arg &
  [ LOCAL [ CAT.VAL [ COMPS < [ PUNCT.LPUNCT no_punct ] >,
		      SPR.FIRST.LOCAL.CONT.HOOK.XARG #xarg ],
            CONT.HOOK [ INDEX #xarg,
			XARG #ind & basic_non_expl ] ],
    LKEYS.KEYREL.ARG1 #ind ].

;; DPF 2018-03-07 - Removed canonical_or_unexpressed constraint on first comp,
;; since we want *cats of which we were afraid arrived*
;; DPF 2020-04-01 - Also pushed COMPS..INDEX non_expl-ind down, so we can
;; get *short of crazy*
;;
basic_trans_adj_pred_synsem := basic_pred_adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ --MIN #cmin,
                              LOCAL [ CAT basic_pp_cat,
                                      CONJ cnil,
				      CONT.HOOK [ LTOP #ltop,
						  INDEX #ind ] ],
			      PUNCT.LPUNCT no_punct ], ... >,
            CONT.HOOK [ LTOP #ltop,
			XARG #xind & basic_non_expl ] ],
    LKEYS [ KEYREL [ ARG1 #xind,
		     ARG2 #ind ],
            --COMPKEY #cmin ] ].

trans_adj_pred_synsem := basic_trans_adj_pred_synsem & pred_adj_synsem &
  [ LOCAL.CAT.VAL.COMPS.FIRST.--SIND non_expl-ind ].

trans_adj_pred_two_arg_synsem := trans_adj_pred_synsem & adj_synsem &
				 two_arg &
  [ LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #xarg,
	    CONT.HOOK.INDEX #xarg ] ].

trans_adj_pred_three_arg_synsem := trans_adj_pred_synsem & three_arg &
				   norm_adj_synsem & basic_adj_synsem.

;; DPF 2016-10-07 - Added type not marked for LEX, to allow *rooms available*.
;; This means copying constraints from types such as two_arg and
;; norm_adj_lex_synsem, to overcome the default LEX +.
;;
trans_adj_pred_two_arg_nolex_synsem := basic_trans_adj_pred_synsem & 
				       basic_adj_synsem & basic_two_arg &
				       norm_adj_synsem &
  [ LOCAL [ CAT [ HEAD basic_adj,
                  VAL [ SPR.FIRST.LOCAL.CONT.HOOK.XARG #arg0,
			COMPS.FIRST.--SIND non_expl-ind ] ],
            CONT [ HOOK.INDEX #arg0,
		   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL.ARG0 #arg0 & non_conj_event ].

; For adjectives like "accessible (by car)" which take a contentful PP compl.
trans_adj_pp_ind_synsem := pred_adj_two_arg_synsem & adj_synsem &
  [ LOCAL [ CAT.VAL.COMPS < canonical_or_unexpressed &
			    [ --MIN #cmin & independent_rel,
                              LOCAL [ CAT basic_pp_cat & [ HEAD.PRD + ],
                                      CONJ cnil,
				      CONT.HOOK [ LTOP #ltop,
                                                  XARG #ind &
                                                        non_expl-ind ] ] ] >,
            CONT.HOOK.LTOP #ltop ],
    LKEYS [ KEYREL.ARG2 #ind,
            --COMPKEY #cmin ] ].

irreg_trans_adj_pred_synsem := pred_adj_two_arg_synsem & adj_synsem &
  [ LOCAL.CAT.VAL.COMPS < synsem &
                          [ --MIN nom_rel & #cmin,
                            LOCAL [ CAT np_cat_acc_min,
                                    CONT.HOOK.INDEX non_expl-ind ] ] >,
    LKEYS.--COMPKEY #cmin ].

aj_np_i_lexent := reg_adj_word &
  [ SYNSEM irreg_trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [ --SIND #index & [ SORT entity ],
				       OPT - ] >,
		     CONT.RELS <! [ ARG2 #index ] !> ] ] ].

; 'worth the price'
aj_np_i_le := aj_np_i_lexent
"""
Adj, NP comp                     
<ex>B isn't worth the effort.
"""
.


; "arr.": "Plane arr. 10:40."
aj_np_i-unsp_le := reg_adj_word &
"""
Adj, NP comp, unspec: *arr.*     
<ex>Plane arr. 10:40.       
"""
  [ SYNSEM irreg_trans_adj_pred_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < canonical_or_unexpressed &
				     [ --SIND #index,
				       OPT - ] >,
		     CONT.RELS <! [ ARG2 #index ] !> ] ] ].

; 'how much is it worth?'
aj_np_gap_le := reg_adj_word &
"""
Adj, only 'worth' with gap       
<ex>B saw how much it is worth
"""
  [ SYNSEM adj_synsem &
	   [ LOCAL [ CAT [ HEAD.PRD +,
                           VAL.COMPS < > ],
		     CONT [ RELS <! [ ARG2 #index ] !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             NONLOC [ SLASH 1-dlist &
                            <! [ CAT np_cat_acc_min &
                                     [ HEAD.MINORS.MIN reg_nom_rel ],
                                 CONT.HOOK.INDEX #index ] !>,
                      REL 0-dlist,
                      QUE 0-dlist ] ] ].

; e.g. 'able' - Can't use equi_intrans_lt since it specifies an arg12_rel, 
; which is incompatible with adj_rel.  

basic_adj_vpcomp_synsem := pred_adj_synsem & basic_inf_or_prp_intrans_subst &
                           basic_two_arg & norm_adj_lex_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN adj_rel,
		  VAL [ COMPS < canonical_or_unexpressed &
			    [ LOCAL.CAT.VAL.SUBJ < synsem & 
						   [ NONLOC.SLASH 0-dlist ] >,
                              OPT -,
                              PUNCT.LPUNCT no_punct ] >,
			SPR.FIRST.LOCAL.CONT.HOOK.XARG #xarg ] ],
	    CONT.HOOK.INDEX #xarg ] ].

basic_adj_equi_synsem := basic_adj_vpcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #subjind ] >,
            CONT.HOOK.XARG #subjind & non_expl ],
    LKEYS.KEYREL adj_arg12_relation &
                   [ ARG1 #subjind ] ].

reg_adj_equi_synsem := basic_adj_equi_synsem & basic_inf_intrans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT [ HOOK.LTOP #vhand ] ] >,
            CONT [ RELS <! relation !>,
                   HCONS <! qeq & [ HARG #hand,
                                    LARG #vhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL.ARG2 handle & #hand ].

adj_vpcomp_prp_synsem := basic_adj_vpcomp_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.VFORM prp,
                                      CONT.HOOK.LTOP #hand ] ] >,
            CONT [ RELS <! relation !>,
                   HCONS <! qeq & [ HARG #chand,
                                    LARG #hand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL.ARG2 handle & #chand ].

; 'done working'
adj_equi_prp_synsem := adj_vpcomp_prp_synsem & basic_adj_equi_synsem.

; 'it is worth reading that book'
adj_atrans_prp_synsem := adj_vpcomp_prp_synsem &
  [ LOCAL.CONT.HOOK.XARG it-ind,
    LKEYS.--+ARGIND it-ind ].

adj_ssr_synsem := basic_adj_vpcomp_synsem & basic_inf_intrans_subst &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #cltop,
						XARG #subjind ] ] >,
            CONT [ HOOK.XARG #subjind,
		   RELS <! #keyrel !>,
		   HCONS <! qeq & [ HARG #arg1, LARG #cltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL adj_arg1_relation & #keyrel &
                   [ ARG1 #arg1 ] ].

;; DPF 18-jul-10 - Don't want to inherit from prd_synsem, since this prevents
;; e.g *tough problem to solve*.  Likewise for basic_adj_atrans_synsem.  So
;; push this down to subtypes like for *pretty*, which do inherit PRD +.
;;
scoping_adj_synsem := norm_adj_lex_synsem & isect_synsem &
  [ LOCAL.CAT [ HEAD.MINORS [ MIN adj_rel,
                              ALTMIN norm_rel ],
                VAL.KCMP [ PUNCT.LPUNCT no_punct,
			   OPT - ] ] ].

;; DPF 2018-09-12 - Allow VP complement to be extracted, so we can get RNR for
;; *it will be [difficult but important] to talk to Kim*
;;
basic_basic_adj_atrans_synsem := basic_adj_synsem & basic_pp_vp_subst & 
				 lex_synsem &
  [ LOCAL 
    [ CAT [ HEAD.MINORS [ MIN adj_rel,
                          ALTMIN norm_rel ],
            VAL [ COMPS < canonical_or_unexpressed &
			  [ --MIN selected_rel & #cmin,
                            LOCAL.CONT.HOOK [ LTOP #ahand,
                                              INDEX #expr & non_expl-ind ] ],
                          #comp &
                          [ LOCAL 
                             [ CAT [ HEAD.VFORM inf_or_prp,
				     VAL.SUBJ < synsem & 
						[ NONLOC.SLASH 0-dlist ] > ],
			       CONT.HOOK [ INDEX.E.TENSE no_tense,
					   XARG #expr ] ],
                            PUNCT.LPUNCT no_punct,
                            OPT - ], ... >,
                  KCMP #comp ] ] ],
    LKEYS [ KEYREL it_adj_arg12_relation &
                   [ LBL #ahand,
                     ARG2 #expr ],
            --COMPKEY #cmin ] ].

basic_adj_atrans_synsem := basic_basic_adj_atrans_synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [] > ].

;; Used by tough-adj lexical rule to avoid recursion.
norm_adj_atrans_synsem := basic_basic_adj_atrans_synsem.

; DPF 30-aug-04 - Generalize to take either inf or prp VP complements, as in
; 'it is tough climbing that hill' or 'it is tough to climb that hill'
;; DPF 2018-06-02 - Removed [--+ARGIND it-ind], since we want these even if
;; there is no expletive, when they have undergone the `tough-adj' lexical rule
;; which produces an entry with a non-expletive subject.
;; 
reg_adj_atrans_synsem := basic_adj_atrans_synsem & basic_three_arg & prd_synsem
			 & nomod_adj_synsem & norm_adj_atrans_synsem &
  [ LOCAL [ CAT.VAL.KCMP.LOCAL.CONT.HOOK.LTOP #chand,
            CONT [ HOOK [ LTOP #ltop,
                          XARG it-ind ],
                   RELS <! relation !>,
                   HCONS <! qeq & [ HARG #arg, LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL [ LBL #ltop,
                     ARG1 handle & #arg ] ] ].

; 'Kim is easy to please'
; `Kim is easier to please than Browne'
;
basic_tough_adj_atrans_synsem := basic_basic_adj_atrans_synsem & 
				 scoping_adj_synsem & norm_adj_synsem &
  [ LOCAL [ CAT.VAL 
		[ COMPS < synsem,
			  [ LOCAL.CONT.HOOK.LTOP #ltop,
			    NONLOC [ SLASH <! [ CAT np_cat_nonnom_min &
						    [ HEAD.MOD < > ],
						CONT.HOOK.INDEX #slind ] !>,
				     QUE 0-dlist ] ], ... >,
		  KCMP.LOCAL.CAT vp_inf_cat,
		  SPR.FIRST.LOCAL.CONT.HOOK.XARG #arg0 ],
	    CONT [ HOOK [ INDEX #arg0,
                          XARG #slind & basic_non_expl-ind ],
		   HCONS <! qeq & [ HARG #arg, LARG #ltop ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL.ARG1 #arg,
	    --COMPKEY _for_p_sel_rel ] ].

; easy to please
tough_adj_atrans_synsem := basic_tough_adj_atrans_synsem & tough_three_arg &
 [ LOCAL.CAT.VAL.COMPS < [], [] > ].

; easier to please than Kim
tough_adj_atrans_compar_synsem := basic_tough_adj_atrans_synsem & 
                                  tough_four_arg_compar &
 [ LOCAL.CAT.VAL.COMPS < [], [], [] > ].

norm_tough_adj_atrans_synsem := tough_adj_atrans_synsem &
  [ LOCAL.CONT.RELS <! relation !> ].

; 'Kim is worth admiring.'
;;
vpslash_adj_atrans_synsem := basic_inf_or_prp_intrans_subst & isect_synsem &
                           adj_vpslash_two_arg & norm_adj_synsem &
                           basic_adj_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN adj_rel,
                  VAL [ COMPS < [ LOCAL [ CAT.VAL.SUBJ 
                                                < synsem &
						  [ NONLOC.SLASH 0-dlist ] >,
                                          CONT.HOOK [ LTOP #ltop,
                                                      INDEX event &
                                                       [ E.TENSE no_tense,
                                                         SF prop-or-ques ] ] ],
                                  NONLOC.SLASH 
                                        <! [ CAT np_cat_acc_min &
                                                 [ HEAD.MOD < > ],
                                             CONT.HOOK.INDEX #slind ] !>,
                                  PUNCT.LPUNCT no_punct,
                                  OPT - ] >,
                        SPR.FIRST.LOCAL.CONT.HOOK.XARG #event ] ],
	    CONT [ HOOK.XARG #slind & ref-ind,
                   RELS <! relation & #keyrel & [ ARG1 #mlbl,
                                                  ARG0 #event ] !>,
                   HCONS <! qeq & [ HARG #mlbl,
                                    LARG #ltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel ].

;; *easier (for us) to arise (than browne)*
;; *easier to sleep than (to) arise*
;; DPF 2018-06-03 - Removed +--ARGIND since we want this entry also when
;; there is no expletive it.
;; DPF 2020-05-08 - To block *it is better to win than losing* in place of
;; *it is better to win than to lose*, tried using hack of CASE acc, where 
;; than+NP imposes CASE obl.  But this blocks *Kim is easier to see than Browne*
;; so find some other way to exclude *than losing* above.  FIX?
;;
comp_adj_atrans_synsem := norm_adj_atrans_synsem & four_arg & prd_synsem & 
			  adj_unsp_ind_synsem &
  [ LOCAL [ CAT [ HEAD basic_adj &
		       [ MOD < [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
			 TAM #tam,
			 MINORS.MIN adj_or_card_or_much_rel ],
		  VAL [ KCMP.LOCAL.CONT.HOOK.LTOP #chand,
			COMPS < [ --MIN #cmin ], 
				[ LOCAL.CONT.HOOK.XARG #xarg ],
			      canonical_or_unexpressed &
			      [ --MIN #ocmin & selected_rel,
				LOCAL [ CAT basic_pp_cat,
					CONJ cnil,
					CONT.HOOK [ LTOP #ltop,
						    INDEX #ind2 &
							  basic_non_expl,
						    XARG #xarg ] ],
				PUNCT.LPUNCT no_punct ] >,
			SPR.FIRST [ --MIN much_deg_rel,
				    LOCAL.CONT.HOOK.XARG #altarg0 ] ] ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #arg0 & [ E #tam ],
                          XARG it-ind ],
                   RELS <! #keyrel, #altkeyrel !>,
                   HCONS <! qeq & [ HARG #arg, LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL #keyrel & [ LBL #ltop,
			       ARG1 handle & #arg ],
	    ALTKEYREL #altkeyrel & [ LBL #ltop,
				     PRED more_comp_rel,
				     ARG0 event & #altarg0,
				     ARG1 #arg0,
				     ARG2 #ind2 ],
	    --COMPKEY #cmin,
	    --OCOMPKEY #ocmin & _than_p_compar_rel ] ].

;; DPF (9-Mar-99) It appears that there are no CP-taking adjectives which 
;; select for a 'like-CP' of the kind some verbs take (e.g. 'It sounds like
;; Kim will leave').  So we constrain the KCMP to be prop-or-ques_m_rel.
;; But there are adjectives (like 'doubtful, unclear, unsure') which can take 
;; a whether-CP, so we introduce a subtype of reg_adj_cp_synsem for those that 
;; only take a 'that-CP', and similarly for expletive-it subject-taking 
;; adjectives.
;;
; 'uncertain': '?Kim is uncertain that Sandy left' 
;              'Kim is uncertain whether Sandy left' 
;              'It is uncertain that Sandy left'
;              'It is uncertain whether Sandy left'
;; DPF 2012-05-31 - It appears that S complements of adjectives cannot be
;; extracted, so we want to block that extraction.  See e.g. **They lost he 
;; was sad*.  But since we treat "intraposition" via extraction, as in
;; *That kim won was obvious*, we want to block extraction for S but not
;; for CP.  Rather than duplicating lexical entries for S-or-CP-taking
;; adjectives, we constrain the type of the SLASH list to only allow CPs.
;; DPF 2016-10-22 - Re 2012-05-31: But this cplist constraint wrongly prevents
;; any extraction out of the CP, as in *Kim, we are sure will win* or
;; *Tomorrow I'm sure she'll win*.  And even the no-S-extraction claim may be
;; wrong: *She'll win, I'm sure*.  So drop *cplist* constraint on SLASH.
;; Note for good measure that this constraint also blocked relative clauses
;; headed by these adjectives, as in *the one who is glad we left*.
;;
basic_adj_cp_synsem := scoping_adj_synsem & basic_two_arg &
		       cp_addin_tam_pn &
  [ LOCAL [ CAT.VAL [ COMPS < synsem & #comp &
                              [ LOCAL [ CAT s_cat_v_c,
					CONJ cnil,
					CONT.HOOK.INDEX.SF prop-or-ques ] ] >,
		      KCMP #comp ],
	    CONT.RELS <! relation !> ] ].

adj_cp_fin_inf_synsem := basic_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_cat_fin_or_inf_v_c ] > ].

; 'unclear' '*Kim is unclear that/whether Sandy left'
;           'It is unclear that Sandy left'
;           'It is unclear whether Sandy left'
; DPF 10-jul-04 - FIX -- Why is the ARG1 constrainted to PNG.PN 3s?  
; Shouldn't that ARG1 be for an optional (experiencer) to-PP (not yet
; provided)?
; DPF 21-dec-05 - Removed CAT.HEAD comp to allow "it's obvious why we did it"
;; DPF 2020-06-12 - Removed --+ARGIND it-ind because this entry is also used for
;; sentential subjects (via extraction) as in |That he won was obvious|, where
;; there is no expl-it in the sentence.

adj_atrans_cp_fin_inf_synsem := adj_cp_fin_inf_synsem & nomod_adj_synsem &
				 prd_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
            CONT [ HOOK.XARG it-ind,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL it_adj_arg1_relation & [ ARG1 handle & #arg ] ].

; 'imperative': 'it is imperative that you be here'
adj_atrans_bse_cp_synsem := basic_adj_cp_synsem & nomod_adj_synsem &  
			    prd_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT s_cat_bse,
                                      CONT.HOOK.LTOP #chand ] ] >,
            CONT [ HOOK.XARG it-ind,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL it_adj_arg1_relation & [ ARG1 handle & #arg ],
            --+ARGIND it-ind ] ].

reg_adj_cp_synsem := adj_cp_fin_inf_synsem & adj_synsem & prd_synsem &
  [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
	    CONT [ HCONS <! qeq & [ HARG #arg, LARG #chand ] !>,
		   ICONS <! !> ]  ],
    LKEYS.KEYREL [ ARG1 non_expl,
                   ARG2 handle & #arg ] ].

; 'afraid'  'Kim is afraid that Sandy left'
;           '*Kim is afraid whether Sandy left'
;           '*It is afraid that/whether Sandy left'
reg_adj_that_cp_synsem := reg_adj_cp_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    CONT.HOOK.INDEX.SF basic-prop ] ] > ].

; 'obvious' '*Kim is obvious that/whether Sandy left'
;           'It is obvious that Sandy left'
;           '*It is obvious whether Sandy left'
;   but cf. 'It is not obvious whether Sandy left' ***Needs fixing***

adj_atrans_that_cp_synsem := adj_atrans_cp_fin_inf_synsem &
  [ LOCAL.CAT.VAL.KCMP.LOCAL [ CAT.HEAD.TAM.TENSE real_tense,
                                    CONT.HOOK.INDEX.SF basic-prop ] ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking of "more many"
;; DPF 2011-08-15 - Tried adding SPEC < > to stop positive adjs from undergoing
;; partitive_intadj rule, which should only apply to comparatives and
;; superlatives.  (Now that we use ALTMIN to distinguish morphological -er
;; adjectives fromo more+adj ones, that way of distinguishing comp/superl
;; from positive adjs no long serves.)  But, SPEC is passed from hd-dtr to
;; mother in head-spec rule, so *most beautiful* has same SPEC as *beautiful*,
;; which blocks *the most beautiful*, sadly.  
;;
basic_norm_adj_word := nonc-hm-nab &
"""
CSY 31-08-2020 - changed from nonc-hm-nab to nonc-h-nab take away mcna
    19-9-2020 - changed back
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD adj & [ MINORS.ALTMIN non_ellipt_rel ],
			 VAL.SPR.FIRST synsem &
			      [ --MIN more_or_very_deg_rel,
				LOCAL.CAT.HS-LEX #hslex ],
			 HS-LEX #hslex ],
	     MODIFD notmod ] ].

; CSY 19-9-2020 - new word type without the SPR information
basic_nocop_norm_adj_word := nonc-hm-nab &
  [ SYNSEM [ LOCAL.CAT [ HEAD adj & [ MINORS.ALTMIN non_ellipt_rel ] ],

	     MODIFD notmod ] ].

; CSY 05-09-2020 - predicative adjective for sentences without copulas
;     13-9-2020 - changed the SYNSEM from intrans_pred_adj_synsem
;     16-9-2020 - added in MC +
;     19-9-2020 - to allow it to join in the sb-hd rule, MC has to be na
;     20-9-2020 - SPR of SUBJ changed to *olsit* from empty list
; HEAD of the SUBJ is supnoun as it allows for modified NP
aj_nocop_i-prd_le := basic_norm_adj_word &
  [ SYNSEM intrans_nocop_pred_adj_synsem & 
              [ LOCAL [ CAT [ HEAD [ MINORS.MIN norm_adj_rel,
                                     MOD < anti_synsem_min > ],
			      VAL [ SUBJ < [ --SIND #subjind & basic_non_expl,
					     LOCAL.CAT [ HEAD supnoun,
						      	 VAL.SPR *olist*] ] > ],
			      MC na,
                              POSTHD + ],
            		CONT.HOOK [ LTOP #ltop,
				    XARG #subjind ] ] ] ].

;; Hook for adding robust contraints on capitalization as in "European"
norm_adj_word := basic_norm_adj_word.

; DPF 25-may-09 - Tried adding MOD..LPERIPH - to block "the tall many cats"
; but proper names are LPERIPH +, so this hack doesn't work.
basic_reg_adj_word := basic_norm_adj_word &
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT.HEAD [ MOD < [ --SIND #ind ] >,
                                MINORS.MIN adj_rel ],
                     CONT [ HOOK [ INDEX.SORT basic-entity-or-event,
				   XARG #ind ],
                            RELS <! relation !> ] ],
             LKEYS.KEYREL.ARG1 #ind ] ].


reg_adj_word := basic_reg_adj_word & norm_adj_word.

reg_intrans_adj := reg_adj_word & 
  [ SYNSEM intrans_adj_synsem ].

; DPF 2010-09-20 - Removed LPERIPH -, since it blocks "big dog Fido", and
; since we independently block "big many cats" now.
;
aj_-_i_le := reg_intrans_adj &
"""
Adj (intersective), no comp      
<ex>The beautiful dog won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

aj_-_i-cap_le := basic_reg_adj_word &
"""
Adj (intersective), no comp, capitalized
<ex>The European dog won.
"""
  [ SYNSEM intrans_adj_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ] ].

aj_-_i-maycap_le := basic_reg_adj_word &
"""
Adj (intersective), no comp, may be capitalized
<ex>We studied Ancient Egypt.
"""
  [ SYNSEM intrans_adj_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ] ].

aj_-_i-er_le := reg_intrans_adj &
"""
Adj (intersective), no comp, only -er comparative
<ex>The big dog won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS [ MIN norm_adj_rel,
				   ALTMIN comp_or_meas_rel ] ].

aj_-_i-ndpt-er_le := reg_intrans_adj &
"""
Adj (intersective), no comp, only -er comparative, not depictive
<ex>Kim felt strange.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN norm_adj_rel,
				     ALTMIN comp_or_meas_rel ],
	     OPT - ] ].

aj_-_i-unsp_le := reg_intrans_adj &
"""
Adj, no constraint on LPERIPH
<ex>B slept the whole afternoon.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

; DPF 21-oct-09 - Removed LPERIPH -, since it blocks "He arrived the next day"
;
aj_-_i-oblsp_le := reg_intrans_adj &
"""
Adj (intersective), no comp, requires spr for modified N
<ex>The next dog won.
<nex> *Next dogs won.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD 
		       [ MINORS.MIN norm_adj_rel,
			 MOD.FIRST.LOCAL.CAT.VAL.SPR < expressed_synsem > ],
		       POSTHD - ] ].

aj_-_i-spobl_le := reg_intrans_adj &
"""
Adj (intersective), no comp, oblig specifier of its own, predic.
<ex>The very surprising cat arose.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN norm_adj_rel,
			      PRD + ],
		       VAL.SPR.FIRST expressed_synsem ] ].

aj_-_i-nopn_le := reg_intrans_adj &
"""
Adj (intersective), no comp, no mod of proper NPs, attrib
<ex>We respond with all due respect.
<nex>The due 1998 arrived.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD [ MOD < [ --MIN norm_nom_rel ] >,
			      MINORS.MIN norm_adj_rel ],
		       POSTHD - ] ].

aj_-_i-color_lexent := norm_adj_word &
  [ SYNSEM adj_unsp_ind_onearg_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN color_rel,
			   VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #xarg ],
		     CONT [ HOOK [ INDEX #xarg,
				   XARG #ind ],
			    RELS <! relation !> ] ],
             LKEYS.KEYREL.ARG1 #ind & basic_non_expl-ind ] ].

aj_-_i-color_le := aj_-_i-color_lexent
"""
Adj, color                       
<ex>The cat is gray.
"""
.

aj_-_i-color-er_le := aj_-_i-color_lexent &
"""
Adj, color, only -er comparative
<ex>The cat is gray.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_or_meas_rel ].

; For adjs like 'far' which don't get used as depictives: 
; constrain NORM to be norm_rel (hack).
; DPF 27-jan-08 - But this prevents coordination with ordinary adjectives
; like "pleasant but far from ...".  So live with ambiguity of e.g.
; "Kim lived far from the city."

aj_-_i-ndpt_le := reg_intrans_adj &
"""
Adj, not depictive               
<ex>B swam to the far shore.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel,
	     OPT - ] ].

; only: 'his only books'
aj_-_i-only_le := reg_intrans_adj &
"""
Adj, 'only', not pred., allows n-adj compound 'residents-only'
<ex>B's only dog won.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS [ MIN norm_adj_rel,
				     NORM no_rel ],
	     MODIFD.LPERIPH + ] ].

aj_-_i-poss_lexent := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD 
     [ MINORS.MIN norm_adj_rel,
       PRD -,
       MOD < [ LOCAL.CAT.VAL.SPR < [ --MIN explicit_q_rel,
				     LOCAL.CAT.HEAD.POSS + ] > ] > ] ].

; own: 'his own books'
aj_-_i-poss_le := aj_-_i-poss_lexent
"""
Adj, only 'own'                  
<ex>B's own dog won.
"""
.

; own: 'his every wish'
aj_-_i-poss-sg_le := aj_-_i-poss_lexent &
"""
Adj, only 'every'                  
<ex>B's every wish was granted.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD 
		        < [ LOCAL.CAT.VAL.SPR < [ LOCAL.AGR.PNG.PN 3s ] > ] > ].

; Not bare adj-noun : 
;   *we arrived last weeks
;   'many chairs' - avoid spurious ambig with determiner 'many'
;; DPF 2012-02-01 - Added NORM no_rel to prevent these from appearing as
;; subord modifiers (spurious ambiguity): *he arrived last.*

adj_intrans_notb_lexent := reg_intrans_adj &
  [ SYNSEM.LOCAL.CAT.HEAD 
     [ MINORS [ MIN norm_adj_rel,
		NORM no_rel ],
       MOD < [ LOCAL.CAT.VAL.SPR.FIRST expressed_synsem &
				       [ --MIN def_or_demon_q_rel ] ] > ] ].

aj_-_i-spn-att_le := adj_intrans_notb_lexent &
"""
Adj, attrib, mod n w/expl spr    
<ex>That very dog won.
"""
  [ SYNSEM basic_attr_adj_synsem ].

; 'many/much' - allows QUE specifier ('how many')
; DPF 12-jul-06 - Added LPERIPH + to block e.g. "*the tall many chairs"
; DPF 16-apr-11 - Making these [PRD -] blocks e.g. *this many*, *this much*.
; So change SYNSEM from basic_attr_adj_synsem to intrans_adj_synsem and
; add POSTHD -, to still block **cats many*.
;; DPF 2017-09-16 - Re 12-jul-96: But we also want *the past several days* and
;; *the first few days*.  So let's leave the unwanted order of *tall many* to
;; the larger non-syntax issue of adjective ordering, and remove LPERIPH + here.
;;
adj_attr_intrans_que_lexent := nonc-hm-nab &
  [ SYNSEM intrans_adj_synsem &
    [ LOCAL [ CAT [ HEAD compar_adj &
                         [ MOD < [ --SIND #ind ] >,
                           MINORS.MIN meas_adj_rel ],
		    POSTHD - ],
	      CONT [ HOOK.XARG #ind,
                     RELS <! relation !> ] ],
      MODIFD notmod,
      NONLOC.REL 0-dlist,
      LKEYS.KEYREL [ ARG0.E [ TENSE no_tense,
                              ASPECT no_aspect ],
                     ARG1 #ind & non_event ] ] ].

;; DPF 2018-03-10 - Generalized MOD..LPERIPH from - to na_or_-.
;;
aj_-_i-many_lexent := adj_attr_intrans_que_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ AGR.PNG.PN 3p,
                                          CONT.HOOK.INDEX.IND + ],
				  MODIFD.LPERIPH na_or_- ] > ].

; 'many, few'
; DPF 28-mar-10 - Constrain LPERIPH to block spurious "many more cats"
aj_-_i-many_le := aj_-_i-many_lexent &
"""
Adj, only 'many'                 
<ex>Many dogs ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN
			      def_or_udef_or_demon_q_rel,
		       VAL.SPR.FIRST.LOCAL.CAT.HEAD no_head ] ].

;; DPF 2018-05-14 - Added ALTMIN nom_nondim_rel to exclude comparative degree
;; specifiers as in **more few cats than mice appeared*
;;
aj_-_i-many-spr_le := aj_-_i-many_lexent &
"""
Adj, only 'many' with specifier
<ex>This many dogs ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SPR.FIRST unexpressed ] >,
		       VAL.SPR.FIRST synsem & [ --MIN very_this_that_rel,
		                                LOCAL.CAT.HEAD.MINORS.ALTMIN
						              nom_nondim_rel,
						OPT - ] ] ].

aj_-_i-much_lexent := adj_attr_intrans_que_lexent &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ LOCAL [ AGR [ PNG.PN 3s,
					     	  DIV + ],
					    CAT.VAL.SPR.FIRST unexpressed ] ] >,
	     MODIFD.LPERIPH + ] ].

; 'much, little'
aj_-_i-much_le := aj_-_i-much_lexent &
"""
Adj, only 'much'                 
<ex>B didn't win much money.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD no_head ].

aj_-_i-much-spr_le := aj_-_i-much_lexent &
"""
Adj, only 'much' with specifier
<ex>B didn't win that much money.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST synsem & [ --MIN very_this_that_rel,
					      OPT - ] ].

; 'several, a few': exclude QUE specifier
; DPF 3-May-08 - Add MOD..NORM norm_rel to block "a few cat" from being
; left member of n-n-cmpnd.
;
aj_-_i-svrl_lexent := adj_attr_intrans_que_lexent &
  [ SYNSEM [ LOCAL.CAT [ HEAD 
			 [ MOD < [ LOCAL [ AGR.PNG.PN 3p,
					   CAT [ HEAD.MINORS 
						   [ ALTMIN def_or_udef_q_rel,
						     NORM norm_rel ],
						 VAL.SPR.FIRST unexpressed ],
					   CONT.HOOK.INDEX.IND + ] ] > ],
			 VAL.SPR.FIRST synsem & [ --MIN very_this_that_rel ] ],
	     NONLOC.QUE 0-dlist ] ].

aj_-_i-svrl_le := aj_-_i-svrl_lexent
"""
Adj, vague number                
<ex>Our several cats fell.
"""
.

;; DPF 2020-04-02 - Block partitive via ALTMIN, to avoid second analysis for
;; *a couple of days*.
;;
aj_-_i-svrl-noprt_le := aj_-_i-svrl_lexent &
"""
Adj, vague number, no partitive
<ex>A couple cats fell.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN no_rel ].


;; DPF 2015-03-16 - Added for *some years ago*
;;
aj_-_i-meas_le := adj_attr_intrans_que_lexent &
"""
Measure adj, vague number                
<ex>They arrived some years ago.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MOD < [ LOCAL [ AGR.PNG.PN 3,
					      CAT.HEAD [ MINORS 
							 [ ALTMIN no_rel,
							   NORM norm_rel ],
							 CASE no_case ],
					      CONT.HOOK.INDEX.IND + ] ] >,
				MINORS.ALTMIN no_rel ],
			 VAL.SPR.FIRST synsem & [ --MIN very_this_that_rel ] ],
	     NONLOC.QUE 0-dlist ] ].

; 'not many' - Can't easily do this compositionally since 'not + Adj' usually
; holds only for predicative adjectives: "kim is occasionally not clever" but
; "*The not clever consultant".  We now treat 'many' as sitting in the
; syntactic position of an attributive adjective, yet it can appear with a
; 'not' modifier.  So we'll treat it for now as a multi-word.
; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"

attr_adj_onearg_synsem := norm_adj_synsem & basic_one_arg & 
                          basic_adj_synsem & nonprd_synsem &
  [ LOCAL.CAT [ HEAD adj & [ MINORS.MIN norm_adj_rel ],
                POSTHD -,
                VAL [ SPR.FIRST synsem &
				[ --MIN more_or_very_deg_rel,
				  LOCAL.CAT.HS-LEX #hslex ],
		      COMPS < > ],
                HS-LEX #hslex ],
    NONLOC.REL 0-dlist ].

;; 'not many/not much'
aj_-_i-mneg_lexent := norm_adj_word &
  [ SYNSEM attr_adj_onearg_synsem &
           [ LOCAL [ CAT.HEAD.MOD 
                           < [ LOCAL 
                               [ CAT.VAL.SPR < [ LOCAL.CONT.HOOK.LTOP #lbl ] >,
                                 CONT.HOOK [ LTOP #albl,
                                             INDEX #ind ] ] ] >,
                     CONT [ HOOK [ LTOP #albl,
                                   XARG #ind ],
                            RELS <! [LBL #albl,
                                      PRED much-many_a_rel ], 
				    #altkeyrel &
                                    [ LBL #lbl,
                                      PRED neg_rel,
                                      ARG0.E.TENSE no_tense ] !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL.ARG1 #ind & non_event,
		     ALTKEYREL #altkeyrel ] ] ].

aj_-_i-mneg-c_le := aj_-_i-mneg_lexent &
"""
Adj, only 'not many'
<ex>Not many dogs ran.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.IND + ] > ].

aj_-_i-mneg-m_le := aj_-_i-mneg_lexent &
"""
Adj, only 'not much'
<ex>Not much rice arrived.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.IND - ] > ].

aj_-_i-att_le := reg_adj_word &
"""
Adj, attributive                 
<ex>The inner ring is small.
"""
  [ SYNSEM basic_attr_adj_synsem ].

aj_-_i-att-er_le := reg_adj_word &
"""
Adj, attributive, only -er comparative
<ex>The early ring is small.
"""
  [ SYNSEM basic_attr_adj_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.ALTMIN comp_or_meas_rel ] ].

; DPF 25-may-09 - Added LPERIPH bool to block "Kim other gems"
;; DPF 2012-03-13 - Added NORM no_rel to block *these cat and other dogs*
;; DPF 2012-12-14 - Constrain MINORS.MIN to norm_adj_rel to prevent unif with
;; selected_adj_rels.
;;

aj_-_i-att-nsp_le := nonc-hm-nab &
"""
Adj, attrib, no specifier        
<ex>A mere beginner won.
"""
  [ SYNSEM attr_adj_synsem &
           [ LOCAL [ CAT [ HEAD adj &
				[ MINORS [ MIN norm_adj_rel,
					   NORM no_rel ] ],
                           VAL.SPEC < > ],
                     CONT.RELS <! relation !> ],
	     MODIFD notmod & [ LPERIPH bool ] ],
    ALTS.JTOR - ].

aj_-_i-att-pn_le := reg_adj_word &
"""
Adj, attributive, only modifies proper names: for deverbal adjectives that overcome reluctance to have passive participles modify unspecified proper names.
<ex>They acquired closely held Compaq.
"""
  [ SYNSEM basic_attr_adj_synsem & 
	   [ LOCAL.CAT.HEAD.MOD < [ --MIN named_np_or_num_rel,
				    LOCAL.CAT.VAL.SPR.FIRST unexpressed ] > ] ].

aj_-_i-prd_le := norm_adj_word &
"""
Adj, predicative                 
<ex>C is awake.
"""
  [ SYNSEM intrans_pred_adj_synsem &
	      [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ],
    ALTS.ATTRJ - ].

; nuts: only complement of copula, or depictive.
aj_-_i-prd-nmd_le := norm_adj_word &
"""
Adj, pred, cannot modify         
<ex>C is nuts.
"""
  [ SYNSEM intrans_pred_adj_synsem & 
              [ LOCAL.CAT [ HEAD [ MINORS.MIN norm_adj_rel,
                                   MOD < anti_synsem_min > ],
                            POSTHD + ] ] ].



; 'else': not even as depictive
;; DPF 2012-11-09 - Added OPT - to prevent these from appearing as depictives,
;; since we can't use NORM no_rel, since the ordinary copula wants norm_rel
;; for its complement, and we want *that was so* where `so' the adjective
;; meaning `true' is also of this type.
;;
aj_-_i-prd-ndpt_le := nonc-hm-nab &
"""
Adj, pred, no mod incl depictve  
<ex>The race is over with.
"""
  [ SYNSEM basic_adj_abstr_lex_synsem &
           [ LOCAL [ CAT [ HEAD adj &
                                [ PRD +,
                                  MINORS [ MIN norm_adj_rel,
					   NORM norm_rel ],
				  TAM #tam,
                                  MOD < anti_synsem_min &
					[ --SIND event ] > ],
                           VAL [ SPR.FIRST anti_synsem_min,
                                 COMPS < > ],
                           POSTHD + ],
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #arg0 & [ E #tam ],
                                   XARG #xarg ],
                            RELS <! #keyrel & relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
             NONLOC non-local_none,
	     OPT -,
             MODIFD notmod & [ LPERIPH bool ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
				      ARG0 #arg0,
				      ARG1 #xarg & non_expl-ind ] ] ].

aj_-_i-prd-nm_le := norm_adj_word &
"""
Adj, predicative, no cop or depictive                 
<ex>We ordered one book only
"""
  [ SYNSEM intrans_pred_adj_synsem &
	   [ LOCAL.CAT.HEAD [ MINORS [ MIN norm_adj_rel,
				       NORM norm_rel ],
			      TAM.TENSE nontense ] ],
    ALTS.ATTRJ - ].

;; DPF 2018-03-23 - Only for *ten degrees celsius/centigrade/fahrenheit*
aj_-_i-prd-meas_le := norm_adj_word &
"""
Adj, predicative, no copula or depictive
<ex>The temperature is ten degrees centigrade.
"""
  [ SYNSEM intrans_pred_adj_synsem &
	   [ LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			      MOD.FIRST.LOCAL.CAT.HEAD.MINORS 
					 [ MIN meas_nom_rel,
					   NORM quantity_rel ],
			      TAM.TENSE nontense ] ],
    ALTS.ATTRJ - ].

intrans_adj_oddsem := noncqrs-hm-nab &
  [ SYNSEM intrans_adj_synsem &
           [ LOCAL [ CAT [ POSTHD -,
                           HEAD.MINORS.MIN norm_adj_rel ],
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #ind ] ],
             LKEYS.KEYREL [ LBL #ltop,
                            ARG1 #ind ],
	     MODIFD notmod ] ].

; DPF 10-Jun-03 - Added MOD..HEAD no_head to prevent these from appearing as
; modifiers. They have to be MOD nonempty in order to combine with the copula, 
; and in fact MOD < synsem> to combine with base form "be".
aj_-_i-wthr_le := norm_adj_word &
"""
Adj, weather, expl it subj       
<ex>It is cloudy.
"""
  [ SYNSEM adj_onearg_lex_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < synsem & [ LOCAL.CAT.HEAD no_head ] >,
                                  MINORS.MIN expl_adj_rel ],
                           VAL.COMPS < > ],
                     CONT [ HOOK.XARG it-ind,
                            RELS <! relation !> ] ],
             NONLOC non-local_none,
             LKEYS.--+ARGIND it-ind ] ].

aj_pp_i-it_le := norm_adj_word &
"""
Adj, expl it subj   
<ex>It is time for the race.
"""
  [ SYNSEM adj_twoarg_lex_synsem &
    [ LOCAL [ CAT [ HEAD [ MOD < synsem & [ LOCAL.CAT.HEAD no_head ] >,
                           MINORS.MIN expl_adj_rel ],
                    VAL.COMPS < canonical_or_unexpressed &
				[ --MIN selected_rel & #cmin,
                                  LOCAL [ CAT basic_pp_cat,
                                          CONT.HOOK.INDEX #ind &
                                              non_expl-ind,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist,
                                  OPT - ] > ],
              CONT [ HOOK.XARG it-ind,
                     RELS <! relation & [ ARG1 #ind ] !> ] ],
      NONLOC non-local_none,
      LKEYS [ --COMPKEY #cmin,
              --+ARGIND it-ind ] ] ].

aj_-_i-cmpd_lexent := intrans_adj_oddsem &
  [ SYNSEM attr_adj_synsem &
	 [ LOCAL 
	   [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK [ LTOP #hand,
                                                INDEX #nind & non_expl-ind]] >,
             CONT [ HOOK.LTOP #hand,
		    RELS <! relation & [ ARG0 #aind ],
			    #altkeyrel &
                            prep_notense_relation &
                            [ LBL #hand,
                              PRED compound_rel,
                              ARG1 #nind,
                              ARG2 #aind ] !> ] ],
	   LKEYS.ALTKEYREL #altkeyrel ] ].

;; doctor's appointment
aj_-_i-cmpd_le := aj_-_i-cmpd_lexent
"""
Adj, human poss cmpnd            
<ex>The doctor's office called
"""
.

;; {OPT +] is on reg_trans_adj and not on trans_adj_synsem because the 
;; comparison_lr uses trans_adj_synsem and requires OPT -. Same for semantics.

basic_adj_trans_lexent := norm_adj_word &
  [ SYNSEM trans_adj_pred_two_arg_synsem &
	   [ LOCAL [ CAT.VAL.COMPS < [] >,
		     CONT.RELS <! relation !> ] ] ].

adj_trans_lexent := basic_adj_trans_lexent & reg_adj_word.

aj_pp_i_le := adj_trans_lexent &
"""
Adj, pp comp w/sem empty prep    
<ex>B is sure of C.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

;; *nothing short of brilliant*
trans_adj_pred_pp_adj_synsem := basic_trans_adj_pred_synsem & adj_synsem &
				 two_arg & pred_adj_synsem &
  [ LOCAL [ CAT.VAL [ SPR.FIRST.LOCAL.CONT.HOOK.XARG #xarg,
		      COMPS < canonical_synsem > ],
	    CONT [ HOOK.INDEX #xarg,
		   RELS <! relation !> ] ] ].

;; DPF 2020-04-01 - Added type for adjectives such as `short', which take
;; an of-PP hose complement is an adjective.
;;
aj_pp_i-aj_le := reg_adj_word &
"""
Adj, pp comp w/sem empty prep whose comp is adj
<ex>B is nothing short of brilliant
"""
  [ SYNSEM trans_adj_pred_pp_adj_synsem &
	   [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ] ].

aj_pp_i-er_le := adj_trans_lexent &
"""
Adj, pp comp w/sem empty prep, only -er comparative
<ex>B is sure of C.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS [ MIN norm_adj_rel,
				   ALTMIN comp_or_meas_rel ] ].

aj_pp_i-prd_le := norm_adj_word &
"""
Adj, predicative, pp comp        
<ex>B is akin to C.
"""
  [ SYNSEM trans_adj_pred_two_arg_nolex_synsem &
	   [ LOCAL [ CAT [ HEAD [ PRD +,
				  MINORS.MIN norm_adj_rel ],
			   VAL.COMPS < [] > ],
		     CONT.RELS <! relation !> ] ],
    ALTS.ATTRJ - ].

aj_pp_i-obl_le := adj_trans_lexent &
"""
Adj, oblig pp comp               
<ex>B is flush with cash.
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ] ].

aj_pp_i-obl-er_le := adj_trans_lexent &
"""
Adj, oblig pp comp, only -er comparative
<ex>B is good at games.
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ OPT - ] >,
             LKEYS [ --COMPKEY #cmin,
                     --+COMPKEY #cmin ] ] ].

aj_pp_i-ind_le := reg_adj_word &
"""
Adj, pp comp w/sem-cont PP       
<ex>B is accessible by foot.
"""
  [ SYNSEM trans_adj_pp_ind_synsem &
           [ LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !> ] ] ] ].

adj_reg_equi_lexent := nonc-hm-nab &
  [ SYNSEM reg_adj_equi_synsem & 
           [ LOCAL.CAT [ HEAD adj,
                         VAL.SPR.FIRST synsem &
			      [ --MIN more_or_very_deg_rel,
				LOCAL.CAT.HS-LEX #hslex ],
                         HS-LEX #hslex ],
	     MODIFD notmod ] ].

aj_vp_i-seq_le := adj_reg_equi_lexent &
"""
Adj, vp comp, subj equi          
<ex>B is eager to win.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ].

; For e.g. "supposed to"
aj_vp_i-seq-nmd_le := adj_reg_equi_lexent &
"""
Adj, vp comp, sequi, no modify   
<ex>B is supposed to win.
"""
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.MIN norm_adj_rel,
			    MOD < anti_synsem > ] ].

aj_vp_i-seq-prp_le := norm_adj_word &
"""
Adj, vp comp pr-part, sequi      
<ex>B is done running.
"""
  [ SYNSEM adj_equi_prp_synsem & [ LOCAL.CAT.HEAD.MINORS.MIN norm_adj_rel ] ].

aj_pp-vp_i-it_le := norm_adj_word &
"""
Adj, opt PP, VP comp, it-subj   
<ex>It is easy for B to win.
"""
  [ SYNSEM reg_adj_atrans_synsem &
           [ LKEYS.--COMPKEY _for_p_sel_rel ] ].

aj_pp-vp_i-it-nt_le := norm_adj_word &
"""
Adj, opt PP, VP comps, it-subj, no tough alternation
<ex>It is urgent for B to win.
<nex>B is urgent to win.
"""
  [ SYNSEM reg_adj_atrans_synsem &
           [ LKEYS.--COMPKEY _for_p_sel_rel ],
    ALTS.TOUGH - ].

; incumbent on X
aj_pp-vp_i-on-it_le := norm_adj_word &
"""
Adj, opt PP-on, VP comps, it-sbj 
<ex>It's incumbent on B to go.
"""
  [ SYNSEM reg_adj_atrans_synsem &
           [ LKEYS.--COMPKEY _on_p_sel_rel ],
    ALTS.TOUGH - ].

; it is nice of X to Y
aj_pp-vp_i-of-it_le := norm_adj_word &
"""
Adj, PP-of, VP comp, it-sbj 
<ex>It's nice of B to go.
"""
  [ SYNSEM reg_adj_atrans_synsem &
           [ LOCAL.CAT.VAL.COMPS.FIRST.OPT -,
	     LKEYS.--COMPKEY _of_p_sel_rel ],
    ALTS.TOUGH - ].

; 'it is worth reading that book.'
aj_vp_i-it-prp_le := norm_adj_word &
"""
Adj, vp comp it-subj, presprt    
<ex>B is worth following.
"""
  [ SYNSEM adj_atrans_prp_synsem ].

aj_vp_i-ssr_le := norm_adj_word &
"""
Adj, vp comp, raising, 
<ex>There are destined to be unicorns in the garden.
"""
  [ SYNSEM adj_ssr_synsem ].

reg_adj_atrans_cp_word := norm_adj_word &
  [ SYNSEM adj_atrans_cp_fin_inf_synsem ].

;;aj_pp-cp_i-it_le := reg_adj_atrans_cp_word &
aj_cp_i-it_le := reg_adj_atrans_cp_word &
"""
Adj, CP comps, it-subj   
<ex>It is possible B won.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

;;aj_pp-cp_i-it-c_le := reg_adj_atrans_cp_word &
aj_cp_i-it-c_le := reg_adj_atrans_cp_word &
"""
Adj, CP w/obl cmpzr, it-sbj  
<ex>It is odd that B won.
"""
  [ SYNSEM adj_atrans_that_cp_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ OPT - ] > ] ].

aj_pp-vp_i-tgh_le := norm_adj_word &
"""
Adj, PP, VP/NP, it-subj          
<ex>The race is tough to win.
"""
  [ SYNSEM norm_tough_adj_atrans_synsem ].

aj_vp_i-wrth_le := norm_adj_word &
"""
Adj, only 'worth'                
<ex>The race is worth winning.
"""
  [ SYNSEM vpslash_adj_atrans_synsem &
	   [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM prp ] > ] ].

aj_vp_i-prty_le := norm_adj_word &
"""
Adj, infinitival VP complement with gap
<ex>Paris is pretty to look at.
"""
  [ SYNSEM vpslash_adj_atrans_synsem &
	   [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM inf ] > ] ].

reg_adj_cp_word := norm_adj_word &
  [ SYNSEM reg_adj_cp_synsem &
	   [ LOCAL.CONT.HOOK.XARG #ind,
             LKEYS.KEYREL.ARG1 #ind ] ].

aj_cp_i_le := reg_adj_cp_word & 
"""
Adj, fin/inf CP comp             
<ex>B is sure C won.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
		       VAL.COMPS < [ OPT - ] > ] ].

aj_cp_i-fin_le := reg_adj_cp_word &
"""
Adj, fin CP comp                 
<ex>B is aware C won.
"""
  [ SYNSEM reg_adj_that_cp_synsem &
           [ LOCAL.CAT [ HEAD.MINORS.MIN norm_adj_rel,
			 VAL.COMPS < [ OPT - ] > ] ] ].

aj_cp_i-bse_le := norm_adj_word &
"""
Adj, base-form CP comp, it-sbj   
<ex>It's imperative that C win
"""
  [ SYNSEM adj_atrans_bse_cp_synsem ].

; How is Sandy?  How does Tuesday look?
; We adopt the following second-order quantification semantics for these:
;    which (p, property(p), look_seem(proposition_to_property(adj(x),p)))
; where we exploit a type-shifting relation to change the proposition "adj(x)"
; into the associated property "the set of entities of which adj(x) is true",
; so the "which" operator can quantify over that property.
; DPF 14-Apr-00 - Changed SUBJ.CAT from nomp_cat_nom_min to nomp_cat_min
; since [CASE nom] conflicts with the CASE hack on pro_ss to prevent the
; latter from undergoing subject xxtraction (see ERB notes for pro_ss).

aj_-_i-wh_le := noncrs-m-nab &
"""
Adj, only 'how'                  
<ex>B sees how C feels.
"""
  [ SYNSEM lex_synsem &
      [ LOCAL [ ARG-S < >,
		CAT [ POSTHD +,
		      HEAD adj & [ MOD < synsem &
					 [ LOCAL intersective_mod &
                                                 [ CAT nbar_cat_min,
                                                   CONJ cnil ],
                                           --SIND #ind & non_expl-ind ] >,
                                   MINORS [ MIN adj_abstract_rel,
					    ALTMIN no_rel ] ],
		      VAL [ SPR < >,
			    COMPS < > ] ],
		CONT [ HOOK [ LTOP #ltop,
                              INDEX #arg0,
                              XARG #ind ],
		       RELS <! [ LBL #ahand,
                                 PRED unspec_adj_rel,
				 ARG0 #arg0,
                                 ARG1 #ind,
				 CFROM #from,
				 CTO #to ],
			       #altkeyrel &
			        [ PRED which_q_rel,
                                  ARG0 #pind & overt_non_expl-ind,
                                  RSTR #hand ],
			       #alt2keyrel &
			        [ LBL #hand,
                                  PRED property_rel,
                                  ARG0 #pind ],
			        prpstn_to_prop_relation & #keyrel &
			        [ LBL #ltop,
				  ARG1 handle & #ahand,
				  ARG2 #pind,
				  CFROM #from,
				  CTO #to ] !>,
		       HCONS <! !>,
		       ICONS <! !> ] ],
        LKEYS [ KEYREL #keyrel,
		ALTKEYREL #altkeyrel,
		ALT2KEYREL #alt2keyrel ],
	MODIFD notmod,
	NONLOC.QUE 1-dlist &
	           [ LIST < param > ] ] ].

; "cat-like"
; DPF 09-dec-08 - Would like to restrict spr to be non-inflected, but not
; currently possible.  So at least constrain to singular, to avoid spurious
; '*cats-like'.
; DPF 2010-09-17 - Re 09-dec-09: Here as well, use the dastardly combination 
; of PN 3p, DIV - to effect uninflected.  Hack.
;; DPF 2012-10-24 - Re 2010-09-17: and unfortunately, one that prevents mass
;; nouns as left members, as in *lumber-like*.  So modify the hack to use
;; [LOCAL noninfl_noun_local] instead.
;
aj_-_i-nspr_le := nonc-hm-nab &
"""
Adj, with noun specifier         
<ex>The cat-like kid won.
"""
  [ SYNSEM adj_synsem_n_spr &
	   [ LOCAL.CAT.VAL.SPR.FIRST [ --MIN nonpro_rel,
				       LOCAL noninfl_noun_local &
					     [ CAT.VAL.SPR.FIRST synsem & 
								 [ OPT - ] ],
				       MODIFD notmod ] ] ].
; "2-dimensional"
aj_-_i-numspr_le := nonc-hm-nab &
"""
Adj, with numeral specifier         
<ex>The 3-dimensional figure appeared.
"""
  [ SYNSEM adj_synsem_n_spr &
	   [ LOCAL.CAT.VAL.SPR.FIRST [ --MIN named_num_rel,
				       LOCAL.CAT.VAL [ SPR.FIRST synsem &
								 [ OPT - ],
						       SPCMPS < > ] ] ] ].

; DPF 03-Feb-06 - Changed analysis so INDEX is now the ARG0 of the comp_rel
; rather than of the basic predicate, to give a more plausible semantics
; for e.g. 'Dogs are 5 cm. taller than horses.'
; DPF 09-may-06 - But this is unnecessary, and creates an unwanted asymmetry
; with '5 cents more expensive', since in the first case the ARG0 of the
; proposition is the ARG0 of the comp_rel, but in the second it's the ARG0
; of the adjective's relation (since we use the head_compositional head-spr
; variant to build 'more expensive').  So let's go back to making the INDEX
; the ARG0 of the basic adjective relation, and still hook up the comp_rel's 
; argument as desired, but by referring to the adj's SPR value.
;; DPF 2011-09-22 - Added MODIFD hasmod to avoid spurious ambig for e.g.
;; *quickly different*.  Cannot be the normal notmod value, since the rule for
;; partitives as in *the highest* requires the daughter to have value hasmod.
;; DPF 2014-01-30 - Removed the recently added ALTKEYREL.ARG0.E.TENSE no_tense,
;; which of course prevents these with predicative copula.  Can't recall what
;; motivated the addition, but maybe we'll see.
;; nonc-hm-nab &
;; DPF 2018-04-17 - Moved default HC-LEX - value down to most subtypes, in order
;; to assign a non-default value bool to aj_pp_i-onemore_le, so we can block
;; **one more than mice cat arrived* by requiring the num_det rule's dtr to be
;; LEX bool.
;;
basic_compar_superl_adj_word := nonconj &
  [ INFLECTD +,
    SYNSEM adj_unsp_ind_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind & non_expl ] >,
				  TAM #tam,
				  MINORS.MIN adj_or_card_or_much_rel ],
                           VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #altarg0,
			   MC na ],
		     CONT [ HOOK [ XARG #ind,
                                   INDEX #arg0 & event & [ E #tam ] ],
                            RELS.LIST < [ LBL #hand,
                                          ARG1 #ind ],
                                        #altkeyrel &
                                        [ LBL #hand,
                                          ARG0 event & #altarg0 & 
					      [ E [ TENSE no_tense,
						    ASPECT no_aspect ] ],
                                          ARG1 #arg0 ], ... > ] ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

compar_superl_adj_word := basic_compar_superl_adj_word &
  [ SYNSEM.LOCAL.CAT.HC-LEX - ].

; DPF 03-Feb-06 - Changed analysis so INDEX is now the ARG0 of the comp_rel
; rather than of the basic predicate, to give a more plausible semantics
; for e.g. 'Dogs are 5 cm. taller than horses.'

basic_adj_comp_lexent := basic_compar_superl_adj_word &
  [ SYNSEM adj_unsp_ind_twoarg_synsem &
	   [ LOCAL [ CAT.VAL [ COMPS < canonical_or_unexpressed &
                                     [ --MIN #cmin,
                                       LOCAL [ CAT basic_pp_cat,
                                               CONJ cnil,
                                               CONT.HOOK [ LTOP #ltop,
                                                           INDEX #ind ] ] ] > ],
                     CONT.HOOK [ LTOP #ltop,
                                 XARG #xarg ] ],
             LKEYS [ KEYREL.ARG1 #xarg,
                     ALTKEYREL.ARG2 #ind,
                     --COMPKEY #cmin ] ] ].

;; DPF 2018-03-31 - To block *nothing is tougher than lose*, add NORM norm_rel.
;; to complement than-PP.
;;
adj_comp_lexent := basic_adj_comp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAl.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
	     LKEYS [ --COMPKEY _than_p_compar_rel,
                     ALTKEYREL.PRED more_comp_rel ] ] ].

norm_adj_comp_lexent := adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN comp_rel ],
                           VAL.SPR.FIRST.--MIN much_deg_rel,
			   HC-LEX - ],
		     CONT.RELS <! relation, 
				  relation & #altkeyrel !> ],
             MODIFD.LPERIPH bool,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

aj_pp_i-cmp_le := norm_adj_comp_lexent
"""
Adj, compar "-er" adj, PP-than   
<ex>B is richer than C.
"""
.

;; DPF 2012-09-12 - To block spurious analyis of *we arrived earlier* with
;; subconj-prd for `earlier', given the existence of the np-adv `earlier', 
;; we try a hack of making this class of adjectives itself [OPT -], even
;; though this feature is otherwise almost exclusively used inside of VAL
;; specifications.  The other half of the hack is to make the dtr in the
;; subconj rule be unifiable with OPT + (which all other adjectives will
;; presumably do).  Maybe FIX in a better fashion someday.
;; 

aj_pp_i-cmp-nsb_le := norm_adj_comp_lexent &
"""
Adj, compar "-er" adj, PP-than, block as subord predicatives
<ex>The earlier cat arrived.
"""
  [ SYNSEM.OPT - ].

;; DPF 2017-11-29 - We want *two more cats* where *two more* is compatible
;; with [LEX +] as required by aj-hdn rule, but we don't want 
;; *two more than him cats* where *more than him* is LEX -.  So identify
;; HS-LEX here with the LEX value at the point where the specifier attaches,
;; namely SPEC..LEX.
;; Also add SPR..ALTMIN norm_rel to block *a more* while keeping *one more*
;; DPF 2018-03-23 - Now that n_-_pr_le (for *something* etc) identifies its
;; ALTMIN with its ALTKEYREL.PRED, we need to change this one's MOD..ALTMIN
;; from implicit_q_rel to nodef_q_rel to still get *something/nothing more*.
;; DPF 2020-06-01 - Changed SPEC *synlist* to *synnull" to avoid *more taller*
;;
aj_pp_i-more_lexent := adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD compar_adj &
                              [ MOD < [ LOCAL [ AGR #agr & [ DIV + ],
                                                CAT.HEAD.MINORS.ALTMIN 
                                                        nodef_q_rel ] ] > ],
                           VAL [ SPR.FIRST.LOCAL.CAT 
					   [ HEAD.MINORS [ MIN card_or_much_rel,
							   ALTMIN norm_rel ],
					     VAL [ COMPS < >,
						   SPEC.FIRST.LEX #lex ] ],
				 COMPS < [ LOCAL.AGR #agr ] >,
                                 SPEC *synnull* ],
			   HS-LEX #lex,
			   HC-LEX -,
                           POSTHD - ],
                     CONT.RELS <! relation, 
				  relation & #altkeyrel !> ],
             MODIFD.LPERIPH +,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; 'more'
aj_pp_i-more_le := aj_pp_i-more_lexent
"""
Adj, only 'more'                 
<ex>B has more cats than C.
"""
.

aj_pp_i-more-obl_le := aj_pp_i-more_lexent &
"""
Adj, only `other', oblig compl
<ex>B has other cats than Felix.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

aj_pp_i-more-ct_le := aj_pp_i-more_lexent &
"""
Adj, `fewer', for count nouns
<ex>B has fewer cats.
<nex>B has fewer rice.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.AGR.PNG.PN 3p ].

; 'one more'
aj_pp_i-onemore_le := adj_comp_lexent &
"""
Adj, only 'one more'             
<ex>B has one more cat than C.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD intadj1 &
                              [ MOD < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN 
                                                        implicit_q_rel,
                                                CONT.HOOK [ LTOP #lbl,
                                                            INDEX #index & 
                                                              [ PNG.PN 3s ] ],
                                                AGR [ PNG.PN 3s,
                                                      DIV - ] ],
                                        MODIFD.LPERIPH bool ] > ],
			   HC-LEX na,
                           POSTHD - ],
                     CONT.RELS <! relation & 
                                  [ LBL #lbl,
                                    ARG1 #index ], 
                                  relation & #altkeyrel &
				  [ ARG0 #arg0 ],
                                  integer_relation & #alt2keyrel &
                                  [ PRED card_rel,
                                    LBL #lbl,
                                    ARG1 #arg0,
                                    CARG "1" ] !> ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].


; For 'different from/than', 'similar_to'
; (Takes both 'very' and 'much' specifiers.)
aj_pp_i-cmp-dif_le := basic_adj_comp_lexent &
"""
Adj, only 'different'            
<ex>B is different from C.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN non_ellipt_rel ],
                           VAL.SPR.FIRST synsem & 
				[ --MIN much_or_very_deg_rel ],
			   HC-LEX - ],
		     CONT.RELS <! relation, 
				  relation !> ],
             MODIFD.LPERIPH bool,
             LKEYS.ALTKEYREL.PRED comp_rel ] ].

;; DPF 2015-09-10 - Removed MOD..NORM norm_rel, because it blocks e.g.
;; *same rights as ...*.  Let's see if we can recall what it was for.
;;
#|
aj_pp_i-cmp-sme_lexent := basic_adj_comp_lexent &
  [ SYNSEM 
   [ LOCAL 
    [ CAT 
     [ HEAD superl_adj &
	    [ PRD -,
	      MOD < [ LOCAL.CAT.VAL.SPR < expressed_synsem &
				          [ --MIN def_or_demon_q_rel ] > ] >,
	      MINORS.ALTMIN non_ellipt_rel ],
       VAL.SPR.FIRST synsem & [ --MIN much_deg_rel ],
       HC-LEX -,
       POSTHD - ],
      CONT.RELS <! relation, relation !> ],
     MODIFD.LPERIPH bool,
     LKEYS [ ALTKEYREL.PRED comp_equal_rel,
	     --COMPKEY _as_p_comp_rel ] ] ].
|#

;; For *the same cat as Kim has* and *such advice as may be requested*
;;
aj_pp_i-cmp_lexent := basic_adj_comp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD superl_adj &
				[ PRD -,
				  MINORS.ALTMIN non_ellipt_rel ],
			   VAL.SPR.FIRST synsem & [ --MIN much_deg_rel ],
			   HC-LEX -,
			   POSTHD - ],
		     CONT.RELS <! relation, relation !> ],
	     MODIFD.LPERIPH bool,
	     LKEYS [ ALTKEYREL.PRED comp_equal_rel,
		     --COMPKEY _as_p_comp_rel ] ] ].

aj_pp_i-cmp-sme_lexent := aj_pp_i-cmp_lexent &
  [ SYNSEM 
   [ LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR < expressed_synsem &
		   	                   [ --MIN def_or_demon_q_rel ] > ] >]].

; For 'same as' - Note "*Kim is same", "*A same car arrived"
aj_pp_i-cmp-sme_le := aj_pp_i-cmp-sme_lexent
"""
Adj, only 'same', MOD has obligatory expressed specifier
<ex>B has the same cat as C.
"""
.

; For 'exact ... as' as in "the exact car as Kim has" (e.g. wsj04:20465050)
aj_pp_i-cmp-ex_le := aj_pp_i-cmp-sme_lexent &
"""
Adj, only 'exact', like `same' but with oblig PP
<ex>B has the exact cat as C.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

; For 'such...as'
aj_pp_i-such_le := aj_pp_i-cmp_lexent &
"""
Adj, only 'such'
<ex>Such advice as was requested arrived.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

aj_pp_i-cmp-wthr_le := nonc-hm-nab &
"""
Adj, comparative weather         
<ex>B is rainer than C.
"""
  [ SYNSEM norm_adj_lex_synsem &
        [ LOCAL [ CAT [ HEAD [ MOD < >,
                               MINORS.ALTMIN comp_rel ],
                        VAL [ SPR.FIRST.--MIN much_deg_rel,
                              COMPS < > ] ],
                  CONT [ HOOK [ LTOP #hand,
                                XARG it-ind ],
                         RELS <! [ LBL #hand ],
                               #altkeyrel &
                               [ LBL #hand,
                                 ARG0 event ] !> ] ],
          LKEYS [ ALTKEYREL #altkeyrel & [ PRED more_comp_rel ],
                  --+ARGIND it-ind ] ] ].

;; DPF 2017-09-12 - Surprisingly, the analysis of
;; *it is easier for kids than it is for adults* assumes that the INDEX value
;; of *than it is for adults* is the handle which is the LTOP of the predicative
;; for-PP.  Probably not what we should do, since INDEX should mostly likely not
;; be allowed to be handle-valued.  FIX.
;; DPF 2018-03-31 - To block *nothing is tougher than lose*, add NORM norm_rel.
;; to complement than-PP.
;;
aj_pp-pp_i-cmp_lexent := compar_superl_adj_word &
  [ SYNSEM trans_adj_pred_three_arg_synsem &
	   [ LOCAL [ CAT [ HEAD adj,
                           VAL [ COMPS < [ LOCAL.CONT.HOOK [ LTOP #ltop,
                                                             INDEX #ind1 ],
					   --MIN #cmin & selected_rel ],
					 canonical_or_unexpressed &
					 [ --MIN #ocmin & selected_rel,
					   LOCAL [ CAT basic_pp_cat &
					               [ HEAD.MINORS.NORM
						                 norm_rel ],
						   CONJ cnil,
						   CONT.HOOK [ LTOP #ltop,
							       INDEX #ind2 &
  							       basic_non_expl]],
					   PUNCT.LPUNCT no_punct ] >, 
				 SPR.FIRST.--MIN much_deg_rel ] ],
		     CONT [ HOOK.LTOP #ltop,
                            RELS <! relation, relation !> ] ],
             LKEYS [ KEYREL.ARG2 #ind1,
                     ALTKEYREL [ PRED more_comp_rel,
				 ARG2 #ind2 ],
		     --COMPKEY #cmin,
		     --OCOMPKEY #ocmin & _than_p_compar_rel ] ] ].


aj_pp-pp_i-cmp_le := aj_pp-pp_i-cmp_lexent
"""
Adj, compar, two PP comps, both optional
<ex>B is closer to C (than D).
"""
.

;; *it is easier to solve this problem (than that one)*
;;
aj_pp-vp-pp_i-cmp-it_le := nonc-hm-nab &
"""
Adj, compar, two optionalPP comps and VP comp, 
<ex>it is easier [for B] to solve this problem [than that one]
"""
  [ SYNSEM comp_adj_atrans_synsem ].

; DPF 14-jul-06 - Added LPERIPH + to block spurious analysis of "next 
; tallest" as adj-head; only want spr-head analysis.  But this isn't quite
; right - make LPERIPH na.
; DPF 06-sept-07 - Require MOD nbar to have an explicit determiner, to 
; block e.g. "biggest dogs barked."
; DPF 15-jan-08 - Re: 14-jul-06 But this blocks "the two tallest trees",
; so remove, and find alternative to block "next tallest".  FIX...

aj_-_i-sup_le := compar_superl_adj_word &
"""
Adj, superlative                 
<ex>The fastest runner won.
"""
  [ SYNSEM adj_unsp_ind_onearg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel,
                                         MOD < [ LOCAL.CAT.HEAD.MINORS.ALTMIN
                                                   explicit_q_rel ] > ],
                    VAL.SPR.FIRST.--MIN ord_or_very_rel ],
              CONT.RELS <! relation, relation !> ],
      LKEYS.ALTKEYREL.PRED superl_rel ] ].

aj_pp_i-sup_le := compar_superl_adj_word &
"""
Adj, superlative, PP complement
<ex>The runner closest to Kim won.
"""
  [ SYNSEM adj_unsp_ind_twoarg_synsem &
    [ LOCAL [ CAT [ HEAD superl_adj & [ MINORS.ALTMIN superl_rel,
                                         MOD < [ LOCAL.CAT.HEAD.MINORS.ALTMIN
                                                   explicit_q_rel ] > ],
                    VAL [ SPR.FIRST.--MIN ord_or_very_rel,
			  COMPS < canonical_or_unexpressed &
				  [ --MIN #cmin,
				    LOCAL [ CAT basic_pp_cat,
					    CONJ cnil,
					    CONT.HOOK [ LTOP #ltop,
							INDEX #ind ] ] ] > ] ],
	      CONT [ HOOK.LTOP #ltop,
		     RELS <! relation, relation !> ] ],
      LKEYS [ KEYREL.ARG2 #ind,
	      ALTKEYREL.PRED superl_rel,
	      --COMPKEY #cmin ] ] ].

adj_atrans_superl_lexent := nonc-hm-nab &
  [ SYNSEM norm_adj_lex_synsem &
       [ LOCAL [ CAT [ HEAD [ MOD < >,
                              MINORS.ALTMIN superl_rel ],
                       VAL [ SPR.FIRST.--MIN ord_or_very_rel,
                             COMPS < > ] ],
                 CONT [ HOOK [ LTOP #hand,
                               XARG it-ind ],
                        RELS <! [ LBL #hand ],
                              #altkeyrel &
                              [ LBL #hand ] !> ] ],
         LKEYS [ ALTKEYREL #altkeyrel & [ PRED superl_rel ],
                 --+ARGIND it-ind ] ] ].

aj_-_i-sup-it_le := adj_atrans_superl_lexent &
"""
Adj, superl, it-subj             
<ex>B is the rainiest place.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

;; DPF 2014-11-26 - Seemingly perversely, made this POSTHD - even though it
;; can only appear after the head, because its modiifier targets are all 
;; pronominal forms that take a lexical modifier as an optional complement,
;; as in *someone tall*.  Se we use this head-complement analysis for
;; *someone else* and block the "ordinary" head-modifier one.
;;
aj_-_i-else_le := norm_adj_word &
"""
Only `else', modifier of `anything, somewhere, anyplace, etc'
<ex>Something else appeared.
"""
  [ SYNSEM intrans_pred_adj_synsem &
	   [ LOCAL [ CAT [ HEAD [ MINORS [ MIN norm_adj_rel,
					   NORM no_rel ],
				  MOD < [ LOCAL.CAT 
					  [ HEAD partn,
					    VAL.SPR.FIRST.--MIN 
						   just_only_deg_rel ] ] > ],
			   POSTHD - ],
		   CONT.HOOK.INDEX.E.TENSE no_tense ] ],
    ALTS.ATTRJ - ].

such_adj_synsem := basic_adj_abstr_lex_synsem & basic_two_arg & 
		   cp_addin_tam_pn & 
  [ LOCAL [ CAT [ HEAD adj & [ MINORS [ MIN adj_rel,
					ALTMIN non_ellipt_rel ],
			       MOD < [ LOCAL.CAT.HEAD.MINORS.MIN no_rel ] >,
			       TAM #tam ],
		  VAL [ SPR < anti_synsem_min >,
			COMPS < synsem & #comp &
				[ LOCAL [ CAT s_cat_v_c &
					      [ HEAD comp & [ VFORM fin ] ],
					  CONT.HOOK [ LTOP #chand,
						      INDEX.SF prop ],
					  CONJ cnil ],
				  NONLOC non-local_none,
				  PUNCT.LPUNCT no_punct,
				  OPT - ] >,
			KCMP #comp ] ],
            CONT [ HOOK [ LTOP #ltop,
			  INDEX #index & [ E #tam ],
			  XARG non_expl ],
		   RELS <! #keyrel & relation !>,
		   HCONS <! qeq & [ HARG #arg, LARG #chand ] !>,
		   ICONS <! !> ] ],
    NONLOC non-local_none,
    MODIFD notmod & [ LPERIPH bool ],
    LKEYS.KEYREL #keyrel & [ LBL #ltop,
			     ARG0 #index & non_conj_event,
			     ARG1 #arg ] ].

aj_cp_such_le := nonc-hm-nab &
"""
Only `such' with CP complment
<ex>The cost was such that he departed.
"""
  [ SYNSEM such_adj_synsem ].

; Titles like 'mister', 'professor' which modify proper names
; DPF 5-Apr-01 - Changed MOD..MIN to abstr_named_rel from named_rel, to
; include integers, as in "number ten"
; Removed LPERIPH na - it blocked "order fivedigitersatz" since the num-np
; rule cannot accept numerals modified by adjectives or noun-noun compounds -
; we want to block the NP "Toshiba 2000" but allow the NP "order (number) 2000"
; DPF 12-Nov-03 - Removed MOD.MODIFD notmod_or_rmod since it prevented
; "number 222" where "222" is MODIFD lmod.  We'll see what that constraint
; was trying to block.
; DPF 03-may-04 - Added LPERIPH + to distinguish "number five" from "five",
; so the former can appear in appositives but not the latter.
; DPF 01-sep-05 - Changed MOD..MIN from gen_named_rel to named_np_or_num_rel
; to block "my summer house" as post_title.
; DPF 08-sep-06 - Changed SPR < anti_synsem_min > to synsem with unexpr SPR
; to allow Adj-N titles as in "federal highway 66".
; DPF 23-may-10 - Removed MOD..MIN named_np_or_num_rel since it blocked
; "Itel Systems Inc.", but instead ensure that SPR is unexpressed, to avoid
; spurious ambiguity for "the Stigen farm"
;; DPF 2012-12-15 - Restrict to modifying proper names.
;; DPF 2014-06-05 - Since now using this only for post-titles, remove the
;; MOD..SPR.FIRST unexpressed, so we can get *the defunct Smith Inc.*
;; DPF 2014-07-08 - Re 2014-06-05: But this leads to unwanted ambiguity for
;; e.g. *the Smith bank*.  So push this unexpressed SPR down to the subtypes
;; excluding post-title-only *Inc.* etc.
;;
basic_title_synsem := basic_zero_arg & count_noun_synsem &
  [ LOCAL [ CAT [ HEAD ttl &
                  [ MOD < [ LOCAL intersective_mod &
                                  [ CAT basic_nbar_cat &
                                    [ HEAD.MINORS.MIN named_or_part_nom_rel,
                                      VAL.SPR < [ OPT - ] > ],
                                    CONJ cnil,
                                    CONT.HOOK [ INDEX #nind,
                                                XARG #nhand ] ],
                            NONLOC non-local_none,
                            PUNCT.RPUNCT comma_or_rbc_or_clause_or_no_punct ]>,
                    MINORS [ MIN generic_entity_rel,
                             ALTMIN no_rel ] ],
                  VAL [ SUBJ < >,
                        SPR < unexpressed &
                              [ --MIN explicit_q_rel ] >,
                        COMPS < > ] ],
            AGR #ind,
	    CONT [ HOOK [ LTOP #nhand,
			  INDEX #ind,
                          XARG #khand ],
		   RELS.LIST 
			< #keyrel & 
                          [ LBL #khand,
			    ARG0 #ind ],
                          [ PRED udef_q_rel,
                            ARG0 #ind,
                            RSTR #rhand ],
                          [ LBL #nhand,
                            PRED compound_rel,
                            ARG1 #nind,
                            ARG2 #ind ], ... >,
                   HCONS.LIST < qeq &
                           [ HARG #rhand,
                             LARG #khand ], ... >,
		   ICONS <! !> ] ],
    MODIFD notmod & [ LPERIPH + ],
    LKEYS.KEYREL #keyrel ].

title_synsem := basic_title_synsem &
  [ LOCAL.CONT [ RELS <! relation, 
		         relation & #altkeyrel,
		       relation & #alt2keyrel !>,
		 HCONS <! qeq !>,
		 ICONS <! !> ],
    LKEYS [ ALTKEYREL #altkeyrel,
	    ALT2KEYREL #alt2keyrel ] ].

; DPF 7-mar-05 - Added MOD..MODIFD notmod to remove spurious analysis of e.g.
; '[Abrams in Berlin] river rises.'
; DPF 25-may-10 - Added [PN 3s]: block *Kim is* with plural roman numeral
; DPF 2011-02-11 - Added constraint that modifiee must be a singular 
; proper name, to avoid analysis of *dogs' house*.
; DPF 2017-07-13 - Changed MOD..MODIFD notmod to notmod_or_lmod, so we can
; get *closely held Acme Corp.* while still treating *Corp.* as a 
; post-head modifier, now that we attach pre-mod before post-mod.
;; DPF 2020-03-12 - Removed MOD..AGR..PN 3s since we want *Abrams, Brownes & Co*
;; where (for some reason) the city-state compound for *Abrams, Brownes* makes
;; the mother's AGR that of the right dtr.  Not the whole story, but not clear
;; why we constrained the head nominal's AGR anyway.
;; DPF 2020-07-24 - Re 2017-07-13: Now that we build "closely held Acme" first,
;; we could again consider having post-title attach to NP rather than nbar,
;; which would give a better analysis of "Abrams and Browne Inc.", which just
;; now can only be analyzed with constituent "Browne Inc.".
;; And Re 7-mar-05: This blocks desired analysis of "Fruit of the Loom Inc.",
;; so consider removing MODIFD constraint and see what ambiguity we face,
;; independent of whether post-titles modify NP or nbar.
;;
n_-_tt-post_lexent := noncqrs-hm &
  [ INFLECTD -,
    SYNSEM title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
			   HEAD [ MOD < [ MODIFD notmod_or_lmod,
					  LOCAL [ CAT.VAL.SPR < unexpressed &
							    [ OPT - ] > ] ] >,
				  PRD - ] ],
		     AGR.PNG.PN 3s ] ] ].

n_-_tt-post_le := n_-_tt-post_lexent
"""
Title noun, follows head         
<ex>B street appeared.
"""
.

n_-_tt-post-caps_le := n_-_tt-post_lexent &
"""
Title noun, follows head, all caps
<ex>Bigcorp AS suffered.
"""
 [ TOKENS.+LIST.FIRST.+CLASS.+CASE capitalized+upper ].

;; DPF 2012-04-07 - Added LEX - to avoid spurious analysis for *Kim Browne Inc.*
;; (avoid using title-compound rule with *Inc.* as head).
n_-_tt-post-npt_le := basic_word &
"""
Title noun, follows head, head optionally comma or clause marked
<ex>Lee Browne, Esq appeared.
"""
  [ INFLECTD +,
    SYNSEM title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
			   HEAD [ MOD < [ MODIFD notmod_or_lmod ] >,
				  PRD - ],
			   MC na ],
		     CONJ cnil ],
	     NONLOC non-local_none,
	     LEX -,
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT comma_or_clause_or_no_punct,
		     RCLSTR [ RPAREN -,
			      RFP - ] ] ] ].

; For 'high mountain lodges' until a better solution emerges ...
n_-_tt-post-mwe_le := noncqrs-hm &
"""
Title noun, follows hd, multiwd  
<ex>Bygdin high mtn lodge is.
"""
  [ INFLECTD -,
    SYNSEM basic_title_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
			   HEAD.MOD < [ MODIFD notmod,
					LOCAL.CAT.VAL.SPR < unexpressed &
					  		    [ OPT - ] > ] > ],
		     CONT [ RELS <! [ LBL #khand,
				      ARG0 #kind,
				      CFROM #from, CTO #to ],
				    relation & [ CFROM #from, CTO #to ],
				    relation & [ CFROM #from, CTO #to ],
				    #altkeyrel & 
				    [ LBL #lhand,
 				      ARG0 #lind ],
				    [ PRED udef_q_rel,
				      ARG0 #lind & ref-ind,
				      RSTR #lrstr,
				      CFROM #from, CTO #to ],
				    [ LBL #khand,
				      PRED compound_rel,
				      ARG1 #kind,
				      ARG2 #lind,
				      CFROM #from, CTO #to ],
				    #alt2keyrel &
				    [ LBL #khand,
				      ARG0.E [ TENSE untensed, 
					       ASPECT no_aspect ],
				      ARG1 #kind ] !>,
			    HCONS <! qeq, qeq & [ HARG #lrstr,
						  LARG #lhand ] !>,
			    ICONS <! !> ] ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PREPOSITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Most prepositions can be modifiers.  If they act as a modifier, we'll assume
; they have no subject (leaving for some distinct analysis Carl's "A unicorn
; at the helm, the ship sailed into the horse latitudes."  This lets us use a
; single attribute, ARG, for the index of the phrase modified, or for the
; index of the subject of the PP, in a predicative construction.

; Prepositions also have a distinguished role ARG2 which has as value the
; index of the object of the preposition.  We could introduce distinct role
; names for each preposition (e.g. "ON" for on_rel, "IN" for in-rel) but this
; would complicate the definition of the prep_synsem type, since it needs to
; know the role name to which it assigns the object's index.

; An ARG0 attribute is needed for PPs (and other substs used predicatively)
; occurring as complements of the copula as in "the meeting is on Tuesday",
; but on this analysis not postnominally.  This ARG0 role used to be
; introduced in a separate support_rel, supplied by the copula, but is now
; introduced directly in the relation introduced by the predicate (prep or
; adj or verb).

; Prepositions, like adjectives and participial verbs, can have either
; predicative or nonpredicative synsems, so each ordinary preposition
; (actually the PP headed by the P) can unify with either a pred. or non-pred.
; constraint, which resolves the underspecification.  One assumption here is 
; that there are no contexts which are underspecified for the PRD feature 
; for PPs.

; N.B. The RELS value of basic_prep_synsem cannot be a singleton list, since
; adverbs like "when" inherit this synsem, and add additional rels lexically.

; Here we only amalgamate non-local features from the complements, not the
; subject.  This is so we don't get two identical gaps in an example like "Who
; does kim think is under the bed?".  On the other hand, binding theory
; suggests that the subjects of prepositions really are on the ARG-S list.

; DPF (14-Mar-99) Constrained prepositions to not allow pied-piping in
; free relative constructions, where the QUE value is an index rather than
; a handle.

; DPF 18-Nov-04 - FIX - make HEAD be prep rather than n_or_p: no longer any
; visible motive for n_or_p.
; DPF 20-oct-09 - Changed HEAD to p_or_adv, to allow "how" and "why" to be
; underspecified for prep or adv.

basic_prep_synsem := canonical_synsem & 
  [ LOCAL.CAT [ HEAD p_or_adv,
                VAL [ SUBJ < >,
		      SPCMPS < > ] ] ].

; DPF 18-Apr-01 - Removed ident. of ALTMIN with COMPS..MIN, since it prevents
; selection in v-np-pp verbs for a PP which is temporal or locative: want to
; block "When did kim put the book", but allow "Where did Kim put the book"
; We'll see where this constraint was being used.
; DPF 28-jun-07 - Made contentful preps PRD + so they take the right kind
; of measure-NP specifiers: "miles under the ice" but not "mile under the ice"

norm_prep_synsem := basic_prep_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_prep & 
                       [ MINORS.MIN #min,
                         TAM #tam ],
                  VAL.COMPS < synsem &
                              [ LOCAL.CAT.NEGPOL #negpol,
				PUNCT.LPUNCT pair_or_no_punct ], ... >,
                  POSTHD +,
		  NEGPOL #negpol ],
	    CONT.HOOK.INDEX.E #tam ],
    LKEYS.KEYREL.PRED #min ].

prep_synsem := norm_prep_synsem &
  [ LOCAL [ CAT.HEAD prep,
	    CONT.RELS.LIST < #keyrel, ... >,
	    ARG-S < [ NONLOC [ SLASH #slash,
			       REL #rel,
			       QUE #que ] ], ... > ],
    NONLOC [ SLASH #slash,
             REL #rel,
             QUE #que ],
    LKEYS.KEYREL #keyrel ].

; For predicative Ps and PPs like "when" which have a (non-expletive) NP subj

prep_p_synsem := basic_prep_synsem &
  [ LOCAL [ CAT [ HEAD basic_prep,
		  VAL.COMPS #comps ],
	    ARG-S #comps ] ].

;; DPF 17-Jul-01 - Restricted SPR to be very_deg_rel, to avoid e.g. "much 
;; for Kim".  
;; DPF 16-Nov-01 - But "very for Kim" is also bad", and note "very much for
;; Kim" is good, but not "very very for Kim".  Seems reminiscent of contrast
;; between "*I want much to stay" and "I want very much to stay".  Don't know
;; how to get this, but in any case fixed SPR.
;; DPF 10-Sept-01 - Made SPR be synsem_min rather than synsem, so PPs can
;; coordinate with VPs (which are necessarily SPR anti_synsem_min).
;; DPF 27-Apr-03 - Note that making SPR be much_deg_rel means that for now we
;; have to have two degree specifier lex-entries for the just_only_deg ones,
;; since we want them to work for positive adjectives, and cannot underspecify
;; much_deg vs. very_deg yet.  Once we move to PRED for relation names, we
;; should be able to get rid of those duplicate deg-spec entries.
;; DPF 18-jul-06 - Removed SPR..MODIFD notmod_or_lmod since this interacted
;; badly with degree-specs identifying their MODIFD value with their SPEC's,
;; blocking examples like "directly down under Berlin".  Believe this was here
;; to block e.g. (((ten meters) (in Paris)) (under Berlin)), but we can now
;; instead block this in rule pumping measure-NPs to degree-specs.

prep_with_spr_synsem := basic_prep_synsem & abstr_lex_synsem &
  [ LOCAL 
    [ CAT [ HEAD.MINORS.MIN #min,
            VAL.SPR < synsem_min & 
                      [ LOCAL
                        [ CAT [ HEAD n_or_adv,
                                VAL [ COMPS *olist*,
                                      SPEC < [ LOCAL.CAT.VAL.COMPS < > ] > ]]],
                        NONLOC.QUE 0-dlist ] > ] ],
    LKEYS.KEYREL.PRED #min ].

; Ps and PPs that can be modifiers.
; Block PP modification of infinitival "to" - spurious ambiguity.
; Constrain MOD < [ --SIND > to be non_expl, for fragments like 
; "perhaps in a week"
; DPF 10-Sept-01 - Removed MOD..MIN relation, since it prevents modification
; of no_copula VPs, as in "rain likely tomorrow"
; DPF 19-Feb-03 - Added link between HOOK.INDEX and KEY.ARG1 - don't know why
; this went missing (example: "Can kim arrive on tuesday after four").
; DPF 11-Nov-03 - Removed reentrancy of LTOP and MOD..LTOP since this is being
; supplied by the head-modifier constructions generally, as required by the
; solution to the "apparently unsolvable problem" Kasper scoping examples.
; One extra benefit of this division of labor is that we now also get the 
; right scoping for "On Tuesday who arrives?" where the PP does not want to 
; share the handle with the filler-head phrase that it modifies.
; DPF 12-Mar-04 - Added MOD..SPEC < anti_synsem_min > to block modification by
; PPs of measure-NPs.  Though this prevents "Five kilometers on snow is
; difficult", so we should reconsider.
; DPF 19-nov-04 - Okay, we reconsidered, and removed this constraint, in order
; to provide an analysis for "five kilometers on artificial snow is difficult".
; The apparently spurious additional ambiguity seems to be manageable.
; DPF 11-mar-05 - Finally decided to take the plunge and allow PPs to modify
; other PPs (along with Nbars, VPs, and APs), so we can get rid of the
; spurious ambiguity for "Kim will arrive on Tuesday":  also constrain
; MOD to AUX -.  Note that this analysis assumes that elided VPs are not
; marked for AUX: 'Kim can on Tuesdays'.
;;
basic_mod_n_or_vp_synsem := abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ --MIN independent_rel,
                               LOCAL intersective_mod &
                                     [ CAT [ HEAD subst &
                                                  [ AUX - ],
                                             VAL [ SPR < synsem_min, ... >,
                                                   COMPS < > ],
                                             MC #mc ],
				       CONJ cnil ],
                               --SIND #ind & basic_non_expl ] >,
                  MC #mc,
                  POSTHD + ],
            CONT [ HOOK [ LTOP #hand,
                          INDEX #event,
                          XARG #ind ] ] ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #event & non_conj_event,
                   ARG1 #ind ] ].

prep_spr_mod_synsem := basic_mod_n_or_vp_synsem & prep_with_spr_synsem.

prep_p_mod_synsem := prep_p_synsem & prep_spr_mod_synsem.

prep_prd_or_nonprd_synsem := prep_synsem & prep_p_mod_synsem.

; Strict transitive prepositions which can be either predicative or non-pred:

basic_one_arg_prep_synsem := prep_prd_or_nonprd_synsem & basic_one_arg &
  [ LOCAL.CONT.RELS.LIST < prep_relation, ... > ].

one_arg_norel_prep_synsem := prep_p_synsem & norm_prep_synsem.

one_arg_prep_synsem := basic_one_arg_prep_synsem &
  [ LOCAL.CAT.VAL.SPR < [ LOCAL 
                          [ CAT [ HEAD.MINORS [ MIN much_deg_rel,
                                                ALTMIN abstr_meas_nom_rel],
                                  VAL [ SPR *olist*,
                                        SPEC < synsem >,
                                        COMPS < > ] ],
                            CONT.HOOK [ LTOP #ltop,
                                        XARG #arg0 ] ] ] >,
    LKEYS.KEYREL [ LBL #ltop,
                   ARG0 #arg0 ] ].

; DPF 14-may-09 - Changed SPR..COMPS from < > to *olist*, to allow
; *most probably from Kim*
basic_trans_prep_synsem := basic_one_arg_prep_synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
                    SPR < [ LOCAL.CAT.VAL [ SPEC < synsem >,
                                            COMPS *olist* ] ] > ],
    LKEYS.KEYREL.ARG2 #ind & non_expl ].

; DPF 21-Jun-01 - Changed COMPS..INDEX from ref-ind to non_expl-ind so preps
; can be particles.
; DPF 8-Aug-01 - Removed identification of LTOP and COMPS..LTOP - unwanted.

basic_norm_trans_prep_synsem := basic_trans_prep_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ COMPS < [ --SIND overt_non_expl-ind,
                                  --MIN #cmin,
				  LOCAL.CONT.HOOK.LTOP #ltop,
                                  NONLOC.QUE.LIST *paramlist* ] >,
                      SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                             [ MIN just_only_notvery_deg_rel ],
					    VAL.SPR *olist* ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #arg0 ] ] ] > ] ],
            CONT [ RELS <! prep_relation &
                           [ LBL #ltop,
                             ARG0 #arg0 ] !>,
		   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.--COMPKEY #cmin ].

; Exclude possessive `of'
norm_trans_prep_synsem := basic_norm_trans_prep_synsem &
  [ LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN abstr_meas_nom_rel ].

; DPF 27-sept-04 - Added TAM.TENSE tense to enable blocking of coordination
; of ordinary PPs with nbar-complement PPs like "per unit" or "a person"

trans_prep_synsem := norm_trans_prep_synsem &
  [ LOCAL.CAT.HEAD.TAM.TENSE tense ].

ditrans_prep_synsem := prep_prd_or_nonprd_synsem & basic_two_arg &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                 [ MIN much_deg_rel,
                                                   ALTMIN abstr_meas_nom_rel ],
                                            VAL [ SPR *olist*,
                                                  SPEC < synsem >,
                                                  COMPS < > ] ],
                                      CONT.HOOK [ LTOP #ltop,
                                                  XARG #arg0 ] ] ] >,
                      COMPS < [ --MIN #cmin,
                                NONLOC.QUE.LIST *paramlist*,
                                --SIND #objind ], 
                              [ --MIN #ocmin,
                                LOCAL [ CAT.HEAD.TAM [ ASPECT no_aspect ],
					CONT.HOOK.LTOP #ltop ] ] > ] ],
	    CONT.RELS.LIST < prep_relation &
                             [ ARG2 #objind & overt_non_expl-ind,
                               LBL #ltop,
                               ARG0 #arg0 ], ... > ],
    LKEYS [ --COMPKEY #cmin,
            --OCOMPKEY #ocmin ] ].

basic_lex_pp_synsem := prep_p_synsem & abstr_lex_synsem &
  [ LOCAL [ ARG-S < >,
	    CAT [ VAL.COMPS < >,
		  NEGPOL - ],
            CONT [ HCONS <! !>,
		   ICONS <! !> ] ],
    LEX - ].

; Try excluding lexical PPs modifing PPs, to avoid spurious ambiguity
; DPF 21-apr-08 - Added ALTMIN no_rel to let us exclude these from v_mod
; rule, to avoid spurious ambiguity for e.g. "We brought up the cat"
; DPF 19-jun-08 - Re 21-apr-08: But this ambiguity is not spurious - note
; also "We brought aboard the new arrivals" "We have since departed" etc.
; DPF 03-jun-10 - Move exclusion of PP modifee down to subtype, so we can
; still get e.g. colon-as-PP modifying PPs, as in *in this way :*
;; DPF 2012-09-30 - Removed MOD synsem constraint, since this prevented
;; extraction in copula constructions, as in *when is the game over?*,
;; where the extracted-adj rule imposes MOD anti_synsem on mother (and hence
;; on head-dtr).
;; DPF 2016-12-03 - Removed MOD..MODIFD notmod_or_rmod since this should be
;; handled phrasally by the head-adjunct rules.
;
norm_lex_pp_synsem := basic_lex_pp_synsem & basic_mod_n_or_vp_synsem &
  [ LOCAL [ CAT.HEAD [ MINORS.MIN #min,
                       PRD + ],
            CONT.RELS.LIST.FIRST #keyrel & [ PRED #min ] ],
    LKEYS.KEYREL #keyrel & [ ARG0 event,
                             ARG1 individual ] ].

; DPF 26-aug-07 - Restrict NORM to prevent these from appearing in
; v_mod constructions as in "moving on the river"
; DPF 20-apr-08 - Re 26-aug-07: But this also blocks ordinary copula-be+PP
; so remove, and revisit.  FIX??
;
lex_pp_synsem := norm_lex_pp_synsem & prep_with_spr_synsem &
  [ LOCAL.CAT.VAL.SPR < [ --MIN much_deg_rel,
              	          LOCAL [ CAT.VAL [ SPR *olist*,
                                            COMPS < >,
                                            SPEC < synsem > ],
                                  CONT.HOOK [ LTOP #ltop,
                                              XARG #arg0 ] ] ] >,
    LKEYS.KEYREL [ LBL #ltop,
                   ARG0 #arg0 ] ].

; Ordinary prepositions:

; Moved [ OPT - ] specification to subtypes, to allow "the day before" where
; the complement is missing.
; DPF (9-Mar-99) Made basic_prep_word not inherit from nonmsg, since it has
; its MSG identified with that of its modifiee (via the head_modifier rule)
; and that modifiee will sometimes have a non-empty message, as in
; "Is kim happy in Berlin"
; DPF 19-Nov-01 - Removed COMPS..MSG no_msg, since now want to get "this
; depends on whether kim arrives" and "I'm interested in who you met"
; DPF 25-may-09 - Added MODIFD notmod to avoid spurious ambig for e.g.
; 'barely in Paris'

basic_prep_word := nonc-h-nab &
  [ INFLECTD +,
    SYNSEM [ PUNCT no_punctuation_min,
	     MODIFD notmod ] ].

;; DPF 2016-10-27 - Replaced COMPS..CAT nomp_cat_nonnom_min with the
;; corresponding constraints for nomp_cat and CASE, excluding the SUBJ *olist*
;; constraint which differentiates verbs and prepositions for NPs that are 
;; WH-CPs, as in *we won with what he did*.
;; DPF 2018-06-01 - Added --SIND non_expl to enable chart dependencies to
;; exclude it- and there- copulas
;;
norm_prep_word := basic_prep_word &
  [ SYNSEM basic_norm_trans_prep_synsem &
	 [ LOCAL.CAT.VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT [ HEAD supnoun &
						      [ POSS -, MOD < >,
							CASE non_nom ],
						 VAL [ SPR *olist*,
						       COMPS < > ],
						 MC na_or_- ],
                                           CONT.HOOK.INDEX index,
                                           CONJ cnil ] ] >,
	   --SIND non_expl ] ].

; Changed ref-ind constraint to non_expl-ind so prep's can be used as particles
; DPF 20-Oct-02 - Made SORT of ARG1 and first COMP be identified, to avoid
; spurious ambiguity for e.g. "ten to five"
; DPF 27-Oct-02 - But this runs afoul of the facts (1) that preps identify 
; their own index with that of their MOD's index (since they're intersective),
; (which is also their ARG's index) and (2) that predicative ones identify 
; their XARG index with their ARG's index.  And anyway, "ten to five" doesn't
; use the preposition, but rather the n_x_to_y lexical entry.

prep_word := norm_prep_word &
  [ SYNSEM trans_prep_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ --SIND overt_non_expl-ind ] > ] ].

; DPF 02-Apr-02 - For now, block measure-phrase specifiers of ordinary 
; prepositions -- too many spurious parses.
; DPF 17-Jul-03 - But we're losing too many good sentences, such as "Kim
; arrived a week after me" so removed SPR..LEX +.

p_np_i_le := prep_word & 
"""
Prep, np, intersective           
<ex>B sang for C.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT - ] > ].

; DPF 24-aug-04 - For prepositions like "as" that exclude verbal gerund 
; complements (to avoid spurious ambiguity)
; DPF 29-sept-05 - Also make PRD - to prevent e.g. "*Kim arrived from as 
; Abrams"
; DPF 12-nov-05 - But this prevents these PPs from ever being modifiers,
; so instead tighten constraints on complements of e.g. 'from' to exclude
; these.
; DPF 11-sep-07 - Added SPR < anti_synsem_min > to avoid spurious reading
; for "(as) well as .."

;; DPF 2017-02-27 - Abandoned this type, since the only instance was "as", and
;; we do want to get *I'll go on record as saying that victory is possible*
;;
p_np_i-nger_le := prep_word & 
"""
Prep, np, no gerund              
<ex>B was hired as a writer.
"""
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < anti_synsem_min >,
                           COMPS < [ OPT -,
                                     LOCAL.CAT.HEAD basic_noun ] > ] ].

basic_p_nmod_lexent := norm_prep_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD noun_or_nomger ] >,
                       VAL.COMPS < [ OPT -,
                                     --SIND non_expl-ind ] > ] ].

; DPF 25-oct-05 - Collapsed this type with the following - need PRD + on PPs
; in order to force measure-NPs to be inflected: "ten feet under them" not
; "*ten foot under them".  (was only used for 'about')
;p_nmod_prd_le := basic_p_nmod_lexent & 
;  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].
; DPF 13-mar-10 - Moved SLASH 0-dlist down to subtypes, so we can analyze e.g.
; `the trip to and from Paris'

p_nmod_lexent := basic_p_nmod_lexent &
  [ SYNSEM norm_trans_prep_synsem &
	   [ LOCAL.CAT.HEAD.PRD + ] ].


p_np_i-nm_le := p_nmod_lexent
"""
Prep, np, noun mod               
<ex>B knew a lot about C.
"""
.

; 'than' of "kim had more of them than sandy"
; 13-mar-06 - But we also need this, for now, to get "more to offer than Kim".
; So we'll live with the spurious ambiguity for the simple case.
; DPF 14-may-10 - To allow for the hyper-correct "taller than I", copy the
; relevant constraints from intervening types, and make it basic_prep_word.
;
p_np_i-than_le := basic_prep_word &
"""
Prep, np, 'than' FIX (eliminate) 
<ex>B has more to say than C.
"""
  [ SYNSEM norm_trans_prep_synsem &
	   [ LOCAL.CAT [ HEAD [ PRD +,
				MOD < [ LOCAL.CAT.HEAD noun_or_nomger,
					--MIN part_nom_rel ] > ],
			 VAL.COMPS < synsem & 
				     [ OPT -,
                                       --SIND non_expl-ind,
				       LOCAL [ CAT [ HEAD supnoun &
							  [ POSS -, MOD < > ],
						     VAL [ SPR *olist*,
							   COMPS < > ],
						     MC na_or_- ],
					       CONT.HOOK.INDEX index,
					       CONJ cnil ] ] > ],
             NONLOC.SLASH 0-dlist,
	     --SIND non_expl,
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].


; For "to", to avoid so much ambiguity for e.g. "ten to twelve"
; DPF 3-nov-03 - Changed MOD..MIN from non_temp_nom_rel to norm_nom_rel to
; prevent attachment to proper names.
; DPF 21-dec-05 - Changed COMPS..MIN from non_temp_nonpro_rel to 
; non_temp_nom_rel, since we want 'the road to it is open'
; DPF 30-sept-06 - Re: 3-nov-03 - But this blocks eg. "Berlin to the north
; is cooler."  FIX.
; DPF 10-oct-06 - Okay, made named_np_rel be subtype of this MIN, so now
; get attachment to proper names, and will live with added ambiguity.
; DPF 16-oct-06 - Replaced MOD..MIN norm_nom_or_place_rel with old and better
; non_temp_nom_rel to include partitives as modifiees: "two to Paris"
;; DPF 2020-05-23 - Make MOD.FIRST be synsem, to block these from extracted-adj
;; rule as in *rose [to 10 million]*

p_np_i-nm-no-tm_le := p_nmod_lexent &
"""
Prep, np, non-temp noun mod      
<ex>B went into the house.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD < synsem &
				    [ --MIN non_temp_nom_rel,
                                      LOCAL.CAT.HEAD basic_noun ] >,
                         VAL.COMPS < [ --MIN non_temp_nom_rel ] > ],
                   CONT.HOOK.INDEX.E.TENSE no_tense ] ].

; possessive 'of'
; DPF 28-mar-05 - Removed ARG0..TENSE nontense since this prevents e.g.
; 'Pollock is of what nationality?'  Also removed PRD - for same reason.
; DPF 17-apr-05 - Block SPR from being realized, to avoid spurious analyis
; of e.g. 'bits of rope'
; DPF 18-jul-07 - But this also blocks "mainly of Kim's", so let's instead
; restrict the SPR to being a degree adv.
; DPF 24-jul-07 - Still want to avoid having PPs modify these of-PPs, so
; add hack [AUX +] here.  FIX someday.  Note that currently fail to analyze
; *In Paris, he is of considerable interest.*
; DPF 18-jul-07 - While it was tempting to make the COMP be basic_nonpro_rel,
; to contrast "cats of mine" vs. "*cats of me", this also blocks ordinary
; constructions like "the intensity of it" "the presence of us (in the room)".
; So relax constraint to nom_rel, and wait for more insight about how to
; block "the cats of us".
; DPF 15-apr-08 - Re 24-jul-07: Note that this blocks "This paper is of high
; quality today".  But the extra ambiguity is still a pain, so leave hack in
; for now.
; DPF 2010-11-05 - Constrain SPR..ALTMIN to no_rel in order to prevent 
; meas-NP-deg phrases as in spurious analysis of *three miles of roads*.
;; DPF 2015-03-14 - Re 24-jul-07: It's also wrong to block PP modification of
;; of-PPs: *he was of the same opinion yesterday*, and even 
;; *people of the same opinion yesterday ...*.
;; So removed hack, and choose to live with the spurious ambiguity in e.g.
;; *the cats of New York in winter ...*
;; DPF 2017-09-16 - Generalized COMPS..SPEC from < anti_synsem_min > to
;; *anti_list*, so we can also get measure phrases, as in 
;; *two thirds of the $2 billion* where the of-PP is now treated as normal
;; possessive `of', not selected for.
;; DPF 2020-07-02 - Considered constraining ALTMIN to no_rel to prevent these 
;; in absolutives (np_pred_phr) such as "*[[The trees] [of New York]], we arose"
;; but we also want e.g. jh:3013882 "...two branches... both of equal length".
;;
p_np_i-nm-poss_lexent := basic_p_nmod_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SPR.FIRST.--MIN quant_or_deg_rel,
			   NONLOC.REL 0-dlist ] >,
	      VAL [ SPR < [ LOCAL.CAT.HEAD adv &
					   [ MINORS.ALTMIN no_rel ] ] >,
		    COMPS < synsem &
			    [ --MIN nom_rel,
			      LOCAL.CAT.VAL.SPEC *anti_list* ] > ] ],
	CONT.HOOK.XARG ref-ind ],
      NONLOC.SLASH 0-dlist ] ].

p_np_i-nm-poss_le := p_np_i-nm-poss_lexent
"""
Prep, np, poss 'of'              
<ex>The cities of France grew.
"""
.

p_np_i-nm-poss_le_mal := p_np_i-nm-poss_lexent &
"""
Prep, np, poss 'of'              
<ex>The cities of of France grew.
"""
  [ GENRE robust ].

; 'of mine', 'of Kim's'
; DPF 11-jan-10 - Removed COMPS..MIN implicit_q_rel since this blocked
; `of Kim's', since `Kim's' now has def_explicit_q_rel.
;
p_np_i-poss-gen_le := basic_prep_word &
"""
Prep, np, genitive NP            
<ex>Those dogs of B's barked.
"""
  [ SYNSEM one_arg_prep_synsem &
     [ LOCAL 
        [ CAT [ HEAD [ PRD -,
                       AUX +,
                       TAM.TENSE tense,
                       MOD < [ LOCAL 
		               [ CAT [ HEAD noun,
                                       VAL.SPR 
                                        < [ LOCAL [ CAT.HEAD det,
				                    CONT.HOOK.XARG #cind ],
					    --MIN nodef_q_rel ] > ],
                                 CONT.HOOK.LTOP #ltop ] ] > ],
                VAL.COMPS < synsem &
                            [ LOCAL [ CAT [ HEAD det &
                                               [ MINORS.ALTMIN poss_rel,
						 POSS + ],
                                            VAL [ SPR *olist*,
                                                  SPEC < anti_synsem_min > ] ],
                                      CONT.HOOK.INDEX #cind,
                                      CONJ cnil ],
                              OPT - ] > ],
          CONT [ HOOK.LTOP #ltop,
                 RELS <! prep_relation &
                       [ LBL #ltop,
                         PRED poss_rel,
                         ARG0 [ E [ TENSE no_tense,
                                    ASPECT no_aspect ],
                                --TPC - ],
                         ARG2 #cind ] !>,
                 HCONS <! !>,
		 ICONS <! !> ] ],
       NONLOC.SLASH 0-dlist,
       --SIND non_expl ] ].

p_np_i-ngap_lexent := basic_prep_word & 
  [ SYNSEM norm_prep_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < [ --MIN independent_rel,
					LOCAL intersective_mod &
					      [CAT [ HEAD subst &
							  [ AUX - ],
						     VAL [ SPR.FIRST synsem_min,
							   COMPS < > ] ],
					       CONT.HOOK [ LTOP #ltop,
							   INDEX #mind &
							      basic_non_expl ],
					       CONJ cnil ] ] >,
			   VAL [ COMPS < [ LOCAL [ CAT [ HEAD supnoun &
							      [ POSS -, MOD < >,
								CASE non_nom ],
							 VAL [ SPR *olist*,
							       COMPS < > ],
							 MC na_or_- ],
						   CONT.HOOK [ LTOP #ltop,
							       INDEX #cind ],
						   CONJ cnil ],
					   NONLOC [ SLASH 0-dlist,
						    REL #nlocrel,
						    QUE #nlocque ],
					   OPT - ] >,	 
				 SPR *anti_list* ] ],
		     CONT [ HOOK [ LTOP #lbl,
				   INDEX #arg0 ],
			    RELS <! #rel & relation !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     NONLOC [ SLASH 0-dlist,
		      REL #nlocrel,
		      QUE #nlocque ],
	     LKEYS.KEYREL #rel & [ LBL #lbl,
				   ARG0 #arg0,
				   ARG1 #mind,
				   ARG2 #cind ],
	     --SIND non_expl ] ].

; e.g. since
p_np_i-ngap_le := p_np_i-ngap_lexent
"""
Prep, np, no gap                 
<ex>B has grown since 1990.
"""
.

;; DPF 2016-03-01 - Also prevent these from being extracted as a whole
;;
; e.g. *e.g.*
p_np_i-nmob_le := p_np_i-ngap_lexent &
"""
Prep, np, no gap, not extractable
<ex>B arises, e.g. on Monday.
"""
  [ SYNSEM.LOCAL.CAT.HEAD prep_nonmob ].

p_np_minute_le := basic_prep_word & 
"""
Prep, np, only for minute prep hour
<ex>B arises at ten after three.
"""
  [ SYNSEM basic_prep_synsem &
	   [ LOCAL [ CAT [ HEAD prep_nonmob &
				[ MINORS.MIN conj_rel,
				  MOD < anti_synsem_min > ],
		  	   VAL [ COMPS < synsem & 
                                       [ LOCAL [ CAT nomp_cat_nonnom_min,
                                                 CONT.HOOK.INDEX #rind,
                                                 CONJ cnil ],
				         --MIN numbered_hour_rel,
					 PUNCT.LPUNCT pair_or_no_punct,
					 NONLOC non-local_none ] >,
			         SPR *anti_list* ],
			   POSTHD + ],
		     CONT [ HOOK [ INDEX #ind & ref-ind,
				   XARG #xarg ],
		            RELS <! [ PRED conj_rel & #min,
			              LBL #lbl,
				      ARG0 #ind,
				      ARG1 #rind & non_expl-ind,
				      ARG2 #xarg,
				      CFROM #cfrom, CTO #cto ],
				    [ PRED udef_q_rel,
				      ARG0 #ind,
				      RSTR #rhand,
				      CFROM #cfrom, CTO #cto ] !>,
			    HCONS <! qeq & [ HARG #rhand, LARG #lbl ] !>,
			    ICONS <! !> ] ],
             NONLOC.SLASH 0-dlist,
	     LKEYS.KEYREL.PRED #min,
	     --SIND non_expl ],
    ORTH [ FROM #cfrom, TO #cto ] ].

; For particles
; DPF 31-may-07 - Removed COMPS..INDEX non_expl since we want to allow
; 'We saw to it that Kim left' where "to it" needs expletive "it".
;; DPF 2011-jul-30 - Removed PRD -, since we want these to unify in context
;; where need PRD +, namely in small clauses for gapping: *Kim relies on
;; speed, and Terry on stamina*
;; DPF 2016-10-27 - Removed COMPS..SUBJ *olist* since we want to allow NPs
;; that are WH-CPs here, but still block them as complements of verbs, so now
;; use SUBJ for the contrast.
;; DPF 2020-05-23 - Added INDEX basic_non_expl so particles don't license
;; expletive it/there in parse chart.
;;
gen_p_prtcl_lexent := basic_prep_word & 
 [ SYNSEM gen_prep_nomod_synsem &
     [ LOCAL [ CAT [ HEAD [ MINORS [ MIN selected_prep_rel,
                                     ALTMIN #min ],
                            TAM [ TENSE untensed,
                                  ASPECT no_aspect ] ],
                     VAL [ SPR < anti_synsem_min & 
				 [ --MIN just_only_deg_rel ] >,
                           COMPS < synsem &
                                   [ --MIN #min,
                                     LOCAL [ CAT [ VAL [ COMPS < > ],
                                                   MC na_or_- ],
                                             CONJ cnil ],
				     NONLOC [ REL #nonlocrel,
					      QUE #que ],
                                     OPT - ] > ] ],
	       CONT.HOOK.INDEX basic_non_expl ],
       NONLOC [ REL #nonlocrel,
		QUE #que ] ] ].

basic_p_prtcl_lexent := gen_p_prtcl_lexent &
  [ SYNSEM basic_prep_nomod_synsem &
	   [ LOCAL.CONT.ICONS <! !> ] ].

; DPF 06-may-04 - Changed COMPS..CASE from acc to non_nom to allow obliq
; complement NPs, including WH-S NPs, as in "that depends on who stays"
; DPF 29-may-07 - FIX semantics for "Kim's belief only in Abrams" where
; the LTOP and XARG of "only" need to get bound to something reasonable.
;; DPF 2018-06-04 - It's tempting to reduce parse chart ambiguity by limiting
;; the complement NP to non_expl, but this conflicts with at least the verb
;; *see to it that S*.
;; DPF 2019-10-12 - Changed to identify AGR of particle and complement, to
;; preserve distinction between *one of a group of cats* and **one of a cat*
;;
p_prtcl_lexent := basic_p_prtcl_lexent &
  [ SYNSEM [ LOCAL 
             [ CAT.VAL [ SPR < [ LOCAL.CONT.HOOK.LTOP #sprtop ] >,
                         COMPS < synsem &
				 [ LOCAL [ CAT [ HEAD nominal &
						      [ POSS -,
							MOD < >,
							CASE non_nom ] ],
					   AGR #agr ] ] > ],
	       AGR #agr,
	       CONT.HOOK.LTOP #sprtop ] ] ].

; Disallow measure-NPs for most particle preps (except 'of')
;; DPF 2012-09-21 - The above is a strange constraint, doubly so since now
;; MNPs without an overt determiner already have a non-empty SPEC, so all
;; this was doing was blocking *we rely on a meager $10 to survive*
;; Let's see what else goes wrong by changing it to *anti_list*.
;;
norm_p_prtcl_lexent := p_prtcl_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.VAL [ SPR *olist*,
						     SPEC *anti_list* ] ] >,
		   CONT [ RELS <! !>,
			  HCONS <! !> ] ] ].

;; DPF 2020-05-23 - May not need both this type and p_np_ptcl-ref_le below. FIX
;;
p_np_ptcl_le := norm_p_prtcl_lexent &
"""
Prep, np, sem empty              
<ex>B relies on C.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK #hook,
		   CONT.HOOK #hook & [ XARG basic_non_expl ] ] ].

p_np_ptcl-expl_le := norm_p_prtcl_lexent &
"""
Prep, np, sem empty, expletive complement
<ex>B saw to it that C arrived.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #ltop,
							 INDEX #cind & it-ind ],
		   CONT.HOOK [ LTOP #ltop,
			       INDEX basic_non_expl,
			       XARG #cind ] ] ].

p_np_ptcl-ref_le := norm_p_prtcl_lexent &
"""
Prep, np, sem empty, no expletive compl
<ex>The salmon was devoured by the bear
<nex>He was annoyed by it to shave himself
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST [ --SIND non_expl,
					 LOCAL.CONT.HOOK #hook ],
		   CONT.HOOK #hook ] ].

p_nb_ptcl_le := p_prtcl_lexent &
"""
Prep, nbar, sem empty              
<ex>B promoted C to vice president.
"""
  [ SYNSEM.LOCAL 
    [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD noun,
				      VAL [ SPR.FIRST synsem & [ OPT - ],
					    SPEC *anti_list* ] ],
		                CONT.HOOK #hook & [ LTOP #nhand,
						    INDEX #ind ] ] ] >,
      CONT [ HOOK #hook,
	     RELS <! [ PRED udef_q_rel,
		       ARG0 #ind & ref-ind,
		       RSTR #rhand,
		       CFROM #cfrom, CTO #cto ] !>,
	     HCONS <! qeq & [ HARG #rhand,
			      LARG #nhand ] !> ] ],
    ORTH [ FROM #cfrom, TO #cto ] ].


; DPF - This is a place-holder solution for equative and comparative phrases,
; until we work out an adequate semantics for e.g. "taller than Abrams" or
; "as soon as convenient"
; DPF 31-mar-05 COMPS..MOD *anti_list* excludes subord-preps as in spurious
; analysis for "(as soon) as possible"
; DPF 13-nov-05 - But this also prevents lexical PPs like "before" which
; make MOD be synsem.  So let's use NORM norm_non_num_rel instead, 
; DPF 15-jul-07 - Removed COMPS..CASE non_nom, since we want "taller than he"
; in formal written English. 
;; DPF 2013-10-26 - This no-gap constraint just seems wrong: 
;; *Who is Kim taller than?*
;; So we remove it, and see what happens.
;; DPF 2016-01-30 - Push COMPS..NORM norm_non_num_rel down to the non_NP-taking
;; subtype, so we can get e.g. *than Italian* where *Italian* happens to have
;; NORM no_rel.

; For VP,AP,PP, and NP complements
p_noslash_prtcl_lexent := basic_p_prtcl_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT.VAL.COMPS < synsem &
                        [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_rel,
                                        VAL.SPR *olist* ],
				  CONT.HOOK.INDEX #index ],
			  NONLOC.SLASH #slash ] >,
	CONT [ HOOK.INDEX #index,
	       RELS <! !>,
	       HCONS <! !> ] ],
      NONLOC.SLASH #slash,
      --SIND non_expl ] ].

; For VP,AP,PP complements, where need to bind LTOP
; 30-aug-05 - Can't have PRD + on COMPS since this would block
; 'as soon as Kim arrives'
; 14-nov-05 - But to block "than in" we'll try constraining the COMPS..MOD
; to be an *anti_list* which excludes lexical PPs.
;; 2010-10-23 - Re 14-nov-05: But this blocks "easier than before".  So to
;; distinguish "in" from "before", constrain MOD to be [HEAD verb], even
;; though this blocks adjectives; make separate type for these.
;; DPF 2015-07-20 - The COMPS..ALTMIN role_rel blocks *than ever*, so let's
;; try doing without, and accept the (possibly correct) ambiguity of e.g.
;; *than Tuesday*
;; DPF 2017-09-27 - Re 30-aug-05: But we do now get *as soon as Kim arrives*
;; without using this type, so let's put PRD + back on complement, so we can
;; block **we would rather arrive than arises*.  Note that this means we can't
;; treat *we would rather arrive than arise* with the comparative `than' since
;; `rather' blocks the CP-taking `than' (to avoid **kim would rather arise than
;; seemed possible* - cf. *Kim arrived more quickly than seemed possible*).
;; So we instead use the correlative conjunction pair `rather...than' and treat
;; *would rather arrive than arise* as VP-coordination.  
;;
p_prd_ptcl-ngap_lexent := p_noslash_prtcl_lexent &
  [ SYNSEM.LOCAL 
           [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD v_or_a_or_p &
                                             [ MINORS 
						[ MIN independent_rel,
						  NORM norm_non_num_rel ],
					       MOD.FIRST.LOCAL intersective_mod,
					       PRD + ],
					     VAL.SUBJ *synlist* ],
				       CONT.HOOK [ LTOP #ltop,
                                                   INDEX.SF basic-prop ] ],
                               NONLOC.REL 0-dlist ] >,
             CONT.HOOK.LTOP #ltop ] ].

p_prd_ptcl-ngap_le := p_prd_ptcl-ngap_lexent &
"""
Prep, prdp (PP or VP)
<ex>B was better than in Paris.
<ex>Who is B better than?
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.MOD 
					     < [ LOCAL.CAT.HEAD verb ] > ] > ].

p_prd_ptcl-j_le := p_prd_ptcl-ngap_lexent &
"""
Prep, AP comp, no gap
<ex>B was the opposite of happy.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < canonical_synsem &
				 [ LOCAL.CAT.HEAD adj & 
						  [ PRD +,
						    MOD < synsem > ] ] > ].

; For NP complements, where cannot bind LTOP (given that for some lexical NPs
; like 'anyone' or 'that', the LTOP exposes the nominal relation's LBL, in
; order to support intersective post-nom modification, e.g. 'anyone in Paris')
; DPF 23-jun-08 - With improved treatment of lexical NPs, can now bind LTOP
; as we should.
; DPF 25-may-09 - Changed COMPS..HEAD back from noun_or_gerund to nominal,
; since no record of why changed, and we were blocking "higher than now"
;; 2010-10-24 - Added COMPS..PRD + to avoid spurious ambiguity for 
;; npadv measure-NPs as in *as big as a dollar*
;; DPF 2012-11-07 - Added COMPS..MOD < > to block predicative NPs, as in
;; *than president*
;; DPF 2020-05-08 - To block *it is better to win than losing* in place of
;; *it is better to win than to lose*, use hack of CASE obliq here, and
;; CASE acc for than+VP.
;;
p_np_ptcl-ngap_le := p_noslash_prtcl_lexent &
"""
Prep, np, sem empty, no gap      
<ex>B is taller than C.
"""
  [ SYNSEM.LOCAL [ CAT [ VAL.COMPS < [ LOCAL [ CAT.HEAD nominal & 
						      [ PRD +,
							MOD < >,
							CASE real_case ],
					     CONT.HOOK [ LTOP #ltop,
							 INDEX ref-ind ] ] ] >,
			 HEAD.CASE obliq ],
		   CONT.HOOK.LTOP #ltop ] ].

;; DPF 2016-04-22 - Propagate --BARE from NP complement to phrase, so we can
;; avoid mal-rule analysis of *what kind of cat* with bare-sg *cat*.

p_np_ptcl-of_le := p_prtcl_lexent &
"""
Prep, np, sem empty, meas-np ok  
<ex>B reached a height of 3 ft
"""
  [ SYNSEM.LOCAL [ CAT [ VAL.COMPS.FIRST.LOCAL [ CAT [ VAL.SPR *olist*,
						       HEAD.--BARE #bare ],
						 CONT.HOOK #hook ],
			 HEAD.--BARE #bare ],
		   CONT [ HOOK #hook,
			  RELS <! !>,
			  HCONS <! !> ] ] ].

addin_cp_basic_prep_synsem := basic_prep_nomod_synsem & cp_addin_tam_pn.
addin_cp_prep_nomod_synsem := gen_prep_nomod_synsem & cp_addin_tam_pn.

;; DPF 2017-09-27 - Make these NORM no_rel so we can block these gapped
;; than-CPs for `rather, sooner' as in **we would rather arise than he did*
;; DPF 2020-05-23 - Algebra mismatch.  FIX.
;;
; 'Kim hired more consultants than Abrams did'
p_cp_ptcl-ell_le := basic_p_prtcl_lexent &
"""
Prep, S-elided, particle         
<ex>B hired more than C did.
"""
  [ SYNSEM addin_cp_basic_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD.MINORS.NORM norm_rel,
	      VAL [ COMPS < synsem & #keycomp &
                        [ LOCAL [ CAT [ HEAD verb & 
                                             [ MINORS.ALTMIN ellipsis_rel ],
                                        VAL [ SUBJ *anti_list*,
					      SPR *olist* ],
                                        MC - ],
                                  CONT.HOOK.LTOP #ltop ],
                          NONLOC non-local_none ] >,
		    KCMP #keycomp ] ],
        CONT [ HOOK.INDEX #ltop,
	       RELS <! !>,
	       HCONS <! !> ] ],
      NONLOC.SLASH 0-dlist ] ].

;; DPF 2018-04-03 - Remove NORM no_rel to get "less than he ate"
;; DPF 2018-06-01 - Note that this type surprisingly identifies INDEX with
;; the comp's LTOP, so the comparative predication can preserve scope for
;; the argument supplied by *than ...*.
;; DPF 2020-05-23 - Algebra mismatch.  FIX.
;;
p_cp_ptcl-gap_lexent := gen_p_prtcl_lexent &
  [ SYNSEM addin_cp_prep_nomod_synsem &
    [ LOCAL 
      [ CAT [ VAL [ COMPS < synsem & #keycomp &
                        [ LOCAL [ CAT [ HEAD verb & 
                                             [ MINORS.ALTMIN non_ellipt_rel,
					       TAM indic_tam ],
                                        VAL [ SUBJ *anti_list*,
					      SPR *olist* ],
                                        MC - ],
                                  CONT.HOOK [ LTOP #ltop,
					      INDEX.SF basic-prop ] ] ] >,
		    KCMP #keycomp ] ],
        CONT.HOOK.INDEX #ltop & handle ],
      NONLOC.SLASH 0-dlist ] ].

;; DPF 2018-04-08 - Block subject gap: *this is easier than disappear*
p_cp_ptcl-npgap_le := p_cp_ptcl-gap_lexent &
"""
Prep, S-with-NP-gap, particle       
<ex>B hired more than C hired.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ NONLOC.SLASH <! [ CAT.HEAD noun,
						       CONT.HOOK [ INDEX #ind &
								      ref-ind],
						       AGR #slagr ] !> ] >,
		   CONT [ HOOK.XARG #ind,
			  RELS <! [ PRED udef_q_rel,
				    ARG0 #ind,
				    RSTR #rhand,
				    CFROM #cfrom, CTO #cto ],
				  [ LBL #nhand,
				    ARG0 #ind,
				    PRED generic_entity_rel,
				    CFROM #cfrom, CTO #cto ] !>,
			  HCONS <! qeq & [ HARG #rhand,
					   LARG #nhand ] !>,
			  ICONS <! !> ],
		   AGR #slagr ],
    ORTH [ FROM #cfrom, TO #cto ] ].

;; DPF 2016-08-01 - The COMPS..SLASH..HEAD was just `mobile' but should be
;; `prep' to exclude CP-gaps as in *it is higher than the treaty allows*.
;;
p_cp_ptcl-ppgap_le := p_cp_ptcl-gap_lexent &
"""
Prep, S-with-PP-gap, particle       
<ex>B arrived as soon as we disappeared.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ NONLOC.SLASH <! [ CAT.HEAD prep & 
							    [ MOD < synsem > ],
						       CONT.HOOK.XARG #event &
							  non_expl ] !> ] >,
		   CONT [ HOOK.XARG #event,
			  RELS <! !>,
			  HCONS <! !>,
			  ICONS <! !> ] ] ].

; *easier to arise than to sleep*
;; DPF 2018-03-31 - Distinguish VP-inf from VP-bse complement, to block
;; **there is nothing more important than read this book* contrasted with
;; *there is nothing more important than to read this book*.
;; DPF 2020-05-08 - To block *it is better to win than losing* in place of
;; *it is better to win than to lose*, use hack of CASE acc here, and
;; CASE obl for than+NP.
;;
p_vp_ptcl-ngap_lexent := p_noslash_prtcl_lexent &
  [ SYNSEM.LOCAL 
           [ CAT [ VAL.COMPS < [ LOCAL [ CAT vp_cat &
					     [ HEAD.VFORM bse_or_inf ],
					 CONT.HOOK #hook ],
				 NONLOC.REL 0-dlist ] >,
		   HEAD.CASE acc ],
             CONT.HOOK #hook ] ].

p_vp_ptcl-ngap_le := p_vp_ptcl-ngap_lexent &
"""
Prep, inf VP with no gap, particle       
<ex>It is easier to stay than to go.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM inf ].

p_vp_ptcl-ngap-bse_le := p_vp_ptcl-ngap_lexent &
"""
Prep, base VP with no gap, particle       
<ex>It is easier to stay than go.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.NORM no_rel,
                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VFORM bse ] ].

; DPF 8-Jan-02 - Added constraint on SPR to exclude measure-NP specifiers, as
; in "*There are a book in the office"
; DPF 1-Jun-09 - Re 8-Jan-02: But this also excludes coordinated sprs, as in
; 'Kim arrived nearly but not entirely in readiness.'  So 
p_reg_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN non_temp_nom_rel,
				   OPT - ] > ].


; DPF 25-oct-05 - Make [PRD +] to force measure-NP specs to be inflected:
; "ten feet under the ground" not "*ten foot under the ground".  
p_np_i-reg_le := p_reg_lexent &
"""
Prep, np, non-temp               
<ex>B stood behind C.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].

; DPF 02-Apr-02 - blocks e.g. "an office by Sandy" as in "kim was shown an 
; office by Sandy".  Hack, since it also blocks "Kim lives right by the river"
; DPF 31-oct-03 - Changed this constraint from SPR < unexpressed > to 
; restriction excluding measure NPs which are now [HEAD noun].
; DPF 18-mar-05 - Further constrained to locative sense which does not take
; gerundive complements, and introduce separate "by" for "by means of", to
; enable blocking of unwanted coordinations such as "from here and by arriving"
; And further constrained to prevent stranding, though this may be too strong:
; "?Which library is that tree by?"
;; DPF 2017-06-09 - Re 18-mar-05: Yes, too strong, since it also prevents RNR
;; as in *by and for the people*.

p_np_i-dgsp_le := p_reg_lexent &
"""
Prep, np, no meas-np specifier.  Only *by*
<ex>B stood right by C.
"""
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                           COMPS < [ --SIND.SORT entity ] > ] ].

; For "from" of "ten weeks from now" where in AmEng we block "he'll be here
; from now".

p_np_i-oblsp_le := p_temp_lexent &
"""
Prep, np, obl specifier          
<ex>B arrives a week from now.
"""
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < expressed_synsem >,
                             COMPS < [ OPT -,
                                       LEX + ] > ],
             LKEYS.--COMPKEY temp_abstr_rel ] ].

; 'by hiring Abrams'
; DPF 29-may-09 - Relaxed MOD..HEAD to include nominals, as in
; 'Kim, by arriving, surprised us.'
p_np_i-ger_le := p_reg_lexent &
"""
Prep, np, gerund                 
<ex>B won by singing well.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD n_or_v_or_a ] >,
                       VAL [ SPR < [ LOCAL.CAT.HEAD adv ] >,
                             COMPS < canonical_synsem &
                                     [ LOCAL.CAT.HEAD supnoun,
                                       --SIND.SORT nom-event,
				       --MIN nonpro_rel ] > ] ] ].

; DPF 24-Oct-01 - Added identity of AGR..PN, DIV and NP comp's AGR..PN, DIV to
; support agreement in partitives, as in "none of the rice arrives" but "*none
; of the rice arrive"
; DPF 1-Mar-02 - Removed TAM.TENSE no_tense since this blocked predicative 
; of-PP as in "this picture is of Sandy".  Also replaced
; [MOD..MIN never_unify_rel] with never_unify_event_rel since it blocked the 
; no-copula "a chance of rain".
; DPF 17-Apr-03 - Identified prep's ALTMIN with its complement's MIN, to
; preserve visibility of the embedded NP's MIN for NP's like
; 'both of the days' where this can still serve as an adverbial modifier,
; while 'both of the chairs' cannot.
; DPF 2-Sept-04 - Restricted MOD..INDEX to ref-ind, to block "a bit of rain"
; as a no_copula construction (contra 1-Mar-02 view - now treat those as
; NP fragments).

; DPF 31-May-02 - Constrain to only modify nominals.
;; DPF 2016-10-18 - Re 31-May-02: Until we have a general mechanism for allowing
;; VP-final post-posing of post-modifiers of subject nouns, we'll relax this
;; plausible constraint so we can also get *nothing was to be seen but the sky*
;; DPF 2017-09-28 - We want to avoid this type in *but Kim was a surprise*, so
;; require MOD to be expressed.
;; DPF 2018-02-15 - Exclude nominalized questions, to avoid this analysis for
;; *we departed but he remained*
;;
p_np_i-nsp-ngap_le := prep_word & 
"""
Prep, np, no gap, no specifier, non-mobile
<ex>B won nothing but the gold
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD.FIRST expressed_synsem,
		         VAL [ SPR < unexpressed >,
                               COMPS < [ OPT -,
		  		         --SIND.SORT norm-entity-or-event,
                                         NONLOC.SLASH 0-dlist ] > ] ],
		   CTXT.ACTIVATED - ] ].

p_temp_lexent :=  basic_prep_word &
  [ SYNSEM trans_prep_synsem &
	 [ LOCAL.CAT [ HEAD.MINORS.MIN temp_loc_rel,
                       VAL.COMPS < synsem & 
                                 [ LOCAL [ CAT [ HEAD nominal &
                                                      [ CASE non_nom,
                                                        POSS - ],
                                                 VAL [ SUBJ *olist*,
                                                       SPR *olist*,
                                                       COMPS < > ],
                                                 MC na ],
                                           CONJ cnil ],
                                   OPT - ] > ],
	   --SIND non_expl ] ].

p_np_i-tmp_le := p_temp_lexent
"""
Prep, np, temporal               
<ex>The game on Monday is here
"""
.

;; DPF 2016-08-10 - Generalize from MOD..HEAD v_or_p to v_or_a_or_p in order
;; to also get *I'll be awake by then*
;; DPF 2019-11-15 - Changed entry for "by" from this type to the one above,
;; so we can get *Cats who by then had eaten slept*.
;;
p_np_i-tmp-vm_le := p_temp_lexent &
"""
Prep, np, temporal, vp mod       
<ex>B had won by Friday.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a_or_p ] >,
                       VAL.SPR < [ LOCAL.CAT.HEAD adv ] > ] ].

; Used e.g. for "from", as in "from under the table"
; DPF 6-Apr-01 - Also used for "worth" as in "ten dollars worth of food"
; DPF 01-sept-04 - Removed PRD + since it prevents "Kim put it back in the box"
; DPF 29-sept-05 - Added COMPS..PRD + to block depictives as complements:
; "*Kim arrived from happy."
; DPF 21-may-06 - Changed MOD n_or_v to MOD n_or_v_or_a
;; DPF 2015-09-21 - Replaced SLASH 0-dlist with SLASH.LIST *arglist* so we
;; can get *the place where she came from* even though we don't have an NP
;; variant for relative "where".
;; DPF 2018-02-24 - Re 2015-09-21 - But this *arglist* means we can't parse
;; *in Paris, cats were admired except near the Louvre* because "except"
;; restricts the SLASH to a type which is incompatible with the extracted
;; modifier of *admired*.  Anyway, we now do have an NP relative pronoun *where*
;; so we go back to SLASH 0-dlist here.
;;
p_ppcomp_lexent := basic_prep_word &
  [ SYNSEM one_arg_prep_synsem &
	 [ LOCAL [ CAT [ HEAD [ PRD +,
                                TAM.TENSE tense,
                                MOD < [ LOCAL.CAT 
                                         [ HEAD subst,
                                           VAL.SPR < synsem_min, ... > ] ] > ],
                         VAL.COMPS < synsem &
				   [ --MIN #min,
				     OPT -,
                                     LOCAL [ CAT [ HEAD prep &
                                                        [ PRD + ],
						   VAL [ SPR *olist*,
							 COMPS < > ] ],
					     CONJ cnil ] ] > ],
                   CONT [ HOOK.XARG non_expl,
                          RELS.LIST < prep_relation, ... >,
			  ICONS <! !> ] ],
           NONLOC.SLASH 0-dlist,
           LKEYS.--COMPKEY #min,
	   --SIND non_expl ] ].

;; 2020-05-11 - Added COMPS..INDEX..TENSE no_tense
;;
p_pp_i-coprd_lexent := p_ppcomp_lexent &
  [ SYNSEM one_arg_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD.PRD +,
              VAL.COMPS < [ --MIN loc_abstr_rel,
                            LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
                                    CONT.HOOK [ LTOP #ltop,
						INDEX.E.TENSE no_tense,
                                                XARG #ind ] ],
			    NONLOC.REL 0-dlist,
                            --SIND event ] > ],
        CONT [ HOOK [ LTOP #ltop,
		      INDEX #ind ],
	       RELS <! relation !>,
	       HCONS <! !> ] ] ] ].

;; DPF 2012-04-02 - Restrict complement to nonlex_synsem to avoid analysis for
;; *in on*
p_pp_i-coprd_le := p_pp_i-coprd_lexent &
"""
Prep, pp, no lex-pp complements, not modifying PPs
<ex>B wins except on clay.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD n_or_v_or_a ] >,
		       VAL.COMPS < nonlex_synsem > ] ].

p_pp_i-coprd-lx_le := p_pp_i-coprd_lexent
"""
Prep, pp, can also take lex-pps and modify PPs
<ex>B directed from within.
"""
.

p_ppcomp_scop_lexent := p_ppcomp_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD subst ] >,
			   VAL.COMPS < [ --MIN independent_rel,
					 LOCAL.CONT.HOOK.LTOP #cltop ] > ],
		     CONT [ HCONS <! qeq & [ HARG #arg2, LARG #cltop ] !> ] ],
	     LKEYS.KEYREL.ARG2 #arg2 ] ].

p_pp_i_le := p_ppcomp_scop_lexent &
"""
Prep, pp, not modifying PPs
<ex>B bought books, such as for C.
"""
  [ SYNSEM.LOCAL [ CAT [ VAL.COMPS < [ LOCAL [ CAT.HEAD.MOD 
						 < [ LOCAL intersective_mod ] >,
					       CONT.HOOK.XARG #xarg ] ] > ],
		   CONT [ HOOK.XARG #xarg,
			  RELS <! relation !> ] ] ].

p_pp_s_le := p_ppcomp_scop_lexent &
"""
Prep, subord-PP complement
<ex>B bought books, except as prohibited.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.MOD
					       < [ LOCAL scopal_mod ] >,
					     CONT.HOOK.XARG #xarg ] ] >,
		   CONT.RELS <! relation, [ PRED ellipsis_rel,
					    LBL #xarg,
					    ARG0 event ] !> ] ].

; 'from now on', maybe 'from two to four'
p_ditrans_lexent := noncs-m &
  [ SYNSEM ditrans_prep_synsem &
	 [ LOCAL [ CAT.VAL.COMPS < synsem & [ LOCAL [ CONJ cnil ],
                                            OPT - ], 
                                 synsem & [ LOCAL.CAT.MC na,
                                            NONLOC.QUE.LIST *paramlist*,
                                            OPT -,
                                            PUNCT.LPUNCT no_punct ] >,
                   CONT.HOOK.LTOP #ltop ],
           LKEYS [ KEYREL.LBL #ltop,
                   --COMPKEY #cmin,
                   --+COMPKEY #cmin,
                   --OCOMPKEY #ocmin,
                   --+OCOMPKEY #ocmin ] ] ].

p_np-ptcl_i_le := p_ditrans_lexent &
"""
Prep, np, prtcl, only 'from'     
<ex>B won from Monday on.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT nomp_cat_acc_min,
                                             CONT.HOOK [ LTOP #ltop,
							 INDEX index ] ] ],
                                   [ LOCAL [ CAT.VAL.COMPS < synsem >,
                                             CONT.HOOK.LTOP #ltop ],
                                     NONLOC non-local_none,
                                     LEX + ] >,
                   CONT [ HOOK.LTOP #ltop,
                          RELS <! relation !>,
                          HCONS <! !>,
			  ICONS <! !> ] ] ].
                                                 
;; DPF 2012-08-01 - Changed to make the second PP complement supply its own 
;; semantics, rather than being a semantically empty PP.
;;
p_ditrans_from_to_lexent := p_ditrans_lexent &
  [ SYNSEM 
    [ LOCAL [ CAT.VAL.COMPS < [ --SIND #arg2,
                                LOCAL.CAT.HEAD.MINORS 
                                       [ MIN nonpro_rel,
                                         ALTMIN quant_rel ] ],
                              [ LOCAL [ CAT.VAL.COMPS < >,
                                        CONT.HOOK [ LTOP #ltop,
						    INDEX non_expl,
						    XARG #xarg ] ] ] >,
	      CONT.HOOK [ LTOP #ltop,
			  XARG #xarg ] ],
      LKEYS.KEYREL.ARG2 #arg2 ] ].

p_np-pp_i-frm-to_le := p_ditrans_from_to_lexent &
"""
Prep, np, pp, only 'from'        
<ex>B won from April to July.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CAT nomp_cat_acc_min,
                                               CONT.HOOK [ LTOP #ltop,
							   INDEX index ] ],
                   CONT [ HOOK.LTOP #ltop,
			  RELS <! relation !>,
                          HCONS <! !>,
			  ICONS <! !> ] ] ].

;; DPF 2012-12-21 - Added more general --MIN gen_nom_nbar_rel instead of 
;; non_temp_nbar_rel.
;; DPF 2020-03-24 - Removed second comp's --MIN _to_p_nbar_rel per trunk
;;
p_nb-pp_i-frm-to_le := p_ditrans_from_to_lexent &
"""
Prep, nbar, pp, only 'from'      
<ex>B ran from room to room.
"""
  [ SYNSEM [ LOCAL
             [ CAT.VAL.COMPS
                      < abstr_lex_synsem &
                        [ OPT -,
                          --MIN gen_nom_nbar_rel,
                          LOCAL [ CAT [ HEAD noun,
                                        VAL [ SPR < synsem &
                                                    [ LOCAL.CAT.HEAD det,
                                                      NONLOC [ SLASH 0-dlist,
                                                               QUE 0-dlist ]]>,
                                              COMPS < > ] ],
                                  CONT.HOOK [ LTOP #nhand,
                                              INDEX #arg ] ],
                          NONLOC.SLASH 0-dlist ],
                        [ ] >,
               CONT [ RELS <! relation,
			  #altkeyrel &
                          [ PRED udef_q_rel,
                            ARG0 #arg & ref-ind,
                            RSTR #rhand ] !>,
                      HCONS <! qeq & [ HARG #rhand,
                                       LARG #nhand ] !>,
		      ICONS <! !> ] ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

; DPF 13-Mar-02 - Changed PRD - to PRD +: "the response was as expected"
; DPF 2-Jul-02 - Added MOD..HEAD verb to prevent spurious analysis for e.g.
; "Abrams sees Browne as being a competent manager."
; DPF 8-Jun-03 - Split this "as" into two lexical entries, one with an
; independent rel, taking verbal (PRD +) complements and able to serve as a 
; modifier phrase or copular complement, and one with a selected_rel
; taking adj-or-prep complements, but MOD < >. and nonprd.
;; DPF 2012-06-15 - Corrected semantic composition so the ARG2 is a handle,
;; not the VP's event.
;; DPF 2018-03-25 - Re 2-Jul-02: We also want *papers as described*, so
;; generalize MOD..HEAD to n_or_v

p_vp_i_le := basic_prep_word &
"""
Prep, vp(prd), only 'as'         
<ex>The price was as expected.
"""
  [ SYNSEM basic_one_arg_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ PRD +,
                     MOD < [ LOCAL.CAT.HEAD n_or_v ] > ],
              VAL [ COMPS < synsem &
                            [ LOCAL [ CAT prd_cat & [ HEAD verb ],
                                      CONJ cnil,
                                      CONT.HOOK [ LTOP #cltop,
						  XARG #xarg ] ],
                              NONLOC [ SLASH 0-dlist,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT - ] >,
                    SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                [ MIN much_deg_rel,
                                                  ALTMIN abstr_meas_nom_rel ],
                                          VAL [ SPR *olist*,
						SPEC < synsem >,
						COMPS *olist* ] ],
				    CONT.HOOK [ LTOP #ltop,
                                                XARG #ind ] ] ] > ] ],
        CONT [ HOOK [ LTOP #ltop,
		      INDEX #ind,
		      XARG #xarg ],
               RELS <! prep_relation & [ LBL #ltop,
					 ARG0 #ind,
					 ARG2 #arg2 ] !>,
               HCONS <! qeq & [ HARG #arg2, LARG #cltop ] !>,
	       ICONS <! !> ] ],
      --SIND non_expl ] ].

p_vp_i-inf_le := basic_prep_word &
"""
Prep, vp(inf), only 'as'         
<ex>The price was not so high as to scare us
"""
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ PRD +,
                     MOD < anti_synsem > ],
              VAL [ COMPS < synsem &
                            [ LOCAL [ CAT vp_inf_cat,
                                      CONJ cnil,
                                      CONT.HOOK #hook & [ LTOP #ltop,
							  INDEX #ind ] ],
                              NONLOC [ SLASH 0-dlist,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT - ] >,
                    SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                [ MIN much_deg_rel,
                                                  ALTMIN abstr_meas_nom_rel ],
                                          VAL.SPR *olist* ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #ind ] ] ] > ] ],
        CONT [ HOOK #hook,
               RELS <! prep_relation & [ LBL #ltop,
                                         ARG0 #ind ] !>,
               HCONS <! !>,
	       ICONS <! !> ] ],
      --SIND non_expl ] ].

p_prd_ptcl_le := basic_prep_word &
"""
Prep, prdp, sem empty            
<ex>B strikes C as clever.
"""
  [ SYNSEM basic_prep_nomod_synsem &
           [ LOCAL 
             [ CAT [ HEAD.PRD -,
                     VAL [ SPR < [ LOCAL.CAT.VAL.SPR *unexplist*,
				   --MIN just_only_deg_rel ] >,
                           COMPS < synsem &
                                   [ LOCAL [ CAT prd_cat,
                                             CONJ cnil,
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #ind,
                                                         XARG #xarg ] ],
                                     NONLOC [ SLASH 0-dlist,
                                              QUE 0-dlist,
                                              REL 0-dlist ],
                                     OPT - ] > ] ],
               CONT [ HOOK [ LTOP #ltop,
                             INDEX #ind,
                             XARG #xarg ],
                      RELS <! !>,
                      HCONS <! !>,
		      ICONS <! !> ] ],
	     --SIND non_expl ] ].

; when: "use of this device when shaving/angry/in Berlin is ..."
;; DPF 2017-06-08 - Also for "until and while", so we can get coord PPs such as
;; *cook for three minutes or until done*
;; *go shopping in paris and while in London*
;;
p_prd_i_le := basic_prep_word &
"""
Prep, prdp, n mod,
<ex>Kids when hungry complain.
"""
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ PRD +,
                     MOD < [ LOCAL.CAT.HEAD subst ] > ],
              VAL [ COMPS < synsem &
                            [ LOCAL [ CAT prd_cat &
					  [ HEAD.MOD.FIRST unexpressed ],
				      CONT.HOOK [ LTOP #ltop,
						  XARG non_expl-ind ],
                                      CONJ cnil ],
                              NONLOC [ SLASH 0-dlist,
                                       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT - ] >,
                    SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                                [ MIN much_deg_rel,
                                                  ALTMIN abstr_meas_nom_rel ],
                                          VAL.SPR *olist* ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #arg0 ] ] ] > ] ],
        CONT [ HOOK [ LTOP #ltop,
                      INDEX #arg0 & non_conj_event ],
               RELS <! prep_relation !>,
               HCONS <! !>,
	       ICONS <! !> ] ] ] ].

; Prepositions that don't modify nominals - e.g, 'until'

; DPF 25-oct-05 - Make [PRD +] to force measure-NP specs to be inflected:
; "ten feet under the ground" not "*ten foot under the ground".  

p_no_nmod_lexent := prep_word &
  [ SYNSEM.LOCAL.CAT [ HEAD [ MOD < [ LOCAL.CAT.HEAD v_or_a_or_p ] >,
                              PRD + ],
                       VAL.COMPS < [ OPT - ] > ] ].

; DPF 1-May-03 - Additionally, block phrasal degree specifiers to avoid
; spurious reading for "Abrams showed an office to Browne".
; DPF 26-sep-07 - Added [CASE obliq] to allow us to block these from the
; it-cleft copula as in "It was to Kim that we ran".
; DPF 2010-08-16 - Added restriction that NP complement is not temporal,
; though this is not principled, to avoid spurious analyses for e.g.
; "We came down early".  FIX someday ??
; DPF 2010-09-17 - Re 2010-08-16: This blocks "continued into the evening".
; so split into two subtypes, one excluding temporals, the other not.

p_np_i-nnm_lexent := p_no_nmod_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE obliq,
		       VAL.SPR < [ LEX + ] > ] ].

; 'into'
p_np_i-nnm_le := p_np_i-nnm_lexent
"""
Prep, NP, no noun mod            
<ex>B ran up the hill.
"""
.


p_np_i-nnm_le_mal := p_np_i-nnm_lexent &
"""
Prep, NP, no noun mod, robust
<ex>B ran to to the hill.
"""
  [ GENRE robust ].

; "down"
p_np_i-nnm-nt_le := p_no_nmod_lexent &
"""
Prep, NP, no noun mod, no temporal complement
<ex>B ran up the hill.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.CASE obliq,
		       VAL [ SPR < [ LEX + ] >,
			     COMPS < [ --MIN non_temp_nom_rel ] > ] ] ].

; Additionally block pronominal NP complements - e.g. 'as'
p_np_i-nnm-npro_le := p_no_nmod_lexent &
"""
Prep, NP, nonpro, no noun mod    
<ex>B waited until the end.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN nonpro_rel ] > ].

; For colon lexical entry
p_np_i-nnm-ngap_le := p_no_nmod_lexent &
"""
Prep, NP, nonpro, no gap *:*     
<ex>C likes cats: red ones.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MOD < synsem >,
				CASE obliq ],
                         VAL [ SPR < anti_synsem_min >,
			       COMPS < [ --MIN basic_nonpro_rel ] > ] ],
             NONLOC.SLASH 0-dlist,
             LKEYS.KEYREL prep_notense_relation ] ].

; "Case-marking" prepositions, which cannot be modifiers
; and (let's assume) also cannot be modified, so stipulate [ SUBJ < > ].
;
; DPF 10-Jun-99 - But they can take specifiers: "Kim fell nearly to the bottom"

gen_prep_nomod_synsem := lex_synsem & prep_with_spr_synsem &
			 prep_p_synsem &
  [ LOCAL [ CAT [ HEAD prep & [ MOD < > ],
		  VAL [ SPR < [ OPT +,
                                LOCAL [ CAT [ HEAD adv,
                                              VAL [ SPR *olist*,
						    SPEC < synsem >,
                                                    COMPS < > ] ],
                                        CONT.HOOK [ LTOP #ltop,
                                                    XARG #arg0 ] ] ] >,
                        COMPS < synsem & 
				[ OPT -,
                                  --MIN #cmin ] > ] ] ],
    LKEYS [ KEYREL basic_arg12_relation & [ PRED prep_rel,
                                            LBL #ltop,
                                            ARG0 #arg0 ],
            --COMPKEY #cmin ] ].

basic_prep_nomod_synsem := gen_prep_nomod_synsem & basic_one_arg.

prep_nomod_synsem := basic_prep_nomod_synsem &
  [ LOCAL [ CAT [ HEAD.PRD +,
                  VAL [ SPR < [ --MIN much_deg_rel ] >,
                        COMPS < [ --SIND #ind,
                                  NONLOC [ QUE.LIST *paramlist*,
                                           SLASH 0-dlist ] ] > ] ],
	    CONT [ HOOK [ INDEX #arg0,
                          XARG #pind ],
                   RELS <! prep_relation & #keyrel !>,
                   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel &
                 [ ARG0 #arg0,
                   ARG1 #pind,
                   ARG2 #ind ] ].

; Lexical PPs

basic_pp_word := noncqrs-hm-nab &
  [ SYNSEM lex_pp_synsem &
    [ LOCAL [ CAT [ VAL.SPR < [ OPT +,
				LOCAL.CAT.HEAD n_or_adv &
				[ MINORS [ MIN much_deg_rel,
					   ALTMIN abstr_meas_nom_rel ] ] ] > ],
	      CONT [ RELS <! arg01_only_relation !>,
                     HCONS <! !>,
		     ICONS <! !> ] ] ] ].

;; DPF 2016-11-01 - Generalized MOD..HEAD to subst, since we also want to get
;; *before, we were beside Kim*

pp_word := basic_pp_word &
  [ SYNSEM [ LOCAL.CAT.HEAD prep & [ PRD +,
				     MOD < [ LOCAL.CAT.HEAD subst ] > ]]].

; 'astray'
pp_-_i_le := pp_word
"""
PP, intersective                 
<ex>B saw C above.
"""
.

pp_-_i-nomodn_le := pp_word &
"""
PP, intersective, no n_mod
<ex>B slept on.
"""
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS.NORM norm_rel,
			    MOD.FIRST.LOCAL.CAT.HEAD v_or_g_or_a_or_p ] ].

; 'about'
pp_-_i-nmb_le := basic_pp_word &
"""
PP, non-mobile (no extrctn)      
<ex>B hung about.
"""
  [ SYNSEM.LOCAL.CAT.HEAD prep_nonmob &
			  [ MOD < [ LOCAL.CAT.HEAD v_or_a_or_p,
				    MODIFD.RPERIPH - ] >,
			    MINORS.NORM norm_rel ] ].

;; DPF 2012-07-25 - Changed MOD..HEAD to subst from v_or_a_or_p, to admit
;; *test cases:*.  This will add ambiguity, but so be it.
;; DPF 2015-05-15 - Removed MOD..RPERIPH - so we can get colon as vmod as in
;; *says: we arise*
;;
pp_-_i-cln_le := basic_word &
"""
PP, only for post-head colon
<ex>B likes cats:
"""
  [ INFLECTD +,
    SYNSEM lex_pp_synsem &
	   [ LOCAL [ CAT [ HEAD prep_nonmob &
			        [ MOD < [ LOCAL.CAT.HEAD subst ] >,
				  PRD + ],
			   VAL.SPR < anti_synsem_min >,
			   MC na ],
		     CONT [ RELS <! arg01_only_relation !>,
			    HCONS <! !>,
			    ICONS <! !> ],
		     CONJ cnil ],
	     NONLOC non-local_none,
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT clause_or_no_punct ] ] ].

; DPF 25-mar-05 - Added hack [CASE obliq] to prevent particle PPs from
; fronting.
;; DPF 2020-05-23 - Added INDEX basic_non_expl so particles don't license
;; expletive it/there in parse chart.
;
pp_-_ptcl_le := noncqrs-hm-nab &
"""
PP, sem empty                    
<ex>B looked forward to it.
"""
  [ SYNSEM basic_lex_pp_synsem &
           [ LOCAL [ CAT [ HEAD prep &
                                [ MINORS.MIN selected_rel & #min,
                                  MOD < >,
                                  PRD -,
                                  CASE obliq ],
                           VAL.SPR < > ],
                     CONT [ HOOK [ INDEX basic_non_expl,
				   XARG #xarg ],
                            RELS <! !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL [ PRED #min,
                            ARG1 #xarg ] ] ].

; 'right away'
pp_-_i-vm_le := pp_word &
"""
PP, vp mod                       
<ex>B left right away.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_a_or_p ] > ].

; 'each'
pp_-_i-nm_le := pp_word &
"""
PP, noun mod                     
<ex>We took two books each.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD supnoun &
					      [ MINORS.MIN basic_nom_rel ] ] >,
		   CONT.HOOK.INDEX.E.TENSE no_tense ] ].

;; DPF 2020-05-16 - For "ago" of *until ten minutes ago*
;; The OPT + prevents subord with-NP-PP for *with ten minutes ago*
;; Constrain SPR to unexpressed, to avoid extra reading for *a year ago*
;; with degadv.
;;
pp_-_i-nm-meas_le := pp_word &
"""
PP, noun mod                     
<ex>B stayed until ten minutes ago
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD supnoun &
						[ MINORS.MIN meas_nom_rel ] ] >,
			   VAL.SPR.FIRST unexpressed ],
		     CONT.HOOK.INDEX.E.TENSE no_tense ],
	     OPT + ] ].

; 'PDT'
pp_-_i-nm-tm_le := pp_word &
"""
PP, hour-noun modifier
<ex>It begins at ten _PDT_.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ --MIN numbered_hour_rel ] >,
		     CONT.HOOK.INDEX.E.TENSE no_tense ],
	     LKEYS.KEYREL.PRED timezone_p_rel ] ].

; below, down, ...
;; DPF 2016-11-01 -  Since we have a pp_-_i-dir-nom_le type which constraints
;; the MOD to be a noun, remove the MOD constraint on the more general type
;; here, so we can get e.g. *He came forth* now that we have directional-PP
;; verbs requiring the PP to be MOD verb (to avoid spurious ambig).
;;
pp_dir_lexent := pp_word &
  [ SYNSEM.LOCAL.CAT.HEAD. MINORS [ MIN dir_rel,
				    NORM norm_rel ] ].

pp_-_i-dir_le := pp_dir_lexent
"""
PP, directional                  
<ex>B flew across.
"""
.

;; DPF 2018-06-02 - For a few frequent preps such as "in", for efficiency,
;; to avoid massive unwanted ambiguity.
;;
pp_-_i-dir-nomodn_le := pp_dir_lexent &
"""
PP, no n_mod
<ex>we stayed in.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD v_or_g_or_a_or_p ].

;; DPF 2018-02-17 - Exclude some lexical PPs from v_mod, particularly "by" to
;; avoid spurious analysis of *given by Kim*
;;
pp_-_i-dir-novmd_le := pp_dir_lexent &
"""
PP, directional, no v_mod
<ex>given by a consultant
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN no_rel ].

; 'after'
pp_-_i-nm-tmp_le := pp_word &
"""
PP, temporal noun mod            
<ex>B arrived the day after.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD [ MOD < [ --MIN basic_nom_rel,
				      LOCAL.CAT.VAL.SPR 
                                                 < [ LOCAL.CAT.HEAD det ] >,
				      --SIND ref-ind & [ SORT time ] ] >,
			      MINORS.NORM norm_rel ],
             LKEYS.KEYREL.ARG0.E.TENSE nontense ] ].

; Postpositions
;; DPF 2016-10-17 - Were wrongly constraining SPR..QUE 0-dlist, but we want
;; *how many years ago ...*.  So remove.
;; DPF 2019-08-23 - Generalized MOD..HEAD to include prep, so we can get
;; *Years ago, we were in Paris.*
;;
pp_-_i-po_lexent := noncs-hm-nab &
  [ SYNSEM norm_lex_pp_synsem &
    [ LOCAL [ CAT [ HEAD prep & [ PRD + ],
		    VAL.SPR < synsem_min & 
			      [ LOCAL
				[ CAT [ HEAD basic_noun,
					VAL [ SPR *olist*,
					      COMPS < >,
					      SPCMPS < > ] ],
				  CONT.HOOK.INDEX #ind ],
				NONLOC [ REl #rel,
					 SLASH #slash ],
				MODIFD notmod_or_lmod,
				OPT - ],
			      anti_synsem_min >,
		    POSTHD + ],
	      CONT [ RELS <! relation &
			   [ ARG2 #ind ] !>,
		     HCONS <! !>,
		     ICONS <! !> ] ],
      NONLOC [ REl #rel,
	       SLASH #slash ] ] ].

;; DPF 2012-08-29 - Changed SPR..ALTMIN from indef_or_num_q_rel to 
;; implicit_q_rel to require only measure NPs, avoiding spurious ambiguity
;; for *a year ago*
;; DPF 2013-01-09 - Generalized SPR..MIN to abstr_meas_nom_rel in order to
;; also allow *We arrived a couple of days ago*
;; DPF 2015-03-18 - Changed SPR..MIN from abstr_meas_nom_rel to meas_nom_rel
;; to avoid spurious ambig for *years ago* with simple bare-plural *years*.
;; DPF 2020-05-16 - Re 2015-03-18: Let's instead try doing without the bare-
;; meas-NP rule, so again generalize to abstr_meas_nom_rel.
;; DPF 2020-05-17 - Re 2012-08-29: But this blocks *a long time ago*, so
;; change SPR..ALTMIN from implicit_q_rel to udef_a_q_rel, and live with 
;; ambig for *a year ago*.
;;
; For 'ago', constrain SPR to be only temporal measure NPs.
pp_-_i-po-tm_le := pp_-_i-po_lexent &
"""
PP, postposition, temporal       
<ex>B arrived two days ago.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST [ --SIND.SORT time,
				     LOCAL.CAT.HEAD.MINORS
						 [ MIN abstr_meas_nom_rel,
						   ALTMIN udef_a_q_rel,
						   NORM quantity_rel ] ] ].

; For e.g. 'Kim's objections notwithstanding, we won't stay.'
pp_-_i-po_le := pp_-_i-po_lexent
"""
PP, postposition (ARG2 as spec)  
<ex>Doubts notwithstanding, go
"""
.

; DPF 29-Nov-02 - Stipulate HOOK.XARG nothing to prevent these from appearing
; as complements of predicative 'be'.
; DPF 4-Feb-03 - But the HOOK of a modifier is now the HOOK of the hadj phrase,
; and a VP (with or without a PP modifier) has to present its XARG as the 
; index of its SUBJ, so it can't be 'nothing' - must be ref-ind.  And anyway,
; by-PPs can be complements of the copula: "The best route is by car".  So
; instead constrain subtype for e.g. "per" with incompatible value for TENSE.
; DPF 4-Feb-03 - Changed COMPS type from lex_synsem to abstr_lex_synsem to
; admit compound nouns, as in "I paid by credit card".
;;
#|
p_nbar_comp_lexent := basic_prep_word &
  [ SYNSEM [ LOCAL 
             [ CAT [ VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                           COMPS < [ OPT -,
                                     --MIN gen_nom_nbar_rel,
                                     LOCAL 
                                      [ CAT [ HEAD basic_noun &
						   [ MINORS.ALTMIN #sprmin,
						     CASE non_nom,
						     --BARE na_or_- ],
                                              VAL [ SPR < synsem &
                                                   [ LOCAL.CAT.HEAD det,
                                                     NONLOC non-local_none,
						    --MIN #sprmin ] >,
                                                    COMPS < > ] ] ],
                                     NONLOC.SLASH 0-dlist ] > ],
                     POSTHD + ] ],
             LKEYS [ KEYREL prep_relation & [ ARG2 #arg ],
                     ALTKEYREL [ PRED udef_q_rel,
                                 ARG0 #arg & ref-ind ] ],
	     --SIND non_expl ] ].
|#
p_nbar_comp_lexent := basic_prep_word &
  [ SYNSEM [ LOCAL 
             [ CAT [ VAL [ SPR < [ NONLOC.SLASH 0-dlist ] >,
                           COMPS < [ OPT -,
                                     --MIN gen_nom_nbar_rel,
                                     LOCAL 
                                      [ CAT [ HEAD basic_noun &
						   [ MINORS.ALTMIN #sprmin,
						     CASE non_nom,
						     --BARE na_or_- ],
                                              VAL [ SPR.FIRST synsem &
                                                       [ LOCAL.CAT.HEAD det,
							 NONLOC non-local_none,
							 --MIN #sprmin ],
						    COMPS < > ] ] ],
                                     NONLOC.SLASH 0-dlist ] > ],
                     POSTHD + ] ],
             LKEYS [ KEYREL prep_relation & [ ARG2 #arg ],
                     ALTKEYREL [ PRED udef_q_rel,
                                 ARG0 #arg & ref-ind ] ],
	     --SIND non_expl ] ].

; DPF 9-jul-04 - But this blocks e.g. "per day", so make this constraint be
; specific to the lex entry for "by".
; DPF 27-aug-04 - Changed COMPS..MODIFD notmod to notmod_or_lmod to allow
; 'by private car' or 'by large Zodiac raft'.

basic_p_nbar_comp_spr_lexent := p_nbar_comp_lexent &
  [ SYNSEM basic_one_arg_prep_synsem &
    [ LOCAL [ CAT 
              [ HEAD.PRD +,
                VAL.COMPS < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN implicit_q_rel,
                                      CONT.HOOK.LTOP #nhand ],
                              --SIND #ind ] > ],
              CONT [ RELS.LIST < #keyrel, #altkeyrel, ... >,
                     HCONS.LIST < qeq & [ HARG #rhand,
                                          LARG #nhand ], ... >,
		     ICONS <! !> ] ],
      LKEYS [ KEYREL #keyrel & [ ARG2 #ind & non_expl ] ,
              ALTKEYREL #altkeyrel & [ RSTR #rhand ] ] ] ].

p_nbar_comp_spr_lexent := basic_p_nbar_comp_spr_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_or_no_punct,
			   OPT - ] >,
              VAL [ SPR < [ LOCAL [ CAT [ HEAD.MINORS 
                                               [ MIN much_deg_rel,
                                                 ALTMIN abstr_meas_nom_rel ],
                                          VAL [ SPR *olist*,
                                                SPEC < synsem >,
                                                COMPS < > ] ],
                                    CONT.HOOK [ LTOP #ltop,
                                                XARG #arg0 ] ] ] >,
                    COMPS < [ LOCAL.CAT.HEAD.MINORS.MIN #ckey ] > ] ],
        CONT [ RELS <! relation, relation !>,
               HCONS <! qeq !>,
	       ICONS <! !> ] ],
      LKEYS [ KEYREL [ LBL #ltop,
                       ARG0 #arg0 ],
              --COMPKEY #ckey,
              --+COMPKEY #ckey ] ] ].


; DPF 12-Apr-03 - Added COMP..MIN non_temp_nom_rel to block e.g. means reading
; for "by three o'clock'
; DPF 21-Mar-07 - Since this also blocks "sorted by date", instead constrain
; the SPR of the nbar-complement to be HEAD det, which will still block this
; analysis for "by three o'clock".  If sustainable, then lose the type
; p_nb_i-per_le.  FIX.
; DPF 03-oct-08 - Need some general mechanism to block unwanted frequently
; occurring phrases like "as well".  For now, co-opt NORM attribute, though
; need to FIX.
;; DPF 2017-06-27 - Re 03-oct-08: Changed NORM norm_rel to quantity_or_norm_rel
;; so we can allow measure phrases as in *ten cents per centimeter*
;;
p_nb_i_lexent := p_nbar_comp_spr_lexent &
"""
Prep, nbar, nontemp noun         
<ex>B arrived by car.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS 
			< abstr_lex_synsem & 
			  [ MODIFD notmod_or_lmod,
			    LOCAL.CAT [ HEAD.MINORS.NORM quantity_or_norm_rel,
					VAL.SPR.FIRST unexpressed ] ] > ].

p_nb_i_le := p_nb_i_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.AGR.DIV -,
					     AGR.DIV - ] ].

; For preps like "as" which can take phrasal nbar complements
p_nb_i-phr_le := p_nbar_comp_spr_lexent & 
"""
Prep, nbar (phrasal)             
<ex>C as new kid was teased.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ MODIFD notmod_or_lmod,
				   LOCAL [ CAT 
                                             [ HEAD.MINORS.NORM norm_rel,
					       VAL.SPR.FIRST.LOCAL.AGR.DIV - ],
					   AGR.DIV - ] ] > ].

; For prep "between" which can take phrasal nbar coord
p_nb_i-crd_le := p_nbar_comp_spr_lexent & 
"""
Prep, nbar (phrasal)             
<ex>the morsel fell between plate and mouth.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ MODIFD notmod_or_lmod,
				   --SIND conj_ref-ind,
				   LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.AGR.DIV -,
					   AGR.DIV - ] ] > ].

; 'step by step'
p_nb_i-oblsp_le := basic_p_nbar_comp_spr_lexent &
"""
Prep, nbar, oblig nbar spec      
<ex>B approached step by step.
"""
  [ SYNSEM [ LOCAL 
	     [ CAT.VAL [ SPR < [ OPT -,
				 --MIN gen_nom_nbar_rel,
				 LEX +,
				 LOCAL [ AGR.PNG.PN unsp_pernum,
					 CAT [ VAL [ SPCMPS < >,
						     COMPS < > ],
					       POSTHD + ],
					 CONT.HOOK [ LTOP #sltop,
						     INDEX #arg &
							  nonconj_ref-ind ] ],
				 LKEYS.KEYREL.PRED #pred ] >,
			 COMPS < abstr_lex_synsem &
				 [ LEX +,
				   MODIFD notmod_or_lmod,
				   LOCAL.AGR.DIV -,
				   LKEYS.KEYREL.PRED #pred ] > ],
	       CONT [ RELS <! relation, 
			      [ CFROM #cfrom, CTO #cto ],
			      #alt2keyrel &
			      [ PRED udef_q_rel,
				ARG0 #arg & ref-ind,
				RSTR #rstr,
				CFROM #cfrom, CTO #cto ] !>,
		      HCONS <! qeq, qeq & [ HARG #rstr,
					    LARG #sltop ] !>,
		      ICONS <! !> ] ],
	     LKEYS.ALT2KEYREL #alt2keyrel ] ].

; DPF 24-Jun-01 - Added SUBJ <anti_synsem_min> to block 'per' reading: "Abrams
; is a manager"
; DPF 29-Nov-02 - But [E.TENSE no_tense] should be enough
; DPF 5-Sep-03 - Added SPR < anti_synsem_min > to prevent spurious readings 
; like for "three times a day"
; DPF 27-Sep-03 - no_tense won't be enough to block this as copula complement
; since all PPs are no_tense.  Instead use new value 'nontense'.
;; DPF 2012-09-21 - Pushed COMPS < abstr_lex_synsem > down to subtype, since
;; want to allow *She ran for governer of Florida*
;;
p_nbar_comp_nospr_lexent := p_nbar_comp_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < anti_synsem_min > ],
             LKEYS.KEYREL.ARG0.E [ TENSE nontense,
                                   ASPECT no_aspect ] ] ].

; Added MOD..ALTMIN no_rel to prevent "a person" from modifying e.g. gerunds.
; 10-Nov-01 - But now gerunds are unmarked for ALTMIN, since they need to be
; able to appear as left members of noun-noun compounds.  
; DPF 30-Aug-01 - Added COMPS <[MODIFD notmod]> to block "a ten percent
; probability" with a_per.
; DPF 3-Jul-02 - Added [MOD..LEX +] to block spurious analyses as for 
; e.g. "every manager who has a bookcase"
; DPF 16-oct-03 - Changed MOD..ALTMIN to impl_or_expl_q_rel to exclude proper 
; nouns, to still block e.g. "Kim a book".
; DPF 19-may-05 - Added MOD..NORM no_rel to prevent modification of
; e.g. locative 'there', while still avoiding modification of gerunds, as
; in 'hiring a consultant'
; DPF 26-mar-06 - But this blocks "ten days a week", so changed NORM to
; norm_rel (still blocks modif of 'there' and gerunds).
; DPF 28-aug-07 - Added COMPS..NORM quantity_or_no_rel to block unusual nouns 
; like in "a little".
; DPF 20-jun-08 - Changed MOD..MIN nonpro_rel to gen_nom_nbar_rel to exclude
; proper names, to avoid e.g. "Browne an office and interviewed programmers"
;; DPF 2013-09-24 - Re 3-Jul-02: But this prevents the desired analysis
;; of *50 / day* with partitive *50* which is [LEX -].  So instead make the
;; MOD be itself MODIFD notmod.
;; DPF 2013-09-26 - Re 30-Aug-01: Generalized to notmod_or_rmod, since we
;; want measure-noun abbreviations to be rmod, so they won't appear as
;; heads of noun compounds.  Also, we want to allow *per pound of flour*.
;; DPF 2016-12-08 - Re 2013-09-26: Generalized to notmod_or_lmod, now that
;; we are attaching prenominal adjectives before post-hd modifiers.
;; DPF 2017-05=30 - No longer recall why this was PRD -, but it conflicts
;; with requiring post-nominal AP and PP modifiers to be PRD + (cf.2017-05-29
;; comment in syntax.tdl for n_adj_redrel_phrase).  So make PRD +, and check.
;; DPF 2020-04-12 - Removed COMPS..MODIFD notmod_or_rmod and instead changed
;; COMPS abstr_lex_synsem to basic_lex_synsem, to still block 
;; *a ten percent probability* but allow *a metric ton*.
;;
; 'a (per)'
p_nbar_comp_nmod_lexent := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_trans_prep_synsem &
    [ LOCAL
      [ CAT [ HEAD [ MOD < synsem &
			   [ LOCAL.CAT [ HEAD basic_noun &
                                        [ MINORS [ MIN gen_nom_nbar_rel,
                                                   ALTMIN impl_or_expl_q_rel]]],
                             NONLOC.QUE 0-dlist,
			     OPT -,
                             PUNCT.RPUNCT pair_or_no_punct,
			     MODIFD notmod_or_lmod ] >,
                     MINORS.ALTMIN no_rel,
                     PRD + ],
              VAL.COMPS < basic_lex_synsem &
			  [ LOCAL [ CAT.HEAD.MINORS.NORM quantity_or_no_rel,
                                    CONT.HOOK.LTOP #nhand ] ] > ],
        CONT [ HOOK.INDEX non_conj_event,
	       RELS <! #keyrel, #altkeyrel !>,
               HCONS <! qeq & [ HARG #rhand,
                                LARG #nhand ] !>,
	       ICONS <! !> ] ],
      LKEYS [ KEYREL #keyrel,
              ALTKEYREL #altkeyrel & [ RSTR #rhand ] ] ] ].

;; DPF 2017-07-24 - Generalized norm_nom_rel to reg_nom_rel, so we can also
;; get *ten cents a share* where *share* is MIN meas_nom_rel.
;; DPF 2017-08-08 - And further to reg_or_temp_nom_rel so we get
;; *two times a day*
;;
p_nb_i-nm_le := p_nbar_comp_nmod_lexent &
"""
Prep, nbar, noun mod, con onset (only *a*)
<ex>B read ten pages a day.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET con_or_unk,
				   --MIN reg_or_temp_nom_rel,
				   LOCAL.AGR [ PNG.PN 3s,
					       DIV - ] ] > ].

p_nb_i-nm-an_le := p_nbar_comp_nmod_lexent &
"""
Prep, nbar, noun mod, voc onset  
<ex>B read ten pages an hour.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET voc_or_unk,
				   LOCAL.AGR [ PNG.PN 3s,
					       DIV - ] ] > ].

p_nb_i-nm-any_le := p_nbar_comp_nmod_lexent &
"""
Prep, nbar, noun mod, any onset
<ex>The sonata for violin was popular.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN norm_nom_rel,
				   LOCAL.AGR [ PNG.PN 3s,
					       DIV - ] ] > ].


;; DPF 2012-12-18 - Added quant_rel for contentful p_nb `to', and removed it
;; from the ditrans p_nb-pp `from', since the LBL of the bare nbar is not
;; visible to the `from'.
;;
p_nb_i-nmd_lexent := p_nbar_comp_nospr_lexent &
  [ SYNSEM basic_prep_nomod_synsem &
    [ LOCAL.CAT [ HEAD.PRD -,
		  VAL [ SPR < [ --MIN much_deg_rel ] >,
			COMPS < [ LOCAL [ CAT.HEAD.PRD -,
					  AGR.DIV - ] ] > ] ] ] ].

; 'of' in "what kind of book(s)'
; 'the 25th to 28th of May'
;
p_nb_i-nmd_le := p_nb_i-nmd_lexent &
"""
Prep, nbar, no mod               
<ex>That kind of dog barks.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MINORS.ALTMIN #min ],
			 VAL.COMPS < [ LOCAL.CONT.HOOK [ LTOP #nhand,
							 INDEX #index ],
				       --MIN #min ] > ],
		   CONT [ HOOK.INDEX #index,
			  RELS <! [ PRED udef_q_rel,
				    ARG0 #index & ref-ind,
				    RSTR #rhand,
				    CFROM #cfrom, CTO #cto ] !>,
			  HCONS <! qeq & [ HARG #rhand,
					   LARG #nhand ] !>,
			  ICONS <! !> ] ],
    ORTH [ FROM #cfrom, TO #cto ] ].

p_nb_i-nmd-to_le := p_nbar_comp_nospr_lexent &
"""
Prep, nbar, no mod, contentful
<ex>From week _to_ week
"""
  [ SYNSEM basic_prep_nomod_synsem &
    [ LOCAL [ CAT [ HEAD.PRD -,
		    VAL [ SPR < [ --MIN much_deg_rel ] >,
			  COMPS.FIRST.LOCAL [ CAT [ HEAD.PRD -,
						    VAL.SPR.FIRST.--MIN quant_rel ],
					      CONT.HOOK [ LTOP #nhand,
							  INDEX #objind ],
					      AGR.DIV - ] ] ],
	      CONT [ HOOK [ LTOP #ltop,
			    INDEX #event,
			    XARG #xarg ],
                     RELS <! #keyrel &
                                 [ LBL #ltop,
                                   PRED prep_mod_rel,
                                   ARG0 #event &
				       [ E.ASPECT no_aspect ],
                                   ARG1 #xarg,
                                   ARG2 #objind ],
			     #altkeyrel !>,
		     HCONS <! qeq & [ HARG #rhand,
                                      LARG #nhand ] !>,
		     ICONS <! !> ] ],
      LKEYS [ KEYREL #keyrel,
              ALTKEYREL #altkeyrel & [ RSTR #rhand ] ] ] ].

; 'planes leave _every_ four hours'
p_np_i-msr_le := basic_prep_word &
"""
Prep, NP, measure phr            
<ex>B arrives every four hours
"""
  [ SYNSEM one_arg_prep_synsem &
    [ LOCAL 
      [ CAT 
        [ HEAD.PRD +,
          VAL 
          [ SPR < [ NONLOC.SLASH 0-dlist ] >,
            COMPS < nonlex_synsem &
                    [ OPT -,
                      LOCAL 
                      [ CAT [ HEAD noun &
				   [ MINORS.MIN meas_nom_rel ],
                              VAL [ SPR < synsem &
					  [ --MIN degree_rel,
					    NONLOC [ SLASH 0-dlist,
						     QUE 0-dlist ] ] >,
                                    COMPS < > ] ],
                        CONT.HOOK.INDEX #nind,
                        AGR.PNG.PN 3s ],
                      NONLOC.SLASH 0-dlist ] > ],
          POSTHD + ],
        CONT [ HOOK [ LTOP #plbl,
                      INDEX #pind,
                      XARG #arg1 ],
               RELS <! prep_relation & #keyrel &
                       [ LBL #plbl,
                         PRED loc_nonsp_rel,
                         ARG0 #pind,
                         ARG1 #arg1,
                         ARG2 #iind ],
		       #altkeyrel &
                       [ LBL #ihand,
                         PRED interval_rel,
                         ARG0 #iind,
                         ARG1 #nind ],
		       #alt2keyrel &
                       [ PRED udef_q_rel,
                         ARG0 #iind & ref-ind,
                         RSTR #rhand ] !>,
               HCONS <! qeq & [ HARG #rhand,
                                LARG #ihand ] !>,
	       ICONS <! !> ] ],
      LKEYS [ KEYREL #keyrel,
	      ALTKEYREL #altkeyrel,
	      ALT2KEYREL #alt2keyrel ],
      --SIND non_expl ] ].

;; DPF 2015-03-26 - Added MINORS.NORM norm_rel to prevent these from using
;; vmod rule as in *[mark {or Kyle sent]] the card*.
;;
p_aj_i-compar_le := basic_prep_word &
"""
Prep with comparative adj complement, modifies named number
<ex>people age ten and older
"""
  [ SYNSEM basic_one_arg_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ MOD < synsem &
			   [ --MIN named_num_or_fract_rel ] >,
		     MINORS.NORM norm_rel ],
	      VAL [ SPR *anti_list*,
		    COMPS < [ OPT -,
			      LOCAL 
			       [ CAT 
				 [ HEAD adj &
					[ MINORS [ MIN adj_rel,
						   ALTMIN comp_rel ] ],
				   VAL [ SPR *olist*,
					 COMPS < [ LOCAL.CAT.HEAD prep,
						   --MIN _than_p_compar_rel]>]],
				 CONT.HOOK [ LTOP #ltop,
					     INDEX #arg ] ],
			      NONLOC.SLASH 0-dlist ] >,
		    SPEC < > ],
	      POSTHD + ],
	CONT [ HOOK.INDEX.E.TENSE no_tense,
	       RELS <! relation !>,
	       HCONS <! !>,
	       ICONS <! !> ] ],
      LKEYS.KEYREL prep_relation & [ LBL #ltop,
				     ARG2 #arg ],
      --SIND non_expl ] ].

;; Temporal prepositions:

; "ten minutes to three" - "to" as head
; Use POSTHD to allow "half past three" and "three thirty" but block
;      "?thirty past three" and "*three half"
; DPF (12-Jul-98) The specifier on hour_prep_words has to be [ OPT + ] in 
; order to block prenominal adjectives from attaching, since they distinguish 
; proper from common nouns by the optionality (or absence) of the specifier.  
; This distinction doesn't seem to work well here, but it's the only case, so 
; perhaps the analysis of "ten after three" should be reconsidered.
; DPF (11-Jul-99) But this [OPT +] incorrectly predicts that "To five thirty 
; suits me" is good, and worse, it allows "to five thirty" to act like an NP in
; appositive constructions.  So instead of this hack, constrain adjectives to
; only modify nominals with a DET specifier.
;; DPF 2016-03-16 - We now have a lexical rule that converts one- and two-digit
;; cardinal number adjectives into nouns which take an obligatory prepositional
;; complement (which is itself underspecified for whether it is 
;; complement-saturated).  This should give us "ten to two", "ten to" and 
;; "ten after (two)".  Now "ten minutes to two" has a separate entry for 
;; "minute" with a similar obligatory to/after PP complement.
;; DPF 2016-10-20 - Added NORM norm_rel to stop these from undergoing vocative
;; rule, as in *First, we ate breakfast*
;;
basic_minute_noun_synsem := lex_synsem &
  [ LOCAL 
    [ CAT 
      [ HEAD noun & [ MOD < >,
                      MINORS [ MIN minute_n_rel,
			       NORM norm_rel ] ],
	VAL [ SPR < >,
              SUBJ < >,
	      SPCMPS < > ] ],
      CONT nom-obj &
          [ HOOK.INDEX ref-ind & [ PNG png & [ PN 3s ] ],
	    ICONS <! !> ] ],
    LKEYS [ KEYREL [ PRED minute_n_rel,
		     ARG0 #mininst & ref-ind,
		     CFROM #cfrom, CTO #cto ],
	    ALTKEYREL [ PRED def_implicit_q_rel,
			ARG0 #mininst,
			CFROM #cfrom, CTO #cto ] ] ].

;; DPF 2018-06-01 - For efficiency, constrain to PP comp, to avoid *ten to*
;; as NP.
;;
minute_noun_wcomp_synsem := basic_minute_noun_synsem &
  [ LOCAL 
    [ CAT 
      [ HEAD noun & [ MOD < >,
                      MINORS.MIN minute_n_rel ],
        VAL [ SPR < >,
              SUBJ < >,
              COMPS < [ LOCAL [ CAT [ HEAD prep_nonmob & 
                                        [ PRD -,
                                          MINORS [ MIN conj_rel,
                                                   ALTMIN numbered_hour_rel ]],
                                      VAL [ SPR *olist*,
					    COMPS < > ],
                                      MC na ],
                                CONT.HOOK [ LTOP #cltop,
					    INDEX #cind,
					    XARG #mininst ],
                                CONJ cnil ],
			OPT -,
                        NONLOC.SLASH 0-dlist,
                        PUNCT.LPUNCT no_punct ] >,
	      SPCMPS < > ] ],
      CONT nom-obj &
          [ HOOK [ LTOP #cltop,
		   INDEX ref-ind & #cind &
                        [ PNG png & [ PN 3s ] ] ],
	    ICONS <! !> ] ],
    LKEYS [ KEYREL [ PRED minute_n_rel,
		     ARG0 #mininst & ref-ind,
		     CFROM #cfrom, CTO #cto ],
	    ALTKEYREL [ PRED def_implicit_q_rel,
			ARG0 #mininst,
			CFROM #cfrom, CTO #cto ] ] ].

; ten pm to two am
; Tuesday to Friday
; ten mph to twenty mph
; DPF 3-Jul-02 - If MIN is interval_rel, then we predict wrongly that all of
; these constructions can be modifier NPs like "Tuesday".  But the modifying
; capability seems to be whatever the interval endpoints are: "Kim stayed
; Tuesday to Saturday" but "*Kim stayed Abrams to Browne".  So let's try 
; making the MIN be the SPR's MIN instead.
; DPF 28-Apr-03 - The [PRD -] feature prevents this from undergoing the
; temp_np rule, so we don't get "Kim stayed Tuesday to Saturday".  Let's try
; removing this constraint and see what happens.
; DPF 15-jun-04 - Restrict two arguments to [LEX +] to avoid spurious
; ambiguities; so admit "Tuesday - Wednesday" but not "Hire Kim -- his brother"
; with the sense of x_to_y.
; DPF 21-aug-04 - Removed SYNSEM..ALTMIN never_unify_rel, since it prevents
; these from appearing in NP-N compounds, as in "the Berlin - Paris route".
; Don't know what it was trying to exclude.
; DPF 25-sept-04 - Can't use LEX + to avoid 'Hire Kim - his brother'
; (cf. 15-jun-04) since this would also block 'Two - three p.m. is okay'
; since 'two' is [LEX -] in order to sustain contrast of 'we have a two p.m.
; meeting' vs. '*we have a two meeting'.  But happily we already have the
; constraint on MIN of each dtr NP requiring abstr_named_rel, which does the
; job we want, as long as we correct the erroneous type definition for
; reason_rel which wrongly unified norm_nom_rel and abstr_named_rel.  Sigh.
; DPF 7-mar-05 - Removed [PRD -] constraint on SPR and COMPS, since proper NPs
; now have their PRD value identified with their INFL value.  Don't know why
; this constraint was originally imposed.  Now only require that the PRD values
; of the two be identified, to avoid spurious ambiguity.
; Also changed parent type from norm_msg_word to norm_word since it needs
; to be unmarked for INFL in order to appear in compounds 
; (eg. "the Berlin - Paris route").
; DPF 14-nov-05 - Hack: added [AUX +] to prevent these from being modified by
; PPs, avoiding spurious analysis for "from Paris [[to Rome] on Thursday]"
; DPF 06-mar-06 - Propagated LEX from right dtr via HS-LEX, to block 'the 
; Paris to a city in Italy tour'
; DPF 24-may-06 - Further constrained NPs to be not post-modified, to avoid
; further spurious ambiguity.
; DPF 15-sept-07 - Removed identif of INFLECTD and PRD, since want to constrain
; HCOMP rule to require INFL + hd-dtr, to avoid spurious edges for e.g.
; 'hire Kim'.  We'll remind ourselves of why this identity was clever?
; DPF 17-may-09 - Changed SPR..MIN nonpro_rel to nonpro_or_num_rel, to allow
; *items 1 - 3*
;; DPF 2016-08-07 - Re 06-mar-06: But constraining HS-LEX this way wrongly
;; excludes *the two to four meeting*, since *four* is necessarily [LEX -] to
;; exclude **the four meeting*.  And anyway, seems grammatical for at least
;; some post-modified X-to-Y phrases in compounds, as in
;; *the city of love to city of flowers tour*.  So remove this constraint, and
;; live with the awkwardness of example above.
;; DPF 2016-10-15 - Push the SPR..COMPS < > constraint down to subtypes, since
;; at least for the dom subtype as in *June 23 - 25* we want to constrain the
;; SPR to still have its COMPS nonempty, so we can ensure that it is not
;; inflected (see below).
;; DPF 2020-04-25 - Pushed identity of SORT on SPR and COMP down to subtypes,
;; since it's not true for the special case of p_nb_pre-meas as in 
;; *10 dollar an huur job*.

basic_n-or-p_x_to_y_lexent := noncqrs-hm &
  [ SYNSEM basic_two_arg &
      [ LOCAL [ CAT [ VAL 
                      [ SPR < synsem &
                              [ LOCAL 
                                [ CAT 
                                  [ HEAD basic_noun &
                                    [ POSS -,
                                      MOD < >,
                                      PRD #prd,
                                      MINORS [ MIN nonpro_or_num_rel ] ],
                                    VAL [ SUBJ *olist*,
                                          COMPS *olist*,
					  SPEC < [ LOCAL.CAT.VAL.COMPS < > ] >,
					  SPCMPS < > ] ],
				  CONT.HOOK.INDEX non_expl,
				  CONJ cnil ],
                                NONLOC non-local_none &
				      [ SLASH.LIST < > ],
                                OPT - ], ... >,
                        SUBJ < >,
                        COMPS < synsem &
                                [ --MIN #cmin,
				  LOCAL [ CAT [ HEAD basic_noun &
                                                [ POSS -,
                                                  MOD < >,
                                                  PRD #prd,
						  MINORS.MIN nonpro_or_num_rel],
						VAL [ SUBJ *olist*,
                                                      COMPS < > ] ],
					  CONT.HOOK.INDEX non_expl,
                                          CONJ cnil ],
				  NONLOC non-local_none &
					[ SLASH.LIST < > ],
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ] >,
                        SPCMPS < > ] ] ],
	LKEYS.--COMPKEY #cmin ] ].

n-or-p_x_to_y_lexent := basic_n-or-p_x_to_y_lexent &
  [ SYNSEM 
    [ LOCAL 
      [ CAT.VAL [ SPR.FIRST [ MODIFD notmod_or_lmod,
			      --SIND.SORT #sort,
			      LOCAL.CAT.VAL.COMPS < > ],
		  COMPS.FIRST.--SIND.SORT #sort ],
	CONT [ RELS.LIST < [ LBL #nhand,
			     ARG0 #index,
			     CFROM #from,
			     CTO #to ],
			   [ PRED udef_q_rel,
			     ARG0 #index & ref-ind,
			     RSTR #rhand,
			     CFROM #from,
			     CTO #to ], ... >,
	       HCONS.LIST < qeq & [ HARG #rhand,
				    LARG #nhand ], ... >,
	       ICONS <! !> ],
	AGR.DIV - ],
      LKEYS.ALTKEYREL.PRED never_unify_rel ] ].

;; DPF 2013-02-12 - Anchored CFROM and CTO to those of the first rel.
;; DPF 2013-06-13 - Added [LPERIPH +] to first SPR, to prevent these
;; interval expressions as right members of compounds.
;; DPF 2016-10-14 - Re 2013-16-13: But we do want these in the head-dtr of
;; compounds when they are not themselves the head, as in 
;; *real-time face-to-face event*.  
;; So instead add constraint MODIFD rmod so these cannot be heads in compounds,
;; but can still modify the head dtr in a compound.
;;
n_x_prep_y_lexent := basic_n-or-p_x_to_y_lexent &
  [ INFLECTD na_or_+,
    SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD noun &
		   [ POSS -,
		     MOD < > ],
	      VAL [ SPR.FIRST [ --SIND #arg1 & [ SORT #sort ],
				LOCAL.CAT.HEAD.MINORS.ALTMIN 
						    abstr_def_or_udef_q_rel ],
		    COMPS.FIRST.--SIND #arg2 & [ SORT #sort ] ] ],
	CONT nom-obj &
	    [ HOOK.INDEX #index,
	      RELS.LIST < #keyrel & [ LBL #nhand,
				      ARG0 #index,
				      CFROM #from, CTO #to ],
			  prep_relation &
			  [ LBL #nhand,
			    PRED interval_p_start_rel,
			    ARG0.E [ TENSE no_tense,
				     ASPECT no_aspect ],
			    ARG1 #index & ref-ind,
			    ARG2 #arg1,
			    CFROM #from, CTO #to ],
			  prep_relation &
			  [ LBL #nhand,
			    PRED interval_p_end_rel,
			    ARG0.E [ TENSE no_tense,
				     ASPECT no_aspect ],
			    ARG1 #index,
			    ARG2 #arg2,
			    CFROM #from, CTO #to ], ... > ] ],
      MODIFD rmod,
      LKEYS.KEYREL #keyrel ] ].

;; DPF 2010-sept-13 - Removed identity of --MIN on SPR and COMPS, since we
;; want e.g. Paris - Berlin - Rome, where one of the two will be interval_rel,
;; while the other will be named_np_rel.
;; DPF 2012-09-26 - Removed COMPS.MIN and SPR..MIN abstr_named_rel, to allow 
;; meas-NPs, so let's see where this overgenerates.
;; DPF 2015-09-08 - Removed COMPS..MODIFD notmod_or_lmod so we can admit
;; *Paris - Berlin (via Brussels)*
;; DPF 2016-08-06 - Removed strange OPT - from second specifier, since it
;; must be unexpressed anyway, and the constraint blocked the projected phrase
;; from undergoing npadv rule to admit (the admittedly informal but occurring)
;; *we'll meet ten to twelve* meaning `from ten o'clock to twelve o'clock'.
;
n_np_x-to-y-sg_le := n_x_prep_y_lexent &
"""
Diadic n 'to' (XtoY) -sg np cmp  
<ex>Berlin to Paris was quick.
"""
  [ INFLECTD +,
    SYNSEM 
    [ LOCAL 
      [ CAT 
	[ HEAD [ MINORS.MIN interval_modable_rel,
		 AUX +,
		 PRD - ],
	  VAL [ SPR < [ LOCAL 
			[ AGR.PNG.PN 3s,
			  CAT [ HEAD.MINORS [ MIN named_or_meas_rel & #sprmin,
					      ALTMIN impl_or_proper_q_rel ],
				VAL [ SPR *olist*,
				      COMPS < > ] ] ],
			MODIFD notmod_or_lmod ],
		      unexpressed_reg &
		      [ OPT +,
			--MIN abstr_def_or_udef_q_rel ] >,
		COMPS < [ --MIN named_or_meas_rel,
			  LOCAL [ AGR.PNG.PN 3s,
				  CAT.VAL.SPR *olist* ] ] > ] ],
	CONT [ HOOK.INDEX #index & [ PNG.PN 3s ],
	       RELS <! [ LBL #nhand, ARG0 #index,
			 CFROM #cfrom, CTO #cto ],
		       relation, relation,
		       [ PRED udef_q_rel,
			 ARG0 #index & ref-ind,
			 RSTR #rhand,
			 CFROM #cfrom, CTO #cto ]!>,
               HCONS <! qeq & [ HARG #rhand,
				LARG #nhand ] !>,
	       ICONS <! !> ],
	AGR.DIV + ],
      LKEYS [ KEYREL.PRED interval_rel,
	      --COMPKEY #cmin,
              --+COMPKEY #cmin,
              --+OCOMPKEY #sprmin ] ] ].

;; DPF 2018-06-10 - We have another analysis of *thirty to fifty* with the to-PP
;; modifying "thirty", so let's disable this one to reduce unwanted ambiguity.
;;
#|
n_np_x-to-y-pl_le := n_x_prep_y_lexent &
"""
Diadic n 'to' (XtoY) -pl np cmp  
<ex>Thirty to fifty arrived.
"""
  [ INFLECTD +,
    SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD [ MINORS.MIN interval_rel,
		     AUX +,
		     PRD - ],
	      VAL [ SPR < [ --MIN part_nom_rel,
			    LOCAL.CAT.VAL [ SPR *olist*,
					    COMPS < > ],
			    MODIFD notmod_or_lmod ],
			  anti_synsem_min >,
		    COMPS < [ --MIN abstr_named_rel,
			      LOCAL [ CAT.VAL.SPR *olist*,
				      AGR.PNG.PN #pn & 3p ],
			      MODIFD notmod_or_lmod ] > ] ],
	CONT [ RELS <! [ LBL #nhand,
			 ARG0 #index,
			 CFROM #from, CTO #to ],
		       relation, relation,
		       [ PRED udef_q_rel,
			 ARG0 #index & ref-ind,
			 RSTR #rhand,
			 CFROM #from, CTO #to ] !>,
               HCONS <! qeq & [ HARG #rhand,
				LARG #nhand ] !>,
	       ICONS <! !> ],
	AGR [ DIV -,
	      PNG.PN #pn ] ],
      LKEYS [ KEYREL.PRED interval_rel,
	      --+COMPKEY card_rel,
	      --+OCOMPKEY card_rel ] ] ].
|#

;; DPF 2016-10-11 - The SPR was constrained to be LOCAL noninfl_noun_local,
;; but this prevents *peer to peer* even though we were getting *text to speech*
;; because *text* also underwent n-opt-comp rule which just gives [LOCAL local]
;; on mother.  Since the head-spec rule type identifies INFLECTD on mother and
;; both dtrs, and this lex type sets INFLECTD to na_or_+, we must drop the LOCAL
;; constraint here.  So let's see if we still overgenerate.
;; -- Yes, we're getting *old to hire* as a full NP, because we had to undo that
;; identify of INFLECTD on the two dtrs of the head-spec rule.  So go back to
;; LOCAL noninfl_noun_local on SPR, and live with the ambig (for now) for those
;; nouns that have an optional complement, and hence can slip by this 
;; constraint.
;; DPF 2016-11-06 - Generalized --MIN values for spr anc cmp to also allow
;; temporal nouns, so we can also get *the year to year trends*.  Was
;; non_temp_nbar_rel, now gen_nom_nbar_rel.
;; DPF 2018-01-06 - Re 2016-10-11: This noninfl_noun_local constraint prevents
;; *the 1960s to 1970s*, so let's drop it, and see if we can impose INFLECTD +
;; generally on the spr in the sp-hd_hc rule.  If not, maybe have to live with
;; the ambiguity, until and unless we make INFLECTD a feature of SYNSEM, as we
;; often seem to need.
;; DPF 2020-05-08 - Block coord nbars to avoid for
;; *[soccer for endurance and team] strategy*
;;
n_nb_x-prep-y_lexent := n_x_prep_y_lexent &
"""
Diadic n 'to' (XtoY) - nbar comp and spr
<ex>The text to speech engine worked.
"""
  [ INFLECTD na,
    SYNSEM 
    [ LOCAL 
      [ CAT 
	[ HEAD [ MINORS.MIN interval_rel,
		 AUX +,
		 PRD - ],
	  VAL [ SPR < [ --MIN gen_nom_nbar_rel,
		      	LOCAL noninfl_noun_local &
			      [ CAT [ VAL [ SPR.FIRST synsem & [ OPT -,
								 --MIN quant_rel ],
					    COMPS < > ],
				      HEAD.--BARE - ],
				CONT.HOOK [ LTOP #spltop,
					    INDEX #spind & nonconj_ref-ind ] ],
			MODIFD notmod_or_lmod ],
		      anti_synsem_min >,
		COMPS < [ --MIN gen_nom_nbar_rel,
		      	  LOCAL [ CAT [ VAL.SPR.FIRST synsem & [ OPT -,
								 --MIN quant_rel ],
					HEAD.--BARE - ],
				  CONT.HOOK [ LTOP #cltop,
					      INDEX #cind & 
						   nonconj_ref-ind ] ] ] > ] ],
	CONT [ HOOK [ LTOP #lbl,
		      INDEX #index ],
	       RELS <! [ LBL #lbl,
			 ARG0 #index,
			 CFROM #from, CTO #to ],
		       relation, relation,
	               [ PRED udef_q_rel,
			 ARG0 #spind & ref-ind,
			 RSTR #sphand,
			 CFROM #from, CTO #to ],
		       [ PRED udef_q_rel,
			 ARG0 #cind & ref-ind,
			 RSTR #chand,
			 CFROM #from, CTO #to ] !>,
               HCONS <! qeq & [ HARG #sphand,
				LARG #spltop ],
		        qeq & [ HARG #chand,
				LARG #cltop ] !>,
	       ICONS <! !> ],
	AGR [ DIV -,
	      PNG.PN 3s ] ] ] ].

;; *the 3-to-2 score*
n_nb_x-to-y_le := n_nb_x-prep-y_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED interval_rel ].

;; *the 2-for-1 stock split*
n_nb_x-for-y_le := n_nb_x-prep-y_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED "exchange_n_rel" ].

;; DPF 2011-11-19 - There is remaining spurious ambiguity here, since we can't
;; demand that the SPR be [INFLECTD +], and since e.g. *October ten* must be 
;; able to be [INFLECTD -] (for *the October ten meeting*), we get two.
;; FIX someday
;; DPF 2013-02-12 - Renamed to n_nb_x-to-y-dom_le since this one is only for
;; dofm specifier and comp.
;; DPF 2013-06-13 - Restricted first SPR to be non-inflected, since we
;; only want one analysis, and can't easily force them to be inflected.  Using
;; constraint [LOCAL noninfl_noun_local].
;; DPF 2016-10-15 - Re 2013-06-13: For this to continue to work, now that we
;; make dofm nouns take an optional yofc complement, we constrain the COMPS
;; list to be non-empty, so the optcomp rule won't apply and thus lose the
;; type constraint on LOCAL.
;;
n_nb_x-to-y-dom_lexent := n_x_prep_y_lexent &
  [ SYNSEM
    [ LOCAL 
      [ CAT [ HEAD.MINORS.MIN interval_modable_rel,
              VAL [ SPR < [ --MIN dofm_rel & #sprmin,
			    LOCAL noninfl_noun_local &
				  [ CAT.VAL [ SPR.FIRST synsem & [ OPT - ],
					      COMPS *cons* ],
				    CONT.HOOK [ LTOP #sptop,
						INDEX #spind ] ] ],
			  synsem &
			  [ LOCAL.CAT [ HEAD det &
					[ MINORS [ MIN basic_def_explicit_q_rel,
						   ALTMIN mofy_or_the_q_rel ] ],
					VAL.SPR *olist* ],
			    OPT - ],
			  anti_synsem_min >,
		    COMPS < [ --MIN dofm_rel & #sprmin,
                              LOCAL [ CAT.VAL.SPR.FIRST synsem & [ OPT - ],
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX #cind ] ] ] > ] ],
	CONT [ HOOK [ LTOP #nhand,
		      INDEX #index ],
	       RELS <! [ LBL #nhand,
			 ARG0 #index,
			 CFROM #cfrom, CTO #cto ],
		       relation, relation,
		       [ PRED udef_q_rel,
			 ARG0 #cind & ref-ind,
			 RSTR #crstr,
			 CFROM #cfrom, CTO #cto ],
		       [ PRED udef_q_rel,
			 ARG0 #spind & ref-ind,
			 RSTR #sprstr,
			 CFROM #cfrom, CTO #cto ]!>,
               HCONS <! qeq & [ HARG #crstr,
				LARG #cltop ],
		        qeq & [ HARG #sprstr,
				LARG #sptop ]!>,
	       ICONS <! !> ],
	AGR [ PNG.PN 3s,
	      DIV - ] ],
      LKEYS [ KEYREL.PRED interval_rel,
	      --COMPKEY #cmin,
              --+COMPKEY #cmin,
              --+OCOMPKEY #sprmin ] ] ].


;; Cardinal dofm interval:
;; *October ten to eleven*, **The ten to eleven (of October)*
;;
;
n_nb_x-to-y-dom_le := n_nb_x-to-y-dom_lexent &
"""
Diad n 'to'  (XtoY) - nbar cmp, cardinal dofm
<ex>We met May 23 to 25.
"""
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.HEAD.MINORS.MIN dofm_card_rel ],
				 [ LOCAL.CAT.HEAD.MINORS.ALTMIN mofy_rel ],
				 [ ] >,
			   COMPS.FIRST.--MIN dofm_card_rel ] ].

;; Ordinal dofm interval:
;; *October tenth to eleventh*, *The tenth to eleventh (of October)*
n_nb_x-to-y-ord_le := n_nb_x-to-y-dom_lexent &
"""
Diad n 'to'  (XtoY) - nbar cmp with ordinal dofm.
<ex>We met May 23 to 25.
"""
  [ SYNSEM.LOCAL.CAT.VAL [ SPR.FIRST.LOCAL.CAT.HEAD.MINORS.MIN dofm_ord_rel,
			   COMPS.FIRST.--MIN dofm_ord_rel ] ].

;; For *the $10 a share price*
;; DPF 2020-04-18 - Added SPR..SPR..HEAD det to disambiguate
;; *the $2 a gallon tax* now that we also allow *the five cent a gallon tax*
;;
p_nb_pre-meas_lexent := basic_n-or-p_x_to_y_lexent &
  [ INFLECTD +,
    SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD prep &
		   [ MOD < synsem &
			   [ LOCAL intersective_mod &
				   [ CAT [ HEAD noun,
					   VAL [ SPR.FIRST synsem,
						 COMPS < > ] ],
				     CONT.HOOK [ LTOP #ltop,
						 INDEX #mind ] ],
			     OPT - ] >,
		     PRD -,
		     MINORS.MIN #pred ],
	      VAL [ SPR < [ LOCAL [ CAT [ HEAD.MINORS [ MIN meas_nom_rel,
							ALTMIN implicit_q_rel ],
					  VAL [ SPR.FIRST synsem &
							  [ LOCAL.CAT.HEAD det],
						COMPS < > ] ],
				    CONT.HOOK [ LTOP #sphand,
						INDEX #arg1,
						XARG #shand ] ],
			    MODIFD notmod_or_lmod,
			    OPT - ],
			  anti_synsem_min >,
		    COMPS < [ LOCAL [ CAT [ HEAD noun &
					     [ MINORS.MIN abstr_meas_nom_rel ],
					    VAL [ SPR.FIRST synsem &
							  [LOCAL.CAT.HEAD det],
						  COMPS < > ] ],
				      CONT.HOOK [ LTOP #chand,
						  INDEX #arg2 ] ],
			      OPT - ] > ],
	      POSTHD - ],
	CONT [ HOOK [ LTOP #ltop ],
	       RELS <! #keyrel & prep_relation &
		     [ LBL #shand,
		       ARG1 #arg1,
		       ARG2 #arg2,
		       CFROm #cfrom, CTO #cto ],
		     prep_notense_relation &
		     [ LBL #ltop,
		       PRED compound_rel,
		       ARG1 #mind,
		       ARG2 #arg1,
		       CFROM #cfrom, CTO #cto ],
		     [ PRED udef_q_rel,
		       ARG0 #arg2 & ref-ind,
		       RSTR #crstr,
		       CFROM #cfrom, CTO #cto ],
		     [ PRED udef_q_rel,
		       ARG0 #arg1 & ref-ind,
		       RSTR #sprstr,
		       CFROM #cfrom, CTO #cto ] !>,
	       HCONS <! qeq & [ HARG #crstr,
				LARG #chand ],
		        qeq & [ HARG #sprstr,
				LARG #sphand ] !>,
	       ICONS <! !> ],
	AGR.DIV - ],
      --SIND non_expl,
      LKEYS.KEYREL #keyrel & [ PRED #pred ] ] ].

p_nb_pre-meas_le := p_nb_pre-meas_lexent &
"""
Measure Nbar complement, cons onset, only `a' meaning `per'
<ex>The $10 a share price
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.PHON.ONSET con ].

p_nb_pre-meas-an_le := p_nb_pre-meas_lexent &
"""
Measure Nbar complement, voc onset, only `an' meaning `per'
<ex>The $10 an ounce price
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.PHON.ONSET voc ].

;; *per* which combines with either con or voc complement
p_nb_pre-meas-cv_le := p_nb_pre-meas_lexent
"""
Measure Nbar complement, cons onset, only `a' meaning `per'
<ex>The $10 a share price
"""
.
p_np_x-to-y-num_le := n-or-p_x_to_y_lexent &
"""
prep 'to' (XtoY) - scores: numbers
<ex>They lost 3 to 2.
"""
  [ INFLECTD +,
    SYNSEM 
    [ LOCAL 
      [ CAT 
	[ HEAD prep &
	       [ MINORS.MIN #min,
		 MOD < [ LOCAL intersective_mod &
			       [ CAT [ HEAD verb,
				       VAL [ SUBJ.FIRST synsem,
					     COMPS < > ] ],
				 CONT.HOOK [ LTOP #ltop,
					     INDEX #xarg ] ] ] > ],
	  VAL [ SPR < [ --SIND #arg1,
			LOCAL.CAT [ HEAD.MINORS.ALTMIN number_q_rel,
				    VAL.SPR *olist* ] ],
		      anti_synsem_min >,
		COMPS.FIRST [ --SIND #arg2,
			      LOCAL.CAT [ HEAD.MINORS.ALTMIN number_q_rel,
					  VAL.SPR *olist* ] ] ] ],
	CONT [ HOOK [ LTOP #ltop,
		      INDEX #index ],
	       RELS <! [ PRED score_n_rel,
			 ARG0 #nindex,
			 ARG1 #arg1,
			 ARG2 #arg2 ],
		       relation,
		       [ LBL #ltop,
			 PRED #min & with_p_score_rel,
			 ARG0 #index,
			 ARG1 #xarg,
			 ARG2 #nindex ] !>,
               HCONS <! qeq !>,
	       ICONS <! !> ] ] ] ].

; DPF 13-Aug-01 - For 'mid to upper' as in "the mid to upper nineties"
; Meaning intended to be something like "the nineties in the interval whose
; start is the mid somethings and whose end is the upper somethings"
; DPF 01-sept-04 - Removed MINORS.MIN basic_adj_rel from SPR and COMPS, to 
; allow "three to five chairs"
; DPF 23-apr-09 - Generalized HEAD from adj to adj_or_intadj to enable
; intervals in measure phrases: *5-10 ft. tall*
; DPF 2010-09-14 - Identified MIN on SPR and COMPS, to avoid spurious analysis
; of *close to fifty cats*
;; DPF 2012-04-07 - Added MOD < synsem > to prevent adjunct extraction here
;; DPF 2013-09-30 - Constrained both SPR and COMP to be LEX + in order to
;; avoid e.g. spurious *impossible to apply to other*
;; DPF 2015-04-28 - Added RPERIPH bool to prevent these from appearing as
;; head of v_mod rule, as in *to PP Adj*
;; DPF 2015-07-07 - Added ALTMIN no_rel to block these from undergoing
;; partitive_np_num_phrase, as in *tricky to implement gen-adj*
;; DPF 2015-09-20 - Don't know why CARD - was added recently, but it blocks
;; measure-NP for *7 - 10 kg.*, so removing it.
;; DPF 2019-11-28 - Added MOD expressed_synsem to block num-det rule as in
;; *big - eared cats*
;;
aj_pp_i-x-to-y_le := noncqrs-m-nab &
"""
Adj, only interval 'to'          
<ex>B has small to big cats.
"""
  [ SYNSEM 
    [ LOCAL 
      [ CAT 
        [ HEAD adj_or_intadj & 
          [ MOD < expressed_synsem &
		  [ LOCAL intersective_mod &
                    [ CAT basic_nbar_cat,
                      CONT.HOOK [ LTOP #hand,
                                  INDEX #nomarg & ref-ind & [ PNG #png ] ],
                      CONJ cnil ] ] >,
            MINORS [ MIN interval_p_end_rel,
	             ALTMIN no_rel ] ],
          VAL 
          [ SUBJ < >,
            SPR < expressed_synsem &
                  [ OPT -,
                    LOCAL [ CAT [ HEAD adj_or_intadj &
                                       [ TAM [ TENSE no_tense,
                                               ASPECT no_aspect ],
                                         MOD < synsem & 
                                               [ LOCAL intersective_mod ] >,
					 MINORS.MIN #min ],
                                  VAL [ SPR *olist*,
                                        COMPS < >,
                                        SPCMPS < >,
                                        SPEC < [ LOCAL.CAT.VAL.COMPS < > ]>]],
			    CONT.HOOK [ LTOP #fghand,
                                        XARG #fromarg ],
                            CONJ cnil ],
		    LEX +,
                    NONLOC.SLASH 0-dlist ],
		  anti_synsem_min >,
            COMPS < [ OPT -,
                      LOCAL [ CAT [ HEAD adj_or_intadj &
                                         [ TAM [ TENSE no_tense,
                                                 ASPECT no_aspect ],
                                           MOD < synsem & 
                                                [ LOCAL intersective_mod ] >,
					   MINORS.MIN #min ],
                                    VAL [ SPR *olist*,
                                          COMPS < > ] ],
                              CONT.HOOK [ LTOP #tghand,
                                          XARG #toarg ],
                              CONJ cnil ],
		      LEX +,
                      NONLOC.SLASH 0-dlist,
                      PUNCT.LPUNCT no_punct ] > ] ],
        CONT [ HOOK [ LTOP #hand,
                      INDEX #arg0 & nonconj_indiv,
                      XARG #nomarg ],
               RELS <! #keyrel &
                     prep_relation &
                     [ LBL #ihand,
                       PRED interval_p_end_rel,
                       ARG0 #arg0,
                       ARG1 #intarg & [ DIV + ],
                       ARG2 #toarg,
		       CFROM #from,
		       CTO #to ],
                     prep_relation &
                     [ LBL #ihand,
                       PRED interval_p_start_rel,
                       ARG0.E [ TENSE no_tense,
                                ASPECT no_aspect ],
                       ARG1 #intarg,
                       ARG2 #fromarg,
		       CFROM #from,
		       CTO #to ],
                     [ LBL #fghand,
                       PRED elliptical_n_rel,
                       ARG0 #fromarg,
		       CFROM #from,
		       CTO #to ],
                     [ PRED udef_q_rel,
                       ARG0 #fromarg & ref-ind,
                       RSTR #fgrhand,
		       CFROM #from,
		       CTO #to ],
                     [ LBL #tghand,
                       PRED elliptical_n_rel,
                       ARG0 #toarg,
		       CFROM #from,
		       CTO #to ],
                     [ PRED udef_q_rel,
                       ARG0 #toarg & ref-ind,
                       RSTR #tgrhand,
		       CFROM #from,
		       CTO #to ],
                     [ LBL #ihand,
                       PRED interval_rel,
                       ARG0 #intarg,
		       CFROM #from,
		       CTO #to ],
                     [ PRED udef_q_rel,
                       ARG0 #intarg & ref-ind,
                       RSTR #irhand,
		       CFROM #from,
		       CTO #to ],
                     prep_relation &
                     [ LBL #hand,
                       PRED loc_nonsp_rel,
                       ARG0.E [ TENSE no_tense,
                                ASPECT no_aspect ],
                       ARG1 #nomarg,
                       ARG2 #intarg,
		       CFROM #from,
		       CTO #to ] !>,
               HCONS <! qeq & [ HARG #irhand,
                                LARG #ihand ],
                      qeq & [ HARG #fgrhand,
                              LARG #fghand ],
                      qeq & [ HARG #tgrhand,
                              LARG #tghand ] !>,
	       ICONS <! !> ],
        AGR [ PNG #png,
              DIV - ] ],
      LKEYS.KEYREL #keyrel,
      MODIFD [ LPERIPH na,
               RPERIPH bool ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ADVERBS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Adverbs modify VPs and APs either pre-head or post-head (or both).
; Sentence-initial adverbials are treated as extractions of post-VP modifiers,
; unless the adverbial is a pre-head modifier. Otherwise, it would be hard to
; block post-S attachment along with post-VP attachment, which would give 
; spurious ambiguity.
; DPF 19-Oct-02 - Removed nonprd_synsem parent, since trying to make
; head_adj rule constrain adj to be PRD +.
;; DPF 2017-09-27 - Pushed COMPS < > down to subtypes, since we want to treat 
;; the special modal-like `rather' and `sooner' as comparative adverbs that 
;; take a than-PP, as in *they would rather sing than dance* or 
;; *he will sooner sing than dance*.
;;
basic_basic_adverb_synsem := basic_one_arg & basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD basic_adv &
		       [ MOD < [ LOCAL local_basic &
				       [ CONJ cnil ],
                                 MODIFD.LPERIPH #lperiph,
                                 OPT - ] >,
                         MINORS.MIN basic_adv_rel ],
                  VAL [ SUBJ < >,
                        SPR #spr & [ FIRST.LOCAL.CAT.VAL.SPCMPS #spc ],
			SPCMPS #spc ] ],
            ARG-S #spr ],
    MODIFD.LPERIPH #lperiph,
    --SIND non_expl ].

basic_adverb_synsem := basic_basic_adverb_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

scopal_spec_adverb_synsem := spec_adverb_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL scopal_mod &
				     [ CAT [ HEAD adverbee,
					     MC #mc ],
				       CONT.HOOK [ LTOP #mhand,
						   INDEX #index,
						   XARG #xarg ] ] ] >,
		  MC #mc ],
	    CONT [ HOOK [ INDEX #index,
			  XARG #xarg ],
                   HCONS <! qeq &
                          [ HARG #hand,
                            LARG #mhand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL.ARG1 #hand & handle ].


; DPF 17-Dec-01 - Made MOD..E-INDEX reentrant with E-INDEX, and the INDEX 
; values the same: 
; 'Chairs currently available arrived"
; DPF 04-may-05 - We consider restricting intersective adverbs to not modify
; auxiliary VPs, to avoid generating e.g. "Abrams carefully is leaving."
; But this also blocks e.g. "Abrams will often be early" - if anything, the
; generalization is that these adverbs don't want to attach to finite aux VPs,
; but that constraint is hard to express, and it's probably even more tricky
; to get the real constraint right - cf. ellipsis: "Kim often will." Or even
; "Kim sometimes might say this".  So remove AUX - from MOD.
;; DPF 2015-03-12 - Removed identification of MC on adv and MOD, since we now
;; want e.g. *we arrived, says Kim happily* where "happily" attaches to the
;; S/CP which is MC -, not MC na.
;; DPF 2017-09-30 - Constrain MOD to be QUE 0-dlist to avoid *when suddenly*
;; since these adverbs identify their QUE value with that of their spr, which
;; ends up as 0-dlist if the spr is unexpressed, and hence these advs don't
;; propagate the QUE of the hd-dtr, so they better not modify QUE 1-dlist guys.
;; DPF 2020-04-21 - We eventually want to identify XARG with MOD..INDEX, but
;; would first have to remove the unwanted identity of XARG on the two dtrs
;; in basic_adj_h_int_phrase.  FIX for algebra.
;;
#|
basic_int_adverb_synsem := basic_basic_adverb_synsem & isect_synsem &
  [ LOCAL [ CAT.HEAD.MOD < [ LOCAL [ CAT.MC na_or_-,
				     CONT.HOOK.INDEX #index ],
			     NONLOC.QUE 0-dlist ] >,
	    CONT.HOOK.XARG #index ],
    LKEYS.KEYREL.ARG1 #index & event ].
|#
basic_int_adverb_synsem := basic_basic_adverb_synsem & isect_synsem &
  [ LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.MC na_or_-,
				   CONT.HOOK.INDEX #index ],
			   NONLOC.QUE 0-dlist ] >,
    LKEYS.KEYREL.ARG1 #index & event ].

basic_spec_adverb_synsem := basic_basic_adverb_synsem &
  [ LOCAL.CAT [ VAL.SPR < synsem & 
			  [ LOCAL [ CAT [ VAL [ SUBJ < >,
						SPR *olist* ],
					  MC na ],
				    CONT.HOOK [ LTOP #hand,
						XARG #arg0 ] ] ] > ],
    LKEYS.KEYREL [ LBL #hand,
                   ARG0 #arg0 ] ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
spec_adverb_synsem := basic_spec_adverb_synsem & basic_adverb_synsem &
  [ LOCAL.CAT.VAL.SPR < [ --MIN more_or_very_deg_rel,
                          LOCAL.CAT.HEAD adv ] > ].

;; For comparative `rather, sooner' as in
;; *they would rather buy books than videos*
;; *they would rather live in Paris than in Rome*
;; But not (currently) for
;; *they would rather sing than dance*
;; because we want to block
;; **they would rather sing than seemed possible*
;; which we do by not allowing these adverbs to take the than-P which takes
;; a CP complement (possibly with a gap).  Contrast the above with a `normal'
;; comparative adverb structure as in
;; *they arrived more quickly than seemed possible*
;; So we analyze *they would rather sing than dance* as VP-coord with the
;; correlative conjunction pair *rather...than*.  Perhaps need to
;; harmonize the semantics of such VP coord with the comparative one here. FIX?
;;
adverb_comp_synsem := basic_spec_adverb_synsem & basic_int_adverb_synsem & 
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT [ HEAD verb,
					     VAL [ SUBJ *synlist*,
						   COMPS < > ] ] ] >,
			 MINORS.MIN adv_rel ],
		  VAL [ SPR < [ --MIN much_deg_rel,
				LOCAL.CAT.HEAD adv ] >,
			COMPS < synsem &
				[ LOCAL [ CAT [ HEAD prep &
						[ MINORS 
						  [ MIN _than_p_compar_rel ] ],
						VAL.COMPS < > ],
					  CONT.HOOK [ LTOP #ltop,
						      INDEX #ind ],
					  CONJ cnil ],
				  OPT -,
				  NONLOC non-local_none,
				  PUNCT.LPUNCT no_punct ] > ] ],
	    CONT.RELS <! [ CFROM #cfrom, CTO #cto ],
		         [ PRED more_comp_rel,
			   LBL #ltop, ARG1 #arg, ARG2 #ind,
			   CFROM #cfrom, CTO #cto ] !> ],
    LKEYS.KEYREL [ LBL #ltop,
		   ARG0 #arg,
		   CFROM #cfrom, CTO #cto ] ].

; VP, PP, AP
scopal_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD adv & 
                   [ MOD < [ LOCAL.CAT [ VAL.COMPS < >,
                                         MC na_or_- ] ] > ] ].

;; DPF 2015-03-12 - Changed MOD..SUBJ *synlist* to MOD..SPR < synsem_min, ...>,
;; in order to admit *we arose, said Kim happily*.  The problem was that 
;; adverbs demanded that the MOD target be [SUBJ *synlist*], while filler-hd 
;; required hd-dtr to be [SUBJ *anti_list*].
;; DPF 2017-10-03 - To avoid this in non-question aux inversion such as
;; **last did we arise ...*, constrain to [MOD..INV -].
;; DPF 2017-11-18 - But this INV - interferes with the hack we use for prd-be
;; `being' to block *Kim is being arising*, where we say its complement is
;; INV +.  Until we improve that analysis, leave MOD..INV here unconstrained,
;; and live with the extra ambiguity.
;;
basic_intersect_adverb_synsem := basic_int_adverb_synsem & 
				 basic_spec_adverb_synsem &
  [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ VAL [ SPR < synsem_min, ... >,
					       COMPS < > ],
					 MC na_or_- ] ] >,
		VAL.COMPS < > ] ].

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
;; DPF 2014-04-29 - But we also need to differentiate positive from comparative
;; adverbs (*very fast* vs *much faster*).  So push the SPR requirement down.
;;
intersect_adverb_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD reg_adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
                  VAL.SPR < [ LOCAL.CAT.HEAD adv ] > ],
            CONT [ HCONS <! !>,
		   ICONS <! !> ] ] ].

; Adverbs like "once" as in "just once" ("*very once")
intersect_adverb_just_only_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD reg_adv & [ MOD < [ LOCAL.CAT adverbee_cat ] > ],
                  VAL.SPR < [ --MIN just_only_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
            CONT [ HCONS <! !>,
		   ICONS <! !> ] ] ].

; 'now' but not 'then' - appears after auxiliary as in "You are now ready"
; DPF 10-apr-05 - Changed SPR..MIN from no_rel to very_deg_rel in order
; to get "Kim is very often unhappy" and "Kim very often refuses to leave"
; Will have to find some other way to block "*Kim is very now unhappy",

; DPF 12-jul-06 - Changed SPR..MIN from very_this_that_rel to 
; more_or_very_deg_rel as part of blocking "more many"
intersect_adverb_auxv_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD lexadv & [ MOD < [ LOCAL [ CAT adverbee_cat &
                                                      [ HEAD v_or_g ],
                                                  CONT.HOOK.LTOP #ltop ],
                                          MODIFD.LPERIPH na_or_- ] > ],
                  VAL.SPR < [ --MIN more_or_very_deg_rel,
                              LOCAL.CAT.HEAD adv ] > ],
            CONT.HOOK.LTOP #ltop ] ].

#|
;; DPF 2012-02-27 - Interestingly, it seems that we need to allow adverbs
;; that modify other adverbs.  At least, this seems to be the right analysis
;; for `already' as in *twice already, kim has lost*.  To be cautious, let's
;; start by constraining the modifiee to LEX +.
;; But in fact, the head-adj rule for intersective modifiers would have to be
;; generalized to allow adverb modifiees, and this will take substantial
;; testing to avoid overgeneration.  So put off for now, but 
;; FIX someday
;;
intersect_adverb_advmod_synsem := basic_intersect_adverb_synsem &
  [ LOCAL [ CAT [ HEAD lexadv & [ MOD < [ LOCAL [ CAT.HEAD adv,
                                                  CONT.HOOK.LTOP #ltop ],
					  LEX + ] > ],
                  VAL.SPR < [ --MIN just_only_deg_rel,
			      LOCAL.CAT.HEAD adv ] > ],
            CONT [ HOOK.LTOP #ltop,
		   RELS <! relation !>,
                   HCONS <! !>,
		   ICONS <! !> ] ] ].

av_-_i-avmod_le := basic_adverb_word &
"""
Intersective, adverb modifiee
<ex>Twice already, B won.
"""
  [ SYNSEM intersect_adverb_advmod_synsem ].
|#


; VP only
; Block adj modifiee to avoid spurious parse for "almost empty"
; DPF 09-Aug-99 - Relaxed MOD..HEAD value to be v_or_g_or_a because okay for 
; adjectives as pre-head modifiers ("an apparently difficult problem"), though
; not post-head.
; DPF 25-Oct-01 - Removed MOD..MOD < synsem > constraint since it blocked
; 'I should never have arrived'
; DPF 30-aug-04 - Changed MOD..SUBJ from <synsem_min> to *synlist* in order
; to return to letting adverbs modify adjectives, while still distinguishing
; VPs from clauses.
; DPF 04-sept - But this prevents modification of inverted sentences as in
; 'why hasn't kim arrived yet'.  So use MOD..MSG no_msg instead.

scopal_vp_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL [ CAT [ HEAD v_or_a,
                                           VAL.SPR.FIRST synsem_min ] ] ] >,
                     MINORS.MIN adv_rel ],
    LKEYS.KEYREL adv_relation ].

; Adverbs like "also" that either (pre) modify VPs or appear as complements of
; aux Vs.
; DPF 24-May-00 - Restrict MOD value to be no_aspect, to avoid spurious
; ambiguity for "kim is probably leaving"
; DPF 14-Oct-00 - But this prevents the desired parse for "Kim is not currently
; sleeping" since "not" should modify a pres-participle VP, not the gerund.  So
; as long as the gerund rule is a lexical rule, we're stuck with the ambiguity.
; DPF 13-Mar-02 - Added [MOD..PRD +] to ensure that when these adverbs modify
; deverbal adjectives, they not appear attributively, as in *the not yet 
; finished book
; DPF 18-Mar-02 - But this [PRD +] prevents these adverbs from pre-modifying
; ordinary finite VPs.  So let's instead accept "the not yet finished book" as
; okay.
; DPF 30-aug-04 - Changed MOD..SUBJ from <synsem_min> to *synlist* in order
; to return to letting adverbs modify adjectives, while still distinguishing
; VPs from clauses.

scopal_vp_aux_adverb_synsem := scopal_spec_adverb_synsem &
  [ LOCAL.CAT.HEAD lexadv &
                   [ MOD < [ LOCAL.CAT [ HEAD v_or_a,
                                         VAL [ SUBJ *synlist*,
                                               COMPS < > ],
                                         MC na ] ] >,
                     MINORS.MIN adv_rel ] ].

scopal_negadv_adverb_synsem := scopal_adverb_synsem &
  [ LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD negadv,
                                         VAL.SUBJ < > ] ] >,
                     MINORS.MIN adv_rel ],
    LKEYS.KEYREL adv_relation ].

; DPF 21-Mar-02 - Added MOD..MSG no_msg, which seemingly should have
; been here all along - needed to block e.g. spurious parse for "kindly leave"
intersect_vp_adverb_synsem := intersect_adverb_synsem &
  [ LOCAL.CAT.HEAD.MINORS.MIN basic_adv_rel,
    LKEYS.KEYREL adv_relation ].

; S (for pre-S scopal adverbs only)
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.
;; DPF 20-05-12 - Generalize MOD..HEAD from verb to verbal so we can get
;; *we know (a) that Kim arrived and (b) that Browne left*

scopal_s_adverb_synsem := spec_adverb_synsem &
  [ LOCAL [ CAT [ HEAD adv &
                     [ MOD < [ LOCAL scopal_mod &
                                     [ CAT [ HEAD verbal,
                                             VAL [ SUBJ *olist*,
                                                   COMPS < > ],
					     MC #mc ],
                                       CONT [ HOOK [ LTOP #arghand,
                                                     INDEX #index ] ] ] ] > ],
		  MC #mc ],
	    CONT [ HOOK [ LTOP #khand,
                          INDEX #index & [ SF #iforce ] ],
		   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #arghand ] !>,
		   ICONS <! !> ] ],
    LEX +,
    PUNCT.RPUNCT.PSF #iforce,
    LKEYS.KEYREL [ LBL #khand,
                   ARG1 handle & #mhand ] ].

; For adverbs like "maybe" which take no degree specifier
;
; DPF 26-Jul-99 - Made MOD..HEAD be 'verb' instead of 'adverbee' to block
; "so then" with "then" as discourse adverb.
; DPF 03-dec-05 - Generalized MOD..HEAD to 'verbal' to allow e.g.
; "they believed therefore that Kim was right"
basic_scopal_s_adverb_nospec_synsem := basic_adverb_synsem &
  [ LOCAL [ CAT [ VAL.SPR < anti_synsem_min >,
		  HEAD adv &
                          [ MOD < [ LOCAL scopal_mod &
                                          [ CAT [ HEAD basic_verb_or_frag,
                                                  VAL [ SUBJ *olist*,
                                                        COMPS < > ],
                                                  MC bool & #mc ],
                                            CONT.HOOK [ LTOP #arghand,
                                                        INDEX #index ] ] ] >,
                            MINORS.MIN adv_rel ],
		  MC #mc ],
	    CONT [ HOOK [ LTOP #khand,
                          INDEX #index & [ SF #iforce ] ],
		   HCONS <! qeq &
			   [ HARG #mhand,
			     LARG #arghand ] !>,
		   ICONS <! !> ] ],
    LEX +,
    PUNCT.RPUNCT.PSF #iforce,
    LKEYS.KEYREL [ LBL #khand,
                   ARG1 handle & #mhand ] ].

scopal_s_adverb_nospec_synsem := basic_scopal_s_adverb_nospec_synsem &
  [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.MC #mc ] >,
		MC #mc ] ].

basic_adverb_word := noncrs-m-nab &
   [ SYNSEM basic_lex_synsem &
	    [ LOCAL.CONT [ HOOK.LTOP #ltop,
			   RELS.LIST < #keyrel, ... > ],
	      PUNCT.PNCTPR ppair,
              LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].


adverb_word := basic_adverb_word &
  [ SYNSEM scopal_vp_adverb_synsem &
	   [ LOCAL.CONT.RELS <! relation !> ] ].

av_-_s-negmod_le := basic_adverb_word &
"""
Scop, modify 'not': 'probably'   
<ex>B is probably not C.
"""
  [ SYNSEM scopal_negadv_adverb_synsem &
	   [ LOCAL.CONT.RELS <! relation !> ] ].

; DPF (27-Apr-99) Assume for now that S-initial adverbs can only modify [INV -]
; S's, in order to block "*Never does kim sleep?"
; DPF 28-Oct-01 - But this blocked e.g. "Meanwhile when does kim sleep"

norm_adv_word := noncrs-nab &
   [ SYNSEM basic_lex_synsem &
	    [ LOCAL.CONT.RELS.LIST < #keyrel, ... >,
	      LKEYS.KEYREL #keyrel ] ].

adv_s_pre_lexent := norm_adv_word &
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL [ CAT [ POSTHD -,
			   HEAD.MOD < [ LOCAL.CAT.MC bool ] > ],
		     CONT.RELS <! relation !> ] ] ].

av_-_s-cp-pr_le := adv_s_pre_lexent &
"""
Scop, S, pre-hd                  
<ex>Obviously B won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN adv_rel ].

av_-_s-cp-pr-inv_le := norm_adv_word &
"""
Scop, inverted S, pre-hd
<ex>Never had B won.
"""
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL [ CAT [ POSTHD -,
			   HEAD [ MINORS.MIN adv_rel,
				  PRD -,
				  MOD < [ LOCAL.CAT [ HEAD.INV +,
						      MC na ] ] > ] ],
		     CONT.RELS <! relation !> ] ] ].

av_-_s-cp-pr-inv-ell_le := norm_adv_word &
"""
Scop, inverted and elided S, pre-hd                  
<ex>So did Kim.
<ex>As did Kim.
"""
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL [ CAT [ POSTHD -,
			   HEAD [ MINORS.MIN adv_rel,
				  PRD -,
				  MOD < [ LOCAL.CAT 
					 [ HEAD verb &
						[ INV +,
						  MINORS.ALTMIN ellipsis_rel ],
					   MC na ] ] > ] ],
		     CONT.RELS <! relation !> ] ] ].


; For "(3)" or "3)" meaning 'thirdly'
av_-_s-cp-gen_le := adv_s_pre_lexent & basic_generic_lex_entry &
"""
Scop, S, generic                 
<ex>Generic-adv, B won.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN adv_rel,
	     LKEYS.KEYREL.PRED "nth_rel",
	     PHON.ONSET unk_onset ] ].

; 'evidently' - only pre-modifies declaratives, not questions or commands
av_-_s-cpp_le := norm_adv_word &
"""
Scop, S-prop, pre-hd             
<ex>Evidently B won.
"""
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL [ CAT 
		     [ HEAD [ MOD < [ LOCAL [ CAT.MC +,
					      CONT.HOOK.INDEX.SF basic-prop ]]>,
			      MINORS.MIN adv_rel ] ],
		     CONT.RELS <! relation !> ] ] ].
    
; DPF 10-Apr-02 - Removed MOD..VFORM imp_vform since this blocked e.g 
; "I would like to know when my order is going to arrive , please"
av_-_s-cp-nsp-po_le := norm_adv_word &
"""
Scop, S, no spec, post-hd        
<ex>B won for sure.
"""
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL [ CAT [ POSTHD +,
			   HEAD.MOD < [ LEX -,
					LOCAL.CAT.MC bool ] > ],
		     CONT.RELS <! relation !> ] ] ].

av_-_s-cp-mc-po_le := norm_adv_word &
"""
Scop, S main cls (mc), post-hd: reserve for robust only
<ex>B won, and ...
"""
  [ GENRE robust,
    SYNSEM basic_scopal_s_adverb_nospec_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.MC +,
					NONLOC.SLASH 0-dlist ] >,
			   POSTHD + ],
		     CONT.RELS <! relation !> ] ] ].

av_-_s-cp-nsp-pr_le := norm_adv_word &
"""
Scop, S, no spec, pre-hd         
<ex>Hence B won.
"""
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL [ CAT.POSTHD -,
		     CONT.RELS <! relation !> ] ] ].
    
av_-_s-cp-mc-pr_le := norm_adv_word &
"""
Scop, S main cls (mc), pre-hd    
<ex>No, B won.
"""
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL [ CAT [ HEAD.MOD < [ NONLOC.SLASH 0-dlist ] >,
			   MC +,
			   POSTHD - ],
		     CONT.RELS <! relation !> ] ] ].
    
av_-_s-cp_le := norm_adv_word &
"""
Scop, S                          
<ex>Actually B won.
"""
  [ SYNSEM scopal_s_adverb_synsem &
	   [ LOCAL [ CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD.INV -,
						  MC bool ] ] >,
				MINORS.MIN adv_rel ],
		     CONT.RELS <! relation !> ] ] ].

;; DPF 2016-08-02 - Added constraint to allow only VP and not S, as the type
;; name suggests, to block *So did Kim arise.*
;;
av_-_s-vp_lexent := adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [ LOCAL.CAT [ HEAD v_or_g_or_a,
						VAL [ SUBJ *synlist*,
						      COMPS < > ] ],
                                  MODIFD [ LPERIPH na_or_-,
					   RPERIPH na_or_- ] ] >,
                            MINORS.MIN adv_rel ] ].

av_-_s-vp_le := av_-_s-vp_lexent
"""
Scopal, VP                       
<ex>B possibly won.
"""
.

av_-_s-vp-only_le := av_-_s-vp_lexent &
"""
Scop, VP (no AdjP)               
<ex>B won too.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g ] > ].

av_-_s-vp-x_le := basic_adverb_word &
"""
Scop, VP w/aux head
<ex>B is obviously C.
"""
  [ SYNSEM scopal_vp_aux_adverb_synsem &
           [ LOCAL [ CAT [ POSTHD -,
			   HEAD.MOD < [ MODIFD.LPERIPH na_or_- ] > ],
		     CONT.RELS <! relation !> ] ] ].
    
av_-_s-vp-only-x_le := basic_adverb_word &
"""
Scop, VP w/aux head, does not modify adjectives
<ex>B is really C.
"""
  [ SYNSEM scopal_vp_aux_adverb_synsem &
           [ LOCAL [ CAT [ POSTHD -,
			   HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g,
					MODIFD.LPERIPH na_or_- ] > ],
		     CONT.RELS <! relation !> ] ] ].
    
; DPF 7-Jun-00 - To avoid apparently spurious ambiguity of attachment of
; VP-final scopal adverbs in e.g. "I have won too", require these adverbs to
; attach only to finite or imperative VP, forcing high attachment.
;; DPF 2017-09-04 - Re 7-Jun-00: Now that we treat "however" as a scopal adverb
;; as in *we could arise, however, in Rome.*, and while we still insist on
;; avoiding attachment of intersective post-modifiers to modals (to avoid more
;; spurious ambiguity), we have to relax this constraint to also allow base form
;;
av_-_s-vp-po_le := adverb_word & 
"""
Scop, VP, post-hd                
<ex>B won too.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD v_or_g & 
                                                   [ VFORM fin_or_bse_or_imp ],
                                    MODIFD.RPERIPH na_or_- ] >,
                       POSTHD + ] ].

av_-_s-vp-pr_le := adverb_word & 
"""
Scop, VP, pre-hd                 
<ex>B thereby won.
"""
  [ SYNSEM.LOCAL.CAT [ POSTHD -,
                       HEAD [ MINORS.MIN adv_rel,
                              MOD < [ MODIFD.LPERIPH na_or_- ] > ] ] ].

av_-_i-ap-pp_le := basic_adverb_word &
"""
Int, AP or PP                    
<ex>Anyone currently ahead won
"""
  [ SYNSEM intersect_adverb_synsem & 
    [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT.HEAD a_or_p &
                                     [ MOD < [ LOCAL intersective_mod ] > ]] >,
			   MINORS.MIN adv_rel ],
		    VAL.SPR.FIRST.--MIN more_or_very_deg_rel ],
	      CONT.RELS <! relation !> ] ] ].
    
av_-_i-pp-po_le := basic_adverb_word &
"""
Int, PP, post-hd only
<ex>The project was for medical purposes only.
"""
  [ SYNSEM intersect_adverb_synsem & 
    [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT.HEAD prep_or_modnp &
                                     [ MOD < [ LOCAL intersective_mod ] > ]] >,
			   MINORS.MIN adv_rel ],
		    VAL.SPR.FIRST unexpressed,
		    POSTHD + ],
	      CONT.RELS <! relation !> ] ] ].

;; For *long* as in *all day long*

aj_-_i-long_le := norm_adj_word &
"""
Adj postnom, only `long'
<ex>It ran all day long.
"""
  [ SYNSEM nomod_adj_synsem &
    [ LOCAL [ CAT [ HEAD [ MOD < [ --MIN no_rel ] >,
			   PRD -,
			   MINORS.MIN long_a_rel ],
		    VAL [ SPR.FIRST.LOCAL.CAT.HEAD no_head,
			  COMPS < > ] ],
	      CONT [ HOOK.XARG #arg,
		     RELS <! #keyrel !>,
		     HCONS <! !>,
		     ICONS <! !> ] ],
      LKEYS.KEYREL #keyrel & [ ARG1 #arg ] ] ].

av_-_i-ap_lexent := basic_adverb_word &
  [ SYNSEM intersect_adverb_synsem & 
    [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT.HEAD adj_or_intadj &
                                     [ MOD < [ LOCAL intersective_mod ] > ]] >,
			   MINORS.MIN adv_rel ],
		    VAL.SPR.FIRST.--MIN more_or_very_deg_rel ],
	      CONT.RELS <! relation !> ] ] ].

av_-_i-ap_le := av_-_i-ap_lexent &
"""
Intersective, AdjP               
<ex>B was sub-optimal
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD adj ].

av_-_i-ap-num_le := av_-_i-ap_lexent &
"""
Intersective, AdjP, intersective adj
<ex>The other five cats
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD intadj ].

;; For normal positive adverbs
;;
int_vp_adverb_word := basic_adverb_word &
  [ SYNSEM intersect_vp_adverb_synsem &
	   [ LOCAL [ CAT.VAL.SPR.FIRST.--MIN more_or_very_deg_rel,
		     CONT.RELS <! relation !> ] ] ].
    
;; For comparative adverbs like *faster*
;;
int_vp_adverb_comp_word := basic_adverb_word &
  [ SYNSEM intersect_vp_adverb_synsem &
	   [ LOCAL [ CAT.VAL.SPR.FIRST.--MIN much_deg_rel,
		     CONT.RELS <! relation !> ] ] ].

int_vp_adv_just_only_word := basic_adverb_word &
  [ SYNSEM intersect_adverb_just_only_synsem &
	   [ LOCAL.CONT.RELS <! relation !> ] ].
    
int_vp_aux_adverb_word := basic_adverb_word &
  [ SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL.CAT.HEAD.MINORS.MIN adv_rel ] ].
    
;; DPF 2014-04-09 - In order to parse *Profits will be down again this year*
;; without VP-ellipsis reading, we have to allow adverbs to modify PPs, since 
;; *this year* will not modify auxiliaries.  To keep ambiguity in check, also
;; block adverbs from modifying auxiliaries.
;; DPF 2017-12-02 - Remove MOD..MODIFD.LPERIPH na_or_-, since we want APs like
;; *as many* to be LPERIPH + to block *large as many cats*.  Also dubious to
;; impose LPERIPH constraint when the adverb is used as post-head modifier
;; (and the same objection may hold for MOD..RERIPH when the adverb is pre-head)
;; 
basic_adv_int_vp_lexent := basic_adverb_word &
  [ SYNSEM.LOCAL.CAT.HEAD adv & 
                          [ MINORS.MIN adv_rel,
                            MOD < [ LOCAL.CAT.HEAD v_or_g_or_a_or_p &
						   [ AUX - ],
                                    MODIFD [ RPERIPH na_or_- ] ] > ] ].

av_-_i-vp_lexent := basic_adv_int_vp_lexent & int_vp_adverb_word.

av_-_i-vp_le := av_-_i-vp_lexent
"""
Intersective, VP                 
<ex>B quickly won.
"""
.

av_-_i-vp-cmp_le := basic_adv_int_vp_lexent & int_vp_adverb_comp_word
"""
Intersective, VP, comparative, pre- or post-head.
<ex>B oftener walked.
"""
.

;; DPF 2017-09-12 - Removed POSTHD + since we want to also get
;; *he (very) much prefers to sleep late* and
;; *he twice tried to enter through the back door*
;; Correspondingly, removed the ad hoc lex entry for "very much preferred..."
;; DPF 2020-05-23 - Tried adding NORM norm_rel to block these in v_mod: 
;; *meant much*.  But we need this for *wants very much to...*
;;
; 'much' - want to avoid "*older much"
av_-_i-vp-only_le := av_-_i-vp_lexent &
"""
Intersective, VP (no AdjP)       
<ex>B didn't sleep much.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ] > ].

; 'most' - paired with non-mobile post-head modifier
av_-_i-vp-only-pr_le := av_-_i-vp_lexent &
"""
Intersective, VP (no AdjP)       
<ex>B most wanted to dance.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
		       POSTHD - ] ].

; 'enough' - want to avoid "*very enough"
av_-_i-vp-nspr_le := av_-_i-vp_lexent &
"""
Intersective, VP-mod, no specifier
<ex>B didn't sleep enough
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD verb ] >,
		       VAL.SPR < unexpressed_min >,
		       POSTHD + ] ].


; CSY 19-9-2020 - MINORS.NORM is used for finer-grain control over which rules can apply
av_-_already_le := av_-_i-vp_lexent &
"""
CSY 31-08-2020 - introduced for 'already' the POSTHD + aspect marker
supposedly MODs entire VP with the VAL.COMPS < >
CSY 17-9-2020 - PRF + which prevents sentences like 'he eats already.'
CSY 19-9-2020 - added MINORS.NORM norm_rel to prevent it from going through vp_mod_int_rule
		which allows it to mod the VP before it gets its complement
"""
  [ SYNSEM.LOCAL.CAT [ HEAD [ MOD < [ LOCAL.CAT [ HEAD verb &
						     [ TAM.ASPECT.PRF + ],
						VAL [ SPR *olist*,
						      COMPS < > ] ] ] >,
			      MINORS.NORM norm_rel ],
		       VAL.SPR < unexpressed_min >,
		       POSTHD + ] ].

; DPF 06-sept-07 - Add type to allow restrictions on which adverbs can take
; part in the v_mod rule which allows modifiers before NP complements.
;; DPF 2012-09-21 - Generalize MOD..HEAD from v_or_a to v_or_a_or_p to allow
;; *for now, at least, we arise*
;; DPF 2018-12-15 - But note that this blocks position between V and inf-to
;; as in *we need at least to arise* (cf wsj07e:20794025).  FIX
;;
av_-_i-vp-nvm_le := av_-_i-vp_lexent &
"""
Intersective, VP (no v_adv_np)   
<ex>B at least likes cats.
"""
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD.FIRST.LOCAL.CAT.HEAD v_or_a_or_p,
			    MINORS.NORM norm_rel ] ].

;; DPF 2019-09-24 - But we also want *He tried hard to win*.  So undo, and
;; count on parse ranking to avoid unwanted "B is hard to understand".
;;
av_-_i-vp-po-nvm_le := int_vp_adverb_word & 
"""
Intersective, VP post-mod, no v_adv_np
<ex>B works hard.
<nex>B is hard to understand
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD adv & [ MINORS [ MIN adv_rel,
					       NORM norm_rel ],
                                      MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                              MODIFD.RPERIPH na_or_- ] > ],
                         POSTHD + ],
             MODIFD hasmod ] ].

av_-_i-vp-j_le := int_vp_adv_just_only_word &
"""
Intersective, VP not modif       
<ex>B sometimes wins.
"""
  [ SYNSEM.LOCAL.CAT.HEAD adv & 
                          [ MINORS.MIN adv_rel,
                            MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                    MODIFD [ LPERIPH na_or_-,
                                             RPERIPH na_or_- ] ] > ] ].

av_-_i-vp-x_le := int_vp_aux_adverb_word &
"""
Int, VP w/aux head               
<ex>B can indeed win.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
                           POSTHD - ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

av_-_i-vp-x-only_le := int_vp_aux_adverb_word &
"""
Int, VP w/aux head, only         
<ex>B should if possible win.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < anti_synsem &
                                      [ LOCAL [ CAT.HEAD verb,
                                                CONT.HOOK.LTOP #ltop ] ] > ],
                     CONT [ HOOK.LTOP #ltop,
                            RELS <! #keyrel !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; 'long' as in "we have long admired abrams"
av_-_i-vp-x-nmd_le := int_vp_aux_adverb_word &
"""
Int, only complement of aux      
<ex>B can in any case win.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < anti_synsem >,
                           POSTHD - ],
                     CONT [ RELS <! #keyrel !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

; 'now'
av_-_i-vp-x-now_le := noncrs-hm &
"""
Int, just 'now'                  
<ex>B can now win.
"""
  [ INFLECTD +,
    SYNSEM intersect_adverb_auxv_synsem &
           [ LOCAL [ CAT [ HEAD [ TAM #tam,
				  MOD < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN
						    non_ellipt_rel,
						  CONT.HOOK.INDEX #arg1 ] ] > ],
			   POSTHD - ],
                     CONT [ HOOK [ INDEX #arg0,
				   XARG #arg1 ],
			    RELS <! [ PRED temp_loc_x_rel,
				      ARG0 #arg0 & event,
				      ARG1 #arg1,
                                      ARG2 #inst & ref-ind,
				      CFROM #from,
				      CTO #to ],
                                   [ LBL #nhand, 
                                     PRED time_n_rel,
                                     ARG0 #inst,
				     CFROM #from,
				     CTO #to ],
                                   [ PRED def_implicit_q_rel,
                                     ARG0 #inst,
                                     RSTR #rhand,
				     CFROM #from,
				     CTO #to ],
                                   [ LBL #nhand,
                                     PRED _now_a_1_rel,
                                     ARG1 #inst,
				     CFROM #from,
				     CTO #to ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #nhand ] !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL.ARG1 [ E #tam,
				 SORT time ] ],
    ORTH [ FROM #from, TO #to ] ].

; DPF 25-aug-07 - Added MODIFD hasmod to prevent these from appearing in
; the robust v_mod construction preceding complements, to avoid spurious
; ambiguity for e.g. "Abrams has more consultants."
; DPF 24-may-07 - Generalized MOD..HEAD from v_or_g_or_a in order to get 
; modification of PPs as in "is down again"

av_-_i-vp-po_le := int_vp_adverb_word & 
"""
Int, VP post-hd                  
<ex>B ran fast.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                      MOD < [ LOCAL.CAT.HEAD v_or_g_or_a_or_p,
                                              MODIFD.RPERIPH na_or_- ] > ],
                         POSTHD + ],
             MODIFD hasmod ] ].

av_-_i-vp-po-cmp_le := int_vp_adverb_comp_word & 
"""
Int, VP post-hd, comparative form
<ex>B ran (much) faster.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                      MOD < [ LOCAL.CAT.HEAD v_or_g_or_a_or_p,
                                              MODIFD.RPERIPH na_or_- ] > ],
                         POSTHD + ],
             MODIFD hasmod ] ].

; DPF 13-nov-05 - Generalized MOD..HEAD from v_or_g to v_or_g_or_a in order
; to get modification of deverbal attrib adjs.
; DPF 24-may-07 - And generalized again in order to get modification of
; PPs as in "professors now at Stanford ..."
;
av_-_i-vp-pr_lexent := int_vp_adverb_word & 
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
				    PRD -,
                                    MOD < [ LOCAL.CAT.HEAD v_or_g_or_a_or_p,
                                            MODIFD.LPERIPH na_or_- ] > ],
                       POSTHD - ] ].

av_-_i-vp-pr_le := av_-_i-vp-pr_lexent
"""
Int, VP pre-hd                   
<ex>B nearly won.
"""
.

av_-_i-vp-pr-bse_le := av_-_i-vp-pr_lexent &
"""
Int, base-VP pre-hd
<ex>You will please wait.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.VFORM bse_only ].

av_-_i-vp-po-nmb_le := int_vp_adverb_word & 
"""
Int, VP post-hd, not extracted, not between V and comp
<ex>B can't win either.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD adv_nonmob & 
                            [ MINORS [ MIN adv_rel,
				       NORM norm_rel ],
                              MOD < [ LOCAL.CAT.HEAD v_or_g_or_a,
                                      MODIFD.RPERIPH na_or_- ] > ],
                       POSTHD + ] ].

; DPF 05-nov-08 - For lexical verbal prefixes like "re-"
;
av_-_i-v-lx-pr_le := int_vp_adverb_word & 
"""
Intersective, lexical V, pre-hd  
<ex>B out-ran the others.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD adv & [ MINORS.MIN adv_rel,
                                    MOD < [ LOCAL.CAT.HEAD verb,
				            LEX + ] > ],
                       POSTHD - ] ].

av_pp_i-cmp_le := norm_adv_word &
"""
Intersective, comparative, obligatory than-PP
<ex>B would rather eat fish than vegetables.
"""
  [ SYNSEM adverb_comp_synsem &
	   [ LOCAL.CAT.VAL.COMPS.FIRST [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
					 MODIFD.LPERIPH bool ] ] ].

; ERB (31-10-96) See notes near n_wh_pro_le.
; where, when, how
; DPF 31-may-06 - SPR constraint propagated from supertype - maybe unneeded.
; DPF 30-sept-06 - Changed MOD..HEAD from v_or_g_or_a to v_or_n_or_g_or_a
; in order to enable e.g "the reason why is obvious." as well as
; "why are there stars?"
; DPF 23-may-07 - Changed MOD..HEAD to just 'subst' since also want modif. of
; PPs as in "They knew why Kim was in Paris."
; DPF 18-feb-08 - Added PRD - to exclude spurious reading for "how is Kim?".
;; DPF 2010-10-08 - Re 31-may-06: Lack of constraint allowed "evening why"
;; as spec-hd.  But we only want a few degree adverbs as in "just why" or
;; "exactly how", so add further constraints.
;; DPF 2018-03-31 - To block **they know why to leave*, make subtype that
;; only modifies finite VPs.
;;
pp_-_i-wh_lexent := noncrs-hm-nab &
  [ SYNSEM prep_spr_mod_synsem &
      [ LOCAL [ CAT [ HEAD p_or_adv &
                           [ PRD -,
			     MOD < [ LOCAL.CAT.HEAD subst ] >,
                             MINORS.ALTMIN nom_rel ],
		      VAL [ COMPS < >,
                            SPR < [ LOCAL [ CAT [ HEAD adv,
						  VAL.SPR *unexplist* ],
					    CONT.HOOK.LTOP #ltop ],
				    --MIN more_or_very_deg_rel ] >,
			    SPEC < > ],
		      POSTHD +,
                      MC na ],
		CONT [ HOOK.LTOP #ltop,
		       RELS <! #keyrel & 
			       [ ARG2 #objind,
				 CFROM #cfrom, CTO #cto ],
			       [ PRED which_q_rel,
				 ARG0 #objind,
				 RSTR #rhand,
				 CFROM #cfrom, CTO #cto ],
			       nom_relation & #altkeyrel &
                               [ LBL #nhand,
				 ARG0 #objind ] !>,
		       HCONS <! qeq &
			       [ HARG #rhand,
				 LARG #nhand ] !>,
		       ICONS <! !> ],
                CONJ cnil ],
        LKEYS [ KEYREL #keyrel,
                ALTKEYREL #altkeyrel ],
        NONLOC.QUE 1-dlist &
              [ LIST < param > ],
        PUNCT no_punctuation_min ] ].

pp_-_i-wh_le := pp_-_i-wh_lexent
"""
PP, WH                           
<ex>B knew how C won.
"""
.
 
pp_-_i-wh-fin_le := pp_-_i-wh_lexent &
"""
PP, WH                           
<ex>B knew why C won.
<nex> B knew why to leave.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.TAM.TENSE real_tense ].

;; DPF 2018-06-10 - Generalized MOD..CAT from vp_cat, to accept *the time when
;; Kim was happy*.
;;
pp_-_i-rel_lexent := nonc-hm &
  [ SYNSEM basic_lex_pp_synsem &
      [ LOCAL [ CAT [ HEAD prep &
                           [ MINORS.MIN #min,
			     MOD < [ LOCAL [ CAT [ HEAD v_or_a_or_p,
						   VAL.COMPS < > ],
					     CONJ cnil ],
				     NONLOC.SLASH 0-dlist,
                                     --SIND #event & event ] > ],
		      VAL.SPR < synsem & 
                                [ --MIN degree_rel,
                                  LOCAL [ CAT [ HEAD n_or_adv,
                                                VAL [ SPR *olist*,
                                                      COMPS < > ] ],
                                          CONT.HOOK [ LTOP #khand,
                                                      XARG #event ] ],
                                  NONLOC.QUE 0-dlist,
                                  OPT + ] >,
		      POSTHD +,
                      MC na,
                      HC-LEX - ],
                CONT [ HCONS <! !>,
		       ICONS <! !> ],
                CONJ cnil ],
        LKEYS.KEYREL [ LBL #khand,
		       PRED #min,
		       ARG1 #event,
		       ARG2 #objind ],
        NONLOC [ REL 1-dlist & [ LIST < [ INDEX #objind ] > ],
                 SLASH 0-dlist,
                 QUE 0-dlist ],
        PUNCT no_punctuation_min ] ].

pp_-_i-rel-indep_lexent := pp_-_i-rel_lexent & non_affix_bearing &
  [ SYNSEM [ LOCAL [ CAT.HEAD.PRD +,
		     CONT [ HOOK [ LTOP #khand,
				   INDEX #event ],
			    RELS <! #keyrel !> ] ],
	     LKEYS.KEYREL #keyrel & [ LBL #khand,
				      ARG1 #event ] ] ].

pp_-_i-rel_le := pp_-_i-rel-indep_lexent
"""
PP, relative                     
<ex>B knew times when C won.
"""
.

pp_-_i-rel-that_le := pp_-_i-rel-indep_lexent &
"""
PP, relative, only `that'
<ex>The time that C arose was memorable.
"""
  [ SYNSEM.NONLOC.REL.LIST < [ INDEX.SORT location ] > ].

;; DPF 2017-09-14 - Need to somehow constrain chart dependencies so this entry
;; for `that' does not cheerfully unify its MIN value with the --COMPKEY
;; constraint of particle verbs, or we lose the lexical filtering of these
;; verbs whenever the word "that" appears in a sentence.  FIX SOON.
;; In the meantime, restrict MIN to _on_p_sel_rel, to show how this will work
;; once the chart-dependency issue is solved.
;;
;; DPF 2017-10-08 - INFLECTD na prevents accepting this lexical PP in situ as
;; complement of e.g. *happy*
;;
pp_-_i-rel-sel_le := pp_-_i-rel_lexent &
"""
Selected PP, relative, only `that' for it-clefts
<ex>It was on him that we relied.
"""
  [ INFLECTD na,
    SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN #min & _on_p_sel_rel,
				       NORM #min ],
		     CONT [ HOOK.INDEX #relind & non_expl-ind,
			    RELS <! !> ] ],
             NONLOC.REL.LIST < [ INDEX #relind ] >,
	     MODIFD rmod ] ].

; 'on vacation', 'in bed'

; DPF 26-aug-07 - Don't know why this is here, but it's not good, since it
; licenses unification of abstr_lex_synsem and phr_synsem. So commented out.
;
; prep_p_mod_phr_synsem := prep_p_mod_synsem & phr_synsem.

prep_nomod_phr_synsem := phr_synsem &
  [ LOCAL [ CAT [ HEAD prep & [ TAM #tam,
                                MOD < > ],
                  VAL [ SUBJ < >,
                        COMPS #comps ] ],
            CONT.RELS.LIST < relation & [ PRED norm_rel,
                                          ARG0.E #tam ], ... >,
            ARG-S #comps ] ].

;; DPF 2018-06-03 - Removed +--ARGIND since we want this entry also when
;; there is no expletive it, for `tough-movement'.
;;
p_ap_i_le := basic_prep_word &
"""
Prep, adj, only 'as'             
<ex>B did as early as possible
"""
  [ INFLECTD +,
    SYNSEM basic_prep_nomod_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ MINORS.MIN _as_p_comp_rel,
                     PRD - ],
              VAL [ SPR < unexpressed >,
                    COMPS < [ LOCAL 
                              [ CAT [ HEAD adj,
                                      VAL.COMPS
                                           < unexpressed &
                                             [ LOCAL.CAT.HEAD prep ],
                                             unexpressed &
                                             [ LOCAL.CONT.HOOK.LTOP #mhand] >],
                                CONT.HOOK [ LTOP #ltop,
                                            INDEX #index,
                                            XARG it-ind ],
                                CONJ cnil ],
                              LEX +,
                              NONLOC non-local_none ] > ],
              HC-LEX - ],
        CONT [ HOOK [ LTOP #ltop,
                      INDEX #index ],
               RELS <! basic_arg12_relation & #keyrel &
                     [ PRED prep_rel],
		     #altkeyrel &
                     arg1_relation &
                     [ LBL #mhand,
                       ARG0.SF prop-or-comm,
                       PRED ellipsis_rel ] !>,
               HCONS <! !>,
	       ICONS <! !> ],
        CONJ cnil ],
      NONLOC [ SLASH 0-dlist,
               REL 0-dlist,
               QUE 0-dlist ],
      LKEYS [ KEYREL #keyrel &
                     [ LBL #ltop,
                       ARG0.E [ TENSE nontense,
                                ASPECT no_aspect ] ],
	      ALTKEYREL #altkeyrel ],
      --SIND non_expl ] ].

;; DPF 2013-09-19 - Added type for the negative conditional`for' of 
;; *If it weren't for Kim, we would have lost.* which Woodley Packard 
;; observed.  See also
;;   Had it not been for the zebra, Kim would have slept.
;;   Were it not for the zebra, Kim would have slept.
;;   If it were not for the zebra, Kim would have slept.
;; The generalizations seem to be that this entry
;; (1) is predicative, with an empty MOD value;
;; (2) takes an expletive `it' subject;
;; (3) constrains its MOOD value to be subjunctive;
;; (4) requires its ARG0 event to be finite;
;;      *If it hadn't happened to be for Kim, we would have lost.
;; (5) only appears in the scope of negation - hard to express in the type def,
;;     so we use the idiom machinery as a post-syntax constraint, triggered by
;;     making the PRED value be an "...i_rel"
;; Related examples:
;;      *It had not been for the zebra.
;;      *It was not for the zebra.
;;      #It should not have been for the zebra.
;;      ?Should it not have been for the zebra, Kim would have slept.
;;      *If it were for Kim, we would have lost.
;;      *If it were never for Kim, we would have lost.
;;       If not for Kim, we would have lost.  
;; This last one is not currently analyzed, since the "if" which takes a
;; PrdP complement requires the complement's XARG to be non-expletive, in
;; order to avoid e.g. "*if obvious that Kim won, ..." or 
;; "*although raining, we decided to stay outside".  
;; FIX, possibly in connection with the following:
;;       But for Kim, we would have lost.
;;       Except for Kim, we would have lost.
;;       Save for Kim, we would have lost.
;;
p_np_negcond_le := nonc-h-nab &
"""
Prep, only negative conditional 'for'
<ex>If it weren't for B, we would have lost
"""
  [ INFLECTD +,
    SYNSEM prep_with_spr_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ MOD < anti_synsem >,
		     MINORS [ MIN _for_p_ncond-i_rel,
			      ALTMIN no_rel ],
                     PRD + ],
              VAL [ SPR < unexpressed >,
                    COMPS < expressed_synsem & 
			    [ LOCAL [ CAT [ HEAD supnoun &
						      [ POSS -, MOD < >,
							CASE non_nom ],
						 VAL [ SPR *olist*,
						       COMPS < > ],
						 MC na_or_- ],
				      CONT.HOOK.INDEX #cind,
				      CONJ cnil ],
			      OPT - ] > ],
	      POSTHD +,
	      HC-LEX - ],
        CONT [ HOOK [ LTOP #ltop,
                      INDEX #index & non_conj_event,
		      XARG it-ind ],
               RELS <! #keyrel !>,
               HCONS <! !>,
	       ICONS <! !> ],
        CONJ cnil ],
      PUNCT no_punctuation_min,
      MODIFD hasmod,
      NONLOC [ SLASH 0-dlist,
               REL 0-dlist,
               QUE 0-dlist ],
      LKEYS [ KEYREL #keyrel & basic_arg12_relation &
                     [ LBL #ltop,
                       ARG0 #index & [ E [ TENSE real_tense,
					   MOOD subjunctive ] ],
		       ARG2 #cind ] ] ],
    IDIOM + ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DETERMINERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Determiners must have the MIN relation be the quantifier, since nouns
; select their determiner in part based on the type of the quantifier rel.
; The basic determiner synsem has a non-null value for its specifier; this is 
; to account for cases like "nearly all books, only his book, exactly which
; book, almost every book".  
;
; Quantifiers need to accommodate expressions like
; 'almost every book'.  One might expect to have the degree_rel of 'almost'
; take the handle of 'every' as its ARG1 value, but this may interfere with 
; the treatment of scope which needs to identify the set of quantifier handles.
; So we do this by adding separate lexical entries for these det-specs.
; DPF 8-Jun-03 - Removed COMPS < > from basic_det_synsem, since want to allow
; possibility of non-empty comps (e.g. for "a/an" as in "an hour and a half"
; analogous to "as tall as kim"
; DPF 17-jun-07 - Restored COMPS < >, since this "a/an" is now an adjective
;; DPF 2020-04-29 - Pushed SPR..QUE 0-dlist down to subtypes, so we can get
;; *how tall a cat* with det_sg_compadj_lexent.

basic_det_synsem := nomod_synsem &
  [ LOCAL [ CAT [ HEAD det & [ MINORS.MIN #pred ],
		  VAL [ SPR < [ NONLOC.REL 0-dlist,
				PUNCT.RPUNCT pair_or_no_punct ] >, 
			SPEC < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #pred,
                                         CONT.HOOK [ LTOP #nhand,
                                                     INDEX #index,
						     XARG #xarg ] ] ] > ] ],
	    CONT nom-obj &
		[ HOOK [ INDEX #index,
			 XARG #xarg ],
		  RELS.LIST < abstract_quant_relation & #keyrel &
                              [ ARG0 #index & overt_non_expl-ind,
                                RSTR #rhand ], ... >,
                  HCONS.LIST < qeq &
				[ HARG #rhand,
				  LARG #nhand ], ... >,
		  ICONS <! !> ],
	    ARG-S < > ],
    LKEYS.KEYREL #keyrel ].

basic_nonpart_det_synsem := basic_det_synsem.

norm_det_synsem := basic_det_synsem & 
  [ LOCAL.CAT [ HEAD.MINORS.MIN #min,
                VAL [ SPR < [ LOCAL [ CAT [ HEAD adv,
					    VAL.SPR *olist* ],
				      CONT.HOOK.LTOP #lbl ],
			      NONLOC.QUE 0-dlist,
			      --MIN degree_rel ] >,
		      SPCMPS < > ] ],
    LKEYS.KEYREL [ LBL #lbl,
                   PRED #min ] ].

nonpart_det_synsem := norm_det_synsem.

det_synsem := nonpart_det_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

basic_part_det_synsem := norm_det_synsem.

part_det_synsem := basic_part_det_synsem &
  [ LOCAL.CAT.VAL.COMPS < > ].

part_det_synsem_nonwh := part_det_synsem & 
  [ NONLOC.QUE 0-dlist ].

; DPF 21-Nov-01 - Removed BV..DIV -* and AGR.DIV -: last Christmas
;; DPF 2016-12-09 - Generalized SPEC..MODIFD notmod to notmod_or_rmod so we
;; can also get *next Monday in the morning would be good*
;; DPF 2017-09-28 - Constrain to SPEC..DIV - to block spurious analysis of
;; *he disappeared last time*.
;; DPF 2017-10-07 - Re 2017-12-09: But this is too permissive, since we also get
;; *[last Saturday I arose] we arrived*.  And we already have another analysis
;; available for *next Monday in the morning* as PP-PP modif.  So go back to notmod.
;;
next_last_det_synsem := nonpart_det_synsem &
  [ LOCAL [ CAT [ HEAD [ POSS -,
                         MINORS.MIN def_implicit_q_rel ],
                  VAL [ SPEC < [ LOCAL [ CAT [ HEAD.MINORS 
                                                    [ MIN temp_abstr_rel,
                                                      ALTMIN norm_rel ],
                                               VAL.COMPS < > ],
                                         CONT.HOOK.LTOP #nhand,
					 AGR.DIV - ],
                                 MODIFD notmod ] >,
                        COMPS < > ] ],
	    CONT [ RELS <! [ PRED def_implicit_q_rel,
                             ARG0 #ind & ref-ind & [ PNG png & [ PN 3s ] ] ],
			    relation & #altkeyrel &
			    [ LBL #nhand,
			      ARG1 #ind ] !>,
		   HCONS <! qeq !>,
		   ICONS <! !> ],
            AGR.PNG.PN 3s ],
    NONLOC.QUE 0-dlist,
    MODIFD hasmod,
    LKEYS.ALTKEYREL #altkeyrel ].

basic_det_word := word.
;; DPF 2012-06-23 - Moved [POSS -] up from det_word to here, in order to
;; block spurious *of all* with poss-gen `of', as in *cats of all arose*.
;;
abstr_det_word := basic_det_word & que_word &
  [ SYNSEM.LOCAL.CAT.HEAD.POSS - ].
 
det_word := abstr_det_word &
  [ SYNSEM det_synsem ].

; DPF 15-Apr-03 - ALTMIN allows most determiners to appear with day-part nouns
; like 'morning' as VP modifiers, as in 'i arrive every morning' but not
; 'I arrive the morning'
; DPF 06-dec-03 - Moved constraint PN 3s down but leave DIV - so we can allow
; coordination in "every dog and cat" where the nbar is PN 3p, but not
; constrained for DIV.  Still blocking "*every dogs"

det_word_sing := det_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                     AGR.DIV - ],
             NONLOC.QUE 0-dlist ] ].

basic_det_word_nonque := det_word &
  [ SYNSEM.NONLOC.QUE 0-dlist ].

det_word_nonque := basic_det_word_nonque &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ RELS <! relation !>,
                          HCONS <! qeq !>,
			  ICONS <! !> ] ] ].

det_pl_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                     AGR.PNG.PN 3p ],
             LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ],
             MODIFD hasmod ] ].

d_-_pl_le := det_pl_lexent
"""
Det, plural                      
<ex>These dogs barked.
"""
.

; 'another two chairs' but '*another chairs'
d_-_pl-modn_le := det_pl_lexent &
"""
Det, plural, noun obl mod - FIX  
<ex>Another six dogs barked.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ MODIFD lmod ] > ].

d_-_sgm_le := det_word_nonque &
"""
Det, sing, deictic               
<ex>This dog barked.
"""
  [ SYNSEM [ LOCAL.AGR.PNG.PN 3s,
	     MODIFD hasmod ] ].

; 'zero effect'
d_-_m_le := det_word_nonque &
"""
Det, mass noun                   
<ex>B had zero effect.
"""
  [ SYNSEM [ LOCAL.AGR.PNG.PN 3s,
             LKEYS.KEYREL.ARG0.DIV + ] ].

d_-_next_le := abstr_det_word &
"""
Det, only 'next'                 
<ex>B arrives next week.
"""
  [ SYNSEM next_last_det_synsem ].

d_-_last_le := abstr_det_word &
"""
Det, only 'last'                 
<ex>B arrived last week.
"""
  [ SYNSEM next_last_det_synsem ].

; "yesterday morning, tomorrow afternoon"
d_-_proxday_le := abstr_det_word &
"""
Det, proximal day                
<ex>B arrives tomorrow morning
"""
  [ SYNSEM next_last_det_synsem & 
	   [ LOCAL.CAT.VAL.SPEC < [ --MIN day_part_rel ] > ] ].

; "all month", "all day" - FIX - not yet blocking "*all October, *all Tuesday"
d_-_all-tm_le := abstr_det_word &
"""
Det, with time noun, only 'all'  
<ex>B slept all afternoon.
"""
  [ SYNSEM next_last_det_synsem ].

; DPF 20-Feb-01 - Use SPEC..ALTMIN to block det-N analysis of 
; "both kim and sandy"
; DPF 11-Mar-02 - Use ALTMIN to block phrasal partitive-NP rule

basic_pdet_word_nonque := abstr_det_word &
  [ SYNSEM part_det_synsem_nonwh &
      [ LOCAL [ CAT.HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                CONT [ RELS.LIST < abstract_quant_relation, ... >,
                       HCONS <! qeq !>,
		       ICONS <! !> ] ],
        NONLOC.QUE 0-dlist,
        MODIFD hasmod ] ].

pdet_word_nonque := basic_pdet_word_nonque &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

; 'any'
d_-_prt_le := pdet_word_nonque &
"""
Det, partitive okay              
<ex>Either dog will bark.
"""
  [ SYNSEM.LOCAL.CAT.NEGPOL + ].

; DPF 19-Oct-02 - Would like to make DIV +* not + to allow coordination of 
; unlike NPs ("my book and some other stuff"), but then we can't block
; spurious "some programmer" whose DIV value ends up +_and_-.  An example
; of problems with this overspecification approach to coordination.

; some
d_-_prt-div_le := pdet_word_nonque &
"""
Det, partv, divisible            
<ex>Some rice arrived.
"""
  [ SYNSEM [ LOCAL.CAT [ VAL.SPR < [ --MIN just_only_deg_rel ] >,
			 NEGPOL - ],
             LKEYS.KEYREL.ARG0.DIV + ] ].

; For "another one/two (of the chairs)"
; Still don't have analysis for "another two chairs" (cf. "*another chairs")
d_-_prt-anthr_le := pdet_word_nonque &
"""
Det, partv, only 'another'       
<ex>Another dog arrived.
"""
  [ SYNSEM 
    [ LOCAL.CAT.VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                      SPEC < [ --MIN part_nom_rel ] > ],
      LKEYS.KEYREL.ARG0.DIV + ] ].

; DPF 06-dec-03 - Removed constraint PN 3s but leave DIV - so we can allow
; coordination in "another time and date" where the nbar is PN 3p, but not
; constrained for DIV.  Still blocking "*another chairs"
d_-_prt-sg_le := pdet_word_nonque &
"""
Det, partv, singular             
<ex>Each dog barked.
"""
  [ SYNSEM [ LOCAL [ AGR.DIV -,
		     CAT.VAL.SPR < [ --MIN just_only_deg_rel ] > ],
             LKEYS.KEYREL.ARG0.DIV - ] ].

d_-_prt-sgm-nag_le := pdet_word_nonque &
"""
Det, partv, sing-mass, no agrmt  
<ex>Little rice arrived.
"""
  [ SYNSEM [ LOCAL.AGR [ PNG.PN 3s,
                         DIV + ],
             LKEYS.KEYREL [ PRED explicit_quant_noagr_q_rel,
                            ARG0 [ PNG png & [ PN 3s ],
                                   DIV + ] ] ] ].

det_part_pl-or-m_lexent := basic_pdet_word_nonque &
  [ SYNSEM [ LOCAL.CONT [ RELS.LIST < [ ARG0 #arg0 ],
                                      #altkeyrel &
                                      [ LBL #lbl,
                                        ARG0 event & [ E [ TENSE no_tense,
                                                         ASPECT no_aspect ] ],
                                        ARG1 #arg0 ], ... >,
			  HCONS <! [ LARG #lbl ] !>,
			  ICONS <! !> ],
             LKEYS.ALTKEYREL #altkeyrel ] ].

d_-_prt-pl_le := det_part_pl-or-m_lexent &
"""
Det, partv, plural               
<ex>A great many dogs barked.
"""
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3p,
		   CONT.RELS <! [ PRED udef_q_rel,
				  ARG0.PNG png & [ PN 3p ] ],
			        relation !> ] ].

d_-_prt-more_le := det_part_pl-or-m_lexent &
"""
Det, partitive, only 'more'      
<ex>More dogs arrived.
"""
  [ SYNSEM [ LOCAL [ AGR.DIV +,
		     CONT.RELS <! [ ARG0.DIV + ],
			        [ PRED much-many_a_rel, LBL #lbl, ARG0 #e ],
			        #alt2keyrel &
			        [ PRED more_comp_rel,
				  LBL #lbl,
				  ARG0 event & [ E [ TENSE no_tense,
						     ASPECT no_aspect ] ],
				  ARG1 #e & [ E [ TENSE no_tense,
						  ASPECT no_aspect ] ] ] !> ],
	     LKEYS.ALT2KEYREL #alt2keyrel ] ].

d_-_prt-pl-both_le := basic_pdet_word_nonque &
"""
Det, partv, plural, only 'both'  
<ex>Both dogs barked.
"""
  [ SYNSEM [ LOCAL [ AGR.PNG.PN 3p,
                     CONT [ HOOK.INDEX #index,
                            RELS <! relation, [ LBL #lbl,
                                                PRED card_rel,
                                                ARG0 event & 
                                                    [ E [ TENSE no_tense,
                                                          ASPECT no_aspect ] ],
                                                ARG1 #index,
                                                CARG "2",
						CFROM #from, CTO #to ] !>,
                            HCONS <! qeq & [ LARG #lbl ] !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL [ ARG0.PNG png & [ PN 3p ],
			    CFROM #from, CTO #to ] ] ].

; This assumes (falsely) that all plurals are divisible (cf "oats", "clothes")
; It also incorrectly blocks coordinations like "Kim and all children" since 
; the alternative (DIV +) would fail to block "all book".
; DPF 28-oct-03 - Added LEX + to block e.g. "a person all of us" as hd-spec.
; DPF 01-may-04 - Changed SPR..MIN from very_deg_rel to just_only_deg_rel

det_part_pl_mass_lexent := pdet_word_nonque &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPR < [ --MIN just_only_deg_rel,
                                     LEX + ] >,
                     AGR.DIV + ],
             LKEYS.KEYREL.ARG0.DIV +,
             MODIFD hasmod ] ].

d_-_prt-plm_le := det_part_pl_mass_lexent &
"""
Det, partv, plural-mass          
<ex>B has enough rice.
"""
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_agr_q_rel ].

d_-_prt-plm-unsp_le := det_part_pl_mass_lexent &
"""
Det, partv, pl-mass, unsp agr    
<ex>B never has such rice.
"""
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_q_rel ].

;; No longer used
#|
d_-_prt-plm-nag_le := det_part_pl_mass_lexent &
"""
Det, partv, pl-mass, no agr      
<ex>B has less rice.
"""
  [ SYNSEM.LKEYS.KEYREL.PRED explicit_quant_noagr_q_rel ].
|#

d_-_prt-unsp_le := abstr_det_word &
"""
Det, partv, only 'which'         
<ex>B saw which rice grew.
"""
  [ SYNSEM part_det_synsem & 
	   [ LOCAL [ CAT.HEAD.POSS -,
		     CONT [ RELS <! abstract_quant_relation !>,
			    HCONS <! qeq !>,
			    ICONS <! !> ] ],
	     NONLOC.QUE 1-dlist &
		           [ LIST < param > ],
             LKEYS.KEYREL.PRED which_q_rel ] ].

; DPF 10-May-00 - We add subtypes of determiners to distinguish "We met every 
; week" from "*We met the week".  The distinction makes use of the feature 
; MODIFD, where the head-specifier rule's mother's MODIFD value is 
; determined by the specifier daughter, so each specifier has to say whether it
; passes on the MODIFD value from its head, or supplies its own.  Thus "the"
; assigns its own value,"every" supplies its own 'hasmod' 
; value, and "a" supplies the opposite value "notmod", to block "*Kim arrived 
; a big week".

; 'no'
d_-_no_le := det_word_nonque &
"""
Det, only 'no'                   
<ex>No book arrived.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                         VAL.SPEC < [ MODIFD #modif ] >,
			 NEGPOL + ],
             LKEYS.KEYREL.PRED no_q_rel,
             MODIFD #modif ] ].


; 'some'
d_-_ndiv_le := det_word_nonque &
"""
Det, only individ 'some'         
<ex>Some book arrived.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                         VAL.SPEC < [ MODIFD #modif ] >,
			 NEGPOL - ],
             LKEYS.KEYREL [ PRED some_q_rel,
                            ARG0.DIV - ],
             MODIFD #modif ] ].

; 'the'
; DPF 2-May-03 - Divide this type into two subtypes, one [MODIFD notmod]
; and one [MODIFD lmod] to support the treatment of VP-modifying NPs with
; the following pattern of grammaticality:
;   Kim arrived the first week
;  *Kim arrived the week
;   Kim arrived the week Sandy left
;   Kim arrived the week of the party
;  *Kim arrived week of the party
;
; DPF 27-May-03 - See discussion in syntax.tdl's npadv_mod_rule for why we
; considered and then abandoned two separate entries for "the".
; DPF 03-dec-03 - Replaced ALTMIN no_rel with dofw_or_poss_q_rel in
; order to get "on the weekend".  But then get two parses for "the night",
; so go back to no_rel.
; DPF 19-sept-07 - Since 'no_rel' blocked "the day we arrived", changed this
; ALTMIN to _the_q_rel, which is compatible with extracted-napdv construction.
;; DPF 2013-13-06 - Re 19-sept-07: Removed ALTMIN _the_q_rel, no longer
;; needed for *the day we arrived*, and it creates trouble for underspec of
;; *the tenth to twelfth of May* and *May tenth to twelfth*.  Replaced with
;; ALTMIN no_rel, to prevent spurious analysis of *the night* with the
;; n_-_c-dpt_le variant of *night* (for Tuesday night).
;; DPF 2018-02-13 - Re 2013-13-06: Not clear what the underspec issue was, but
;; we don't want ambiguity in *he spent the night*, so restore ALTMIN _the_q_rel
;; here.
;;
d_-_the_lexent := det_word_nonque &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN _the_q_rel,
			 VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                               SPEC < [ MODIFD #mod ] > ],
			 NEGPOL - ],
             LKEYS.ALTKEYREL.PRED no_rel,
             MODIFD #mod ] ].

d_-_the_le := d_-_the_lexent &
"""
Det, only 'the'                  
<ex>The book arrived.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN _the_q_rel ].

; For "the the"
d_-_the_le_mal := d_-_the_lexent &
"""
Det, only 'the the' (robust)     
<mex>The the book arrived.
"""
  [ GENRE informal ].

; For "X amount of money"
d_-_x_le := det_word_nonque &
"""
Det, only 'X'
<ex>We received X amount of money.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN _x_q_rel,
                         VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                               SPEC < [ MODIFD #mod ] > ],
			 NEGPOL - ],
             LKEYS.ALTKEYREL.PRED no_rel,
             MODIFD #mod ] ].

; 'half the time'
det_word_modable := det_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN dofw_or_poss_q_rel,
                           VAL.COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !>,
			    ICONS <! !> ] ],
             MODIFD hasmod ] ].

d_-_wh_le := det_word_modable &
"""
Det, nnly 'what'                 
<ex>B knew what book he had.
"""
  [ SYNSEM [ LKEYS.KEYREL.PRED which_q_rel,
	     NONLOC.QUE 1-dlist &
			   [ LIST < param > ] ] ].

d_-_rel_le := nonc-hm-nab &
"""
Det, nnly 'what'                 
<ex>B arrived, by which time C had left
"""
  [ SYNSEM det_synsem &
	   [ LKEYS.KEYREL.ARG0 #objind,
	     LOCAL [ CAT.HEAD.POSS -,
		     CONT [ RELS <! [ ] !>,
			    HCONS <! [ ] !> ] ],
	     NONLOC [ SLASH 0-dlist,
		      QUE 0-dlist,
		      REL 1-dlist & <! [ INDEX #objind ] !> ] ] ].

; 'a/an'
; DPF 15-Nov-01 - Removed [SPR <anti_synsem_min>] since this blocke "more than 
; a week ago"
; DPF 12-nov-05 - Removed 3s constraint from ARG0, since want to allow 
; "A number who sing also dance." where the semantic index is plural,
; but the syntactic agreement is still singular.
; DPF 30-sept-06 - Changed MODIFD notmod to instead identify value with that
; of SPEC.MODIFD, in order to get e.g. "We arrived a week after you."
;; DPF 2016-10-24 - Pushed NEGPOL - down to the det_sg_compadj_lexent subtype, 
;; since the constraint is too strong: we want *not a single cat appeared*, 
;; and even *not a finger was raised*.
;; DPF 2020-04-29 - Pushed QUE 0-dlist down to subtype det_sg_nomod_lexent, 
;; so we can get *how tall a cat* with det_sg_compadj_lexent.
;;
;; det_word_sing &
;;
basic_det_sg_nomod_lexent := abstr_det_word &
  [ SYNSEM basic_det_synsem &
	   [ LOCAL 
             [ CAT [ VAL [ SPEC < [ MODIFD #modif ] >,
			   COMPS < > ] ],
               AGR [ PNG.PN 3s,
		     DIV - ],
               CONT [ HOOK.INDEX.IND +,
		      RELS <! relation !>,
                      HCONS <! qeq !>,
		      ICONS <! !> ] ], 
             MODIFD #modif ] ].

det_sg_nomod_lexent := det_word_sing & basic_det_sg_nomod_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.MINORS.MIN 
							    just_only_deg_rel,
	     NONLOC.QUE 0-dlist,	     
	     LKEYS.KEYREL.PRED some_q_rel ] ].

;; *that happy a cat*
;; DPF 2014-01-23 - Added SPR..LEX - to block **very happy a cat*, using the
;; same property that in contrast blocks **the that happy cat*.
;; DPF 2020-04-29 - Changed NONLOC non-local_none to allow *how tall a cat*
;; 
;;
det_sg_compadj_lexent := basic_det_sg_nomod_lexent &
  [ SYNSEM basic_nonpart_det_synsem &
	   [ LOCAL.CAT [ HEAD [ MINORS.MIN #pred,
				POSS - ],
			 VAL [ SPR 
			     < [ LOCAL [ CAT [ HEAD [ MINORS.MIN adj_rel,
						      MOD < [ --SIND #nind ] >,
						      PRD - ],
					       VAL [ SPR < anti_synsem &
						    [ --MIN this_that_deg_rel]>,
						     COMPS #comps ] ],
					 CONT.HOOK.LTOP #ltop ],
				 OPT -,
				 LEX -,
				 NONLOC [ SLASH 0-dlist,
					  REL 0-dlist,
					  QUE #que ] ] >,
			       SPEC < [ LOCAL.CONT.HOOK [ LTOP #ltop,
							  INDEX #nind ] ] >,
			       SPCMPS #comps ],
			 NEGPOL - ],
	     NONLOC.QUE #que,
	     LKEYS.KEYREL.PRED #pred & _a_q_rel ] ].

d_-_sg-nmd_le := det_sg_nomod_lexent &
"""
Det, sing, not modif, con onset  
<ex>A book arrived.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] > ].

d_-_sg-nmd-an_le := det_sg_nomod_lexent &
"""
Det, sing, not modif, voc onset  
<ex>An apple arrived.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc_or_unk ] > ].

d_-_sg-caj_le := det_sg_compadj_lexent &
"""
Det, sing, oblig compadj spr
<ex>Too big a cat arrived.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_unk ] > ].

d_-_sg-caj-an_le := det_sg_compadj_lexent &
"""
Det, sing, oblig compadj spr
<ex>Too big an apple arrived.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc_or_unk ] > ].

; "a apple"
d_-_sg-a_le_mal := det_sg_nomod_lexent &
"""
Det, only 'a' (robust number)    
<mex>A cats arrived.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET voc ] >,
    GENRE robust ].

; "an dog"
d_-_sg-an_le_mal := det_sg_nomod_lexent &
"""
Det, only 'an' (robust number)   
<mex>An apples fell.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con ] >,
    GENRE robust ].

; "a a cat" "an an apple"
d_-_sg-a-a_le_mal := det_sg_nomod_lexent &
"""
Det, only 'a(n) a(n)' (robust)   
<mex>A a book arrived.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ PHON.ONSET con_or_voc ] >,
    GENRE robust ].

;; DPF 2018-02-17 - Added lexical type for a/an which combine with coord Nbar
;; and show plural number agreement with verb, as in 
;; *a cat and dog are sleeping*.  
;; Using newly added CONJ features LPERNUM and RPERNUM to constrain the
;; number of the left and right noun conjuncts, to block *a cats and dog sleep*
;; and *a [cat and dogs] we love sleep* (also avoiding spurious ambiguity for
;; *a cat and dogs sleep*.  It is the nbar-coord rule that records the values
;; for L/RPERNUM.
;;
det_indef_conj_lexent := det_word &
  [ SYNSEM basic_det_synsem &
	   [ LOCAL 
             [ CAT [ VAL [ SPEC < [ MODIFD #modif,
				    LOCAL [ CONT.HOOK.INDEX conj_ref-ind,
					    CONJ [ LPERNUM 3s, RPERNUM 3s ]]] >,
			   SPR.FIRST [ LOCAL.CAT.HEAD.MINORS.MIN 
							    just_only_deg_rel,
				       NONLOC.QUE 0-dlist ],
			   COMPS < > ] ],
               AGR [ PNG.PN 3p ],
               CONT [ HOOK.INDEX.IND +,
		      RELS <! relation !>,
                      HCONS <! qeq !>,
		      ICONS <! !> ] ], 
	     NONLOC.QUE 0-dlist,
             MODIFD #modif ] ].

d_-_idf-cnj-a_le := det_indef_conj_lexent &
"""
Det, indef, conjoined Nbars, cons onset, only `a'
<ex>A cat and dog sleep.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.PHON.ONSET con_or_unk ].

d_-_idf-cnj-an_le := det_indef_conj_lexent &
"""
Det, indef, conjoined Nbars, voc onset, only `an'
<ex>A cat and dog sleep.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.PHON.ONSET voc_or_unk ].

; 'every'
; DPF 22-may-09 - Changed SPR..MIN from just_only_very_deg_rel to
; just_only_deg_rel - why was it allowing 'very'?
d_-_sg-every_le := det_word_sing &
"""
Det, sing, only 'every'          
<ex>Every dog barked.
"""
  [ SYNSEM [ LOCAL [ CAT.VAL [ SPR < [ --MIN just_only_deg_rel ] >,
                               COMPS < > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! qeq !>,
			    ICONS <! !> ] ],
             MODIFD hasmod,
             LKEYS [ KEYREL [ LBL #lbl,
			      PRED every_q_rel ],
                     ALTKEYREL.LBL #lbl ] ] ].

; We make the non-quantifier relation generically pron_rel, and have each
; individual pronoun simply constrain the ARG0 index of that pron_rel.
;   This type is used for both WH "whose" and relative "whose", so it leaves 
; both  QUE  and  REL  values unspecified, but supplies all other defaults.
; DPF 24-aug-06 - Added ALTMIN no_rel to block possessive determiners from
; combining with e.g.day-of-month nouns as in  "*My five is booked."
;; DPF 2015-03-26 - Added NEGPOL - to enable blocking of 
;; *They told her to not eat her pie before her dinner.*
;; DPF 2017-09-24 - Changed MODIFD value to stamp lmod rather than preserve
;; value from specified noun, since we want to accept *he graduated my year*
;; and *people our age*, where the npadv rule requires the dtr to have nonnull
;; MODIFD value.  Note that this overgenerates for *our time they disappeared*,
;; but can't see how to block it just now.  FIX someday.
;;
basic_poss_word := noncs-m-nab & basic_det_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ POSS +,
				  MINORS.ALTMIN no_rel ],
			   VAL [ COMPS < > ],
			   NEGPOL - ],
		     CONT nom-obj &
			[ HOOK.INDEX #index,
			  RELS.LIST < relation,
                                      prep_relation & #altkeyrel &
                                      [ PRED poss_rel,
                                        ARG0.E [ TENSE no_tense,
                                                ASPECT no_aspect ],
                                        ARG1 #index ], ... > ] ],
	     MODIFD lmod,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

;; Enable robust variants with non-standard constraints.
poss_word := basic_poss_word.

; ERB (31-10-96) See notes near n_wh_pro_le.

d_-_wh-poss_le := poss_word &
"""
Det, only 'whose'                
<ex>B knew whose dog barked.
"""
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN def_implicit_q_rel,
                           VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #nhand ] > ],
		     CONT [ RELS <! #keyrel & [ PRED def_implicit_q_rel,
						CFROM #from, CTO #to ],
                                    [ LBL #nhand,
                                      ARG2 #ind ],
				    [ LBL #phand,
                                      PRED person_rel,
                                      ARG0 #ind & full_non_expl,
				      CFROM #from, CTO #to ],
                                    [ ARG0 #ind,
                                      PRED which_q_rel,
                                      RSTR #rhand2,
				      CFROM #from, CTO #to ] !>,
			    HCONS <! qeq, 
                                     qeq &
                                     [ HARG #rhand2,
                                       LARG #phand ] !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL #keyrel ],
	     NONLOC [ REL 0-dlist,
                      QUE 1-dlist &
			   [ LIST < param > ] ] ] ].

; DPF 17-dec-03 - Added HS-LEX + to avoid sentence "*about my arrives"

nonwh_poss_word := basic_poss_word &
  [ SYNSEM nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN def_explicit_q_rel,
                           VAL [ SPR < [ --MIN just_only_deg_rel ] >,
				 SPEC < [ LOCAL.CONT.HOOK.LTOP #hand ] > ],
                           HS-LEX + ],
                     CONT [ RELS.LIST < relation, [ LBL #hand ], ... >,
			    HCONS.LIST < qeq, ... >,
			    ICONS <! !> ] ],
             NONLOC.QUE 0-dlist,
             LKEYS.KEYREL.PRED def_explicit_q_rel ] ].

;; DPF 2012-12-14 - Removed XARG #ind, since this conflicts with other
;; assumptions about compound names, where the XARG is of type `handle'.
;; We'll see if we can rediscover why this XARG constraint was here...
;; DPF 2014-06-20 - Re 2012-12-14: The constraint is used to get reflexive
;; idioms like "she racked her brains".  Can't quite see why this causes
;; trouble with the compound names, so let's try again, but push down to
;; det-poss_lexent.
;;
basic_det_poss_lexent := nonwh_poss_word &
  [ SYNSEM [ LOCAL [ CONT [ RELS <! relation & [ CFROM #from, CTO #to ],
                                  [ ARG2 #ind ],
				  #alt2keyrel &
                                  [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #ind ],
				  [ LBL #prohand,
                                    ARG0 #ind & ref-ind &
                                        [ SORT entity ],
				    CFROM #from, CTO #to ] !>,
                            HCONS <! qeq, qeq & [ HARG #rhand,
                                                  LARG #prohand ] !>,
			    ICONS <! !> ] ],
             NONLOC.REL 0-dlist,
	     LKEYS.ALT2KEYREL #alt2keyrel ] ].

det_poss_lexent := basic_det_poss_lexent & poss_word &
  [ SYNSEM.LOCAL.CONT [ HOOK.XARG #ind,
			RELS <! relation, relation, relation,
			        [ PRED pron_rel,
			  	  ARG0 #ind & [ PT std ] ] !> ] ].

d_-_poss-her_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3s,
                                                  GEN fem ],
				      IND +,
                                      PT std ] ] !> ].

d_-_poss-her_le := d_-_poss-her_lexent
"""
Det, only 'her'                  
<ex>Her dog barked.
"""
.

d_-_poss-her_le_mal := d_-_poss-her_lexent &
"""
Det, only 'her', robust
<ex>Her her dog barked.
"""
  [ GENRE robust ].

d_-_poss-his_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3s,
						    GEN masc ],
					IND +,
					PT std ] ] !> ].

d_-_poss-his_le := d_-_poss-his_lexent
"""
Det, only 'his'                  
<ex>His dog barked.
"""
.

d_-_poss-his_le_mal := d_-_poss-his_lexent &
"""
Det, only 'his'                  
<ex>His his dog barked.
"""
  [ GENRE robust ].

; DPF 26-sept-04 - Temporary solution until we add determiner coordination,
; at least.
d_-_poss-his-her_le := det_poss_lexent &
"""
Det, only 'his/her'              
<ex>His/her dog barked.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
                             [ ARG0 [ PNG png & [ PN 3s,
                                                  GEN andro ],
                                      PT std ] ] !> ].

d_-_poss-its_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3s,
						    GEN neut ],
					PT std ] ] !> ].

d_-_poss-its_le := d_-_poss-its_lexent
"""
Det, only 'its'                  
<ex>Its tail wagged.
"""
.

d_-_poss-its_le_mal := d_-_poss-its_lexent &
"""
Det, only 'its', robust
<ex>Its its tail wagged.
<ex>It's tail wagged.
"""
  [ GENRE robust ].

d_-_poss-my_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1s ],
					PT std ] ] !> ].

d_-_poss-my_le := d_-_poss-my_lexent
"""
Det, only 'my'                   
<ex>My dog barked.
"""
.

d_-_poss-my_le_mal := d_-_poss-my_lexent &
"""
Det, only 'my', robust
<ex>My my dog barked.
"""
  [ GENRE robust ].

d_-_poss-our_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 1p ],
					PT std ] ] !> ].
d_-_poss-our_le := d_-_poss-our_lexent
"""
Det, only 'our'                  
<ex>Our dog barked.
"""
.

d_-_poss-our_le_mal := d_-_poss-our_lexent &
"""
Det, only 'our', robust
<ex>Our our dog barked.
"""
  [ GENRE robust ].

d_-_poss-their_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3p ],
					PT std ] ] !> ].

d_-_poss-na_le := det_poss_lexent &
"""
Det, only 'their', singular masc/fem                
<ex>Someone craned their neck.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 3s,
			                            GEN andro ],
					PT std ] ] !> ].

d_-_poss-their_le := d_-_poss-their_lexent
"""
Det, only 'their'                
<ex>Their dog barked.
"""
.

d_-_poss-their_le_mal := d_-_poss-their_lexent &
"""
Det, only 'their', robust
<ex>Their their dog barked.
"""
  [ GENRE robust ].

d_-_poss-your_lexent := det_poss_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ ARG0 [ PNG png & [ PN 2 ],
					PT std ] ] !> ].

d_-_poss-your_le := d_-_poss-your_lexent
"""
Det, only 'your'                 
<ex>Your dog barked.
"""
.

d_-_poss-your_le_mal := d_-_poss-your_lexent &
"""
Det, only 'your', robust
<ex>Your your dog barked.
"""
  [ GENRE robust ].

d_-_poss-anoth_le := basic_det_poss_lexent & poss_word &
"""
Det, only 'one anothers'
<ex>They admired one another's cats.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, relation, relation,
			       [ PRED recip_pro_rel,
				 ARG0 [ PNG png & [ PN 3p ] ] ] !> ].

d_-_poss-rel_le := nonwh_poss_word & poss_word &
"""
Det, only relative 'whose'       
<ex>Men whose dogs bark laugh.
"""
  [ SYNSEM [ LOCAL.CONT [ RELS <! relation,
				#altkeyrel &
                                [ LBL #hand,
                                  ARG2 #ind ] !>,
                          HCONS <! qeq !>,
			  ICONS <! !> ],
	     NONLOC.REL 1-dlist &
			   [ LIST < [ LTOP #hand,
				      INDEX #ind ] > ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].


; 'of mine'
det_nospec_synsem := nomod_synsem.
det_poss_nospec_lexent := basic_det_word & noncrs-m-nab &
  [ SYNSEM det_nospec_synsem &
           [ LOCAL [ CAT [ HEAD det & [ POSS +,
                                        MINORS [ MIN implicit_q_rel,
                                               ALTMIN poss_rel ] ],
                           VAL [ SPR < anti_synsem_min >,
                                 SPEC < anti_synsem_min >,
                                 COMPS < > ] ],
                     CONT [ HOOK.INDEX ref-ind & #ind,
                            RELS <! [ PRED pronoun_q_rel,
                                      RSTR #rhand,
                                      ARG0 #ind,
				      CFROM #cfrom, CTO #cto ],
				  #altkeyrel &
                                  [ LBL #prohand,
				    PRED pron_rel,
                                    ARG0 #ind &
					[ PT std,
					  SORT entity ],
				    CFROM #cfrom, CTO #cto ] !>,
                            HCONS <! qeq & [ HARG #rhand,
                                             LARG #prohand ] !>,
			    ICONS <! !> ] ],
             NONLOC non-local_none,
	     LKEYS.ALTKEYREL #altkeyrel ] ].

d_-_poss-mine_le := det_poss_nospec_lexent &
"""
Det, only 'mine'                 
<ex>Mine barked.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 1s ] !> ].

d_-_poss-ours_le := det_poss_nospec_lexent &
"""
Det, only 'ours'                 
<ex>Ours barked.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 1p ] !> ].

d_-_poss-yours_le := det_poss_nospec_lexent &
"""
Det, only 'yours'                
<ex>Yours barked.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 2 ] !> ].

d_-_poss-his-ns_le := det_poss_nospec_lexent &
"""
Det, only 'his'                  
<ex>His barked.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0 [ PNG [ PN 3s,
						       GEN masc ],
						 IND + ] ] !> ].

d_-_poss-hers_le := det_poss_nospec_lexent &
"""
Det, only 'hers'                 
<ex>Hers barked.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0 [ PNG [ PN 3s,
						       GEN fem ],
						 IND + ] ] !> ].

d_-_poss-hers-his_le := det_poss_nospec_lexent &
"""
Det, 'his/hers'                 
<ex>His/hers barked.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG [ PN 3s,
                                                     GEN animate ] ] !> ].

d_-_poss-theirs_le := det_poss_nospec_lexent &
"""
Det, only 'theirs                
<ex>Theirs barked.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! relation, [ ARG0.PNG.PN 3p ] !> ].

;; for *all day long*
;;
d_ap_all-long_le := abstr_det_word &
"""
Det, only `all', with post-mod noun
<ex>It ran all day long.
"""
  [ SYNSEM basic_nonpart_det_synsem &
	   [ LOCAL [ CAT [ HEAD [ MINORS.MIN #pred,
				POSS - ],
			   VAL [ SPR < anti_synsem_min >,
				 SPEC < [ LOCAL.CONT.HOOK [ LTOP #ltop,
							    INDEX #nind ],
					  --MIN temp_abstr_rel,
					  MODIFD notmod & [ RPERIPH - ] ] >,
				 COMPS < >,
				 SPCMPS < [ LOCAL [ CAT [ HEAD adj,
							  VAL.COMPS < > ],
						    CONT.HOOK [ LTOP #ltop,
								XARG #nind ] ],
					    --MIN long_a_rel,
					    NONLOC.SLASH 0-dlist,
					    OPT - ] > ] ],
		     AGR [ PNG.PN 3s,
			   DIV - ],
		     CONT [ HOOK.INDEX.IND +,
			    RELS <! relation !>,
			    HCONS <! qeq !>,
			    ICONS <! !> ] ], 
	     NONLOC.QUE 0-dlist,
	     MODIFD hasmod,
	     LKEYS.KEYREL.PRED #pred & _all_q_rel ] ].


; 'preposition' "a/an" for predicative NPs, as in "It is a (real/rare) 
; pleasure to visit Oslo" and "Oslo is a pleasure to visit"
;; DPF 2013-05-10 - Add NORM norm_rel to block these from v_mod rule.

pred_a_prep_lexent := nonconj &
  [ SYNSEM synsem &
    [ LOCAL [ CAT [ HEAD prep &
                         [ PRD +,
                           MOD < anti_synsem &
                                 [ LOCAL intersective_mod ] >,
                           TAM #tam & [ TENSE tense ],
                           MINORS [ MIN pred_a_rel,
				    NORM norm_rel ] ],
                    VAL [ SPR < >, 
                          SUBJ < >,
                          COMPS < [ --MIN prednom_rel,
                                    LOCAL [ CAT 
                                             [ HEAD noun &
                                                    [ POSS - ],
                                               VAL [ SUBJ < >,
                                                     COMPS < > ],
                                               MC na ],
                                            CONJ cnil,
                                            CONT.HOOK [ LTOP #nhand,
                                                        INDEX #index,
                                                        XARG #xarg ] ],
                                    NONLOC non-local_none &
                                          [ SLASH.LIST < > ],
                                    OPT - ] > ],
                    MC na ],
              CONT [ HOOK [ LTOP #ltop,
                            INDEX #event & event & [ E #tam ],
                            XARG #xarg ],
                     RELS <! #keyrel & abstract_quant_relation, 
			     #altkeyrel &
                             arg1_relation & 
                             [ LBL #ltop,
                               PRED prednom_state_rel,
                               ARG0 #event,
                               ARG1 #index ] !>,
                     HCONS <! qeq &
                             [ HARG #rhand,
                               LARG #nhand ] !>,
		     ICONS <! !> ],
              ARG-S < > ],
      LKEYS [ KEYREL #keyrel & [ PRED some_q_rel,
				 ARG0 #index & ref-ind,
				 RSTR #rhand ],
	      ALTKEYREL #altkeyrel ],
      NONLOC [ SLASH 0-dlist,
               QUE 0-dlist,
               REL 0-dlist ] ],
    INFLECTD + ].

p_np_i-prd-a_le := pred_a_prep_lexent &
"""
Prep, NP, prednom, con onset     
<ex>It is a pleasure to win. 
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET con_or_unk ] > ].

p_np_i-prd-an_le := pred_a_prep_lexent &
"""
Prep, NP, prednom, voc onset     
<ex>It is an honor to be here.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ PHON.ONSET voc_or_unk ] > ].

p_np_i-nonpro_le := p_reg_lexent &
"""
Prep, np, no pronoun. Maybe only `if'
<ex>Any cat, if a pet, sleeps.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ --MIN nonpro_rel ] > ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Free relatives
;
; One crucial property of free relatives is that they have a non-empty QUE
; value whose single list element is an index (rather than the param which
; is employed for ordinary question WH-words).
; The other is that they encode the constraints for their S/XP sister in the
; free-relative construction, in their SLASH attribute.
;; DPF 2012-11-12 - Changed SPR from synsem to unexpressed, to avoid spurious
;; ambiguity as in *just what ...* - force high attachment.
;; DPF 2017-09-12 - Removed identity of XARG and main pred's LBL (see note
;; of same date for generic_bare_np_phrase in syntax.tdl).
;;
free_rel_pro_word := noncr-hm-nab & basic_pronoun_word &
  [ SYNSEM synsem &
	   [ LOCAL [ CAT [ HEAD partn & [ MOD < > ],
			   VAL [ SPR < unexpressed &
				       [ --MIN just_only_deg_rel,
					 LOCAL [ CAT.HEAD adv,
						 CONT.HOOK.LTOP #lbl ],
					 NONLOC [ QUE 0-dlist,
						  REL 0-dlist ] ],
				       anti_synsem_min & [ OPT - ] >,
				 SUBJ < >,
				 COMPS < >,
				 SPEC < > ] ],
		     AGR #ind,
		     CONT [ HOOK [ INDEX nonconj_ref-ind & #ind & 
					 [ PNG.PN 3 ] ],
			    RELS.LIST < [ LBL #lbl,
                                          PRED basic_free_relative_q_rel,
                                          ARG0 #ind,
                                          RSTR #rhand,
					  CFROM #from, CTO #to ], 
					[ LBL #nhand,
                                          ARG0 #ind,
					  CFROM #from, CTO #to ], ... >,
			    HCONS <! qeq &
				    [ HARG #rhand,
				      LARG #nhand ] !>,
			    ICONS <! !> ],
		     ARG-S < > ],
	     NONLOC [ REL 0-dlist,
                      QUE 1-dlist & <! #ind !>,
		      SLASH 1-dlist &
                          <! [ CAT.VAL.COMPS < >,
                               CONJ cnil ] !> ],
	     LKEYS.KEYREL [ CFROM #from, CTO #to ] ] ].

; whatever, whoever
; DPF 20-Aug-01 - Added SLASH..PRD - to block "what my offers are" with 
; predicative copula.
;; DPF 2016-10-19 - The SLASH..--BARE + constraint prevents *what I am* because
;; the identity copula constraints its complement to be --BARE -, presumably to
;; avoid spurious ambiguity somewhere.  Let's remove it here, and see what
;; follows.  FIX?
;; DPF 2018-04-20 - Generalized INDEX.SORT from entity-or-event to
;; basic-entity-or-event in order to allow *What he likes is reading books*.
;;
n_freerel_pro_lexent := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD [ PRD -,
                                MINORS #minors &
				       [ MIN reg_nom_rel & #pred,
					 ALTMIN free_relative_ever_q_rel ] ],
		     CONT [ HOOK [ LTOP #nhand,
				   INDEX #ind & [ PNG.PN 3,
						  SORT basic-entity-or-event ]],
                            RELS <! relation & #altkeyrel, #keyrel !> ] ],
             LKEYS [ KEYREL #keyrel & [ PRED #pred,
					LBL #nhand ],
                     ALTKEYREL #altkeyrel ],
	     NONLOC.SLASH 1-dlist &
                   <! [ CAT.HEAD noun & [ MOD < >,
                                          PRD -,
					  MINORS #minors ],
                        CONT.HOOK [ INDEX #ind ],
                        AGR non_expl-ind ] !> ] ].

; DPF 25-aug-07 - Need to leave underspecified for PN: "We bought what we
; thought were the right amounts"
;; DPF 2020-03-24 - But PN now back in trunk, so let's keep, and CHECK.
n_-_pr-fr_le := n_freerel_pro_lexent &
"""
Free relative pro                
<ex>B did what C wanted.
"""
  [ SYNSEM [ LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_q_rel,
             NONLOC.SLASH <! [ AGR.PNG.PN 3s ] !> ] ].
                                          
n_-_pr-fr-ever_le := n_freerel_pro_lexent &
"""
Free relative pro whatever          
<ex>B did whatever C wanted.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel ].

n_-_pr-fr-ever-sg_le := n_freerel_pro_lexent &
"""
Free relative pro whoever, 3sg only
<ex>B did whatever C wanted.
"""
  [ SYNSEM [ LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel,
             NONLOC.SLASH <! [ AGR.PNG.PN 3s ] !> ] ].

n_-_pr-fr-ever-acc_le := n_freerel_pro_lexent &
"""
Free relative pro whomever, accusative only
<ex>B wrote to whomever he spoke to.
"""
  [ SYNSEM [ LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel,
             NONLOC.SLASH <! [ CAT.HEAD.CASE non_nom,
			       AGR.PNG.PN 3s ] !> ] ].

; when, where
; DPF 15-Apr-02 - Added SLASH..VAL.SUBJ..INDEX #arg to accommodate predicative
; 'be' as in "Find where Kim is"
; DPF 19-Oct-02 - Removed PRD - since need to allow head_adj_phr to have 
; adjunct be PRD +.
; DPF 06-sept-07 - Added INDEX.SORT location to prevent these from appearing
; as non-heads in appositives.
; DPF 07-apr-08 - But this blocks coord with other free rels, as in
; "we admired what he said and where he'd been."  So instead try constraining
; ALTMIN to non_freerel_rel, replacing nonpro_rel.
;; DPF 2018-06-09 - We were wrongly identifying the LBL of the prep_mod_rel
;; with that of the nom_rel, which for examples such as *when Kim is not happy*
;; resulted in the handle of the nom relation being bound both by the RSTR of
;; the freerel_q and by the neg rel. The prep_mod_rel's LBL instead gets unified
;; with the LTOP of SLASH. The nom_rel's LBL is also the LTOP, so the rule for
;; free relatives can identify it with the LTOP of the gapped-S sister, which
;; ensures that the neg_rel and the nom_rel have the same handle for this
;; example.
;;
n_freerel_pro_adv_lexent := free_rel_pro_word &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN #min,
				       ALTMIN #altmin & free_relative_q_rel,
				       NORM prep_mod_rel ],
		     CONT [ HOOK [ LTOP #nomlbl,
				   INDEX.PNG.PN 3s ],
			    RELS <! relation, 
                                   #keyrel & [ LBL #nomlbl,
					       ARG0 #ind ],
                                   #alt2key &
                                   [ LBL #lochand,
                                     PRED prep_mod_rel,
                                     ARG0 [ E [ TENSE no_tense,
                                                 ASPECT no_aspect ] ],
                                     ARG1 #arg,
                                     ARG2 #ind ] !> ] ],
             LKEYS [ KEYREL #keyrel & [ PRED #min ],
                     ALTKEYREL #keyrel,
                     ALT2KEYREL #alt2key & [ PRED #slmin ] ],
	     NONLOC.SLASH 1-dlist &
                   <! [ CAT.HEAD prep & 
                                 [ MOD *nogaplist* &
				       < synsem & [ --SIND #arg ] >,
				   MINORS [ MIN #slmin,
					    ALTMIN #altmin ] ],
                        CONT.HOOK [ LTOP #lochand,
				    XARG #arg ] ] !> ] ].


n_-_pr-fr-wh_le := n_freerel_pro_adv_lexent &
"""
Free relative 'wh'               
<ex>B won when C won.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ].

n_-_pr-fr-whever_le := n_freerel_pro_adv_lexent &
"""
Free relative 'wh-ever'          
<ex>B won whenever C won.
"""
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED free_relative_ever_q_rel ].


; whatever, what
; DPF 25-Nov-03 - Removed [SLASH..CASE acc] since also want "whichever books
; arrived".
; DPF 10-jul-04 - Replacing SLASH..HEAD n_or_p with noun since we don't want
; an extracted adjunct reading for e.g. "kim chases whichever cats bark".
; To still get "kim stays at whichever place he lands", maybe we have to
; make two separate entries for "whichever" - one a simple determiner
; which would in principle allow either NP or PP (maybe appropriately
; constrained ...), and the other the partitive which only allows NP slash.
; FIX ...

free_rel_det_word_gen := noncr-hm-nab &
  [ SYNSEM canonical_synsem &
    [ LOCAL [ CAT.VAL [ SPEC <  >,
			SPR < [ OPT - ] >,
			COMPS < [ LOCAL [ CAT nbar_cat &
					      [ VAL.SPR.FIRST unexpressed_reg ],
					  CONT.HOOK [ LTOP #nhand,
						      INDEX #arg0 ],
					  AGR #agr ],
				  NONLOC.SLASH 0-dlist,
				  OPT - ] > ],
	      CONT [ RELS <! [ PRED basic_free_relative_q_rel,
			       ARG0 #arg0 & ref-ind,
			       RSTR #rhand,
			       CFROM #cfrom, CTO #cto ] !>,
		     HCONS <! qeq & [ HARG #rhand,
				      LARG #nhand ] !>,
		     ICONS <! !> ],
	      AGR #agr ],
      MODIFD.RPERIPH +,
      NONLOC [ QUE 1-dlist &
		   [ LIST < index > ],
	       SLASH 1-dlist &
		   <! [ CAT.HEAD noun & [ MOD < > ],
			CONT.HOOK.INDEX #arg0,
			CONJ cnil ] !> ] ],
    ORTH [ FROM #cfrom, TO #cto ] ].


d_-_freerel_le := free_rel_det_word_gen &
"""
Det, free relative               
<ex>Whichever dog barks wins.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD partn & [ MINORS [ MIN norm_nom_rel,
						   ALTMIN no_rel ] ],
			   VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #ltop,
							     INDEX #index ] ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #index ],
			    RELS <! relation !>,
                            HCONS <! qeq !>,
			    ICONS <! !> ] ],
	     MODIFD notmod ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 'which' for VP-modifying relative clauses
;; e.g. "Kim snored, which bothered Sandy."

vp_rel_word := basic_prep_word &
  [ SYNSEM one_arg_norel_prep_synsem &
    [ LOCAL 
      [ CAT [ HEAD prep_nonmob &
		   [ MOD < [ LOCAL scopal_mod &
				   [ CAT [ HEAD verb,
					   VAL [ SUBJ *oblcons*,
						 COMPS < > ],
					   MC #mc ],
				     CONJ cnil,
				     CONT.HOOK.LTOP #cltop ] ] > ],
	      POSTHD +,
	      MC #mc,
	      VAL [ SPR < >,
		    COMPS < synsem &
			    [ LOCAL [ CAT [ HEAD verb &
					      [ VFORM fin,
						TAM.MOOD indicative,
						MINORS.ALTMIN non_ellipt_rel ],
					    VAL [ SUBJ *anti_list*,
						  COMPS < > ],
					    MC - ],
				      CONJ cnil,
				      CONT.HOOK [ LTOP #cltop,
						  INDEX #cevent ] ],
			      NONLOC [ SLASH 1-dlist &
				        <! [ CAT 
					     [ HEAD comp &
						    [ VFORM fin,
						      TAM.MOOD indicative ],
					       VAL [ SUBJ < >,
						     COMPS < > ] ],
					     CONT.HOOK
						 [ LTOP #chand,
						   INDEX.SF prop-or-comm ] ] !>,
				       QUE 0-dlist,
				       REL 0-dlist ],
			      OPT - ] >,
		    SPEC < > ] ],
	CONT [ HOOK [ LTOP #cltop,
		      INDEX #cevent ],
	       RELS <! [ LBL #chand,
			 PRED ellipsis_ref_rel,
			 ARG0.SF prop-or-comm ] !>,
	       HCONS <! !>,
	       ICONS <! !> ],
	AGR.PNG.PN 3s ],
      NONLOC non-local_none ] ].

p_cp_sl-rel_le := vp_rel_word
"""
Prep, only `which', introducing post-VP relative clause
<ex>Kim snored, which bothered Sandy.
"""
.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Possessives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Possessive "'s" takes an NP[-Poss] specifier and projects either an
;; NP[+Poss] phrase (for "the book of Kim's") or a DetP[+Poss] phrase (for
;; "Kim's book").  Either way, the content of the possessive phrase will be a
;; definite possessive quantifier.  The NP[+Poss] things also work pretty well
;; for things like "Kim's is under the desk" if we allow governed NPs to be
;; +Poss.  The tricky thing will be figuring out exactly where `bare
;; possessives' can show up.  Also, we need to add the restriction that the SPR
;; must be non-pronominal.  We cannot simply make the synsem of the SPR be
;; the type nonpronominal, since that NP might be either lexical or phrasal,
;; distinguished by the synsem types lex_synsem and phr_synsem.  So we use
;; the semantic MIN relation to identify nonpronominals.

;; Another question is what do we do with the scope
;; of quantifiers in the possessor?  This entry assumes that they always have
;; narrow scope.  That should be an empirical question, as the saying goes.
; DPF 10-oct-04 - Added SPR..CASE non_obliq constraint to exclude reflexive 
; pronouns as in "*ourselves's chairs arrived", while still allowing
; reciprocals, as in "we hired each other's consultants."
; DPF 18-Nov-04 - Added SPR..PRD + to require that proper NPs be INFLECTD +,
; possible since the hdn_bnp-pn_c rule identifies PRD and INFLECTD.  This is
; needed since proper-NPs need to be [INFLECTD -] for NP-N-cmpnd rule which
; is also used for measure-NP compounds like "ten foot wall" (cf "*ten feet
; wall"); and further, the sp-hd_hc_c rule must leave the non-hd-dtr unspecified
; for INFLECTD since this rule is used to build "ten foot high (wall)", as
; well as the possessive phrase "kim 's".  Since the value of SPR is a list
; of synsems (with no access to the INFLECTD value), we smuggle in the
; needed constraint by coercing the otherwise unused feature PRD on proper
; NPs (note in defense that this same identity of PRD and INFLECTD is used
; legitimately in measure-NPs).
;; DPF 13-03-13 - Removed SPR..--BARE - so we can detect errors such as e.g.
;; *we admire cat's fur*.  Check for consequences.
;;
basic_n_poss_clitic_lexent := nonc-m-nab &
  [ ALTS.SQPNCT -,
    SYNSEM lex_synsem &
     [ LOCAL [ ARG-S < #spr >,
	       CAT [ HEAD det &
			  [ POSS +,
                            MOD < >,
                            MINORS.ALTMIN poss_rel ],
                     VAL [ SUBJ < >,
                           SPR < #spr & synsem &
                                 [ --MIN nonpro_rel,
                                   LOCAL [ CAT nomp_cat_min &
                                               [ HEAD [ PRD +,
							CASE non_obliq ],
                                                 VAL [ SUBJ < >,
						       SPCMPS < > ] ],
                                           CONT.HOOK [ LTOP #plbl,
						       INDEX index ],
                                           CONJ cnil ],
                                   NONLOC [ SLASH #slash,
                                            REL #rel,
                                            QUE #que ],
                                   --SIND #pindex & individual_min,
                                   OPT - ] >,
                           COMPS < >,
			   SPCMPS < > ] ],
               CONT.HOOK [ INDEX #index,
			   XARG #pindex ] ],
       LKEYS.ALTKEYREL prep_relation &
             [ PRED poss_rel,
	       LBL #plbl,
               ARG0.E [ TENSE no_tense,
                        ASPECT no_aspect ],
               ARG1 #index & full_ref-ind,
               ARG2 #pindex ],
       NONLOC [ SLASH #slash & 0-dlist,
                REL #rel,
                QUE #que ] ] ].

n_poss_clitic_lexent := basic_n_poss_clitic_lexent &
  [ SYNSEM lex_synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN def_explicit_q_rel & #min,
                     VAL.SPEC < [ LOCAL [ CAT.HEAD.MINORS.ALTMIN #min,
					  CONT.HOOK [ LTOP #phand,
						      INDEX #index ] ] ] > ],
	       CONT [ HOOK.INDEX #index,
                      RELS <! #keyrel & [ PRED def_explicit_q_rel,
                                       ARG0 #index,
                                       RSTR #rhand ],
                              #altkeyrel !>,
		      HCONS <! qeq & [ HARG #rhand,
                                       LARG #phand ] !>,
		      ICONS <! !> ] ],
       LKEYS [ KEYREL #keyrel,
               ALTKEYREL #altkeyrel & [ LBL #phand,
					ARG1 #index ] ] ] ].

;; DPF 14-01-30 - Since n_-_cl-poss_le *'s* is constrained to only combine
;; with singular nouns, we need a variant to combine with conjoined NPs, as in
;; *Pat and Kim's cat*
;;
n_-_cl-poss-crd_le := n_poss_clitic_lexent &
"""
Possessive NP clitic "'s" for conjoined NPs
<ex>B and C's cat won.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND conj-ind & [ PNG.PN 3p ] ] > ].

n_-_cl-poss_le := n_poss_clitic_lexent &
"""
Possessive NP clitic "'s"        
<ex>B's cat won.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND.PNG.PN 3s ] > ].

n_-_cl-poss-pl_le := n_poss_clitic_lexent &
"""
Possessive NP clitic plural "'"  
<ex>The cats' owner won.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND.PNG.PN 3p ] > ].

n_-_cl-poss-pl-irr_le := n_poss_clitic_lexent &
"""
Possessive NP clitic plural "'s" for irregular nouns
<ex>The children's teacher won.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --SIND.PNG png-irreg & [ PN 3p ] ] > ].

; For "That dog of Kim's barks."
; DPF 11-jan-10 - Tempted to block plural NPs followed by 's, as in "*dogs's"
; but we want to still allow "people's", so would have to be able to
; distinguish between productive morphological plural and not.  FIX ...
;
n_-_cl-poss-nq_le := basic_n_poss_clitic_lexent &
"""
Possessive NP clitic no-quantif  
<ex>That cat of Browne's won.
"""
  [ SYNSEM lex_synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN implicit_q_rel,
                     VAL [ SPR < [ LOCAL.CONT.HOOK #hook ] >,
                           SPEC < anti_synsem > ] ],
	       CONT [ HOOK #hook,
                      RELS <! !>,
		      HCONS <! !>,
		      ICONS <! !> ] ],
       LKEYS.KEYREL.PRED no_rel ] ].

; Should eventually constrain this based on a PHON.FINAL feature to allow
; "Abrams' chairs" but block "Browne' chairs".  Overgenerate for now.
;; DPF 14-01-30 - Note that this PHON.FINAL will also be needed to allow
;; *Kim and Abrams' chair* but block *Kim and Browne' chair* - FIX.
;;
n_-_cl-poss-pr_le := n_poss_clitic_lexent &
"""
Possessive NP clitic - of Jones' 
<ex>Abrams' cat won.
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ --MIN named_rel,
                                 --SIND.PNG.PN 3s ] > ].

;; The possessive "of" takes an NP[+Poss] complement (e.g., "Kim's", "mine")
;; and modifies an N'[-Poss].  Unfortunately, the way the hierarchy of
;; preposition types is built, there wasn't any type this could inherit from.
;; We could probably rearrange things so this inherits some preposition
;; properties, but right now I'm too lazy.  Also, somehow we'll have to make
;; sure that this doesn't modify a pronoun.  The semantic manipulation here is
;; tricky - keep your eyes on the definite quantifier.  This def_implicit_q_rel
;; provided by the apostrophe-s (for its other life as a determiner), is 
;; dropped by the possessive-of, analogous to nouns, verbs, and adjectives 
;; dropping the semantics of the prepositions that can mark their complements.
;; This dropping of the relation is effected by having the possessive-of 
;; neglect to grab the handle of the def_implicit_q_rel for its complement, 
;; but grab instead the handle (and instance variable) of the NP complement 
;; of the apostrophe-s.  Then the general semantic pruning mechanism will 
;; ignore the def_implicit_q_rel, since its handle will not be a value in any 
;; other relation.

one_arg_isect := one_arg & isect_synsem.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBORDINATING CONJUNCTIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; These are not restricted to modifying only main VPs, since e.g. "if" needs
; to take scope over modals as in "I'd be pleased if we made an appointment."
; This lack of constraint means there will be structural ambiguity for 
; if-clauses, but not spurious - get different scopes of "if" and modals.
; But we restrict them to modifying only finite VPs or imperatives.

; DPF (10-Jan-99) Changed these to modify S rather than VP, since they don't
; appear to survive extraction from embedded clauses, nor do they appear inside
; an extraposed subject relative clause.

; DPF (10-Jan-98) For some reason, can't make the HEAD value prep* - fails to
; unify with strict_type in "Kim sleeps if Sandy sleeps".  Solve later.

; DPF 02-Oct-00 Changed subconj_inf_synsem to modify S rather than VP, in 
; order to make semantics consistent with other subord rels.

; DPF 26-Apr-03 Our analysis prevented subordinating phrases from modifying
; embedded clauses, but clearly we need these for examples like "I wonder
; whether Sandy arrived before Kim left".  So relax MOD..CAT to s_cat_unspec
; and make the subord's MSG be that of its modifiee, to block e.g.
; "*I wonder Kim arrived before Sandy left".  And further relax MOD..CAT to
; allow modification of infinitival VPs as in "Kim didn't want to leave before
; Sandy arrived", which means also dropping [ MOD..E.TENSE real_tense].
; DPF 17-Jul-03 - Removed PRD - since it blocks "Kim arrives two weeks after
; Sandy leaves", given our analysis of measure-NPs.  Not clear what it was for.
; DPF 22-Nov-03 - Removed MOD..SLASH 0-dlist since want to also get "the chair
; (that) I'll buy if you like it is expensive" and "who did you say Kim would
; hire if we were supportive".
; DPF 25-Nov-03 - Added MOD..LPERIPH na_or_- to avoid spurious disc_adv reading
; for "hiring kim and firing sandy happened"
; DPF 7-Jun-04 - This constraint prevented desired analysis for "if kim 
; arrives then sandy arises", so instead only use it in subjconj_vp rule.
; DPF 18-jul-04 - Removed constraint of MOD..MSG message to allow these to
; modify VPs as well as S's, to get e.g. "I found a book to read before 
; Abrams arrives"
; DPF 26-mar-05 - Restricting MOD.HEAD to verbal blocked modification of
; verbal gerunds, such as "safe practices for using a phone while driving",
; so changed to HEAD v_or_g.  Also removed MOD..LEX - since this prevented
; "for singing while driving"
; DPF 14-aug-05 - Re 17-Jul-03: PRD - prevents "not happy" from being
; built spuriously as "not" modifying the subconj-prdp "happy".
; DPF 13-nov-05 - Added MOD..SPR *cons* to exclude complementizer-phrases,
; to avoid spurious ambiguity for e.g. "Kim tried to leave while we slept."
; DPF 04-may-06 - Removed MOD..SUBJ *cons* since this prevents attaching
; subord clauses in relative clauses, as in "The guy that leaves if we
; stay is famous."
; DPF 13-may-06 - FIX - strictly speaking, we should have two versions of
; the filler-head-non-wh rule, one root and one non-root, analogous to the
; two subject-head rules, since the root one incorporates the mood
; of the punctuation mark, while the non-root one would pass it up.
; Right now, we don't parse 'Arise, whereas in Paris we arrive.' since the
; subord-clause prematurely declares the mood to be prop, when
; it should stay underspecified in this clause, and then become comm
; at the root.
; DPF 24-apr-08 - Add MOD..MOD anti_synsem_min to block modification of
; relative clauses (spurious analyses)
;; DPF 2011-08-10 - Added (hack) AUX + to prevent subordinate phrases from
;; being modified by PPs, to avoid spurious ambiguity of "kim arose [to 
;; arrive] [in Paris]".
;; DPF 2016-07-03 - Generalized MOD..HEAD from v_or_g to v_or_g_or_a_or_p,
;; in order to allow *Kim is happy drunk*.  Pushed tighter constraint down
;; to basic_subconj_lex_synsem.
;; DPF 2018-07-28 - Exclude semantically empty prep PPs as MOD target, as in
;; *some of them arriving*
;;
basic_subconj_synsem := canonical_lex_or_phrase_synsem &
  [ LOCAL [ CAT [ HEAD prep &
		       [ MOD < synsem &
                               [ LOCAL scopal_mod &
				       [ CAT [ HEAD v_or_g_or_a_or_p,
					       VAL.COMPS < >,
					       MC #mc ],
					 CONT.HOOK.LTOP #modltop,
                                         CONJ cnil ],
				 --MIN independent_rel ] >,
			 AUX +,
                         MINORS.MIN subord_rel ],
		  VAL.SUBJ < >,
                  MC #mc ],
            CONT [ HOOK.XARG #modltop,
		   RELS.LIST < subord_relation &
                                [ ARG0 [ E [ TENSE no_tense,
                                             ASPECT no_aspect ] ],
                                  ARG1 #main ], ... >,
                   HCONS.LIST < qeq & [ HARG #main,
                                        LARG #modltop ], ... > ] ],
    --SIND non_expl ].

;; DPF 2020-06-21 - Generalized HEAD.MOD..HEAD from v_or_g to v_or_g_or_a so we
;; can also get |tall as he is, he'll be a good player| and |angry though she 
;; was, she kept her temper|.  Let's see if the added ambiguity is tolerable...
;; In connection with the change, generalized HEAD.MOD..HEAD.MOD from
;; anti_synsem_min to unexpressed_min, since adj's MOD is not anti_synsem.
;;
basic_subconj_lex_synsem := basic_subconj_synsem &
  [ LOCAL [ CAT [ VAL.SPR < [ LOCAL [ CAT [ HEAD n_or_adv,
					    VAL.SPR *olist* ],
				      CONT.HOOK [ LTOP #sltop,
						  XARG #arg0 ] ],
			      NONLOC.QUE 0-dlist,
			      OPT + ] >,
		  HEAD [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a &
				      [ MOD < unexpressed_min > ] ] > ] ],
            CONT [ HOOK.LTOP #sltop,
                   RELS.LIST < [ LBL #sltop,
                                 ARG0 #arg0 ], ... >,
		   ICONS <! !> ] ] ].

subconj_lex_synsem := basic_subconj_lex_synsem &
  [ LOCAL [ CAT.VAL.KCMP.--SIND #index,
	    CONT.HOOK.INDEX #index ] ].

;; DPF 2012-09-21 - Corrected COMPS..LPUNCT from no_punct to pair_or_no_punct
;; so we can get *Kim arose because "she won".*
basic_onearg_subconj_synsem := basic_subconj_lex_synsem & lex_synsem &
  [ LOCAL [ ARG-S #comps,
            CAT.VAL.COMPS #comps & < synsem &
                                     [ --MIN #cmin,
				       --SIND #index,
                                       NONLOC non-local_none,
                                       OPT -,
                                       PUNCT.LPUNCT pair_or_no_punct ] >,
            CONT [ HOOK.INDEX #index,
		   RELS.LIST < #keyrel, ... > ] ],
    NONLOC non-local_none,
    LKEYS [ KEYREL #keyrel,
            --COMPKEY #cmin ] ].

;; DPF 2012-03-14 - We wrongly had identified COMPS..PSF with INDEX..SF, but
;; this fails obviously for an example like *if Kim asks `who won?' we quit*
;; So identify it instead with the SF of the KEYREL.ARG0.
;; DPF 2013-11-07 - Since the subord modifier can either be pre- or post-head,
;; we tried unifing the SF values of the complement clause and the main 
;; (modifiee) clause, so the most specific constraint is preserved.  But this
;; blocks *If we arose, would Kim arrive?*, as well as *Would Kim arrive, if
;; we arose?*.  So leave underspecified for now, but note that this can cause
;; problems for the generator, which will fail if the input SF value is the
;; most specific type `prop'.
;;
reg_onearg_subconj_synsem := basic_onearg_subconj_synsem & 
			      subconj_lex_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT.PSF #iforce,
			    NONLOC.SLASH 0-dlist ] >,
    LKEYS.KEYREL.ARG0.SF #iforce ].

norm_onearg_subconj_synsem := reg_onearg_subconj_synsem &
  [ LOCAL.CAT.VAL.SPR < [ --MIN just_only_deg_rel ] > ].

basic_subconj_cp_synsem := basic_onearg_subconj_synsem &
  [ LOCAL [ CAT [ VAL [ COMPS < #keycomp &
			      [ LOCAL.CONT.HOOK [ LTOP #cltop,
						  INDEX event ],
				NONLOC.SLASH 0-dlist ] >,
			KCMP #keycomp ],
                  HC-LEX - ],
            CONT [ RELS <! relation &
                           [ ARG2 #subord ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !>,
		   ICONS <! !> ] ] ].

norm_subconj_cp_synsem := basic_subconj_cp_synsem & cp_addin_tam_pn.

subconj_cp_synsem := norm_subconj_cp_synsem & reg_onearg_subconj_synsem.
;; For *lest he be seen*
subconj_cp_bse_synsem := basic_subconj_cp_synsem & reg_onearg_subconj_synsem.

subconj_synsem := subconj_cp_synsem & 
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT s_cat_unspec & 
					[ HEAD verb & [ VFORM fin_or_imp ],
					  MC - ],
				    CONT.HOOK.INDEX.SF prop-or-comm ],
			    --SIND.E.TENSE real_tense ] > ].
                         
subconj_ind_synsem := subconj_synsem &
  [ LOCAL.CAT [ HEAD.PRD -,
		VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		      COMPS < [ LOCAL.CAT s_cat &
                                    [ HEAD.TAM.MOOD ind_or_modal_subj ]] > ]] ].

; 'Kim arrived, as did Abrams.'
;; `He wouldn't eat fish, nor would he drink wine'
;;
subconj_cp_inv_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.PRD -,
		  VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
					        [ INV +,
						  AUX +,
						  TAM indic_tam,
						  MOD *anti_list*,
						  VFORM fin ],
					      VAL [ SUBJ < anti_synsem_min >,
                                                  COMPS < > ] ],
					CONT.HOOK [ LTOP #cltop,
						    INDEX event & 
							 [ SF prop-or-comm ] ] ],
				NONLOC [ SLASH 0-dlist & [ LIST < > ],
					 QUE 0-dlist,
					 REL 0-dlist ] ] >,
                  HC-LEX - ],
	    CONT [ RELS <! relation &
                           [ ARG2 #mtop ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ] !>,
		   ICONS <! !> ] ] ].

; 'We'll stay as you intended'
; Restrict to nonaux subord clause, to avoid spurious ambig for id-copula
;; DPF 2012-09-28 - Restrict further to not-left-modified clause, to avoid
;; spurious analyses of "as though ..." constructions, as in
;; *as though the author was growing less interested*
;; DPF 2018-07-28 - Now think this gap should be a CP rather than an NP, as in
;; *they lost, as he thought*.  But leave as is for now, just adding a
;; generic_entity to fill the gapped argument position.
;; DPF 2019-06-24 - But nonaux constraint blocks *as Kim has mentioned*, so
;; undo, and live with ambig for id-copula.  Check?
;; DPF 2020-06-23 - Generalized COMPS..SUBJ from < anti_synsem_min > to
;; *anti_list*, so we can also get subj gap: *as was noted, we discovered ...*,
;; and also restricted complement to non-elliptical to avoid *[as was] noted..."
;;
subconj_cp_gap_synsem := subconj_lex_synsem & lex_synsem & cp_addin_tam_pn &
  [ LOCAL [ CAT [ HEAD.PRD -,
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		        COMPS #comps &
                          < #keycomp &
			    [ --MIN #cmin,
                              LOCAL [ CAT [ HEAD verb &
                                                 [ INV -,
						   MINORS.ALTMIN non_ellipt_rel],
                                            VAL [ SUBJ *anti_list*,
                                                  COMPS < > ],
                                            MC - ],
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX event & 
						       [ SF prop-or-comm ] ] ],
			      MODIFD notmod_or_rmod,
                              NONLOC [ SLASH 1-dlist &
                                             <! arg-local &
					      [ CAT [ HEAD n_or_adv,
						      VAL.SPR *olist* ],
						CONT.HOOK.INDEX #ind ] !>,
				       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT -,
                              PUNCT [ LPUNCT no_punct,
                                      RPUNCT.PSF #iforce ] ] >,
			KCMP #keycomp ],
                  HC-LEX - ],
	    CONT [ RELS <! relation & #keyrel &
                           [ ARG2 #mtop,
			     CFROM #cfrom, CTO #cto ],
			   [ PRED udef_q_rel,
			     ARG0 #ind & ref-ind &
				  [ SORT basic-entity-or-event ],
			     RSTR #rhand,
			     CFROM #cfrom, CTO #cto ],
			   [ LBL #nhand,
			     ARG0 #ind,
			     PRED generic_entity_rel,
			     CFROM #cfrom, CTO #cto ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ],
			    qeq & [ HARG #rhand,
				    LARG #nhand ] !>,
		   ICONS <! !> ],
            ARG-S #comps ],
    NONLOC non-local_none,
    LKEYS [ KEYREL #keyrel & [ ARG0.SF #iforce ],
            --COMPKEY #cmin ] ].

subconj_cp_cp-gap_synsem := subconj_lex_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CONT.HOOK.INDEX #mevent ] >,
			 PRD - ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		        COMPS #comps &
                          < #keycomp &
			    [ --MIN #cmin,
                              LOCAL [ CAT [ HEAD verb &
                                                 [ AUX +,
						   MINORS.ALTMIN passive_rel,
						   TAM indic_tam,
						   VFORM fin ],
					    VAL [ SUBJ 
						  < synsem &
						    [ LOCAL.CAT.HEAD noun,
						      NONLOC.SLASH 0-dlist ] >,
						  COMPS < > ],
                                            MC na_or_- ],
                                      CONT.HOOK [ LTOP #cltop,
                                                  INDEX event & 
						       [ SF prop-or-comm ] ] ],
                              NONLOC [ SLASH 1-dlist &
                                         <! [ CAT [ HEAD comp & [ VFORM fin ],
						    VAL [ SPR *olist*,
							  COMPS *olist* ] ],
					      CONT.HOOK.LTOP #sltop ] !>,
				       QUE 0-dlist,
                                       REL 0-dlist ],
                              OPT -,
                              PUNCT [ LPUNCT no_punct,
                                      RPUNCT.PSF #iforce ] ] >,
			KCMP #keycomp ],
                  HC-LEX - ],
	    CONT [ RELS <! relation & #keyrel &
                           [ ARG2 #mtop ],
			   #altkeyrel &
			   relation & [ LBL #sltop,
					PRED v_event_rel,
					ARG0 #proarg0 & event ],
			   #alt2keyrel &
			   relation & [ LBL #sltop,
					PRED id_rel,
					ARG1 #mevent,
					ARG2 #proarg0 ] !>,
                   HCONS <! qeq, qeq & [ HARG #mtop,
                                         LARG #cltop ] !>,
		   ICONS <! !> ],
            ARG-S #comps ],
    NONLOC non-local_none,
    LKEYS [ KEYREL #keyrel & [ ARG0.SF #iforce ],
            ALTKEYREL #altkeyrel,
            ALT2KEYREL #alt2keyrel,
            --COMPKEY #cmin ] ].


; DPF 28-jul-06 - Dropped the zero-pronoun semantics for the subordinate
; infinitival clause - no motivation for it.  But still constrain the XARG
; of the infinitival to be non_expl, and SORT entity to reduce ambiguity
; for e.g. 'Kim tried to be winning.'
; DPF 21-apr-08 - Removed MOD..CAT s_cat_fin_or_imp to allow modif of
; VPs, as in "He arose to wave and sat down again"
; DPF 16-jul-2010 - Added identity of MOD..SUBJ..INDEX and COMPS..XARG so we
; bind the XARG of the complement VP just in case we are modifying a VP, 
; effectively identifying it with the XARG of the VP being modified, but avoid
; always unifying with the MOD's XARG since this is sometimes incorrect when
; the MOD value is a full sentence.  Here are three classes of counterexamples
; to the claim that the index of the syntactic subject of ARG1 is always 
; identified with the index of the implicit subject of the "(in order) to" 
; verb phrase:
; 1. Expletive subjects (where the syntactic subject of the main clause has 
; no semantics of its own)
;   In order to have a winner, there has to be a loser.
;   In order to win the race, it seems that John took a shortcut.
; 2. Bridging verbs
;   In order to get a seat, I think you'll need to arrive early.
;   In order to get a seat, I'm sure he must have arrived early.
; 3. Direct conflicts (the most problematic counterexamples)
;   In order to have a winner, somebody else has to lose.
;   In order to make himself popular, we advised John to kiss more babies.
; So we take advantage of the fact that when the "in order to" phrase 
; follows what it modifies, we typically get two analyses, one attaching to
; VP (where we effectively impose the XARG identity), and one attaching to
; S, where we don't.  This solution is sort of a hack, since it takes advantage
; of our representation of (most) S's as having SUBJ < anti_synsem >, where
; that SUBJ's INDEX is (of course) unbound.  The cleaner alternative would be
; to split this lexical entry for "to" (and "in order to") into two, one for
; VP modification and one for S.  But let's try managing with just one entry.
; DPF 2011-04-17 - Removed identify of COMPS..PSF and INDEX.SF, since this
; blocked *this is why we arise to arrive*.  Don't recall why this was here.
;; DPF 2016-09-09 - Re 28-jul-06: But requiring XARG to be non_expl prevents
;; analysis of e.g. *in order to grow corn, it has to rain* or *in order to
;; grow corn, there has to be rain* or *in order to win, it is known that runs 
;; have to be scored*.  So remove this constraint, and also remove the identity
;; of MOD..SUBJ..INDEX and HOOK..XARG and COMPS..XARG for the same reason.

subconj_bse_or_inf_synsem := basic_onearg_subconj_synsem & subconj_lex_synsem &
  [ LOCAL [ CAT [ HEAD 
		  [ MOD < [ MODIFD.LPERIPH - ] >,
		    PRD + ],
                  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS < [ LOCAL 
                                [ CAT.VAL [ SPR *olist* ],
                                  CONT.HOOK [ LTOP #vpltop,
                                              INDEX event &
                                                [ E.TENSE no_tense ] ] ] ] > ],
                  HC-LEX - ],
            CONT [ RELS <! subord_relation & [ ARG2 #subord ] !>,
                   HCONS <! qeq, 
                            qeq & [ HARG #subord,
                                    LARG #vpltop ] !>,
		   ICONS <! !> ] ] ].

;; DPF 2017-10-02 - Constrain comp's subj to be HEAD basic_noun in order to
;; prevent spurious locative inversion VPs here, as in
;; *he went to go his cats*
;; Also constrain the XARG to exclude do-index, to avoid
;; *it is good to be fight them*
;;
subconj_bse_synsem := subconj_bse_or_inf_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT vp_bse_cat &
					[ HEAD.MINORS.ALTMIN non_ellipt_rel,
					  VAL.SUBJ < unexpressed_reg &
						[ LOCAL.CAT.HEAD basic_noun ]>],
				    CONT.HOOK.XARG non_expl-ind ] ] > ].
;; *so as to ...*
;;
subconj_inf_synsem := subconj_bse_or_inf_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT vp_inf_cat ] > ].

;; *in order (for Kim) to ...*
;;
subconj_inf_vp_or_s_synsem := subconj_bse_or_inf_synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT s_or_vp_inf_cat ] > ].

; DPF 2/6/02 - Changed COMPS..SPR synsem to synsem_min in order to support 
; e.g. 'I slipped while dancing'
; DPF 5/20/02 - Cannot require that COMPS..SUBJ..INDEX be re-entrant with
; the MOD..AGR, since get sentences like "There are age restrictions when
; renting a car" where the AGR is there_expl, but the INDEX is ref-ind.  
; So the subject of the predicative phrase must be discourse-bound.
; DPF 30-May-02 - TO DO - constrain complement to be non-temporal, to allow
; "when there" but block "when Tuesday".
; DPF 3-May-03 - Made [COMPS..MOD..HEAD noun] to avoid some of the  spurious 
; ambiguity for e.g. "Kim knows when to arrive".
; DPF 22-apr-04 - Removed SPR < synsem_min > from complement, since this
; prevents "when really necessary", and it's not clear what it was supposed
; to be blocking.
; DPF 20-aug-04 - Removed [MOD..MSG message] even though this was helping
; with seemingly spurious ambiguity, because it blocked attachment to
; subordinate clauses, as in "if you slip while dancing, you fall".
;
subconj_prd_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.HEAD.VFORM non_inf ] >,
                  VAL.COMPS < [ LOCAL [ CAT prd_or_adv_cat,
					CONT.HOOK [ LTOP #prdltop,
                                                    XARG non_expl-ind ] ]] > ],
            CONT [ RELS <! subord_relation & [ ARG2 #cltop ] !>,
                   HCONS <! qeq, qeq & [ HARG #cltop,
                                         LARG #prdltop ] !>,
		   ICONS <! !> ] ] ].

subconj_prd_pre_synsem := subconj_prd_synsem &
  [ LOCAL.CAT.POSTHD - ].

subconj_prd_post_synsem := subconj_prd_synsem &
  [ LOCAL [ CAT.POSTHD +,
            CONT.HOOK.INDEX.SF #iforce ],
    PUNCT.RPUNCT.PSF #iforce ].

; For "so" of "I can be there, so yes/no/okay"
subconj_disc_adv_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT s_cat_fin_or_imp,
				 MODIFD.LPERIPH - ] >,
			 PRD - ],
                  VAL.COMPS < [ LOCAL [ CAT [ HEAD root-marker,
                                              POSTHD - ],
                                        CONT.HOOK [ LTOP #cltop,
                                                    INDEX.SF prop-or-comm ] ],
                                LEX + ] >,
                  HC-LEX -,
                  POSTHD + ],
            CONT [ HOOK.INDEX.SF #iforce,
                   RELS <! subord_relation & [ ARG2 #subord ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !>,
		   ICONS <! !> ] ],
    PUNCT.RPUNCT.PSF #iforce ].

; DPF 14-May-02 - Cost of having this complementizer-like analysis is that
; we don't get conjoined if-clauses like "If you leave and he stays, I win"
; So why do we have this analysis?  Can't remember ...
; DPF 01-Jun-07 - Removed identity of MOOD on main and subord clauses, due to
; "If it were true, you can be sure we would know" where the irrealis is in
; the complement clause - too hard to pass through, so let's overgenerate.
;; DPF 2013-02-13 - Constrain to non-local empty on both complements.
;
; 'For Kim to win, Abrams must lose'
;
;; DPF 2014-06-04 - Changed COMPS.REST.FIRST..COMPS from *olist* to < > to avoid
;; spurious ambig of e.g. *with Kim angry, ...*
;;
subconj_twoarg_synsem := subconj_lex_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
            CAT [ HEAD [ TAM.MOOD #mood,
			 PRD -,
                         MOD < [ LOCAL [ CAT s_cat_fin_or_imp &
                                           [ HEAD.TAM.MOOD #mood ] ],
                                 NONLOC.SLASH 0-dlist,
                                 MODIFD.LPERIPH - ] > ],
                  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
		        COMPS #comps &
                              < synsem &
                                [ LOCAL [ CAT np_cat_acc_min,
                                          CONJ cnil ],
                                  NONLOC non-local_none,
                                  --SIND #ind,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ],
                                synsem & #keycomp &
                                [ LOCAL
                                  [ CAT [ HEAD.TAM.MOOD #mood,
                                          VAL.COMPS < > ],
                                    CONT.HOOK [ LTOP #chand,
                                                INDEX.SF prop-or-comm,
                                                XARG #ind ] ],
                                  NONLOC non-local_none,
                                  OPT -,
                                  PUNCT [ LPUNCT no_punct,
                                          RPUNCT.PSF #iforce ] ] >,
			KCMP #keycomp ],
		  HC-LEX - ],
            CONT [ RELS <! subord_relation & #keyrel &
                           [ ARG2 #sub,
                             ARG0 [ E [ TENSE no_tense,
                                        ASPECT no_aspect ] ] ] !>,
                   HCONS <! qeq, qeq & [ HARG #sub,
                                         LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG0.SF #iforce ] ].

subconj_for_synsem := subconj_twoarg_synsem &
  [ LOCAL.CAT.VAL.COMPS 
		  < [ LOCAL.AGR #agr ],
		    [ LOCAL.CAT [ HEAD comp & [ VFORM inf ],
				  VAL.SUBJ < synsem &
					     [ LOCAL.AGR #agr,
					       NONLOC.SLASH 0-dlist ] > ]] > ].
                                                
; For predicatives, like "with Kim angry, no one smiled"
;; DPF 2014-06-04 - Constrain COMPS.REST.FIRST..MOD..HEAD to basic_noun, to
;; block (in-order-)to-VP as in *with Kim to arrive soon, ...*
;; DPF 2014-12-03 - Re 2014-06-04: But this blocks *with his boots on...*, so
;; change to [LOCAL intersective_mod]
;; DPF 2020-05-16 - Restrict second comp to SPR *olist* to exclude "ago" that
;; takes spr, and exclude n-modifying "ago"
;;
subconj_with_synsem := subconj_twoarg_synsem &
  [ LOCAL.CAT.VAL.COMPS 
		  < synsem, 
		    [ LOCAL.CAT [ HEAD v_or_a_or_p &
				       [ PRD +,
					 MOD < [ LOCAL intersective_mod ] >],
				  VAL [ SUBJ *olist*,
					SPR *olist* ] ] ] > ].

; Since we don't (yet) have a treatment of predicative NPs, add separate
; type for "With Kim the president, no one worried."
; But block robust bare singular for second NP
subconj_with_np_np_synsem := subconj_lex_synsem & basic_two_arg &
  [ LOCAL [ ARG-S #comps,
	    CAT [ HEAD [ TAM.MOOD #mood,
			 PRD -,
                         MOD < [ LOCAL [ CAT s_cat_fin_or_imp &
                                           [ HEAD.TAM.MOOD #mood ] ],
                                 NONLOC.SLASH 0-dlist,
                                 MODIFD.LPERIPH - ] > ],
		  VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			COMPS #comps &
                              < synsem &
                                [ LOCAL [ CAT np_cat_acc_min,
                                          CONJ cnil ],
                                  NONLOC.SLASH 0-dlist,
                                  --SIND #ind1,
                                  OPT -,
                                  PUNCT.LPUNCT no_punct ],
                                synsem &
                                [ LOCAL
                                  [ CAT np_cat_nonnom &
					[ HEAD.--BARE - ],
				    CONJ cnil ],
                                  NONLOC.SLASH 0-dlist,
                                  --SIND #ind2,
                                  OPT -,
				  --MIN nom_nbar_rel,
                                  PUNCT [ LPUNCT no_punct,
                                          RPUNCT.PSF #iforce ] ] > ],
                  HC-LEX - ],
            CONT [ RELS <! subord_relation & #keyrel &
                           [ ARG2 #sub,
                             ARG0 [ E [ TENSE no_tense,
                                        ASPECT no_aspect ] ],
			     CFROM #cfrom, CTO #cto ],
			   [ PRED cop_id_rel,
			     LBL #chand,
			     ARG1 #ind1,
			     ARG2 #ind2,
			     CFROM #cfrom, CTO #cto ]!>,
                   HCONS <! qeq, qeq & [ HARG #sub,
                                         LARG #chand ] !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel & [ ARG0.SF #iforce ] ].



; For sentence-initial discourse-level PPs like in "as for Chiang, who hired
; her?"
subconj_np_synsem := norm_onearg_subconj_synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL [ CAT s_cat_fin_or_imp,
					 CONT.HOOK.INDEX.SF basic-prop ],
				 NONLOC.SLASH 0-dlist,
				 MODIFD.LPERIPH - ] >,
			 PRD - ],
		  VAL.COMPS < [ LOCAL [ CAT [ HEAD basic_noun &
						   [ POSS -, MOD < >,
						     CASE non_nom ],
					      VAL [ SPR *olist*,
						    COMPS < > ],
					      MC na_or_- ],
                                        CONT.HOOK.INDEX #ind &
					                non_expl-ind ] ] >,
                  POSTHD - ],
            CONT [ RELS <! subord_relation & [ ARG2 #subord ],
			   #altkeyrel &
                           unknown_relation &
                           [ LBL #cltop,
                             ARG #ind ] !>,
                   HCONS <! qeq, qeq & [ HARG #subord,
                                         LARG #cltop ] !>,
		   ICONS <! !> ] ],
    LKEYS.ALTKEYREL #altkeyrel ].

;; DFP 2020-03-24 - Added HS-LEX - as per trunk.
;;
subconj_word := noncqrs-h-nab &
  [ SYNSEM subconj_lex_synsem &
           [ LOCAL.CAT [ VAL.COMPS < [ OPT -,
			  	       NONLOC.SLASH 0-dlist,
				       PUNCT.RPUNCT.PSF #iforce ] >,
			 HS-LEX - ],
	     LKEYS.KEYREL.ARG0.SF #iforce ] ].
    
;; For subordinating preps like 'after' which don't allow topicalized S compl:
;; "*Kim left, after on Tuesday Kim had already arrived."
;; Also take meas-NP specifiers as in "two weeks after ..."
;; DPF 21-mar-10 - Can't make compl be POSTHD -, since ordinary sb-hd phrases
;; are POSTHD +, just like topicalized clauses.  So require complement to be
;; CASE obliq, which prevents topicalized clauses.
;;
p_cp_s-notop_le := subconj_word &
"""
Prep, S, no prep stranding       
<ex>After B lost, C won.
"""
  [ SYNSEM subconj_synsem & 
           [ LOCAL.CAT.VAL [ SPR < [ --MIN just_only_notvery_deg_rel ] >,
			     COMPS < [ LOCAL.CAT.HEAD [ CASE obliq,
							VFORM fin ] ] > ] ] ].

; For subordinating preps like 'since' which allow topicalized S compl, as in
; 'Kim left, since on Tuesday Browne had already arrived'
p_cp_s_le := subconj_word &
"""
Prep, S, subord                  
<ex>B won since C lost.
"""
  [ SYNSEM subconj_ind_synsem &
	   [ LOCAL.CAT.VAl.COMPS < [ LOCAL.CAT s_cat_fin ] > ] ].

;; DPF 2018-05-25 - Added NORM quantity_or_no_rel, to block these in v_mod
;;
; "for"
p_cp_s-post_le := subconj_word &
"""
Prep, S, no fronting             
<ex>C lost, for B won.
"""
  [ SYNSEM subconj_ind_synsem &
           [ LOCAL.CAT [ POSTHD +,
			 HEAD.MINORS.NORM quantity_or_no_rel,
			 VAl.COMPS < [ LOCAL.CAT s_cat_fin_or_imp ] > ] ] ].

; For ones like "as if" which can take subjunctive CP complement
p_cp_s-unsp_le := subconj_word &
"""
Prep, S, unsp for subord         
<ex>C won, as if B were here.
"""
  [ SYNSEM subconj_synsem &
	   [ LOCAL.CAT [ HEAD.PRD -,
			 VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			       COMPS < [ LOCAL.CAT.HEAD.VFORM fin ] > ] ] ] ].

; For ones like "lest" which can take base-vfrom subjunctive CP complement
p_cp_s-bse_le := subconj_word &
"""
Prep, S, base-vform subord
<ex>C ducked, lest he be seen.
"""
  [ SYNSEM subconj_cp_bse_synsem &
	   [ LOCAL.CAT [ HEAD.PRD -,
			 VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			       COMPS < [ LOCAL.CAT s_cat_bse  ] > ] ] ] ].

; 'Kim left, as did Abrams'
p_cp_inv-ell_le := subconj_word &
"""
Prep, S, subord, inverted, only with ellipsis
<ex>B won, as did C.
"""
  [ SYNSEM subconj_cp_inv_synsem &
     [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.ALTMIN ellipsis_rel ] ].

p_cp_inv-s_le := subconj_word &
"""
Prep, S, subord, inverted        
<ex>He wouldn't eat fish, nor would he drink wine
"""
  [ SYNSEM subconj_cp_inv_synsem ].

; 'Kim will stay as time permits'
p_cp_gap-s_le := noncqrs-h-nab &
"""
Prep, S, object NP gap           
<ex>C sings, as time permits.
"""
  [ SYNSEM subconj_cp_gap_synsem ].

; 'as has been shown'
p_cp_cp-gap_le := noncqrs-h-nab &
"""
Prep, S, subj gap                
<ex>C wins, as has been seen.
"""
  [ SYNSEM subconj_cp_cp-gap_synsem ].

; Post-head subordinating prep colon, which also allows
; imperatives: "Berlin: See brochure"

p_cp_s-cln_le := noncqrs-h-nab &
"""
Prep, S, only colon              
<ex>C wins: B loses.
"""
  [ SYNSEM norm_subconj_cp_synsem & basic_onearg_subconj_synsem &
	   subconj_lex_synsem &
           [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ *anti_list* ] >,
			   VAL [ SPR *anti_list*,
				 COMPS < [ OPT -,
					 LOCAL.CAT s_cat_unspec &
					     [ HEAD [ VFORM fin_or_inf_or_imp,
						      TAM indic_tam ],
					       VAL.SPR *olist*,
					       MC + ],
					 NONLOC.SLASH 0-dlist,
					 PUNCT.RPUNCT.PSF #sf ] > ],
			   POSTHD + ],
		     CONT.HOOK.INDEX.SF #sf ] ] ].

; DPF 14-Oct-02 - Collapse above two, just specifying real_tense.

p_cp_s-for_le := noncqrs-nab &
"""
Prep, S, only 'for'              
<ex>C wins, for B loses.
"""
  [ SYNSEM subconj_for_synsem ].

p_cp_s-ncop_le := noncqrs-nab &
"""
Prep, S, nocop frag              
<ex>With B losing, C can win.
"""
  [ SYNSEM subconj_with_synsem ].

;; For special case of *where <math/>* like *when <math/>*, but restrict to
;; lexical complement (with no gap), to avoid spurious ambiguity, since normally
;; we treat *where* as a lexical PP that can fill a modifier gap.
;;
p_cp_s-lex_le := subconj_word &
"""
Prep, S, unsp for subord lexical CP such as *so* or *<math/>*
<ex>The proof follows, where <math/>.
"""
  [ SYNSEM subconj_synsem &
	   [ LOCAL.CAT [ HEAD.PRD -,
			 VAL [ SPR < [ --MIN just_only_deg_rel ] >,
			       COMPS < [ LOCAL.CAT.HEAD.VFORM fin,
					 LEX + ] > ] ] ] ].

p_np-np_s-ncop_le := noncqrs-nab &
"""
Prep, double-np subord nocop
<ex>With B the leader, C can win.
"""
  [ SYNSEM subconj_with_np_np_synsem ].

;; DPF 2014-10-18 - Added types for noun-modifying PPs with S-complements, for
;; ones with no complement gap, as in
;; *he arose the day before we arrived*
;; and for *like* and *such as* (at least), which take an S with an NP gap:
;; *a car like he bought arrived*
;; DPF 2017-06-24 - We notice that at least some of these can coordinate with
;; normal PPs to modify verbs, as in *wait for ten minutes or until we arrive*
;; so let's allow for this subtype.
;; DPF 2018-03-17 - Added NORM no_rel to block these as predic complements, as
;; in *we thought Kim before we arrived* like *we thought Kim crazy*
;; DPF 2020-03-24 - Added HS-LEX - as per trunk.
;;
p_cp_i_lexent := basic_prep_word &
  [ SYNSEM prep_prd_or_nonprd_synsem &
    [ LOCAL 
      [ CAT [ HEAD [ MOD.FIRST.LOCAL.CAT.HEAD subst,
		     MINORS.NORM no_rel ],
	      VAL.COMPS < [ LOCAL [ CAT s_cat_unspec &
				      [ MC -,
					HEAD verb & 
					   [ VFORM fin,
					     TAM #tam,
					     --ADDIN [ ADDTAM #tam,
						       ADDPN #pn ] ] ],
				    CONT.HOOK [ LTOP #cltop,
						INDEX [ E.TENSE real_tense,
							SF prop-or-comm ] ],
				    AGR.PNG.PN #pn ],
			      OPT - ] >,
	      HS-LEX - ],
	CONT [ RELS <! prep_relation &
		       [ ARG2 #arg2 ] !>,
	       HCONS <! qeq & [ HARG #arg2,
				LARG #cltop ] !>,
	       ICONS <! !> ],
	ARG-S < [ NONLOC [ REL #rel,
			   QUE #que ] ] > ],
      NONLOC [ REL #rel,
	       QUE #que ] ] ].

p_cp_i-nmod_lexent := p_cp_i_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD basic_noun ].

p_cp_i-nmod_le := p_cp_i-nmod_lexent &
"""
Prep, S comp, temp-N-modifier
<ex>B arose the day before C arrived
"""
  [ SYNSEM one_arg_prep_synsem ].

p_cp_i-gap-nmod_le := p_cp_i-nmod_lexent &
"""
Prep, S comp with , temp-N-modifier
<ex>The car like you bought arrived
"""
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < [ LOCAL [ CAT [ HEAD.MINORS 
						   [ MIN much_deg_rel,
						     ALTMIN abstr_meas_nom_rel],
						   VAL [ SPR *olist*,
							 SPEC < synsem >,
							 COMPS < > ] ],
					     CONT.HOOK [ LTOP #ltop,
							 XARG #arg0 ] ] ] >,
			     COMPS.FIRST.NONLOC.SLASH 1-dlist &
				      <! [ CAT np_cat_acc_min &
					       [ HEAD.MINORS.MIN reg_nom_rel ],
					   CONT.HOOK.INDEX #index ] !> ],
	     LKEYS.KEYREL [ LBL #ltop,
			    ARG0 #arg0,
			    ARG1 #index ] ] ].

p_cp_i_le := p_cp_i_lexent &
"""
Prep, S comp, modifier of any subst
<ex>Wait ten minutes or until we arrive.
"""
  [ SYNSEM one_arg_prep_synsem ].

p_vp_bse_le := nonconj & non_affix_bearing &
"""
Prep, vp(bse)                    
<ex>B won to avenge C.
"""
  [ SYNSEM subconj_bse_synsem ].

p_vp_inf_le := nonconj & non_affix_bearing &
"""
Prep, VP, inf                    
<ex>B raced so as to win.
"""
  [ SYNSEM subconj_inf_synsem ].

p_vp_inf-or-s_le := nonconj & non_affix_bearing &
"""
Prep, VP or S, inf                    
<ex>B raced in order (for C) to win.
"""
  [ SYNSEM subconj_inf_vp_or_s_synsem ].

p_prd_s_le := noncqrs-nab &
"""
Prep, pred-phr, scopal           
<ex>B sulked while unhappy.
"""
  [ SYNSEM subconj_prd_synsem ].

p_prd_s-v-p_le := noncqrs-nab &
"""
Prep, pred-phr, non-adjective    
<ex>B won as in Paris.
"""
  [ SYNSEM subconj_prd_synsem &
           [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD v_or_p &
                                         [ TAM.ASPECT.PROGR - ] ] > ] ].

p_np_s_le := noncqrs-nab &
"""
Prep, NP, subord                 
<ex>Of these dogs, none won. 
"""
  [ SYNSEM subconj_np_synsem ].

p_adv_s_le := noncqrs-nab &
"""
Prep, disc-adv, subord           
<ex>B won, so yes.
"""
  [ SYNSEM subconj_disc_adv_synsem ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Coordinating conjunctions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; HACK: For efficiency, restrict conjunctions to only coordinate phrases which 
; are saturated for COMPS.  This falsely excludes "Kim bought and sold a car".
; DPF (25-Apr-98) Removed COMPS..HEAD subst constraint, to allow 
; "your and my offices"
; DPF 8-Jun-99 - Removed hack on saturated COMPS - was blocking e.g. "between
; eleven and one p.m."
; DPF 15-May-03 - Discovered that the change to use LKEYS meant all subtypes
; of word were undesirably being coerced to be [LEX +] since type inference
; determined from the LKEYS attribute in 'word' that the synsem type should be
; abstract_lex_synsem which also introduces [LEX +].  This meant among other
; things that conj_word was always [LEX +*] rather than unspecified, and hence
; we could not parse e.g. "Kim is hiring Abrams and firing Browne" though we
; could still parse "Kim hired Abrams and fired Browne".  Now corrected, maybe.
; DPF 29-may-07 - Made conj_word be [LEX na] so we can prevent these from
; being right dtrs in coord phrases by themselves.  Were using nonlex_synsem
; constraint on those right dtrs, but this was inconsistent with "Kim etc,"
; where "etc," has lex_punct_synsem.
; DPF 10-sept-07 - Finally realized that conjunctions were interacting badly
; with chart dependencies, since these words identify their HEAD value with
; that of their complement, which means that they are lexically underspecified
; and hence unifiable with any requirement on MINORS.MIN.  In principle,
; should constrain the chart dependency mechanism to ignore CONJ + entries.
; For now, exclude coordination of selected PPs to gain better efficiency.
;; DPF 2014-05-16 - Re 10-sept-07: Consider changing head-marker phrase so
;; the conjunction is not the head, and then assign some other MIN value to
;; conjunctions to avoid the underspecification problem with chart dependencies.
;; DPF 2014-07-08 - Re 2014-05-16: Made this change, so we can now get
;; conjoined selected PPs, as in *Kim relies on Abrams and on Browne*
;;
basic_conj_word := word &
  [ INFLECTD +,
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN independent_rel,
		     VAL [ SUBJ #subj,
                           SPEC #spec,
			   COMPS < synsem &
				   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
                                                         SPEC #spec,
                                                         COMPS #comps,
							 SPCMPS #spcmps],
                                                   HC-LEX #hclex ],
                                             CONT.HOOK.XARG #xarg,
                                             CONJ cnil ],
				     OPT -,
                                     PUNCT.LPUNCT pair_or_no_punct ] 
				   . #comps >,
			   SPCMPS #spcmps ],
                     HC-LEX #hclex ],
               CONT.HOOK.XARG #xarg ],
       LEX na,
       --SIND non_expl,
       PUNCT no_punctuation_min ] ].

conj_word := basic_conj_word &
  [ SYNSEM.LOCAL.CAT [ MC #mc,
		       VAL [ SPR #spr,
			     COMPS < [ LOCAL.CAT [ MC #mc,
						   VAL.SPR #spr ] ] > ] ] ].

; A coordinating conjunction needs to "prime" the CONJ.LBLS and
; CONJ.INDICES lists, so that the right side of a binary coordination looks
; like an iterated coordination.
;; DPF 2017-10-07 - Also identify IND of complement and head, so we can distingish
;; *the sand and gravel arrives* from **the sand and machines arrives*

norm_conj_word := conj_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN conj_rel,
			   VAL.COMPS < [ LOCAL.AGR [ DIV #div,
						     IND #ind ] ], ... > ],
		     AGR [ DIV #div,
			   IND #ind ] ],
	     LKEYS.KEYREL basic_conj_relation &
		          [ ARG0 conj-ind ] ] ].

basic_conj_complex_lexent := conj_word &
  [ SYNSEM [ LOCAL [ CONJ.CREL #keyrel,
                     CONT [ HOOK [ LTOP #chand,
                                   INDEX #cind ],
                            RELS <! #keyrel &
                                  [ LBL #chand,
                                    ARG0 #cind ] !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

conj_complex_lexent := basic_conj_complex_lexent & norm_conj_word.

; DPF 14-apr-05 - We should distinguish conjoined mass nouns, which can produce
; a still singular phrase ('this hardiness and zest for life') from count nouns
; which are always(?) plural when conjoined, whether singular or plural.  But
; we don't have a natural class of count (whether sg or pl) vs mass, so can't
; easily split this entry into two.
; DPF 01-sept-06 - Re 14-apr-05: Now that we have multiple n-bar coord rules,
; we can locate the AGR..PN 3p in the specific construction that coordinates
; DIV - nouns.  So removed AGR..PN 3p from c_xp_and_le, cp_xp_and-both_le.
; DPF 20-sept-06 - But this would mean we parse "Abrams and Browne arrives", 
; so we use the new attribute CONJ.CPNG to distinguish 'and' from 'or', and
; have only the NP-coord rule (not the nbar-coord rule) include this
; constraint on the mother.

c_xp_and_lexent := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD both_or_cnil,
                                     CPNG.PN 3p ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

c_xp_and_le := c_xp_and_lexent
"""
Conj, only 'and'                 
<ex>B and C arrived.
"""
.

c_xp_and_le_mal := c_xp_and_lexent &
"""
Conj, only 'and', robust
<ex>B and and C arrived.
"""
  [ GENRE robust ].

c_xp_and-not_le := conj_complex_lexent &
"""
Conj, only 'and not'             
<ex>B and not C fell.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and+not_c_rel ] !> ] ].

; DPF 31-oct-05 - Make [CONJ phr-conj] to avoid spurious ambiguity for
; "Then we should go."
;; DPF 2015-09-07 - Re 31-oct-05 - But phr-conj constraints CHEAD to cnil,
;; so never get *first X then Y*.  Remove, and revisit the ambiguity.
; 'first Kim, then Sandy'
c_xp_then_le := conj_complex_lexent &
"""
Conj, only 'then'                
<ex>B tripped then fell.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL.COMPS < > ] ] >,
		   CONJ.CHEAD first_or_cnil,
		   CONT.RELS <! [ PRED _then_c_rel ] !> ] ].

c_xp_and-then_le := conj_complex_lexent &
"""
Conj, only 'then'                
<ex>B tripped then fell.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL.COMPS < > ] ] >,
		   CONJ.CHEAD first,
		   CONT.RELS <! [ PRED _and_c_then_rel ] !> ] ].

c_xp_or-else_le := conj_complex_lexent &
"""
Conj, only 'or else'             
<ex>B won or else tied.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _or+else_c_rel ] !> ] ].

c_xp_else_le := conj_complex_lexent &
"""
Conj, only 'else'             
<ex>B must win, else A loses.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SUBJ *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _else_c_rel ] !> ] ].

c_xp_except-that_le := conj_complex_lexent &
"""
Conj, only 'except that'         
<ex>B'd win except that C did.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _except+that_c_rel ] !> ] ].

c_xp_except_le := conj_complex_lexent &
"""
Conj, only 'except'              
<ex>B would win except C did.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD n_or_p,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _except_c_rel ] !> ] ].

;; DPF 2015-09-21 - Generalized COMPS..HEAD from n_or_p_or_a to subst_or_adv 
;; to include verbs and adverbs, since we want eg. *we arise as well as arrive*
;;
c_xp_aswellas_le := conj_complex_lexent &
"""
Conj, only 'as well as'          
<ex>B saw C as well as D.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD subst_or_adv,
						 VAL [ SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD both_or_cnil,
				     CPNG.PN 3p ],
		   CONT.RELS <! [ PRED _as+well+as_c_rel ] !> ] ].

c_xp_but_lexent := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD non_noun_or_adv ] >,
                   CONJ lex-conj & [ CHEAD not_or_cnil ],
		   CONT.RELS <! [ PRED _but_c_rel ] !> ] ].

c_xp_but_le := c_xp_but_lexent
"""
Conj, only 'but'                 
<ex>B ran fast but lost.
"""
.

c_xp_but_le_mal := c_xp_but_lexent &
"""
Conj, only 'but', robust
<ex>B ran fast but but lost.
"""
  [ GENRE robust ].

;; DPF 2018-03-29 - Number/person of subj *Not Browne but Chiang is here*
;; is that of the right conjunct.
c_xp_but-np_le := conj_complex_lexent &
"""
Conj, only 'but' with NPs        
<ex>B hired consultants but no engineers.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD basic_noun,
                                             AGR #agr ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _but_c_rel ] !>,
                   AGR #agr ] ].

c_xp_but-np-not_le := conj_complex_lexent &
"""
Conj, only 'but' with NPs, paired with `not'
<ex>B hired not C but D.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD basic_noun,
                                             AGR #agr ] ] >,
                   CONJ lex-conj & [ CHEAD not-conj ],
		   CONT.RELS <! [ PRED _but_c_not_rel ] !>,
		   AGR #agr ] ].

c_xp_nor_le := conj_complex_lexent &
"""
Conj, only 'nor'                 
<ex>B can't sing nor dance.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD neither_or_cnil ],
		   CONT.RELS <! [ PRED _nor_c_rel ] !> ] ].

;; DPF 2013-10-12 - Requiring AGR..PN to match COMPS..PN unfortunately
;; blocks *Abrams or Browne are going to win* and *Abrams or Browne win every
;; time*.  Saying nothing overgenerates **Abrams or the kids is winning*.
;; Making it always plural like `and' undergenerates *Abrams or Browne wins*.
;; which isn't great, but *Either Abrams or Browne wins* is better, and
;; singular agreement appears frequently  Sigh.
;; DPF 2015-09-14 - Seeing more examples like jh0:3000062 with
;; *whether it is nature, culture or hiking opportunities that appeals to you*
;; let's live with overgenerating **Abrams or the kids is winning*, and be more
;; robust with the rest.
;;
c_xp_or_lexent := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD either_or_whether_or_cnil ],
		   CONT.RELS <! [ PRED _or_c_rel ] !> ] ].

c_xp_or_le := c_xp_or_lexent
"""
Conj, only 'or'                  
<ex>B saw C or D.
"""
.

c_xp_or_le_mal := c_xp_or_lexent &
"""
Conj, only 'or', robust
<ex>B saw C or or D.
"""
  [ GENRE robust ].

c_xp_plus_le := conj_complex_lexent &
"""
Conj, only 'plus'                
<ex>B saw C plus D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _plus_c_rel ] !> ] ].

c_xp_plus-minus_le := conj_complex_lexent &
"""
Conj, only '+/-'                 
<ex>B saw them +/- C.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _plus-minus_c_rel ] !> ] ].

; DPF 31-oct-05 - Make [CONJ phr-conj] to avoid spurious ambiguity for
; "So we should leave."
; DPF 10-oct-10 - But this makes external interface too mysterious for
; generation, so live with ambiguity.
; DPF 13-aug-09 - Treating 'so' as a conjunction wrongly excludes S-initial
; order: "So Kim could win, we ran more slowly".  Change (back) to subord.
c_xp_so_le := conj_complex_lexent &
"""
Conj, only 'so'                  
<ex>B runs fast so should win.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND event ] >,
		   CONJ.CHEAD cnil,
		   CONT.RELS <! [ PRED _so_c_rel ] !> ] ].

c_xp_vs_le := conj_complex_lexent &
"""
Conj, only 'vs'                  
<ex>B prefers C vs. D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _versus_c_rel ] !> ] ].

c_xp_minus_le := conj_complex_lexent &
"""
Conj, only 'minus'               
<ex>B saw everyone minus C.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun ] >,
		   CONT.RELS <! [ PRED _minus_c_rel ] !>,
                   AGR.PNG png & [ PN 3s ] ] ].

c_xp_but-not_le := conj_complex_lexent &
"""
Conj, only 'but not'             
<ex>B saw C but not D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _but+not_c_rel ] !> ] ].

c_xp_if-not_le := conj_complex_lexent &
"""
Conj, only 'if not'              
<ex>B saw C if not D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _if+not_c_rel ] !> ] ].

c_xp_though-not_le := conj_complex_lexent &
"""
Conj, only 'though not'             
<ex>B saw C though not D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _though+not_c_rel ] !> ] ].

c_xp_but-also_le := conj_complex_lexent &
"""
Conj, only 'but also'            
<ex>B saw C but also D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD notonly_or_cnil ],
		   CONT.RELS <! [ PRED _but+also_c_rel ] !> ] ].

c_xp_much-less_le := conj_complex_lexent &
"""
Conj, only 'much less'           
<ex>B can't run much less win.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _much+less_c_rel ] !> ] ].

c_xp_let-alone_le := conj_complex_lexent &
"""
Conj, only 'let alone'           
<ex>B can't run let alone win.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _let+alone_c_rel ] !> ] ].

c_xp_nottomentn_le := conj_complex_lexent &
"""
Conj, only 'not to mention'      
<ex>B saw C not to mention D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not+to+mention_c_rel ] !> ] ].

c_xp_nottosay_le := conj_complex_lexent &
"""
Conj, only 'not to say'      
<ex>B saw C not to say D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not+to+say_c_rel ] !> ] ].

c_xp_amp_le := conj_complex_lexent &
"""
Conj, only ampersand             
<ex>B saw C &ampD.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD both_or_cnil ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

; DPF 18-Mar-03 - How to block finite VP right conjunct?  Note that not only
; VPs can be conjoined.  Note also that blocking VP right conjunct will also
; correctly block sentence conjunction.
;   This data means either having two lexical entries, or pushing VFORM up to
; type 'head' so non-verbal conjuncts are still permitted here even with
; constraint on VFORM nonfin.  Also suggests that lexical conjunctions and 
; not the coord rules determine which properties of 'head' are unified on the
; two conjuncts, if we want to treat these as regular conjunctions.
;   'Kim will buy a truck rather than rent a car'
;   'Kim will buy a truck rather than renting a car'
;   '*Kim bought a truck rather than rented a car'
;   'Kim wanted to buy a truck rather than to rent a car'
;   '*Kim bought a truck rather than Sandy rented a car'
;   'Kim arrived on Tuesday rather than on Wednesday'

c_xp_rather_le := conj_complex_lexent &
"""
Conj, only 'rather than'         
<ex>B saw C rather than D.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.AGR #agr,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _rather+than_c_rel ] !> ] ].  

; DPF 18-Mar-03 - Need to block not only finite VP right conjunct, but also 
; base form (and maybe infinitival?)
;   '*Kim will buy a truck instead of rent a car'
;   'Kim will buy a truck instead of renting a car'
;   '*Kim bought a truck instead of rented a car'
;   '?Kim wanted to buy a truck instead of to rent a car'
;   'Kim arrived on Tuesday instead of on Wednesday'
;; DPF 2020-05-29 - It's dubious to treat "instead of" as ordinary conjunction,
;; as it has more in common with "rather than", which we treat as a prep.  For
;; now, at least, exclude verb conjuncts, since we also have prep "instead of"
;; and can treat "instead of renting a car" as P + gerund.
;;
c_xp_instead_le := conj_complex_lexent &
"""
Conj, only 'instead of'          
<ex>B saw C instead of D.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD n_or_p_or_a,
					     AGR #agr ] ] >,
                   AGR #agr,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _instead+of_c_rel ] !> ] ].  

c_xp_and-or_le := conj_complex_lexent &
"""
Conj, only 'and/or'              
<ex>B saw C and/or D.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _and_c_rel ] !> ] ].

;; DPF 2017-11-17 - This was identifying number on the mother with that of the
;; right dtr, but this is wrong for *profits, not interest, drive investment*.
;; Instead, it seems that here it is the left conjunct that determines AGR on
;; the mother.
;;
c_xp_not_le := conj_complex_lexent &
"""
Conj, only 'not'                 
<ex>B saw C not D.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND ref-ind,
		   CONJ lex-conj & [ CHEAD cnil,
				     CPNG.PN #pn ],
		   CONT.RELS <! [ PRED _not_c_rel,
				  ARG1.PNG.PN #pn ] !> ] ].

; DPF 18-aug-07 - Also for non-finite VPs, PPs, APs, etc., as in
; "We want to win the game, not lose it!"
c_xp_not-ev_le := conj_complex_lexent &
"""
Conj, only 'not', event cnjcts   
<ex>B wants to win, not lose.
"""
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ *synlist*,
                             COMPS.FIRST.--SIND event & [ E.TENSE untensed ] ],
		   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _not_c_rel ] !> ] ].

c_xp_yet_le := conj_complex_lexent &
"""
Conj, only 'yet'                 
<ex>B ran fast yet lost.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.--SIND event,
		   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _yet_c_rel ] !> ] ].

c_xp_even_le := conj_complex_lexent &
"""
Conj, only 'even'                
<ex>B saw everyone even C.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD n_or_p_or_a,
                                                   VAL.SPR *olist* ],
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _even_c_rel ] !> ] ].

; Different since it sets DIV to +, to get e.g.
; 'chair after chair arrived.'
c_xp_after_le := basic_conj_complex_lexent &
"""
Conj, only 'after'               
<ex>Dog after dog barked.
"""
  [ SYNSEM [ LOCAL [ AGR [ PNG.PN #pn,
                           DIV + ],
                     CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD noun,
                                                     VAL.SPR < synsem > ],
                                               AGR.PNG.PN #pn ] ] >,
                     CONJ lex-conj & [ CHEAD cnil ],
                     CONT.RELS <! [ PRED _after_c_rel ] !> ],
             LKEYS.KEYREL conj_relation ] ].

c_xp_albeit_le := conj_complex_lexent &
"""
Conj, only 'albeit'              
<ex>B saw a cat, albeit C.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _albeit_c_rel ] !> ] ].


c_xp_tog-with_le := conj_complex_lexent &
"""
Conj, only 'together with' with NPs        
<ex>B, C, together with D arrived.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD noun,
						 VAL.SPR *olist* ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ],
		   CONT.RELS <! [ PRED _together-with_c_rel ] !> ] ].


;; DPF 2016-02-29 - Changed COMPS..HEAD from non_noun_or_adv to a_or_adv
;; in order to avoid with VP coord as in *we arise or arrive if a machine fails*
;;
c_xp_if-though_lexent := conj_complex_lexent &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD a_or_adv,
						 VAL [ SUBJ *synlist*,
						       SPR *olist*,
                                                       COMPS < > ] ] ] >,
                   CONJ lex-conj & [ CHEAD cnil ] ] ].

c_xp_though_le := c_xp_if-though_lexent &
"""
Conj, only 'though', excluding NPs and Ss
<ex>The happy though confused cat jumped.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _though_c_rel ] !> ].

c_xp_if_le := c_xp_if-though_lexent &
"""
Conj, only 'if', excluding NPs and Ss
<ex>The happy if confused cat jumped.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _if_c_rel ] !> ].

c_xp_rather-mrk_le := conj_atomic_lexent &
"""
Conj, only discontinuous 'rather' of *rather V than V*
<ex>B would rather sing than dance
"""
  [ SYNSEM.LOCAL.CONJ rather ].

c_xp_than_le := conj_complex_lexent &
"""
Conj, only 'than' of discontinuous *rather V than V*
<ex>B would rather sing than dance.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
						 VAL.SUBJ < synsem_min > ] ] >,
		   CONJ lex-conj & [ CHEAD rather ],
		   CONT.RELS <! [ PRED _rather+than_c_rel ] !> ] ].

; DPF 31-jul-06 - Constrain to *olist* SPR to avoid '*the both dog and cat"
;; DPF 2016-01-28 - But we want *the between 10% and 20% increase*, so push
;; this constraint down to subtypes.

basic_conj_atomic_lexent := basic_conj_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL [ CONT.HOOK #hook,
                                               CONJ cnil ],
		   CONJ atomic-conj,
		   CONT [ HOOK #hook,
			  RELS <! !>,
			  HCONS <! !>,
			  ICONS <! !> ] ] ].

;conj_atomic_lexent := basic_conj_atomic_lexent & norm_conj_word &
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.SPR *olist* ].

conj_atomic_lexent := basic_conj_atomic_lexent & norm_conj_word.


c_xp_both-mrk_le := conj_atomic_lexent &
"""
Conj, 'both' paired with 'and'   
<ex>B saw both C and D.
"""
  [ SYNSEM.LOCAL [ CONJ both,
		   CAT.VAL.COMPS < [ LOCAL.CAT.MC na ] > ] ].

c_xp_btwn-mrk_le := conj_atomic_lexent &
"""
Conj, 'between' paired with 'and', numbers only
<ex>B saw between 10 and 20 cats.
"""
  [ SYNSEM.LOCAL [ CONJ between,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj ] ].

c_xp_btwn-mz-mrk_le := basic_conj_atomic_lexent & norm_conj_word &
"""
Conj, 'between' paired with 'and', measure NPs only
<ex>B has between ten dollars and twenty dollars.
"""
  [ SYNSEM.LOCAL [ CONJ between,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD noun &
						     [ MINORS.MIN 
						        abstr_meas_nom_rel ],
						   VAL.SPR.FIRST.OPT - ] ] ].

c_xp_and-btwn_le := conj_complex_lexent &
"""
Conj, only 'and'                 
<ex>B and C arrived.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD between,
                                     CPNG.PN 3p ],
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj,
		   CONT.RELS <! [ PRED _and_c_btwn_rel ] !> ] ].

c_xp_and-btwn-mz_le := conj_complex_lexent &
"""
Conj, only 'and'                 
<ex>B and C arrived.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD between,
                                     CPNG.PN 3p ],
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD noun &
					             [ MINORS.MIN 
						          abstr_meas_nom_rel ] ],
		   CONT.RELS <! [ PRED _and_c_btwn_rel ] !> ] ].

c_xp_from-mrk_le := conj_atomic_lexent &
"""
Conj, 'from' paired with 'to', numbers only
<ex>B saw from 10 to 20 cats.
"""
  [ SYNSEM.LOCAL [ CONJ from-conj,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj ] ].

c_xp_from-mz-mrk_le := conj_atomic_lexent &
"""
Conj, 'from' paired with 'to', measure NPs only
<ex>B has from ten dollars to twenty dollars.
"""
  [ SYNSEM.LOCAL [ CONJ from-conj,
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD noun &
						     [ MINORS.MIN 
						         abstr_meas_nom_rel ],
						   VAL.SPR *olist* ] ] ].

c_xp_to-from_le := conj_complex_lexent &
"""
Conj, only 'to' with `from'
<ex>From 10 to 20 cats arrived.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD from-conj,
                                     CPNG.PN 3p ],
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD intadj,
		   CONT.RELS <! [ PRED _to_c_from_rel ] !> ] ].

c_xp_to-from-mz_le := conj_complex_lexent &
"""
Conj, only 'to' with `from'
<ex>From ten miles to twenty miles passed.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD from-conj,
                                     CPNG.PN 3p ],
		   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD noun &
					             [ MINORS.MIN 
						          abstr_meas_nom_rel ],
						   VAL.SPR *olist* ],
		   CONT.RELS <! [ PRED _to_c_from_rel ] !> ] ].

c_xp_either-mrk_le := conj_atomic_lexent &
"""
Conj, 'either' paired with 'or'  
<ex>B saw either C or D.
"""
  [ SYNSEM.LOCAL [ CONJ either,
		   CAT.VAL.COMPS.FIRST.LOCAL.CONJ.LCHEAD both_or_cnil ] ].
                   
c_xp_neither-mrk_le := conj_atomic_lexent &
"""
Conj, 'neither' prd with 'nor'   
<ex>B saw neither C nor D.
"""
  [ SYNSEM.LOCAL.CONJ neither ].

c_xp_whether-mrk_le := conj_atomic_lexent &
"""
Conj, 'whether' paired with 'or'  
<ex>B arose, whether quickly or slowly.
"""
  [ SYNSEM.LOCAL.CONJ whether ].

c_xp_notonly-mrk_le := conj_atomic_lexent &
"""
Conj, 'not only':'but also'      
<ex>Not only C but also D won.
"""
  [ SYNSEM.LOCAL.CONJ notonly ].

c_xp_notonly-inv_le := basic_conj_atomic_lexent &
"""
Conj, inverted 'not only'
<ex>Not only did C win but D also won.
"""
  [ SYNSEM [ LOCAL [ CONJ notonly,
		     CAT [ VAL [ SPR < >,
				 COMPS < [ LOCAL.CAT [ HEAD verb & [ INV + ],
						       MC na,
						       VAL [ SUBJ *olist*,
							     SPR *olist*] ]] >],
			   MC bool ] ],
             LKEYS.KEYREL basic_conj_relation &
		          [ ARG0 conj-ind ] ] ].

c_xp_not-mrk_le := conj_atomic_lexent &
"""
Conj, 'not' prd with 'but'       
<ex>Not C but D won.
"""
  [ SYNSEM.LOCAL.CONJ not-conj ].

;; DPF 2018-06-01 - Restrict to NP coord for now.
; 'First Kim, then Sandy'
c_xp_first-mrk_le := conj_atomic_lexent &
"""
Conj, 'first' prd w/ 'and then'  
<ex>B saw first C and then D.
"""
  [ SYNSEM.LOCAL [ CONJ first,
		   CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD noun,
						 VAL.SPR *olist* ] ] > ] ].

;; DPF 2012-09-19 - Note that we can't just treat this as apposition, since
;; (1) the two NPs are temporally disjoint, so apposition semantics isn't
;; quite right, and (2) we still want to disallow appos structure for two
;; named entities, to avoid massive ambiguity.
;;
c_xp_formerly_le := conj_complex_lexent &
"""
Conj, only 'formerly'               
<ex>Kim Smith, formerly Mary Browne, arrived.
"""
  [ SYNSEM.LOCAL [ CONJ lex-conj & [ CHEAD cnil ],
		   CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun ] >,
		   CONT.RELS <! [ PRED _formerly_c_rel ] !> ] ].

; two hundred and fifty
c_xp_and-num_le := conj_word &
"""
Conj, in complex number exprs    
<ex>Two hundred and ten won.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN integer_rel,
                           VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD intadj2- &
                                                     [ MINORS.ALTMIN #altmin ],
                                                     CONT.HOOK.LTOP #hand,
                                                     CONJ cnil,
                                                     AGR.DIV #div ],
                                             MODIFD.LPERIPH na ] ],
                     CONJ num-conj,
                     CONT [ HOOK.LTOP #hand,
                            RELS <! !>,
                            HCONS <! !>,
			    ICONS <! !> ],
                     AGR.DIV #div ],
	     NONLOC non-local_none,
             LKEYS [ KEYREL integer_relation,
                     ALTKEYREL.PRED #altmin ] ] ].

; 'five and a half'
c_xp_and-fract_le := conj_word &
"""
Conj, in fractions               
<ex>Two and a half teams won.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN fraction_rel,
                           VAL.COMPS.FIRST [ LOCAL [ CAT.HEAD fractadj &
                                                     [ MINORS.ALTMIN #altmin ],
                                                     CONT.HOOK [ LTOP #hand,
								 INDEX #ind,
                                                                 XARG #xarg ],
                                                     CONJ cnil,
                                                     AGR.DIV #div ],
                                             MODIFD.LPERIPH na ] ],
                     CONJ num-conj,
                     CONT [ HOOK [ LTOP #hand,
                                   INDEX #ind,
				   XARG #xarg ],
                            RELS <! !>,
                            HCONS <! !>,
			    ICONS <! !> ],
                     AGR.DIV #div ],
             LKEYS [ KEYREL.PRED fraction_rel,
                     ALTKEYREL.PRED #altmin ],
             NONLOC [ SLASH 0-dlist,
                      REL 0-dlist,
                      QUE 0-dlist ] ] ].

;; DPF 2012-12-21 - Added NONLOC non-local_none to prevent spurious nonempty 
;; SLASH.  Sigh.
;; DPF 2012-12-24 - Also added SPR < > to avoid conjoined S's feeding the
;; sp-hd rule.
;; DPF 2016-02-29 - Replace CONJ phr-conj with complex-conj because it was
;; blocking *Kim at al.* with regular np-np_crd-t_c
;;
basic_et_conj_lexent := basic_word &
  [ INFLECTD +,
    ORTH [ CLASS #class, FROM #from, TO #to, FORM #form ],
    TOKENS tokens &
           [ +LIST #tl & < [ +CLASS #class, +FROM #from, +FORM #form ], ... >,
             +LAST.+TO #to ],
    SYNSEM synsem &
     [ LOCAL [ CAT [ HEAD.MINORS.MIN norm_rel,
                     VAL [ COMPS < >,
			   SPEC < > ] ],
               CONJ complex-conj & [ CREL #keyrel ],
	       AGR.PNG png & [ PN 3p ],
               CONT [ HOOK [ LTOP #chand,
                             INDEX #cind ],
                      RELS <! relation & #keyrel &
			      [ LBL #chand,
				ARG0 #cind ] !>,
		      HCONS <! !>,
		      ICONS <! !> ] ],
       NONLOC non-local_none,
       LKEYS.KEYREL #keyrel & 
	     [ CFROM #from,
	       CTO #to ],
       PUNCT [ LPUNCT comma_or_clause_or_no_punct,
               RPUNCT no_punct ],
       PHON.ONSET.--TL #tl ] ].

et_conj_lexent := basic_et_conj_lexent &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < > ].

etc_conj_lexent := et_conj_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _etc_c_rel ] !> ].

c_-_etc_le := etc_conj_lexent &
"""
Conj, only 'etc.'                
<ex>B saw C, D, etc.
"""
  [ SYNSEM.PUNCT.PNCTPR ppair ].

; For "did Kim arrive etc.?" where the PUNCT.PAIRED value must be unconstrained
; even though there's a qmark which would ordinarily stamp PAIRED no_ppair.
c_-_etc-qmark_le := etc_conj_lexent &
"""
Conj, only 'etc?'                
<ex>Did B see C, D, etc?
"""
  [ SYNSEM.PUNCT.PNCTPR no_ppair ].

c_-_so-on_le := et_conj_lexent &
"""
Conj, only 'and so on'           
<ex>B hired C and so on.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _so+on_c_rel ] !> ].

c_-_vice-versa_le := et_conj_lexent &
"""
Conj, only 'and vice versa'      
<ex>B hired C and vice versa.
"""
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED _vice+versa_c_rel ] !> ].

; Similarly for "Kim hired everyone except:" where the colon affix would
; stamp PAIRED no_ppair, but we want it in PNCTPR since this odd "except"
; is acting like a head-marker phrase.

c_-_except_le := et_conj_lexent &
"""
Conj, only 'except'              
<ex>B couldn't win except ...
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD n_or_p,
                     CONT.RELS <! [ PRED _except_c_rel ] !> ],
             PUNCT.PNCTPR ppair ] ].

c_-_except-coln_le := et_conj_lexent &
"""
Conj, only 'except:'             
<ex>B brought nothing except:
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD n_or_p,
                           VAL.SPR *anti_list* ],
                     CONT.RELS <! [ PRED _except_c_rel ] !> ],
             PUNCT.PNCTPR no_ppair ] ].

c_-_etal_le := et_conj_lexent &
"""
Conj, only 'et al'               
<ex>B hired C et al.
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD supnoun & [ MINORS.MIN nonpro_rel ],
                         VAL.SPR < > ],
                   CONT.RELS <! [ PRED _et+al_c_rel ] !> ] ].

c_-_name-few_le := et_conj_lexent &
"""
Conj, only 'to name a few'       
<ex>B saw C,D, to name a few.
"""
  [ SYNSEM [ LOCAL.CONT.RELS <! [ PRED _to+name+a+few_c_rel ] !>,
             PUNCT.PNCTPR ppair ] ].

;; DPF 2016-10-12 - Version for N-bars as in *my cat, mouse, etc.*, with
;; non-empty SPR.
;;
c_-_etc-nb_le := basic_et_conj_lexent &
"""
Conj, only 'etc', for Nbar coord
<ex>My cat, mouse, etc. disappeared.
"""
  [ SYNSEM [ LOCAL.CAT [ HEAD noun_or_nomger,
			 VAL.SPR < synsem & [ OPT - ] > ],
	     LKEYS.KEYREL [ PRED _etc_c_rel,
			    ARG0 ref-ind ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NEG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; not

; "not" requires its VP complement to be [VFORM non_fin], which is a supersort
; for all non-finite vforms except imp_vform, which is a subsort of bse; the
; other subsort of bse, bse_only, is a subsort of non_fin.  Most verbs with
; base morphology are [VFORM bse], and hence (the VPS they project) can be
; modified by "not", and they can also head imperative clauses, which require
; the head to be [VFORM imp_vform].  Only if modified by "not" will a base
; VP be unable to project an imperative clause; in contrast, "never sleep" is 
; fine as an imperative, since "never" does not further restrict its VP 
; complement leaving it [VFORM bse], which is consistent with the imperative 
; rule.  This fine distinction is due to Rob M.
; DPF 2-Feb-01 - Changed MOD..HEAD from verbal to v_or_g, to allow e.g.
; "I tried not hiring kim"

adv_neg_lexent := basic_adverb_word &
  [ SYNSEM lex_synsem & 
	 [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL scopal_mod &
					    [ CAT [ VAL.COMPS < >,
                                                    MC na ],
                                              CONT [ HOOK [ LTOP #mhand,
                                                            INDEX non_expl &
                                                                  #vevent,
                                                            XARG #xarg ] ],
                                              CONJ cnil ] ] >,
                                MINORS.MIN neg_rel ],
                         VAL [ SUBJ < >,
			       COMPS < >,
			       SPR < > ],
                         MC na,
			 POSTHD - ],
		   CONT [ HOOK [ INDEX #vevent,
                                 XARG #xarg ],
			  RELS <! #keyrel &
                                  [ ARG0.E [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                    ARG1 handle & #hand ] !>,
			  HCONS <! qeq &
				  [ HARG #hand,
				    LARG #mhand ] !>,
			  ICONS <! !> ] ],
           NONLOC.QUE 0-dlist,
           LKEYS.KEYREL #keyrel ] ].

;; DPF 17-03-01 - Removed MOD..SF prop-or-ques because it prevented analyzing
;; *let's not move* since we're trating that "let's" as semantically empty
;; beyond adding Sf comm.  Still rightly block parse for imperative *not arise*
;; because *not arise* is VFORM bse_only, incompatible with imperative rule.
;;
av_-_s-not_le := adv_neg_lexent &
"""
Scop, VP, just 'not'             
<ex>B did not win.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD negadv &
                       [ MOD < [ LOCAL.CAT [ HEAD verb_or_frag &
						  [ VFORM non_fin ],
                                             VAL.SUBJ < synsem_min > ] ] > ],
		       NEGPOL + ] ].


; DPF 05-apr-05 - MOD..HEAD v_or_a_or_p allows modnp subtype, which is not
; a subtype of a_or_p for independent reasons.  No spurious ambiguity here, 
; since the SUBJ < > constraint rules out all PRD + verbal projections.
;; DPF 2013-11-15 - But there was still spurious ambiguity with the variant
;; `not' or `never' combining with the copula, as in "Kim is never happy".
;; So avoid by constraining the modifiee to be untensed.
;; DPF 2015-05-09 - Generalized v_or_a_or_p to non_noun_or_adv, to allow 
;; negation of adverbs, as in "not carefully".

av_-_s-not-prdp_le := adv_neg_lexent &
"""
Scop, 'not', modify PrdP         
<ex>Anyone not happy loses.
"""
  [ SYNSEM.LOCAL.CAT.HEAD adv_nonmob &
                          [ MOD < [ LOCAL.CAT [ HEAD non_noun_or_adv &
                                                     [ PRD + ],
                                                VAL [ SUBJ < >,
						      SPCMPS < > ] ] ] > ] ].
; for "non-" as in "non-intrusive"
av_-_s-not-ap_le := adv_neg_lexent &
"""
Scop, 'not', modify AdjP
<ex>The non-intrusive cat won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD adv_nonmob &
                          [ MOD < [ LOCAL.CAT [ HEAD a_or_adv,
                                                VAL.SUBJ < > ] ] > ] ].

; for "non-" as in "non-recurring"
av_-_s-not-vp_le := adv_neg_lexent &
"""
Scop, 'not', modify PRD + VP
<ex>The charge was non-recurring.
"""
  [ SYNSEM.LOCAL.CAT.HEAD adv_nonmob &
                          [ MOD < [ LOCAL.CAT [ HEAD verb & [ PRD + ],
                                                VAL.SUBJ < synsem > ] ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; COMPLEMENTIZERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Complementizers except for 'to' are marked [SUBJ < >] which prevents them
; from having PP modifiers.

; ERB (07-10-96) 'whether' clauses are made with the regular hd-cmp_u_c rule, so
; the polar_q_rel must come from 'whether' itself.  This means that whether
; can't identify its MIN with its --COMPKEY.  Also, I made complementizer_word
; inherit from msg_word (see comments near that type).  This has the effect of
; making non_affix_bearing be inherited by this type, instead of the lower
; types.

; ERB (14-12-97) to_c_prop needs to be MC + for infinitival relatives
; (see notes near to and non_wh_rel_cl) so this type can't say MC -.
; There is no convenient supertype to all of the MC - ones, so I'm
; just going to put it in on each for now.

; ERB (14-12-97) Complementizer_word can't be nonmod_local because 
; to_c_nonprop is going to have a non-empty mod value.  Again, For
; now I'm scattering this constraint among the lower types as appropriate.

; ERB (13-01-98) In fact, complementizer_word can't even be MC bool,
; because to_c_nonprop has to be MC na in order to head hcomps that
; serve as modifiers, as in "a teacher to talk to Sandy".

;;; DPF 01-Mar-00 - Reconsider, now that support_rel has been eliminated.
; DPF (27-Sept-98) Made MIN be v_event_rel, since "to" needs to pass up the
; KEY.LBL of its complement, in order to get the desired semantics for e.g.
; "Kim is going to lose" where the copula's support_rel identified its LBL
; with that of its complement's KEY.
; 
; DPF (13-Jan-99) Generalized to make MIN be v_event_rel for all 
; complementizers, needed in particular to avoid treating complementizers as 
; particles, which are selected by MIN value.
; DPF 25-oct-03 - Change SPR from *olist* to < > to block PP modification.
;; DPF 2017-11-13 - Re 25-oct-03: But this prevents *it's easy for Kim just to 
;; sleep* and *we want him merely to jog*.  So push down to subtypes, excluding
;; *to*, which is already prevented from post-modification due to being AUX +.
;;
complementizer_word := noncr-h-nab &
  [ SYNSEM.LOCAL [ CAT [ VAL.SPR *olist* ],
		   AGR.PNG.PN 3s,
		   CONT.HOOK.INDEX non_expl ] ].

; These are the subject-to-object raising complementizers.  We're giving a
; funny three-constituent analysis to CPs: "that [Kim] [walks]" and "for [Kim]
; [to walk]".  One (beneficial) side effect of this is that finite and
; non-finite CPs get a uniform analysis, and we also can do real subject
; extraction without running afoul of the dreaded that-trace filter
; (Perlmutter 1971).  

; We also need another "that", one that combines with an adverbial and an
; S/Adv.  This accounts for why you get preposed modifiers with that clauses
; and not with for/to clauses, and why you don't get the that-t effect when
; you have an adverb in there.  But, that second "that" is going to have to
; bind off a SLASH value, sort of like the tough-movement cases, and that will
; have to wait for lexicalized SLASH passing.

; ERB (14-12-97) See notes at complementizer_word.

; DPF 2-Apr-01 - Added PP modifier argument to COMPS, to allow for sentence-
; initial modification, as in "I knew that on Tuesday I would be early", and in
; particular for "how come when I arrive he leaves" (given that we treat this
; "how come" as a main-clause-compatible complementizer).
; DPF 26-apr-08 - Generalized COMPS.FIRST..HEAD prep_or_modnp to p_or_adv
; to allow e.g. "Kim thinks that often we arise"
; DPF 27-may-09 - Changed COMPS..PUNCT no_punct to lparen_or_dq_or_no_punct to 
; get *admit that kim "will arrive"* and *that {gene} therapies succeed*

basic_two_place_compl_word := complementizer_word & 
  [ SYNSEM 
    [ LOCAL 
      [ ARG-S #comps,
        CAT [ HEAD [ VFORM #vform,
		     MOD < anti_synsem_min > ],
              VAL [ COMPS #comps,
		    SPR < >,
		    KCMP canonical_synsem &
			 [ --MIN #cmin,
                           LOCAL [ CAT [ HEAD verbal &
                                              [ VFORM #vform ],
                                         VAL [ COMPS < > ],
					 MC na_or_- ],
                                   CONT.HOOK #hook ],
                           OPT -,
                           PUNCT.LPUNCT lparen_or_dq_or_no_punct ] ] ],
	CONT.HOOK #hook ],
      LKEYS.--COMPKEY #cmin ] ].

; Instead of doing raising here by identifying whole synsems, only identify
; semantic indices, as with regular raising for verbs above.  This lets us get
; "I prefer that he be here early" treating the second (VP) complement of 
; "that" as a simple base-form VP, rather than some new morphological form.

basic_sor_compl_word := basic_two_place_compl_word &
  [ SYNSEM basic_one_arg & 
    [ LOCAL.CAT.VAL [ COMPS < #kcmp &
			      [ LOCAL.CAT.VAL.SUBJ < anti_synsem_min > ] >,
		      KCMP #kcmp ] ] ].

norm_compl_word := basic_sor_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD comp & [ INV - ],
		       VAL [ SUBJ < anti_synsem_min >,
			     COMPS < [ LOCAL.CAT [ HEAD verb &
						      [ TAM.TENSE real_tense ],
						   MC - ] ] > ] ] ].

sor_compl_word := norm_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM.MOOD #mood,
		       VAL.COMPS < [ LOCAL [ CAT.HEAD [ --ADDIN [ ADDPN #pn,
								  ADDTAM #tam ],
							TAM #tam &
							    [ MOOD #mood ] ],
					     AGR.PNG.PN #pn ] ] > ] ].

cm_np-vp_that_le := sor_compl_word & 
"""
Cmplzr, only 'that' (int mod)    
<ex>B knew that we won.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  TAM #tam & indic_tam,
				  CASE nom,
				  AUX -,
				  MINORS.MIN verb_aspect_rel ],
			   VAL.COMPS.FIRST.LOCAL.CAT.HEAD [ TAM #tam,
							    CASE non_nom ],
			   MC - ],
		     CONT [ HOOK.INDEX.SF prop,
			    RELS <! !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

;; "I prefer that he be here early"
cm_np-vp_th-sv_le := norm_compl_word & 
"""
Cmplzr, subjnct 'that' (int mod) 
<ex>B insists that C be here.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM bse,
				  AUX -,
				  MINORS.MIN verb_aspect_rel ],
			   VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM bse ] >,
			   MC - ],
		     CONT [ HOOK.INDEX.E.MOOD subjunctive,
			    RELS <! !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

;; DPF 2012-07-22 - Changed MIN to from verb_aspect_rel to v_event_rel to
;; prevent `for' from letting `be_do' verbs into the chart via the --COMPKEY
;; mechanism.
;;
cm_np-vp_for_le := basic_two_place_compl_word &
"""
Cmplzr, only 'for'               
<ex>B hopes for C to win.
"""
  [ SYNSEM basic_two_arg & 
	   [ LOCAL [ CAT [ HEAD comp &
				[ VFORM inf,
				  AUX -,
				  INV -,
				  MINORS.MIN v_event_rel,
				  TAM #tam ],
			   VAL [ SUBJ < anti_synsem_min >,
				 COMPS 
				  < canonical_synsem &
				    [ LOCAL [ CAT nomp_cat_acc_min,
					      CONT.HOOK.LTOP #vltop,
					      AGR #agr,
					      CONJ cnil ],
				      --SIND #ind & index,
				      OPT -,
				      NONLOC #nloc & [ SLASH 0-dlist,
						       REL 0-dlist ],
				      PUNCT [ RPUNCT 
					       comma_or_rbc_or_pair_or_no_punct,
					      PNCTPR ppair ] ],
				    canonical_synsem & #kcmp &
 				    [ LOCAL 
			              [ CAT [ HEAD comp & [ VFORM inf,
							    TAM #tam ],
					      VAL.SUBJ < synsem &
							 [ LOCAL [ CAT 
								   nomp_cat_min,
								   AGR #agr ],
							   NONLOC #nloc ] > ],
					CONT.HOOK [ LTOP #vltop,
						    XARG #ind ] ] ] >,
				 KCMP #kcmp ],
			   MC - ],
		     CONT [ HOOK.INDEX.SF prop-or-comm,
			    RELS <! !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

cm_np-vp_like_lexent := sor_compl_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
				  AUX -,
				  MINORS.MIN verb_aspect_rel ],
                         VAL.COMPS < [ LOCAL 
                                       [ CAT [ MC - ],
                                         CONT.HOOK.INDEX.SF like-iforce ] ] >,
                         MC - ],
                   CONT [ RELS <! !>,
                          HCONS <! !>,
			  ICONS <! !> ] ],
	     LKEYS.KEYREL.PRED no_rel ] ].

cm_np-vp_like_le := cm_np-vp_like_lexent &
"""
Cmplzr, 'like', indicative S-comp
<ex>He looks like he'll win.
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.TAM indic_tam ].

cm_np-vp_asif_le := cm_np-vp_like_lexent
"""
Cmplzr, 'as if', indicative or subjunctive S-comp
<ex>He looks as if he were happy.
"""
.

; ERB (14-12-97) Why is the SUBJ here specified as acc?? I'm taking it
; out because that follows now from pro_ss.

; ERB (08-01-98) Presumably that had to do with "for him/*he to sleep..."
; but that's the other to: to_c_nonprop.

; ERB (14-12-97) In order to implement infinitival relatives (I found
; a teacher to talk to Sandy, I found a teacher to talk to), I am
; making to_c_prop MC +.  The reasons for this is that the relevant
; cx (non_wh_rel_cl) needs to be able to take subjh_decl and hcomps
; headed by to_c_prop as its head-dtr, but not an extrasubj phrase.

; ERB (13-01-98) to_compl_word says SUBJ < unexpressed >, but I don't
; how that can be, unless the analysis of raising has changed drastically.
; (With it that way, raising is broken).  So I am getting rid of it.

; ERB (19-01-98) SUBJ < unexpressed > was in there because something
; had to take care of giving that subject a SLASH value.  The solution
; we've opted for is this: the subject of to_c_prop is always PRO, and
; the subject of to_c_nonprop is always raised (that is, all
; infinitival tos except those in raising constructions are to_c_prop).
; So there is no constraint on to_compl_word, but to_c_prop says
; SUBJ < pro_ss > and to_c_nonprop says SUBJ canonical_synsem.

; ERB (19-01-98) This to has to have a mod value so that it can
; head the infinitival relatives.  Something needs to be said about
; the features mentioned in local, probably, but I'm not sure
; what yet.  It also needs to be MC na so it can feed extrasubj.

; ERB (03-02-98) MIN should be no_rel.  It used to be identified with
; --COMPKEY, but that causes at least one problem: to was able to be the
; SPR of the, since the constrains its choice of SPR by a semantic
; constraint on the KEY.
; DPF (13-Jan-99) This problem should be solved by the above decision to
; make all complementizers have the MIN be of type v_event_rel.
; DPF 17-Sep-01 - Removed INDEX.E.TENSE no_tense, since it prevents e.g. 
; "I am going to arrive".
; DPF 14-Nov-01 - Returned to identifying MIN with --COMPKEY, in order to get
; intended constraint on --COMPKEY.E.ASPECT for e.g. "I have yet to arrive"
; DPF 4-apr-04 - Removed identification of AGR and COMPS.FIRST..AGR, since
; we need to have complementizers stipulate AGR.PNG.PN 3s to get the agreement
; right for sentential subjects (?), but we also say that 'and' is inherently
; AGR.PNG.PN 3p (to get NP coordination right (?)), and the result of both
; of these (dubious?) assertions is that we were not parsing "to arrive and
; arise" with the to-prop guy.  Probably room for improvement, but for now
; let's see what happens removing this AGR identity.
; DPF 17-sept-07 - Restrict VP complement to SUBJ..HEAD noun to avoid spurious
; analyses with locative inversion verbs as in "to run".
; DPF 3-apr-10 - Removed [POSTHD -] - don't know why it was here, but it
; blocks coord as in "Kim tried to eat and to sleep".
; DPF 04-jun-10 - Changed SUBJ..HEAD from no_head to basic_noun, since now want
; to unify SUBJ..HEAD values in control constructions, given locative invers,
; and also now need to build inf-S in "for Kim to arrive".

basic_to_compl_word := complementizer_word &
  [ SYNSEM basic_one_arg &
     [ LOCAL [ CAT [ HEAD comp &
			  [ AUX +,
                            MINORS #mins & [ MIN verb_aspect_rel ],
			    MOD < anti_synsem &
                                      [ LOCAL intersective_mod &
                                              [ CAT nbar_cat_min ] ] > ],
                     VAL [ SUBJ < synsem & #subj &
				           [ OPT -,
					     LOCAL.CAT.HEAD basic_noun ] >,
			   SPR < anti_synsem >,
                           COMPS #comps & 
                              < canonical_synsem &
				[ LOCAL 
                                  [ CAT vp_cat &
                                        [ HEAD.MINORS #mins,
                                          VAL.SUBJ 
                                           < #subj &
					     [ LOCAL.CAT.HEAD noun,
                                               NONLOC
                                                     [ SLASH 0-dlist,
                                                       REL 0-dlist,
                                                       QUE 0-dlist ] ] > ],
				    CONT.HOOK 
                                         [ LTOP #chand,
                                           INDEX #ind & [ SF prop-or-ques ],
					   XARG #xarg ] ],
				  --MIN #cmin,
				  --SIND #ind,
				  OPT - ] > ],
		     MC na_or_- ],
	       CONT [ HOOK [ LTOP #chand,
			     INDEX #ind,
                             XARG #xarg ],
		      RELS <! !>,
		      HCONS <! !>,
		      ICONS <! !> ],
	       ARG-S #comps ],
       MODIFD notmod,
       LKEYS [ KEYREL.PRED no_rel,
	       --COMPKEY #cmin ] ] ].

to_compl_word := basic_to_compl_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.--SIND.E.TENSE no_tense ].

cm_vp_to_lexent := to_compl_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

cm_vp_to_le := cm_vp_to_lexent
"""
Cmplzr, 'to'                     
<ex>B tried to win.
"""
.

cm_vp_to_le_mal := cm_vp_to_lexent &
"""
Cmplzr, 'to', robust
<ex>B tried to to win.
"""
  [ GENRE robust ].

; try and win
cm_vp_and_le := to_compl_word &
"""
Cmplzr, 'and'                    
<ex>B will try and win.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_and,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].
; help but notice
cm_vp_but_le := to_compl_word &
"""
Cmplzr, 'but'                    
<ex>B can't help but win.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_but,
                       VAL.COMPS < [ LOCAL.CAT vp_bse_cat ] > ] ].

; prevent him from leaving (cf "*prevent him from danger")
cm_vp_from_le := to_compl_word &
"""
Cmplzr, 'from'                   
<ex>B prevents C from winning.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf_from,
                       VAL.COMPS < [ LOCAL.CAT vp_prp_cat ] > ] ].

; ERB (14-12-97) This one will have a non-empty MOD value in order to
; build things like "Kim found a friend to talk to Sandy" where the
; subject of talk has to be bound to friend (unlike in "Kim found a
; friend to talk to" where we're convinced it is discourse bound.)
;
; The semantics are probably not right -- as a place holder in the
; modcont I put a appropriate_rel.  The idea is that "I found a person
; to talk to Sandy" means something like "I found a person who is willing/
; appropriate/suitable to talk to Sandy."  But I don't see how to make
; (something like) the appropriate_rel take the comlement of the to
; as an argument.  There is also the question of whether there should be
; any message associated with this.  One would think not, given that we've
; decided the relevant to is the nonprop one...
;   For now, we're not including this rel.

; ERB (13-01-98) to_compl_nonprop_word must be MC na if it is
; to head hcomps that serve as modifiers as in "a teacher to talk to Sandy".
;
; ERB (19-01-98) All infinitival relatives are now headed by
; to_c_prop.  To_c_nonprop only appears in raising constructions.
; Accordingly, it has no MOD value, and its subject is constrained
; to be canonical_synsem.  I'm not sure the latter constraint is
; actually doing any work for us, but I believe it to be true.
; It can also now inherit from nomod_local.  The MC value might
; could be changed, as well.

; ERB (2003-08-11) Try changing SUBJ < canonical_synsem > to
; SUBJ < unexpressed >.  There are several places in the grammar
; where the SLASH value of the SUBJ here is being constrained.
; Since it is, in fact, always unxpressed, it would seem safe.
; Testing to see whether coverage is lost or gained because something
; was relying on this constraint.

;;; DPF (21-Oct-98) Added types for elided "to", since we can't use the lexical
;; rule of auxiliary verbs, since we need to block the NP "the book to", which
;; would be built by that lexical rule, then by the application of subject
;; extraction, and then the infinitival relative rule.
;; DPF 2012-02-06 - Changed MC from na to na_or_- so we get 
;; *She was too tired to.*

cm_-_to_le := noncqr-h-nab &
"""
Cmplzr, 'to' elided              
<ex>B tried to.
"""
  [ SYNSEM basic_one_arg &
	   [ LOCAL [ CAT [ HEAD comp &
				[ VFORM inf,
				  INV -,
				  AUX +,
				  PRD -,
                                  MINORS [ MIN ellipsis_rel,
                                           ALTMIN ellipsis_rel ],
				  MOD < > ],
                           VAL [ SUBJ < synsem & [ OPT - ] >,
				 SPR *olist*,
				 COMPS < > ],
			   MC na_or_- ],
		     CONT [ HOOK [ LTOP #chand,
				   INDEX #event,
                                   XARG #index ],
			    RELS <! #keyrel & arg1_relation &
				    [ LBL #chand,
				      PRED ellipsis_ref_rel,
				      ARG0 #event & [ SF prop-or-comm ],
				      ARG1 #index ] !>,
			    HCONS <! !>,
			    ICONS <! !> ],
                     ARG-S < [ ] > ],
	     NONLOC.SLASH 0-dlist,
             LKEYS.KEYREL #keyrel ] ].


; ERB (08-10-96) Whether was previously a que_word so that things selecting
; for questions could select by QUE values.  This is clearly a hack, and
; further, one that is no longer necessary now that we have semantic selection.
; I have split the old type whether_compl_word into two types: finite and
; nonfinite.  I have also gotten rid of the feature CMP.  
; As for the semantics, whether contributes a polar_q_rel (see notes near
; polar_q_rel in fundamentals.tdl).  Now, according to Rob, things that
; take complements with message-type semantics usually take the handle of
; those complements as the argument in their KEYs.  However, also according
; to Rob, if we did that here, it would imply that "whether Kim left every
; party" has more readings than "Kim left every party", which doesn't seem
; to be true.  Accordingly, whether will identify its handle with the
; handle of its complement, and take the complement's INDEX as the value
; of the ARG1 in the polar_q_rel.  Now, if whether further identified its
; INDEX with that one, things would be getting pretty twisty, so whether
; will have its own INDEX of type event.

; ERB (24-10-96) MSG now functions like KEYREL as a pointer to
; a certain rel on the RELS.  Both wh and yn questions will have an
; int_m_rel on their RELS.  This is actually sewn into the RELS
; by the constructions.  Whether just carries it in its MSG value
; so that it unifies with the right constructions.  In this way, we
; even kind of get Rob's intuition -- whether doesn't, in a sense,
; have a message, because that message isn't on its RELS.
; Anyway, all of this makes the polar_q_rel irrelevant, so I am removing
; it.  The hcomp_yn_nr construction will make sure the MARG value
; of the int_m_rel takes the LBL of whether's complement.   I don't
; know what to do about whether's LBL and ARG0 now, so I am 
; leaving them unspecified.
;
; ERB (14-12-97) See notes at complementizer_word.
;
whether_compl_word := complementizer_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < anti_synsem_min >,
			   VAL.SPR < > ],
		     CONT.HOOK.INDEX.SF ques ],
             NONLOC.SLASH 0-dlist ] ].

comp_whether_if_fin_lexent := whether_compl_word & basic_sor_compl_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp &
                                [ VFORM fin,
                                  MINORS.MIN verb_aspect_rel ],
                           VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                      [ TAM #tam,
						       --ADDIN [ ADDTAM #tam,
								 ADDPN #pn ] ],
						       MC - ],
						 AGR.PNG.PN #pn ] ] >,
                           MC - ],
                     CONT [ RELS <! !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL.PRED verb_aspect_rel ] ].

cm_np-vp_wh_le := comp_whether_if_fin_lexent &
"""
Cmplzr, 'whether'
<ex>B wondered whether C won.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD comp & [ TAM #tam & [ MOOD indicative ] ],
                       VAL [ SUBJ < >,
			     COMPS < [ LOCAL.CAT.HEAD.TAM #tam & indic_tam]>]]].

; DPF 10-sept-07 - Add NORM no_rel to prevent these from undergoing the np_cp
; rule, to avoid spurious analysis for e.g. "if Kim arrives, Abrams is."
; And similarly for the subjunctive variant.
;
cm_np-vp_if-ic_le := comp_whether_if_fin_lexent &
"""
Cmplzr, 'if'
<ex>B wondered if C won.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD [ CASE acc,
			      MINORS.NORM no_rel,
			      TAM #tam ],
                       VAL [ SUBJ < >,
			     COMPS < [ LOCAL 
                                      [ CAT.HEAD.TAM #tam & indic_tam,
                                        CONT.HOOK.INDEX.SF prop-or-ques ]]>]]].

cm_np-vp_if-sv_le := sor_compl_word &
"""
Cmplzr, 'if' subjctv
<ex>B'd know if C were here.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD comp &
                                [ CASE acc,
                                  VFORM fin,
                                  MINORS [ MIN verb_aspect_rel,
                                           NORM no_rel ] ],
                           VAL [ SUBJ < anti_synsem_min >,
				 COMPS < [ LOCAL.CAT.HEAD.TAM.MOOD 
                                                       basic_subjunctive ] > ],
			   MC - ],
                     CONT [ RELS <! !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             NONLOC.SLASH 0-dlist,
	     LKEYS.KEYREL.PRED no_rel ] ].             

; DPF 13-Mar-02 - Blocked first (optional PP) complement from being picked up
; to avoid misparse for e.g. "I need an explanation of how to return the 
; order to you"
; DPF 12-Apr-03 - But the entry for "how" leads to spurious ambiguity for e.g.
; "I know how kim arrived", and doesn't help with other WH-S's as objects of
; prepositions: "I need an explanation of who we hired".  Seems better to 
; return to our analysis treating WH-S's as NPs, and look again at the
; resulting spurious ambiguities there.  So we'll use this type only for
; "how come".

; 'how come they left'
cm_np-vp_how_le := sor_compl_word & whether_compl_word & 
"""
Cmplzr, 'how come'               
<ex>B wondered how come C won.
"""
  [ SYNSEM [ LOCAL 
             [ CAT [ HEAD comp &
                          [ VFORM fin,
                            TAM.MOOD indicative,
			    MINORS.MIN verb_aspect_rel ],
                     VAL.COMPS < [ LOCAL [ CAT [ HEAD.TAM.MOOD 
							   ind_or_modal_subj ],
					   CONT.HOOK [ LTOP #cltop,
                                                       INDEX #cind &
                                                       [ SF prop-or-ques ]]]]>,
                     MC + ],
               CONT [ HOOK.INDEX #cind & [ SF prop-or-ques ],
                      RELS <! #keyrel & 
                            [ LBL #cltop,
                              ARG0.E [ TENSE no_tense,
                                       ASPECT no_aspect ],
                              ARG1 #cind,
                              ARG2 #objind,
			      CFROM #from,
			      CTO #to ],
                            [ PRED which_q_rel,
                              ARG0 #objind & ref-ind,
                              RSTR #rhand,
			      CFROM #from,
			      CTO #to ],
                            #altkeyrel &
                            [ LBL #nhand,
                              ARG0 #objind ] !>,
                      HCONS <! qeq &
                             [ HARG #rhand,
                               LARG #nhand ] !>,
		      ICONS <! !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ] ] ].


; ERB (08-10-96) In the older version, I had whether_compl_word_inf 
; selecting for something that was just vp_inf_cat.  I never
; tested for this, but this probably allowed Sandy knew whether whether
; to leave, etc.  One way to get around this is for whether to
; select for something that is MSG no_msg.  In order to do 
; this, I need to build to CPs that are no_rel, but we want this
; anyway (even though I talked Dan out of it at one point).
; DPF 09-Jan-00 - Made "whether" be MC -, not MC na, since e.g. "know"
; wants [MC -] CP complements.

cm_vp_wh_le := whether_compl_word &
"""
Cmplzr, 'whether' with VP        
<ex>B wondered whether to run.
"""
  [ SYNSEM basic_one_arg &
	   [ LOCAL [ CAT [ HEAD comp &
                                [ VFORM inf,
                                  MINORS.MIN verb_aspect_rel ],
			   VAL [ SUBJ < >,
				 COMPS #comps &
                                      < [ LOCAL [ CAT [ HEAD comp &
							  [ VFORM inf ],
							VAL [ SUBJ *cons*,
							      COMPS < >,
							      SPR *olist* ],
							MC na ],
                                                  CONT [ HOOK.LTOP #chand ] ],
                                          --SIND #ind,
                                          OPT - ] > ],
			   MC - ],
		     CONT [ HOOK [ LTOP #chand,
                                   INDEX #ind ],
			    RELS <! !>,
			    HCONS <! !>,
			    ICONS <! !> ],
                     ARG-S #comps ],
	     LKEYS.KEYREL.PRED no_rel ] ].

;; DPF 2012-03-13 - Make these AUX + to avoid modification by PPs, as in
;; *Kim knows when to work*
;; DPF 2013-03-18 - Added MC - to avoid these in run-on-S
;;
basic_s_compl_phrase_lexent := noncqr-h-nab &
  [ SYNSEM [ LOCAL 
		 [ CAT [ HEAD verb & 
			      [ INV -,
				VFORM fin ],
			 VAL [ COMPS < > ],
			 POSTHD bool ],
		   CONT [ HOOK [ INDEX #event ],
			  RELS.LIST < arg1_relation &
                                      [ PRED ellipsis_rel,
                                        ARG0 #event,
					CFROM #cfrom, CTO #cto ], ... > ],
                   ARG-S < > ],
	     NONLOC.SLASH 0-dlist ],
    ORTH [ FROM #cfrom, TO #cto ] ].

;; DPF 2016-07-04 - Added MIN ellipsis_rel to prevent these from being modified
;; by subord-prd phrases, as in spurious *Kim knew who Abrams hired*
;;
s_compl_phrase_lexent := basic_s_compl_phrase_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ AUX +,
				  MOD < >,
				  MINORS.ALTMIN ellipsis_rel ],
			   MC - ] ],
	     LEX + ] ].

; 'so'
x_-_so-cp_le := basic_s_compl_phrase_lexent &
"""
Pro-form CP, only 'so'           
<ex>B thought so.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN v_event_rel,
				  AUX +,
				  MOD < > ],
			   VAL [ SUBJ *olist* & < anti_synsem_min >,
				 SPR *anti_null* ],
			   MC - ],
                     CONT [ HOOK [ LTOP #khand,                              
				   INDEX.SF prop-or-comm ],
                            RELS <! relation & #keyrel & [ LBL #khand ] !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
	     LEX +,
	     LKEYS.KEYREL #keyrel & [ PRED v_event_rel ] ] ].

; 'not'
x_-_not-cp_le := s_compl_phrase_lexent &
"""
Pro-form CP, only 'not'           
<ex>B hoped not.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN v_event_rel ],
			   VAL [ SUBJ *olist* & < anti_synsem_min >,
				 SPR *anti_list* ] ],
                     CONT [ HOOK [ LTOP #nlbl,
				   INDEX.SF prop-or-comm ],
                            RELS <! relation & #keyrel &
				    [ LBL #chand,
				      PRED v_event_rel,
				      CFROM #cfrom, CTO #cto ],
				    [ LBL #nlbl,
				      PRED neg_rel,
				      ARG1 #arg,
				      CFROM #cfrom, CTO #cto ] !>,
                            HCONS <! qeq &
				    [ HARG #arg,
				      LARG #chand ] !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL #keyrel ] ].

x_-_wh-cp_le := s_compl_phrase_lexent &
"""
Pro-form CP, wh-adv forms            
<ex>B wondered why/how/when.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN prep_mod_rel,
					 NORM norm_rel ],
			   VAL [ SUBJ < >,
				 SPR < synsem &
				     [ LOCAL [ CAT [ HEAD.MINORS.MIN #min & 
							just_only_deg_rel,
						     VAL.SPR  *olist* ],
					       CONT.HOOK.LTOP #hand ],
				       NONLOC [ QUE 0-dlist,
						REL 0-dlist ],
				       --MIN #min ] > ] ],
		     CONT [ HOOK [ LTOP #hand,
				   INDEX.SF ques ],
                            RELS <! relation & 
                                 [ LBL #hand,
                                   ARG0 #event,
				   CFROM #from,
				   CTO #to  ],
                                 #keyrel &
                                 [ LBL #hand,
                                   PRED prep_mod_rel,
                                   ARG0.E [ TENSE no_tense,
                                            ASPECT no_aspect ],
                                   ARG1 #event,
                                   ARG2 #objind,
				   CFROM #from,
				   CTO #to  ],
                                 [ PRED which_q_rel,
                                   ARG0 #objind & ref-ind,
                                   RSTR #rhand,
				   CFROM #from,
				   CTO #to  ],
                                 #altkeyrel & [ LBL #nhand,
						ARG0 #objind ] !>,
			    HCONS <! qeq &
				   [ HARG #rhand,
                                     LARG #nhand ] !>,
			    ICONS <! !> ] ],
             LKEYS [ KEYREL #keyrel,
                     ALTKEYREL #altkeyrel ] ] ].

; 'what, who'
x_-_who-cp_le := s_compl_phrase_lexent &
"""
Pro-form CP, wh-pro forms
<ex>B wondered who.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN verb_aspect_rel,
			   VAL [ SUBJ < >,
				 SPR < unexpressed & 
				       [ --MIN deg_rel ] > ] ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX.SF ques ],
                            RELS <! relation & 
                                 [ LBL #ltop,
				   CFROM #from, CTO #to  ],
                                 [ PRED which_q_rel,
                                   ARG0 #objind & ref-ind,
                                   RSTR #rhand,
				   CFROM #from,
				   CTO #to  ],
                                 #altkeyrel & [ LBL #nhand,
						ARG0 #objind ] !>,
			    HCONS <! qeq &
                                   [ HARG #rhand,
                                     LARG #nhand ] !>,
			    ICONS <! !> ] ],
             LKEYS [ ALTKEYREL #altkeyrel ] ] ].

; '_MATH_'
;; Can't have SF prop-or-comm, because we want *in time, _MATH* but we don't
;; have a gapped-S lexical entry for _MATH_
;; Can't have LEX + because the aj-hd-scop rule wants the head to be LEX -,
;; for *if _MATH_ then _MATH_.*
;;
x_-_generic-cp_le := basic_s_compl_phrase_lexent &
"""
Tokens such as _MATH_ which replace a `clause' in text
<ex>B proved (that) _MATH_.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS [ MIN v_event_rel,
					   ALTMIN ellipsis_rel ],
				  MOD < anti_synsem_min >,
				  PRD - ],
			   VAL [ SUBJ *olist* & < anti_synsem_min >,
				 SPR *anti_list* ] ],
                     CONT [ HOOK [ LTOP #khand ],
                            RELS <! relation & #keyrel & [ LBL #khand ] !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
	     LKEYS.KEYREL #keyrel & [ PRED v_event_rel ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Imperative words "don't" and "let's"

; ERB (05-10-97) In order to conflate hcomp_root and hcomp_nc into just one
; hd-cmp_u_c, root_marker_words have to identify their value for mc with that of
; their complement.  (Hcomp_root identified MC for mother and non-head
; daughter.)

root_marker_word := noncqr-h-nab &
  [ SYNSEM synsem &
	 [ LOCAL [ CAT [ HEAD verb & [ AUX - ],
			 VAL.COMPS < synsem &
                                     [ LOCAL [ CAT.VAL.COMPS < >,
                                               CTXT #ctxt ],
                                       NONLOC [ SLASH #slash,
                                                QUE 0-dlist,
                                                REL 0-dlist ] ] > ],
                   CTXT #ctxt ],
	   NONLOC.SLASH #slash ] ].

; DPF 14-jul-06 - moved SUBJ < anti_synsem_min > down to 'lets' subtype, so 
;'dont' subtype can say SUBJ < >, which (nearly) enables it to be modified 
; by VP adverbs, as in "Still don't move!".  But we await the departure of
; messages, since adj_head_intersective rule requires head to be MSG no_msg.
; Leave for now.
; DPF 31-jul-06 - But this blocks e.g. 'Kim arrived but don't move!"  So
; will have to find some other solution for VP modifiers
; DPF 30-sept-06 - Changed MIN no_rel to nonaux_v_rel in order to admit
; "arise; don't move!"
;; DPF 2020-05-07 - Considered constraint MC +. instead of just bool, to 
;; avoid spurious analyses, but we still want *Tomorrow, let's dance!*, so
;; leave as is.
;; DPF 2020-08-11 - Added MOOD indicative to block "insists that do not arise"
;;
lex_imperative := root_marker_word &
  [ SYNSEM [ LOCAL 
             [ CAT [ HEAD [ MOD < anti_synsem_min >,
                            TAM.MOOD #mood & indicative,
                            PRD -,
			    INV -,
                            VFORM imp_vform,
                            MINORS.MIN nonaux_v_rel ],
                     VAL 
		    [ SPR < >,
                      SUBJ < anti_synsem & [ LOCAL.CAT.HEAD.CASE acc,
                                             --SIND #inst & ref-ind ] >,
		      COMPS < [ LOCAL 
                                 [ CAT [ HEAD verb & 
                                              [ VFORM bse_only,
                                                TAM.MOOD #mood ],
                                         VAL.SUBJ 
                                             < synsem &
                                               [ NONLOC [ SLASH 0-dlist,
                                                          QUE 0-dlist,
                                                          REL 0-dlist ] ] >,
                                         MC na ],
                                   CONT.HOOK [ INDEX #ind,
                                               XARG #inst ] ],
                                PUNCT.LPUNCT no_punct ] > ],
                     MC bool ],
               AGR #inst,
               CONT [ HOOK [ LTOP #khand,
                             INDEX #ind & [ E.TENSE present,
                                            SF comm ] ],
                      RELS.LIST < [ PRED pronoun_q_rel,
                                    RSTR #rhand,
                                    ARG0 #inst,
				    CFROM #from, CTO #to ],
				  #altkeyrel &
                                  [ LBL #prohand,
                                    PRED pron_rel,
                                    ARG0 #inst &
                                        [ PT zero,
                                          SORT entity ] ], ... >,
                      HCONS.LIST < qeq &
                                   [ HARG #rhand,
                                     LARG #prohand ], ... >,
		      ICONS <! !> ] ],
             LKEYS [ KEYREL [ LBL #khand,
			      PRED no_rel,
			      CFROM #from, CTO #to ],
		     ALTKEYREL #altkeyrel ] ] ].
		    
v_vp_lets-imp_le := lex_imperative &
"""
Cmps VP(bse), hd_imp_c              
<ex>Let's sing.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #chand ] >,
		   AGR.PNG png & [ PN 1p ],
		   CONT [ HOOK.LTOP #chand,
                          HCONS <! qeq !>,
			  RELS <! relation, relation !>,
			  ICONS <! !> ] ] ].

v_vp_dont-imp_le := lex_imperative &
"""
Cmps VP(bse), hd_imp_c, neg         
<ex>Don't sing.
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CONT [ HOOK.LTOP #chand ],
                                             CAT.HEAD.MINORS.ALTMIN 
                                                            non_conj_rel ],
				     OPT - ] >,
                   AGR.PNG png & [ PN 2 ],
		   CONT [ HOOK.LTOP #neghand,
                          RELS <! relation,
				  relation &
				 [ CFROM #cfrom, CTO #cto ],
                                 [ LBL #neghand,
                                   PRED neg_rel,
				   ARG1 #arg,
				   CFROM #cfrom, CTO #cto ] !>,
			  HCONS <! qeq,
                                   qeq &
				    [ HARG #arg,
				      LARG #chand ] !>,
			  ICONS <! !> ] ] ].

; 09-09-97  Added ARG0 and BODY attributes temporarily for VM2, since the
; whq external relation for how_about is like a quantifier, needing four args.
; Had to change the relation introduced by "how about" to '_which_q_rel'
; rather than '_how_about_rel' because of some property of vitADT.  Similar
; change made to the 'frag-msg' instance in syntax.tdl.
; 06-Oct-98 DPF - Changed MC value from na to +, to allow "okay, how about kim"
; DPF 25-sept-04 - Changed SUBJ, SPR, and MOD from < > to < anti_synsem_min > 
; so these can conjoin with ordinary clauses.
; DPF 18-aug-08 - But SPR for clauses is now empty, so change here.
; DPF 25-jun-09 - Added LEX - to prevent these from appearing as e.g. head
; in n-nh_vorj-cpd_c, and added PRD - to prevent them in pred coord like
; "why Kim and happy"
;; DPF 2016-11-07 - Generalized MC + to MC bool in order to admit
;; *Kim quipped, "how about Browne"* where we maybe don't want to relax all
;; of these verbs of saying to take MC + clauses.
;;
basic_how_about_word := word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < anti_synsem_min >,
                                  MINORS.MIN how+about_r_rel,
                                  VFORM fin,
                                  AUX -,
				  INV -,
				  PRD -,
                                  TAM.TENSE real_tense ],
                           VAL [ SUBJ < anti_synsem_min >,
                                 SPR < > ],
                           MC bool,
                           HC-LEX - ],
                     CONT [ HOOK.LTOP #rhand,
                            RELS.LIST < event_relation &
                                        [ PRED generic_verb_rel,
                                          LBL #arghand,
					  CFROM #from,
					  CTO #to  ],
                                        relation & #keyrel &
                                        [ LBL #rhand,
                                          ARG0.SF prop-or-ques,
                                          ARG1 #arg,
					  CFROM #from,
					  CTO #to  ], ... >,
                            HCONS <! qeq &
                                     [ HARG #arg,
                                       LARG #arghand ] !>,
			    ICONS <! !> ],
                     CONJ cnil ],
             NONLOC non-local_none,
	     LEX -,
             LKEYS.KEYREL norm_adj_relation & #keyrel,
             PUNCT no_punctuation_min ] ].

how_about_word := basic_how_about_word & root_marker_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD indicative,
                         VAL.COMPS < [ --MIN independent_rel,
                                       LOCAL [ CAT.VAL [ SPR *olist*,
                                                         COMPS < > ],
                                               CTXT #ctxt ],
                                       PUNCT.RPUNCT.PSF #pred ] > ],
                   CONT.HOOK.INDEX.SF #pred,
                   CTXT #ctxt ] ].

; DPF 12-Apr-03 - Constrained COMPS..VAL.COMPS to be < > to avoid spurious
; ambiguity due to application of hdn_optcmp_c rule (e.g. "how about sometime").
;; DPF 2011-05-29 - Constrained COMPS..VAL.SUBJ to be empty, to exclude NPs
;; derived from sentences, as in "why is the sky blue? Malia asked."
;;
comp_how_about_n_or_p_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD n_or_p,
                                                   VAL [ SUBJ < >,
							 COMPS < > ] ] ] ] >,
                   CONT [ HOOK.INDEX #event & event,
                          RELS.LIST < relation, 
                                      [ ARG0 #event ], ... > ] ] ].

;; DPF 2016-05-02 - Restrict complement to [PRD +] to exclude subordinate
;; clauses, including *why you strict?*
;; DPF 2016-08-07 - Re 2016-05-02: But this also blocks *how about two to 
;; three*
;; so let's draw the distinction instead using SUBJ *synnull* since subord adv
;; phrases are SUBJ *anti_null*.
;; DPF 2018-08-01 - Re 2016-08-07: No longer always the case, so let's use
;; AUX - to exclude subord phrases.
;;
; how about
x_xp_howabt-n-p_le := comp_how_about_n_or_p_lexent &
"""
WH-about, NP or PP comp          
<ex>How about rice?
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD.AUX -,
					     CONT.HOOK [ LTOP #ltop,
							 INDEX #ind ] ],
				     OPT - ] >,
                   CONT [ HOOK.LTOP #ltop,
			  RELS <! relation, [ ARG2 #ind ]  !> ] ] ].

; how long before the end?  how long before kim arrives?
x_pp_howabt_le := comp_how_about_n_or_p_lexent &
"""
WH-about, only 'how long'        
<ex>How long before C arrives?
"""
  [ SYNSEM.LOCAL 
     [ CAT.VAL.COMPS < [ LOCAL [ CAT.HEAD prep &
                                  [ MOD < [ LOCAL scopal_mod &
                                                  [ CONT.HOOK.LTOP #mtop ] ]>],
                                 CONT.HOOK.LTOP #ltop ],
                         OPT - ] >,
       CONT.RELS <! relation, 
                  [ ARG2 #ltop,
		    CFROM #cfrom, CTO #cto ],
                  event_relation &
                  [ PRED generic_verb_rel,
                    LBL #mtop,
		    CFROM #cfrom, CTO #cto ] !> ] ].

x_cp_howabt_le := how_about_word &
"""
WH-about, CP comp                
<ex>How about we leave now?
"""
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD #mood,
                         VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                          [ TAM.MOOD #mood ],
                                                     MC + ],
                                               CONT.HOOK.LTOP #ltop ],
                                       OPT - ] > ],
                   CONT [ HOOK.INDEX #event,
                          RELS <! relation & [ ARG1 #ltop ],
                                 [ ARG0 #event ] !> ] ] ].

; DPF 25-Nov-01 - Removed INDEX..TENSE no_tense since root_strict requires
; real_tense.
comp_how_about_or_why_vp_lexent := how_about_word &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM.MOOD #mood,
                         VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                          [ TAM.MOOD #mood ],
                                                     VAL.SUBJ < synsem > ],
                                             CONT.HOOK [ LTOP #cltop,
                                                         INDEX.SF prop-or-comm ] ],
                                     OPT - ] > ],
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation & [ ARG1 #cltop ], 
                                 [ ARG0 #ind ] !> ] ] ].

; DPF 17-Apr-01 - Changed COMPS.FIRST..SUBJ from canonical_synsem to synsem
; since the former blocked "Why be late"

x_vp_howabt_le := comp_how_about_or_why_vp_lexent &
"""
WH-about, VP comp                
<ex>How about leaving now?
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM prp ] > ].

x_vp_why_le := comp_how_about_or_why_vp_lexent &
"""
WH-about, only 'why', VP comp    
<ex>Why leave now?
"""
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VFORM bse_only ] > ].

x_-_why_le := basic_how_about_word &
"""
WH-about, no comps               
<ex>Why?
"""
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < >,
                   CONT [ HOOK.INDEX #ind & event,
                          RELS <! relation, 
                                [ ARG0 #ind ] !> ] ] ].

; Discourse-related sentential adverbs
;   (e.g. 'then, but')
; DPF 06-Oct-98 - Added MC + to MOD, to block "Kim says but sandy left"
; DPF 15-Oct-98 - Changed HEAD from adv to root-marker, to get "yes, okay"
; DPF 22-Oct-98 - Added MC + to the SYNSEM itself to block the relative clause
;   in "a programmer but he hired".
; DPF 09-Jun-99 - Added SLASH 0-dlist to MOD, to block e.g. "when yes Kim left"
; DPF 03-Oct-99 - Added SUBJ *olist* to MOD specific. - why wasn't it here 
; before?
; DPF 17-Apr-00 - Removed CONJ cnil to enable e.g. "yes and Kim left"
; DPF 22-Nov-01 - We have to make sure that disc_adv_words propagate the MC 
; feature of their modifiee, to block e.g. yes-no parse for "I would like to 
; arrive"
;; DPF 2012-08-09 - Added SPR *olist* to prevent spurious attachment of 
;; `like' adverbs to both N-bar and NP, as in *Kim though though arose.*
;; DPF 2016-09-15 - Re 2012-08-09 - But we do (for now, at least) want to
;; allow some subtypes to attach to N-bar, such as *or so* of *ten feet or so*
;; in order to get *[75% or more] reliable*.  So push this down to subtypes.

basic_disc_adv_synsem := synsem &
  [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT.MC #mc ] > ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < >,
			SPCMPS < > ],
                  MC #mc ],
	    CONJ cnil ],
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ] ].

disc_adv_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD root-marker &
		       [ PRD -,
			 MOD < [ LOCAL scopal_mod &
                                   [ CAT [ HEAD disc_adverbee &
                                              [ TAM.TENSE real_tense ],
                                           VAL [ SUBJ *olist*,
                                                 SPR *olist*,
                                                 COMPS < >,
                                                 SPEC < > ] ] ],
                                 NONLOC.SLASH 0-dlist ] > ] ] ] ].

;; DPF 2015-03-16 - Removed MOD..SLASH 0-dlist in order to allow
;; *Today, Kim, we will arise*
disc_adv_phr_synsem := basic_disc_adv_synsem & phr_synsem &
  [ LOCAL.CAT.HEAD adv &
                   [ MOD < [ LOCAL scopal_mod &
				   [ CAT.VAL [ SPR *olist*,
					       COMPS < > ] ] ] > ] ].

;; DPF 24-Oct-98 Removed [MC +] from disc_adv_word, since this runs afoul of
;; the carefully balanced constraint on head-modifier structures which requires
;; [MC na], to allow relative clauses as modifiers while preventing ordinary
;; finite clauses from being modifiers.

disc_adv_word := non-qr-h-nab &
  [ SYNSEM disc_adv_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.MIN abstr_excl_rel,
		     CONJ cnil,
                     CONT [ HOOK [ LTOP #chand & handle,
                                   INDEX #cind ],
			    RELS.LIST < #keyrel,
                                        [ LBL #chand,
                                          PRED discourse_rel,
                                          ARG0 #cind ], ... >,
                            HCONS <! !>,
			    ICONS <! !> ] ],
	     PUNCT [ LPUNCT no_punct,
		     RPUNCT comma_or_clause_or_no_punct ],
             LKEYS.KEYREL #keyrel & [ PRED abstr_excl_rel ] ] ].

adv_disc_preh_lexent := disc_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ POSTHD -,
			   HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #mltop ] > ],
		     CONT.RELS <! [ LBL #khand ],
			      #altkeyrel &
                              [ ARG1 #khand,
                                ARG2 #mltop ] !> ],
	     PUNCT [ RPUNCT no_punct,
		     PNCTPR ppair ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

av_-_dc-pr_le := adv_disc_preh_lexent &
"""
Disc adv, pre-hd                 
<ex>Folks, B won.
"""
  [ SYNSEM.LKEYS.KEYREL.PRED excl_rel ].

av_-_dc-grt-pr_le := adv_disc_preh_lexent &
"""
Disc, greeting, pre-hd           
<ex>Hello, B is here.
"""
  [ SYNSEM [ LKEYS.KEYREL.PRED greet_rel,
             MODIFD.LPERIPH + ] ].

; DPF 18-aug-07 - Constrain the modifiee to be comma-marked, to avoid
; spurious ambiguity for e.g. "The goal brought more cheers."
;; DPF 29-sept-11 - Move this down to more specific subtype, so we can still
;; admit *I'm taking off bye-bye*
;; DPF 18-04-30 - We now make main-clause declaratives be POSTHD +, so remove
;; MOD..POSTHD - here.

adv_disc_posth_lexent := disc_adv_word &
  [ SYNSEM [ LOCAL [ CAT [ POSTHD +,
			   HEAD.MOD < [ LOCAL [ CONT.HOOK.LTOP #mltop ] ] > ],
		     CONT.RELS <! [ LBL #khand ],
				#altkeyrel &
                                [ ARG1 #mltop,
				  ARG2 #khand ] !> ],
	     LKEYS.ALTKEYREL #altkeyrel ] ].

av_-_dc-po_le := adv_disc_posth_lexent &
"""
Disc, post-hd                    
<ex>B won, folks.
"""
  [ SYNSEM [ LKEYS.KEYREL.PRED excl_rel,
	     PUNCT [ RPUNCT no_punct,
		     PNCTPR ppair ] ] ].

av_-_dc-po-cma_le := adv_disc_posth_lexent &
"""
Disc, post-hd, head must be comma-marked.                    
<ex>B won, cheers!
"""
  [ SYNSEM [ LKEYS.KEYREL.PRED excl_rel,
	     LOCAL.CAT.HEAD.MOD < [ PUNCT.RPUNCT comma_or_no_punct ] >,
	     PUNCT.RPUNCT comma_or_clause ] ].

av_-_dc-grt-po_le := adv_disc_posth_lexent &
"""
Disc, greeting, post-hd          
<ex>We're leaving, bye.
"""
  [ SYNSEM.LKEYS.KEYREL.PRED greet_rel ].

; This is like really necessary
disc_adv_like_synsem := basic_disc_adv_synsem & lex_synsem &
  [ LOCAL [ CAT.HEAD root-marker &
                     [ PRD -,
                       MOD < [ LOCAL scopal_mod &
                                     [ CAT.HEAD subst,
                                       CONT.HOOK #hook ] ] >,
                       MINORS.MIN abstr_excl_rel ],
            CONT [ HOOK #hook,
                   RELS <! !>,
                   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL.PRED abstr_excl_rel ].

basic_adv_disc_like_lexent := noncqr-h-nab &
  [ SYNSEM disc_adv_like_synsem &
           [ LOCAL.CONT.HOOK [ LTOP #ltop,
			       INDEX basic_non_expl ],
             LKEYS.KEYREL [ LBL #ltop,
                            PRED excl_rel ] ] ].

adv_disc_like_lexent := basic_adv_disc_like_lexent &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR *olist* ] > ].

;; DPF 2012-10-23 - Generlized LPERIPH from na to na_or_+ in order to also
;; get *Kim, that is, the hero, arrived*

av_-_dc-like-pr_le := adv_disc_like_lexent &
"""
Disc, 'like'-type, pre-hd        
<ex>B found like the best cat.
"""
 [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.COMPS < >,
				     NONLOC.SLASH 0-dlist ] >,
			POSTHD - ],
	    MODIFD.LPERIPH na_or_+ ] ].

av_-_dc-like-unk_le := adv_disc_like_lexent &
"""
Disc adv, generic, matches "UH" PTB tag
<ex>B found like the best cat.
<native> av_-_dc-like-pr_le
"""
 [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.COMPS < >,
				     NONLOC.SLASH 0-dlist ] >,
			POSTHD - ],
	    MODIFD.LPERIPH na_or_+,
	    PHON.ONSET unk_onset ] ].

av_-_dc-like-phr_le := adv_disc_like_lexent &
"""
Disc, 'like'-type, pre-hd, not main clause mod.
<ex>B found like the best cat.
"""
 [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ VAL.COMPS < >,
						 MC na_or_- ],
				     NONLOC.SLASH 0-dlist ] >,
			POSTHD - ],
	    MODIFD.LPERIPH na ] ].

av_-_dc-spch-pr_le := noncqr-h-nab &
"""
Only *\*delete\** token found in some speech lattices
"""
 [ SYNSEM synsem &
	  [ LOCAL [ CAT [ HEAD no_head &
			       [ MOD < [ LOCAL scopal_mod &
					       [ CAT [ HEAD verb_or_frag,
						       VAL [ SUBJ *olist*,
							     SPR *olist*,
							     COMPS < >,
							     SPEC < > ],
						       MC #mc ],
						 CONT.HOOK #hook ],
					 NONLOC.SLASH 0-dlist ] >,
				 MINORS.MIN no_rel ],
			  VAL [ SUBJ < >,
				SPR < >,
				COMPS < > ],
			  MC #mc ],
		    CONJ cnil,
		    CONT [ HOOK #hook,
			   RELS <! !>,
			   HCONS <! !>,
			   ICONS <! !> ] ],
	    LEX -,
	    MODIFD.LPERIPH na_or_+,
	    NONLOC [ SLASH 0-dlist,
		     REL 0-dlist,
		     QUE 0-dlist ] ] ].

; 'i think'
av_-_dc-like-po_le := adv_disc_like_lexent &
"""
Disc, 'like'-type, post-hd       
<ex>B sent C, I think, to D.
"""
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
		      POSTHD + ] ].

; 'though'
av_-_dc-like-po-pnct_le := adv_disc_like_lexent &
"""
Disc, 'like'-type, post-hd, must have comma-marked target
<ex>The cat, though, chased dogs.
<nex> We act as though Kim chased deals.
"""
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_punct ] >,
		      POSTHD + ] ].

; 'ten minutes or so'
av_-_dc-meas-po_le := basic_adv_disc_like_lexent &
"""
Disc, just 'or so'               
<ex>B fell ten feet or so.
"""
 [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ --MIN abstr_meas_nom_rel,
				   LOCAL.CAT.VAL.SPR.FIRST.OPT -,
                                   PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
                      POSTHD + ] ].

; Speech filler tokens like *delete*
;
speech_filler_synsem := basic_lex_synsem &
  [ LOCAL [ CAT [ HEAD spfill &
                       [ MINORS [ MIN never_unify_rel,
				  ALTMIN never_unify_rel ] ],
		  VAL [ SUBJ < >,
			SPR < >,
			COMPS < > ] ],
	    CONJ cnil,
            CONT [ RELS <! !>,
                   HCONS <! !>,
		   ICONS <! !> ] ],
    NONLOC [ SLASH 0-dlist,
             REL 0-dlist,
             QUE 0-dlist ],
    LKEYS.KEYREL.PRED no_rel ].

av_-_spfill_le := noncqr-h-nab &
"""
Another type for *\*delete\** token in speech lattice
"""
  [ SYNSEM speech_filler_synsem ].

; Tell me please if my account is closed
;; DPF 2018-10-14 - Removed MOD..SLASH 0-dlist, since we need this entry for
;; *during the performance, please smile* with extracted-adj.
;;
av_-_dc-pls_le := noncqr-h-nab &
"""
Disc, just 'please'              
<ex>Please leave.
"""
  [ SYNSEM basic_disc_adv_synsem &
	   [ LOCAL [ CAT [ HEAD adv &
                                [ MOD < [ LOCAL intersective_mod &
                                                [ CAT [ HEAD subst,
                                                        VAL [ SPR *olist*,
                                                              COMPS < >,
							      SUBJ *olist* ] ],
                                                  CONT.HOOK #hook ],
					  MODIFD notmod_or_rmod ] >,
                                  MINORS.MIN abstr_excl_rel ] ],
                     CONT [ HOOK #hook &
                                 [ LTOP #ltop,
                                   INDEX #ind ],
                            RELS <! #rel !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LEX +,
             LKEYS.KEYREL #rel & [ PRED polite_rel,
                                   LBL #ltop,
                                   ARG1 #ind ] ] ].

x_-_wh-the-hell_le := noncqr-h-nab &
"""
Emph, comp of WH-words           
<ex>Who the hell told you?
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD wh_adv &
                                [ MOD < >,
                                  MINORS.MIN wh_the_hell_rel ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ],
		     CONT [ HOOK.INDEX basic_non_expl,
			    RELS <! !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL.PRED wh_the_hell_rel,
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Temporal nouns
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Extend to COMPS of temporal nouns the hack blocking extraction of subjects of
; inverted auxiliaries, which exploits CASE value.
; Block N-N compound of "a two meeting" by stipulating that hour_words are
; PRD +, incompatible with requirement of compound rule.  In contrast, e.g.,
; day_of_week words are unmarked for PRD.
;
; Made CONT.HOOK.LTOP be the handle of the numbered_hour_rel rather than that 
; of the implicit def_implicit_q_rel, since hour_words can be modified, as in 
; "two o'clock on the sixteenth".  Since the PP unifies its LTOP handle with 
; the ; LTOP handle of the phrase it modifies, that handle can't be the handle
; of the quantifier, so must be that of the numbered_hour_rel.

; DPF (18-Oct-98) - Removed PRD + from hour_word, so it can combine with its
; minute or am-pm complements and still be a prenominal adjective, as in
; "a ten thirty am meeting"

; DPF (22-Dec-98) - SYNSEM is typed phr_synsem in order to block 
; "a two meeting" while admitting "a two o'clock meeting" - this works because
; "two o'clock" combines with "meeting" using the noun-noun compound rule, 
; which requires the left member to have SYNSEM of type lex_synsem.

; DPF 13-May-01 - Added [RPERIPH +] to prevent hour words from being modified
; (especially by relative clauses), and therefore added optional prd-pp 
; complement to still get e.g. "three in the morning"
; DPF 9-Oct-02 - Can't have these be phr_synsem, since that prevents them from
; undergoing the (necessary) hdn_optcmp_c rule (which is constrained to lex_synsem
; dtrs in order to prevent spurious ambiguity from n-n-cmpnds).  So instead
; make it LEX - without commitment to the synsem type.
; DPF 27-Oct-02 - Changed HC-LEX from + to +* so we can get coordination of
; "two and two thirty".
; DPF 30-Apr-03 - Considered adding ALTMIN no_rel to prevent these from 
; appearing as left member of np-n compounds after getting a specifier, as in
; "*the at least two chairs", but this fails because the entry for 'from'
; as in "from ten to two" requires the first comp to have non-empty ALTMIN.
; So look for a more general reason to block the above.
; DPF 05-dec-03 - Added SPEC < anti_synsem_min > to prevent these from being 
; specifiers of the sp-hd_n_c rule; preferring instead the sp-hd_hc_c rule for "nine 
; to ten pm'.  Can't say SPEC < > since particle preps want NP complement
; which is SPEC < anti_synsem_min >.
;; DPF 2014-07-08 - These can't be stamped INFLECTD + because we also see
;; them as nonheads in compounds, as in *the six o'clock news*.  So change to
;; INFLECTD -, and count on the AGR..PN 3s to exclude plural inflection.
;; DPF 2015-05-18 - Added PRD + to prevent these as non-heads in N-N compounds,
;; now that INFLECTD no longer stops them.
;; DPF 2016-08-06 - Removed MODIFD notmod since this prevented the phrase
;; *ten to twelve* from undergoing npadv rule (because MODIFD value of spec-hd
;; phrase is identified with MODIFD value of left dtr, and npadv rule requires
;; dtr to have a MODIFD value of hasmod).  Let's see what happens.  FIX?
;; And RE 13-May-01: We do want *eleven in the morning* to be ordinary modif,
;; so instead add NORM no_rel to prevent modification by relative clauses.
;; DPF 2016-08-26 - Re 2015-05-18 - But we want *the ten thirty departure*,
;; and already have the LEX feature to prevent *the ten departure*, so remove
;; PRD constraint.
;;
basic_hour_synsem := count_noun_synsem &
  [ LOCAL 
      [ CAT [ HEAD noun & [ POSS -,
			    MINORS [ MIN numbered_hour_rel,
				     ALTMIN implicit_q_rel ],
			    MOD < > ],
	      VAL [ SUBJ < >,
		    SPR < [ --MIN just_only_deg_rel,
			    LOCAL [ CAT [ HEAD adv,
					  VAL [ SPR  *olist*,
						COMPS < >,
						SPEC < [ LOCAL.CAT.VAL.COMPS 
                                                                  < > ] > ] ],
				    CONT.HOOK [ LTOP #nhand,
						XARG #index ] ],
			    OPT + ] >,
		    SPEC < anti_synsem_min >,
		    KCMP synsem &
			 [ --MIN am_pm_rel,
			   LOCAL [ CAT.HEAD no_head,
				   CONJ cnil,
				   CONT.HOOK [ LTOP #nhand,
					       XARG #index ] ],
			   NONLOC.SLASH 0-dlist,
			   OPT +,
			   PUNCT.LPUNCT no_punct ] ],
	      HC-LEX +,
	      HS-LEX - ],
	CONT nom-obj & [ HOOK.INDEX.SORT time,
			 HCONS.LIST <  qeq &
				       [ HARG #rhand,
					 LARG #nhand ], ... >,
			 ICONS <! !> ],
	AGR #index,
	ARG-S < > ],
      NONLOC non-local_none,
      LKEYS [ ALTKEYREL [ LBL #nhand,
			  PRED basic_numbered_hour_rel,
			  ARG0 #index & [ PNG.PN 3s,
					  SORT time ] ],
	      ALT2KEYREL [ PRED def_implicit_q_rel,
			   ARG0 #index,
			   RSTR #rhand ] ] ].

;; DPF 2016-08-07 - These were INFLECTD na_or_-, but now that we used n-modif
;; to admit *eleven in the morning*, we would get spurious ambig since that
;; rule only constrains the dtr to INFLECTD na_or_+.  So change to INFLECTD -,
;; and see what the na was for.
;; DPF 2016-08-26 - Re 2016-08-07: The INFLECTD na would be necessary to let us
;; admit *the ten thirty departure* since the head-comp rule requires the head
;; to be na_or_+.  But since we now have a lexical rule applying to *ten* to
;; add the complement, we'll have the rule change INFLECTD, so we can continue
;; to avoid the above ambiguity.
;; 
abstr_hour_word := noncqrs-m & basic_noun_word &
  [ INFLECTD -,
    SYNSEM basic_hour_synsem ].

n_-_pn-hour_lexent := abstr_hour_word &
  [ SYNSEM [ LOCAL [ CAT.VAL [ COMPS < #kcmp >,
			       KCMP #kcmp ],
		     CONT [ HOOK.INDEX #ind,
			    RELS <! #altkeyrel & [ ARG0 #ind ],
				    #alt2keyrel !>,
			    HCONS <! qeq !> ] ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

n_-_pn-hour_le := n_-_pn-hour_lexent &
"""
Named hour of day                
<ex>B won at noon.
"""
  [ SYNSEM.LEX - ].

; sixish
n_-_pn-hour-apx_le := abstr_hour_word &
"""
Approximate named hour           
<ex>B won at eightish.
"""
  [ SYNSEM [ LOCAL [ CAT.VAL [ COMPS < #ampmcomp >,
			       KCMP #ampmcomp ],
		     CONT [ HOOK.INDEX #arg0,
			    RELS <! #altkeyrel &
				  [ LBL #hand,
				    ARG0 #arg0,
				    CFROM #cfrom, CTO #cto ],
				  #alt2keyrel,
				  [ LBL #hand,
				    PRED approx_grad_rel,
				    ARG1 #arg0,
				    CFROM #cfrom, CTO #cto ] !>,
			    HCONS <! qeq !> ] ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

n_-_pn-hour-gen_le := n_-_pn-hour_lexent & generic_ne_lex_entry
"""
Named hour, generic              
<ex>B arose at 6:00.
<native> n_-_pn-hour_le
"""
.

;; Since these appear in *three o'clock* where the *three* has already undergone
;; a lexical rule to add the minute_n_rel wrapped around the card_rel, these
;; should also only supply a card_rel.
;;
abstr_minute_word := np_word_no_aff &
  [ SYNSEM [ LOCAL [ CAT.HEAD intadj2 &
                              [ MINORS.MIN minute_rel,
                                PRD + ],
                     CONT [ HOOK [ LTOP #hand,
				   INDEX #index,
				   XARG #xarg ],
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     LKEYS.KEYREL [ LBL #hand,
                            PRED card_rel,
                            ARG0 #index,
			    ARG1 #xarg ],
	     MODIFD notmod ] ].


aj_-_i-mnt-pr_le := abstr_minute_word &
"""
Adj, named minutes, pre-hd       
<ex>It is half past three.
"""
  [ SYNSEM.LOCAL [ CAT.POSTHD -,
                   CONT.RELS <! relation !> ] ].


aj_-_i-mnt-po_le := abstr_minute_word &
"""
Adj, named minutes, post-hd      
<ex>It is three o'clock.
"""
  [ SYNSEM.LOCAL [ CAT.POSTHD +,
                   CONT.RELS <! relation !> ] ].

; am/pm, AD/BC
xp_suffix_lexent := np_word_no_aff &
  [ SYNSEM [ LOCAL [ CAT.HEAD no_head,
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #arg0 & ref-ind,
				   XARG #xarg ],
                            RELS <! [ LBL #ltop,
                                      ARG0 #arg0,
				      ARG1 #xarg ] !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL const_arg0_relation ] ].

xp_suffix_quant_lexent := np_word_no_aff &
  [ SYNSEM [ LOCAL [ CAT.HEAD no_head,
		     CONT [ HOOK [ LTOP #cpdtop,
				   INDEX #arg0 & ref-ind & [ PNG.PN 3s, IND + ],
				   XARG #xarg ],
			    RELS <! [ LBL #nhand,
				      ARG0 #arg0,
				      CFROM #cfrom, CTO #cto],
				  #altkeyrel &
				    [ PRED udef_q_rel,
				      ARG0 #arg0,
				      RSTR #rhand ],
				    prep_notense_relation &
				    [ LBL #cpdtop,
				      PRED compound_rel,
				      ARG1 #xarg,
				      ARG2 #arg0,
				      CFROM #cfrom, CTO #cto ] !>,
			    HCONS <! qeq & [ HARG #rhand,
					     LARG #nhand ] !>,
			    ICONS <! !> ] ],
	     LKEYS [ KEYREL const_arg0_relation,
		     ALTKEYREL #altkeyrel ] ] ].

x_-_am-pm_le := xp_suffix_lexent &
"""
Time expr, only 'am/pm'          
<ex>B arrived at ten pm.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN am_pm_rel ].

x_-_bc-ad_le := xp_suffix_quant_lexent &
"""
Time expr, only 'bc/ad'          
<ex>It was built in 500 A.D.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN bc_ad_rel ].

; DPF 01-dec-05 - Constrain these to only appear as complements of preps,
; to avoid spurious ambiguity with the ordinary noun of same spelling in
; each case.
; DPF 20-mar-06 - Also exclude these from modification by relative clauses,
; to avoid e.g. "*dinner that I had yesterday was late."

n_-_pn-mealtm_le := noncqrs-hm-nab & basic_noun_word &
"""
Mealtime noun                    
<ex>We met at breakfast.
"""
  [ SYNSEM noun_synsem &
	 [ LOCAL [ CAT [ HEAD [ POSS -,
                                MINORS [ MIN gen_hour_rel,
                                         ALTMIN #altmin,
                                         NORM mealtime_rel ],
				MOD < >,
                                CASE obliq ],
			 VAL [ SUBJ < >,
			       SPR < [ --MIN just_only_deg_rel,
                                       LOCAL [ CAT [ HEAD adv,
                                                     VAL [ SPR  *olist*,
							   COMPS < > ] ],
                                               CONT.HOOK [ LTOP #nhand,
                                                           XARG #index ] ],
                                       OPT + ] >,
			       COMPS < > ] ],
		   CONT nom-obj &
		       [ HOOK [ INDEX #index & [ SORT time ] ],
			 RELS <! #keyrel &
                               [ LBL #nhand,
                                 ARG0 #index ],
			       #altkeyrel &
                               [ PRED def_implicit_q_rel & #altmin,
                                 ARG0 #index,
                                 RSTR #rhand ] !>,
			 HCONS <! qeq &
			   [ HARG #rhand,
			     LARG #nhand ] !>,
			 ICONS <! !> ],
		   ARG-S < > ],
           LKEYS [ KEYREL #keyrel,
		   ALTKEYREL #altkeyrel ],
           MODIFD notmod ] ].

; DPF 16-Apr-03 - Finally added type for odd entries "October the" as in
; 'October the fifth'.  Duplicates much of what is in date_det_lr type, but
; not easy to see how to abstract (cf. HCONS for example).
;; DPF 2013-09-25 - Constrained SPEC to dofm_ord_rel, to block **April the two*
;; DPF 2019-10-11 - Replaced seemingly redundant defdate_q_rel with the_q_rel,
;; and similarly in lexrules.tdl's month_det_lr, so we get more consistency
;; in the MRSs for *February the fifth* and *the fifth of February*
;; DPF 2020-03-24 - Added sem link for SPEC XARG, and RELS as per trunk
;; DPF 2020-03-28 - Re 2019-10-11, restored defdate_q_rel, so we can get
;; *the September 11 event* where the NP-N compound rule constrains the NP's
;; ALTMIN, and we don't generally want "the"-NPs there.
;;
det_date_synsem := norm_det_synsem &
  [ LOCAL [ CAT [ HEAD [ POSS -,
                         MINORS.MIN defdate_q_rel ],
                  VAL [ COMPS < >,
                        SPEC < [ --MIN dofm_ord_rel,
				 LOCAL.CONT.HOOK.XARG #spind ] > ] ],
            CONT [ RELS <! #keyrel &
			   [ CFROM #from,
			     CTO #to ],
                           #altkeyrel,
                           [ PRED proper_q_rel,
                             ARG0 #spind,
                             RSTR #mhand,
			     CFROM #from,
			     CTO #to ] !>,
                   HCONS <! qeq,
                            qeq &
                            [ HARG #mhand,
                              LARG #mltop ] !>,
		   ICONS <! !> ] ],
    LKEYS [ KEYREL #keyrel,
            ALTKEYREL #altkeyrel & diadic_nom_relation &
		      [ LBL #mltop,
                        PRED mofy_rel,
                        ARG0 #spind & ref-ind ] ],
    NONLOC [ SLASH 0-dlist,
             QUE 0-dlist,
             REL 0-dlist ],
    MODIFD hasmod ].

d_-_month_le := que_word &
"""
Det, month plus 'the'            
<ex>October the tenth arrived.
"""
  [ SYNSEM det_date_synsem &
	     [ LOCAL.CAT.HEAD [ MINORS.ALTMIN mofy_rel,
				POSS - ] ] ].

;; DPF 2016-08-07 - This type seems to be necessary for non-head of compounds
;; as in *my Monday the tenth appointment*, but we don't want the spurious
;; ambiguity under normal conditions, as in *Monday the tenth is good*.  So
;; let's constrain the spec nominal to be [CASE no_case].
;;
d_-_dow_le := abstr_det_word &
"""
Det, day-of-week plus 'the'            
<ex>This Friday the 13th party began.
"""
  [ SYNSEM det_date_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.ALTMIN dofw_rel,
			 VAL.SPEC.FIRST.LOCAL.CAT.HEAD.CASE no_case ] ] ].

common_noun_nomod_comp_synsem := basic_count_noun_synsem & 
                                 nonpro_nomod_synsem & two_arg.

; DPF 22-May-01 Added LPERIPH + constraint to block these from beings heads of
; n-n compounds.
; DPF 24-mar-06 For now, require SPR to be unexpressed, to avoid generating
; '*Kim arrived in the 1997.'  So we lose e.g. 'I imagine that your 1997
; was more enjoyable.'  In general, want to avoid 'the' as spr of unadorned
; proper names.  FIX ...
; DPF 28-jun-07 - Added REL 0-dlist.
; DPF 2010-09-17 - Removed the recently added ALTMIN meas_nom_rel, since it
; blocks "the 2010 yearbook".  Not sure what it was intended to do...
;; DPF 2020-04-29 - Generalize LPERIPH from + to bool, so can still get
;; *fiscal 1989*
;; DPF 2020-05-16 - With the changes to measure-NPs, add CASE real_case here
;; to prevent these from undergoing np_adv-mnp rule.
;;
n_-_pn-yoc_lexent := basic_word &
  [ SYNSEM temp_noun_comp_two_arg_synsem &
   [ LOCAL [ CAT [ HEAD [ MOD < >,
                          MINORS [ MIN yofc_rel,
				   ALTMIN proper_q_rel,
                                   NORM norm_rel ],
			  CASE real_case ],
                   VAL [ SPR.FIRST unexpressed &
				   [ --MIN abstract_q_rel,
				     LOCAL.CAT.HEAD det,
				     NONLOC.QUE #que ],
                         COMPS < [ --MIN bc_ad_rel,
                                   LOCAL [ CAT.HEAD no_head,
                                           CONJ cnil,
                                           CONT.HOOK [ LTOP #nhand,
						       XARG #ind ] ],
                                   NONLOC.SLASH 0-dlist,
                                   OPT + ] > ],
		   HC-LEX -,
		   MC na ],
             AGR [ DIV -,
                   PNG.PN 3s ],
             CONJ cnil,
             CONT [ HOOK [ LTOP #nhand,
                           INDEX #ind & [ PNG png & [ PN 3s ] ] ],
                    RELS <! relation !>,
                    HCONS <! !>,
		    ICONS <! !> ] ],
     NONLOC [ QUE #que,
              SLASH 0-dlist,
              REL 0-dlist ],
     PUNCT [ LPUNCT no_punct,
	     RPUNCT no_punct ],
     LKEYS [ KEYREL [ PRED yofc_rel,
                      LBL #nhand ],
             ALTKEYREL.PRED abstract_q_rel ],
     MODIFD notmod & [ LPERIPH bool ] ] ].

n_-_pn-yoc-gen_le := n_-_pn-yoc_lexent &
"""
Named year of century - generic  
<ex>B won in generic-year.
"""
  [ INFLECTD -,
    TOKENS.+LIST < [ +TNT null_tnt,
		     +CARG #carg ] >,
    SYNSEM [ LKEYS.KEYREL const_arg0_relation & [ CARG #carg ] ] ].

; 'the first', 'October first', 'the first of October'
; Need to find way to block '*October first of October'
; DPF 20-Nov-99 - Added PRD + to block membership in N-N-compounds
; DPF 23-Oct-03 - Instead of PRD +, (which is now not consistent with making
; all non-measure NPs [PRD -]), use ALTMIN no_rel to block ordinals as 
; heads of n-n-compounds.
; DPF 25-aug-04 - Try adding LPERIPH - to prevent these from appearing as
; heads of n-n-compounds.  Can't be LPERIPH + since 'May 23 to 25' uses 'to'
; which requires complement to be LPERIPH na_or_- (for reasons no longer 
; clear).
; DPF 24-sept-04 - But LPERIPH - prevents application of np_adv_c rule, as in
; 'we arrived the tenth', and anyway that LPERIPH constraint for 'to' is no
; longer used, so we make these LPERIPH +.
; DPF 26-jun-10 - Removed NORM never_unify_rel since we want *June 24 event*
;; DPF 2015-05-06 - We want to analyze *the December 6, 2004, event* with the
;; NP-N compound rule, yet we don't want to generally allow post-head-modified
;; NPs as non-hds in this rule, so we can't treat the year in *December 6, 2004*
;; as a modifier.  Hence it must be an optional complement of the dom.  Because
;; of our analysis of *6 December 2004* as head-initial, we also make use of
;; a KCMP2 feature here, to get the desired generality of US and Euro dates.
;; DPF 2020-03-24 - Added XARG binding as per trunk.
;;
generic_dom_synsem := basic_noun_synsem & lex_synsem &
  [ LOCAL 
    [ CAT 
      [ HEAD.MINORS [ MIN dofm_rel,
		      ALTMIN #spmin ],
	VAL [ SPR.FIRST #spr & synsem &
		    [ --MIN #spmin & quant_rel,
		      LOCAL.CAT [ HEAD det,
				  VAL [ SUBJ < >,
					SPR *olist*,
					SPEC < [ LOCAL.CONT.HOOK.LTOP #hand]>]],
		      LEX + ],
	      COMPS #comps,
	      SPEC < anti_synsem_min >,
	      KCMP2 [ --MIN yofc_rel,
		      LOCAL [ CAT nomp_cat_acc_min,
			      CONT.HOOK.INDEX #cindex ] ] ] ],
      AGR #agr,
      CONT [ HOOK [ INDEX #agr,
		    XARG #cindex ],
	     RELS.LIST < generic_named_nom_relation &
			 [ LBL #hand,
			   PRED dofm_rel,
			   ARG0.PNG png & [ PN 3s,
					    GEN neut ],
			   ARG1 #cindex ], ... > ],
      ARG-S < #spr . #comps > ] ].

;; DPF 2014-03-26 - To still get generic-proper "First" as in "First Boston",
;; HEAD cannot be `noun', so to block bare-npq rule for "first", make 
;; SPR.FIRST be expressed_synsem, and to block bare-npq rule for 
;; "October first", make second SPR synsem be OPT +.
;; DPF 2014-04-02 - Re 2014-03-26: But if SPR.FIRST is expressed, then cannot
;; admit "(May) 23 to 25" since here the "23" does not have an overt specifier.
;; So let's try setting RPERIPH -, since these should not be post-modified,
;; unlike the inputs to the bare-npq rule.
;; DPF 2015-05-04 - Re 2014-04-02: But we really don't want these as stand-alone
;; NPs (too much spurious ambiguity), and anyway we now parse *May 23-25* with
;; *23-25* as an interval, the way we should, so let's go back to expressed SPR.
;; DPF 2015-05-12 - Re 2015-05-04: SPR cannot be expressed, because we want to
;; admit *25 - 30* via the sp-hd_hc_c rule, which constrains its left dtr to 
;; be *unexplist*.  Happily, even without this constraint, these guys do not
;; undergo the plural/mass bare-NP rule because they are DIV -, and not the
;; bare-NP num rule because their MIN value is incompatible.
;; DPF 2016-08-06 - Added SPR expressed_synsem to avoid 
;; *eleventh in the morning* from becoming bare-NP, even though its HEAD value
;; is partn.
;;
basic_dom_synsem := generic_dom_synsem & count_noun_synsem &
  [ LOCAL [ CAT [ HEAD partn & [ MOD < > ],
		  VAL [ SPR < expressed_synsem &
			      [ --MIN abstract_q_rel,
				LOCAL.AGR.PNG.PN 3s,
				OPT - ],
			      [ OPT + ] >,
			COMPS < #kcmp2 >,
			KCMP2 #kcmp2 ] ],
	    CONT.HOOK.INDEX.DIV - ],
    MODIFD hasmod & [ LPERIPH +,
		      RPERIPH - ] ].

basic_dom_ord_synsem := basic_dom_synsem &
  [ LOCAL.CAT [ HEAD.MINORS [ MIN dofm_ord_rel,
			      ALTMIN basic_def_explicit_q_rel ],
                VAL.SPR < synsem &
			  [ --MIN def_q_rel,
			    LOCAL.CAT.HEAD.POSS - ],
			  anti_synsem_min > ] ].

;; DPF 2013-06-13 - The OPT - on the second (anti_synsem) SPR prevents these
;; from serving as nominal adverbials, as in *We arrived May ten*.  So remove,
;; and be reminded of what that constraint was doing for us.  Same for
;; dom_card_synsem below
;;
dom_ord_synsem := basic_dom_ord_synsem & nonpro_nomod_synsem & two_arg &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel, 
                  VAL [ SUBJ < >,
                        SPR.FIRST expressed_synsem,
                        SPEC < anti_synsem_min > ] ],
            CONT [ HOOK.INDEX.SORT time,
                   RELS <! relation !> ] ] ].

; DPF 31-May-02 - Changed SPR..MIN from implicit_q_rel to def_q_rel, 
; to make sure these dom's don't undergo the robust bare_pl_sg rule.
basic_dom_card_synsem := basic_dom_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN dofm_card_rel,
		VAL.SPR.FIRST.LOCAL.CAT.HEAD.MINORS [ MIN def_q_rel,
						      ALTMIN mofy_rel ] ],
    LKEYS.ALTKEYREL relation ].

dom_card_synsem := basic_dom_card_synsem & nonpro_nomod_synsem & two_arg &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN temp_abstr_rel,
                  VAL [ SUBJ < >,
                        SPR < [ OPT - ], anti_synsem_min >,
                        SPEC < anti_synsem_min > ] ],
            CONT [ HOOK.INDEX.SORT time,
                   RELS <! relation !> ] ] ].

;; 12 october (2003)
;; DPF 2020-03-23 - Changed MOD notmod to hasmod, so we can get
;; *They arrived 12-feb-20*
;;
dom_euro_synsem := generic_dom_synsem & abstr_noun_npcomp_synsem &
                   basic_mass_or_count_synsem &
  [ LOCAL [ CAT [ HEAD noun & [ MOD < > ],
		  VAL [ SPR.FIRST unexpressed &
				  [ --MIN udef_q_rel ],
			COMPS < #keycomp & expressed_synsem &
				[ --MIN mofy_rel,
				  LOCAL [ CONT.HOOK.LTOP #ltop,
					  CONJ cnil ],
				  OPT -,
				  PUNCT.LPUNCT hyphen_sgl_or_no_punct ],
				#keycomp2 >,
			KCMP #keycomp,
			KCMP2 #keycomp2 ] ],
            CONT.HOOK [ LTOP #ltop,
			INDEX [ PNG png & [ PN 3s ],
				DIV +,
				IND - ] ] ],
    LKEYS.KEYREL.LBL #ltop,
    MODIFD hasmod ].

abstr_n_day_of_month_lexent := noun_hclex_word &
  [ INFLECTD -,
    SYNSEM generic_dom_synsem &
           [ LOCAL.AGR.PNG.PN 3s ] ].

n_-_pn-dom-ord_le := abstr_n_day_of_month_lexent &
"""
Named day of month - ordinal     
<ex>B won on the tenth.
"""
  [ SYNSEM dom_ord_synsem ].

n_-_pn-dom-card_le := abstr_n_day_of_month_lexent &
"""
Named day of month - cardinal    
<ex>B won on June 10.
"""
  [ SYNSEM dom_card_synsem ].

n_-_pn-dom-euro_le := abstr_n_day_of_month_lexent &
"""
Nmd day of month - europe - pre  
<ex>B won on 10 June.
"""
  [ SYNSEM dom_euro_synsem ].

n_-_pn-dom-gen_le := abstr_n_day_of_month_lexent & generic_ne_lex_entry &
"""
Named day of month - generic     
<ex>B won on generic-dom.
<native> n_-_pn-dom-card_le
"""
  [ SYNSEM dom_card_synsem ].

n_-_pn-dom-o-gen_le := abstr_n_day_of_month_lexent & generic_ne_lex_entry &
"""
Named day of month, ordinal - generic     
<ex>B won on the generic-dom.
<native> n_-_pn-dom-ord_le
"""
  [ SYNSEM dom_ord_synsem &
	   [ PHON.ONSET unk_onset ] ].

; 'Tuesday (the first (of October))', 'Tuesday (October first)'
; 'Tuesday of that week'
; DPF 31-Jul-99 - Made SYNSEM be nonpro_nomod_onearg_synsem instead of 
; nomod_basic_onearg_synsem since they can appear in noun-noun compounds,
; and also in appositive constructions.

n_-_pn-dom-e-gen_le := abstr_n_day_of_month_lexent & generic_ne_lex_entry &
"""
Nmd day of month - europe - generic
<ex>B won on 10 June.
<native> n_-_pn-dom-euro_le
"""
  [ SYNSEM dom_euro_synsem ].

; 'morning' of 'each morning', 'Tuesday morning'
; DPF 19-Oct-02 - Broke this up into two entries, one with empty COMPS
; that excludes "the" to block "I arrived the morning"; and the other with
; PP-of to allow "I arrived the morning of the fifth."
; DPF 23-Apr-03 - Moved MODIFD from basic_n_day_part_lexent to the nocomp
; subtype, to continue to block "*I arrived the morning" (where the temp_np
; rule requires the dtr to be [MODIFD hasmod], and where the determiner "the"
; passes up the MODIFD value of its SPEC) while allowing "I arrived the
; morning of the third" where this pp-comp 'morning' is unmarked for MODIFD.
; DPF 26-Apr-03 - Note that this awkward machinery for three entries (at least)
; for day-part words like "morning" will have to be generalized, since the same
; constraints hold for a few non-temporal nouns like "way" as in 
; 'Kim sang the way you did'  and 'Kim sings that way' but '*Kim sang the way'.
; Also "time" as in "I fell the time he was here" but "*I fell the time".
;; DPF 2017-09-29 - Added [SORT time] consistent with other temporal nouns.
;;
basic_n_day_part_lexent := noncqrs-hm & basic_noun_word &
  [ INFLECTD -,
    SYNSEM lex_synsem &
           [ LOCAL [ CAT [ HEAD noun &
                                [ MINORS.MIN day_part_rel ],
                          VAL.SPR < synsem &
                                     [ --MIN abstract_q_rel,
                                       LOCAL
					  [ CAT [ HEAD det,
                                                  VAL [ SUBJ < >,
							COMPS < > ] ] ],
                                       --SIND #ind,
                                       OPT - ] > ],
                     AGR #ind,
                     CONT [ HOOK [ LTOP #ltop,
                                   INDEX #ind & [ SORT time ] ],
			    RELS <! #keyrel & [ LBL #ltop ] !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             LKEYS.KEYREL #keyrel &
                   [ LBL #ltop,
                     ARG0 #ind ] ] ].

onearg_count_n_synsem := nonpro_nomod_onearg_synsem & count_noun_synsem.
twoarg_count_n_synsem := noun_two_arg_nomod_synsem & count_noun_synsem.

n_-_c-dpt_lexent := basic_n_day_part_lexent &
"""
Icn, part of day                 
<ex>B won on Friday afternoon.
"""
  [ SYNSEM onearg_count_n_synsem &
	   [ LOCAL [ ARG-S < #spr >,
                     CAT.VAL [ SPR < #spr &
                                    [ LOCAL.CAT.HEAD.MINORS.ALTMIN 
                                                    dofw_or_poss_q_rel ] >,
                               COMPS < > ] ],
	     MODIFD notmod ] ].

n_-_c-dpt_le := n_-_c-dpt_lexent
"""
Icn, part of day                 
<ex>B won on Friday afternoon.
"""
.

n_-_c-dpt-cap_le := n_-_c-dpt_lexent
"""
Icn, part of day, capitalized
<ex>B won on Friday afternoons.
"""
.

n_day_part_ppcomp_lexent := basic_n_day_part_lexent &
  [ SYNSEM twoarg_count_n_synsem &
    [ LOCAL [ ARG-S < #spr . #comps >,
              CAT.VAL [ SPR < #spr >,
                        COMPS #comps &
                            < [ LOCAL [ CAT [ HEAD.MINORS.MIN _of_p_sel_rel,
					      VAL.COMPS < > ],
                                        CONT.HOOK [ LTOP #nhand,
                                                    INDEX #ind ] ],
                                NONLOC.SLASH 0-dlist,
                                OPT - ] > ],
              AGR [ DIV - ] ],
      LKEYS.KEYREL [ LBL #nhand,
		     ARG1 #ind ] ] ].

n_pp_c-dpt-sg-of_le := n_day_part_ppcomp_lexent &
"""
Cn, part-of day, sg, PP-of comp  
<ex>B won the night of the 2nd
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3s,
                                         GEN neut ] ].

n_pp_c-dpt-pl-of_le := n_day_part_ppcomp_lexent &
"""
Cn, part-of day, pl, PP-of comp  
<ex>Nights of May 10 and 11 do
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].

; 'Advent', 'summer', 'Christmas'
; DPF 20-jan-08 - Removed NORM norm_rel since this blocked e.g. "summer day"
; DPF 27-jan-08 - Remoevd LPERIPH na since this blocked "Paris summer day"
;; DPF 2020-05-16 - With the changes to measure-NPs, add CASE real_case here
;; to prevent these from undergoing np_adv-mnp rule.
;;
basic_n_-_m-ssn_lexent := basic_noun_word & nonc-hm &
  [ INFLECTD -,
    SYNSEM mass_noun_onearg_synsem &
           [ LOCAL [ CAT [ HEAD.CASE real_case,
			   VAL.SPR < unexpressed_reg > ],
                     CONT [ HOOK [ LTOP #ltop,
				   INDEX.PNG png & [ PN 3s ] ],
                            RELS <! nom_relation !> ] ],
             LKEYS.KEYREL.LBL #ltop ] ].

n_-_m-ssn_lexent := basic_n_-_m-ssn_lexent & noun_word &
  [ SYNSEM.MODIFD notmod ].

; 'winter, summer' - "in winter", "*at winter"
;; DPF 2020-05-08 - Considered blocking "in long winter" via LPERIPH +, but
;; we want *in late winter* and *in early spring*, so leave as is.  Also failed
;; for *many [summer dairies]*.
;;
n_-_m-ssn_le := n_-_m-ssn_lexent &
"""
Mass, season name                
<ex>B won in winter.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN season_rel,
             LKEYS.KEYREL.PRED season_rel ] ].

; 'Advent, Christmas' - "at Christmas"
;; DPF 2019-09-14 - Allow lexical blocking of premodif as in 
;; *celebrating Thanksgiving*

n_-_m-hldy_le := basic_n_-_m-ssn_lexent &
"""
Mass, holiday name               
<ex>B won at Christmas.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN holiday_rel,
	     LKEYS.KEYREL.PRED holiday_rel ] ].

; DPF 21-dec-05 - Removed MODIFD.LPERIPH na, since it prevented e.g.
; NP-N-N compound 'Avdalen summer farm'
; DPF 29-jun-07 - But now getting 'summer farm' via making 'summer' a
; bare meas-NP, so add NORM norm_rel to prevent spurious N-N-cmpnd.
;; DPF 2017-10-04 - Note that the name is misleading, since we can also get
;; *a good Christmas*, as count noun.
;; DPF 2020-04-24 - To get *summer and winter routes*, remove NORM norm_rel,
;; noting that the problem of 29-jun-07 no longer surfaces.  But we don't
;; want *winter routes* to also use this entry for *winter*, so let's constrain
;; LOCAL to force inflection.
;; 
;;
n_-_m-ssn-spr_le := basic_basic_intr_noun_word &
"""
Mass or count, season w/ oblig specifier  
<ex>B won in the winter.
"""
  [ SYNSEM noun_nocomp_synsem &
           [ LOCAL sing_or_plur_noun &
		   [ CAT [ HEAD.MINORS [ MIN season_rel,
                                         ALTMIN abstract_q_rel ],
                           VAL.SPR < expressed_synsem > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

;; DPF 20-04-24 - Without rethinking the existing inventory of lexical types
;; for season and holiday nouns, just add a type to allow bare plurals, as in
;; *chilly winters began*
;;
n_-_c-ssn-pl_le := basic_basic_intr_noun_word &
"""
Mass or count, season w/ oblig specifier  
<ex>B won in the winter.
"""
  [ SYNSEM noun_nocomp_synsem &
           [ LOCAL plur_noun &
		   [ CAT [ HEAD.MINORS [ MIN season_rel,
                                         ALTMIN abstract_q_rel,
					 NORM norm_rel ],
                           VAL.SPR < unexpressed > ],
                     CONT [ RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ],
		     AGR.PNG.PN 3p ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

n_np_m-ssn_le := noun_word &
"""
Mass, season, NP comp (yoc)      
<ex>B won in winter 1993.
"""
  [ SYNSEM mass_noun_npcomp_synsem &
           [ LOCAL [ CAT [ HEAD.MINORS [ MIN season_rel,
                                         ALTMIN abstract_q_rel ],
                           VAL.COMPS < [ --MIN yofc_rel ] > ],
                     CONT.HOOK.INDEX.PNG png & [ PN 3s ] ],
             MODIFD notmod,
             LKEYS.KEYREL.PRED season_rel ] ].

; "the morning" etc.
; DPF 14-Oct-02 - Added ALTMIN relation to prevent these entries from 
; appearing as complements of "per", to avoid spurious ambiguity for e.g.
; "per night"
; DPF 15-Apr-03 - Removed strange constraint SPR..CONT.RELS <! relation !>,
; which blocked (among other things) "my mornings".  Instead, made
; SPR..MIN be def_explicit_q_rel to allow only "the" and possessive pronouns.
;; DPF 2011-12-14 - Removed LPERIPH na_or_-, since this blocked *we arrived 
;; the night before*.
;; DPF 2020-05-16 - Made SPR expressed_synsem to prevent spurious ambiguity for
;; *I am free afternoons*. Also considered generalizing SPR..MIN from 
;; basic_def_explicit_q_rel to def_or_demon_q_rel, to get *in those mornings*,
;; but that makes *this morning* ambiguous, so leave as is.
;;
n_def_day_part_lexent := noncqrs-hm-nab & basic_noun_word &
  [ SYNSEM nomod_onearg_synsem &
	   [ LOCAL [ ARG-S < #spr >,
		     CAT [ HEAD noun & [ MINORS [ MIN def_day_part_rel,
                                                  ALTMIN norm_rel ] ],
			   VAL 
			    [ SPR < expressed_synsem & #spr &
				  [ --MIN basic_def_explicit_q_rel,
                                    LOCAL.CAT [ HEAD det,
                                                VAL [ SUBJ < >,
                                                      COMPS < > ] ],
                                   --SIND #inst,
                                    OPT - ] >,
			      COMPS < >,
			      SPCMPS < > ],
                           POSTHD + ],
		     AGR #inst,
                     CONT [ HOOK [ LTOP #nhand,
                                   INDEX #inst & ref-ind ],
			    RELS <! #keyrel !> ] ],
             LKEYS [ KEYREL #keyrel &
                            [ LBL #nhand,
                              ARG0 #inst & [ SORT time ] ],
                     ALTKEYREL relation ],
             MODIFD notmod ] ].

n_-_c-dpt-df-sg_le := n_def_day_part_lexent &
"""
Day part, sg, def                
<ex>B enjoyed the evening.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0 [ PNG png & [ PN 3s,
                                           GEN neut ],
                               DIV - ] ].

n_-_c-dpt-df-pl_le := n_def_day_part_lexent &
"""
Day part, pl, def                
<ex>B spent the nights.
"""
  [ SYNSEM.LKEYS.KEYREL.ARG0.PNG png & [ PN 3p ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Degree specifiers for adjectives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 'very, really, much, a lot, almost';
; Treated as measure phrases, selected as specifiers by adjectives.

;; DPF 27-Aug-01 - Removed INDEX ref-ind constraint, which was blocking
;; e.g. "kim is just behind the door"
;; DPF 8-Sep-01 - Added MODIFD.LPERIPH na to make sure that "about two weeks"
;; has this value, to block its appearing as head in n_n_compounds.
;; DPF 25-Sep-01 - Block specification of conjoined phrase for now, since we
;; don't know what to do with the semantics anyway.
;; DPF 10-Apr-03 - Made HEAD simply adv rather than old adv_or_partn, since
;; no need to treat these phrases as noun-like - solves several problems,
;; including avoiding these appearing as complements of prepositions.
;; Can probably get rid of LPERIPH specification now - check later.
;; DPF 26-sept-04 - Moved [XARG individual_min] down to lex_degree_spec
;; subtype, in order to allow measure-NPs (with phr_degree_spec_synsem) to
;; appear in appositive constructions like "three meters (10')".  (Can't
;; remember what this constraint is meant to exclude, but it's probably useful)
;; DPF 8-oct-05 - Yes, that constraint helps to block the spurious use of
;; the nonhead-compos variant of the head-specifier rule to pick up 
;; degree-specifiers, as in "at least part of ..." (since the nonhead-compos
;; variant requires its XARG to be a handle).

basic_degree_spec_synsem := canonical_synsem &
  [ LOCAL [ CAT [ HEAD.MOD < >,
		  VAL [ SUBJ < >,
			SPR.FIRST [ --MIN degree_rel,
				    LOCAL [ CAT [ HEAD n_or_adv,
						  VAL [ SPR *olist*,
							SPEC < synsem > ] ],
					    CONT.HOOK [ LTOP #khand,
							XARG #spind ] ],
				    NONLOC.QUE 0-dlist ] ] ],
            CONT.RELS.LIST.FIRST [ LBL #khand,
                                   ARG0 #spind ] ] ].

; DPF 11-Feb-02 - Can't have this be POSTHD - (and why did we want it?), 
; since the spec-head rule takes the value of POSTHD from the head's spr
; value, which blocked "kim arrives really soon".
; DPF 25-May-03 - Need POSTHD of specifier to be that of its SPEC, to make
; sure that "maybe in Berlin" is still POSTHD +.
;; DPF 2011-09-23 - Added identity of SPEC..HS-LEX and SPEC..LEX, to preserve
;; LEX property of adjective (phrases), as in *probably easy to hire*, in order
;; to block **the probably easy to hire consultant*.  But note that this 
;; requires treating the degree-spec "how" differently, since we use this
;; mechanism to distinguish "how many cats" from "*the how tall cats".  So
;; push down to subtypes, and exclude "how", as well as "so", "too", etc.

basic_lex_degree_spec_synsem := basic_degree_spec_synsem & lex_synsem &
  [ LOCAL [ CAT [ HEAD adv,
                  VAL [ SPEC < [ LOCAL.CAT.POSTHD #ph ] >,
			SPR < synsem_min > ],
                  POSTHD #ph ],
            CONT [ HOOK [ INDEX #index,
                          XARG individual_min ],
                   RELS.LIST.FIRST #keyrel & [ ARG0 #index ] ] ],
    LKEYS.KEYREL #keyrel ].

lex_degree_spec_synsem := basic_lex_degree_spec_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN degree_rel,
		  VAL [ COMPS < >,
			SPEC < [ MODIFD #modif,
				 LOCAL.CAT.HS-LEX #hslex,
				 LEX #hslex ] > ] ],
            CONT [ HOOK [ LTOP #ltop,
                          INDEX.E [ TENSE no_tense,
                                    ASPECT no_aspect ],
                          XARG #xarg ],
                   RELS.LIST.FIRST [ LBL #ltop,
                                     ARG1 #xarg ] ] ],
    MODIFD #modif ].


; For measure_nps as in "two foot tall"
; DPF 4-Nov-02 - Removed [ LOCAL.CONT.HOOK.XARG nothing ], since now identify
; XARGs of modifier and modifiee.  Why was it added before?
;; DPF 2014-04-27 - This type wrongly required its SPEC..COMPS to be the empty 
;; list: need nonempty for *10% more cats than dogs*, so remove constraint,
;; and make SPCMPS empty.
;;
phr_degree_spec_synsem := basic_degree_spec_synsem & lex_phr_synsem &
  [ LOCAL [ CAT.VAL [ SPR.FIRST.--MIN just_only_very_deg_rel,
		      COMPS < >,
                      SPCMPS < > ],
            CONT [ HOOK.XARG #xarg,
                   RELS.LIST.FIRST.ARG1 #xarg ] ] ].

; For "as" of "as soon as possible" and "too" in "too good to miss"

basic_comp_degree_spec_synsem := basic_lex_degree_spec_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN comp_rel,
                  VAL.SPEC < [ LOCAL [ CAT [ HEAD comp_spec_able,
                                             VAL.COMPS < > ],
                                       CONT.HOOK.LTOP #ltop ] ] > ],
            CONT [ HOOK [ LTOP #ltop,
                          XARG #xarg ],
                   RELS.LIST < [ LBL #ltop,
				 ARG0 event & [ E [ TENSE no_tense,
						    ASPECT no_aspect ] ],
				 ARG1 #xarg ], ... >,
                   HCONS <! !>,
		   ICONS <! !> ] ],
    NONLOC.QUE 0-dlist ].

;; DPF 2014-10-13 - Removed reentrancy of SPCMPS.FIRST and COMPS.FIRST, since
;; this prevents *more like Kim than Sandy* (because "like" wants its SPR to be
;; COMPS *olist*), and because there does not seem to be a structure where the
;; COMPS can be used.  (In *more than ten feet tall* the analysis currently is
;; with *more than* as a deg-spec of the MNP *ten feet* analogous with 
;; *at least ten feet tall*.)
;; DPF 2020-04-30 - Generalized SPCMPS..LPUNCT to pair_or_no_punct, so we
;; can get *...so upset "that you complained"*
;;
;; was HEAD.MINORS.MIN comp_as_too_enough_rel,
basic_comp_degree_wcomps_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_more_less_rel,
                VAL [ SPR.FIRST synsem,
		      SPCMPS < synsem &
				   [ LOCAL.CONJ cnil,
				     OPT -,
				     PUNCT.LPUNCT pair_or_no_punct ] >,
		      COMPS < > ] ] ].

;; DPF 2012-03-13 - For some reason, recently added MODIFD notmod, but this
;; blocks *We arrived as soon as Kim left*, so remove.
comp_degree_wcomps_synsem := basic_comp_degree_wcomps_synsem &
  [ LOCAL [ CAT [ HEAD.MINORS.MIN comp_as_too_enough_rel,
		  VAL.SPEC < [ LOCAL.CAT.HEAD n_or_a_or_adv_or_det ] > ],
	    CONT [ RELS <! relation !> ] ] ].

comp_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS.FIRST [ LOCAL.CONT.HOOK [ LTOP #ltop,
						     INDEX #ind ],
				   NONLOC non-local_none ] ],
    LKEYS.KEYREL [ LBL #ltop,
                   ARG2 #ind ] ].

;; DPF 2017-12-07 - Change LPERIPH from na_or_+ to +, to block
;; *tall as many cats as mice*
;;
as_degree_spec_synsem := comp_degree_spec_synsem &
  [ LOCAL.CAT.VAL.SPCMPS.FIRST [ --MIN _as_p_comp_rel,
				 LOCAL.CAT [ HEAD prep,
					     VAL.COMPS < > ] ],
    MODIFD.LPERIPH +,
    LKEYS.KEYREL.PRED comp_equal_rel ].

;; DPF 2018-03-31 - To block *nothing is tougher than lose*, add NORM norm_rel.
;; to complement than-PP.
;;
basic_more_degree_spec_synsem := basic_comp_degree_wcomps_synsem &
  [ LOCAL.CAT.VAL [ SPR < [ --MIN just_only_much_deg_rel ] >,
		    SPCMPS.FIRST [ --MIN _than_p_compar_rel,
				 LOCAL [ CAT [ HEAD prep &
				                    [ MINORS.NORM norm_rel ],
					       VAL.COMPS < > ],
					 CONT.HOOK.LTOP #ltop ],
				 NONLOC non-local_none ] ],
    LKEYS.KEYREL.LBL #ltop ].
                           
more_degree_spec_synsem := basic_more_degree_spec_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_enough_rel,
		VAL [ SPR < [ --MIN much_deg_rel ] >,
		      SPCMPS.FIRST.LOCAL.CONT.HOOK.INDEX #ind ] ],
    LKEYS.KEYREL.ARG2 #ind ].

basic_too_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS.FIRST.LOCAL [ CAT s_or_vp_inf_cat,
					 CONT.HOOK.LTOP #ltop ] ],
    LKEYS.KEYREL [ PRED _too_x_comp_rel,
                   ARG2 #ltop ] ].

too_degree_spec_slash_synsem := basic_too_degree_spec_synsem &
  [ LOCAL.CAT.VAL [ SPCMPS.FIRST.NONLOC.SLASH 1-dlist &
                                    <! [ CAT np_cat_acc_min &
                                             [ HEAD [ MINORS.MIN norm_nom_rel,
                                                      MOD < > ] ],
                                         CONT.HOOK.INDEX #ind ] !>,
		    SPEC < [ LOCAL.CONT.HOOK.XARG #ind ] > ] ].

too_degree_spec_synsem := basic_too_degree_spec_synsem &
  [ LOCAL.CAT.VAL.SPCMPS.FIRST.NONLOC.SLASH 0-dlist ].

; DPF 15-aug-07 - Removed HEAD comp to allow "He was so late we couldn't wait"
so_degree_spec_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS.FIRST [ LOCAL [ CAT s_cat_fin_v_c,
					   CONT.HOOK [ LTOP #ltop,
						       INDEX.SF prop-or-comm ] ],
				   NONLOC.SLASH 0-dlist ] ],
    LKEYS.KEYREL [ PRED _so_x_comp_rel,
                   ARG2 #ltop ] ].

; *not so tall as to scare you*
so_degree_spec_as_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
		VAL.SPCMPS.FIRST [ LOCAL [ CAT [ HEAD prep &
						      [ MINORS.MIN _as_p_rel ],
						 VAL.COMPS < > ],
					   CONT.HOOK [ LTOP #ltop,
						       INDEX.SF prop-or-comm ] ],
				   NONLOC.SLASH 0-dlist ] ],
    LKEYS.KEYREL [ PRED _so_x_comp_rel,
                   ARG2 #ltop ] ].

; DPF 28-Apr-03 - Until we move to always discharging optional complements,
; we have to split 'as' into two lexical entries, one with an as-comp and one
; without, in order to be able to coordinate "as early and as late" where
; the top_coord_nom rule requires COMPS to be empty (since this 'as' pushes
; its complement to 'as early').
;;
basic_comp_degree_spec_nc_synsem := basic_comp_degree_spec_synsem &
  [ LOCAL [ CAT.VAL [ SPCMPS #spc,
		      SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
		      COMPS < > ],
	    CONT.RELS <! relation !> ] ].

comp_degree_spec_nc_synsem := basic_comp_degree_spec_nc_synsem &
  [ LOCAL.CAT.VAL.SPR.FIRST synsem ].

comp_degree_spec_enough_synsem := basic_comp_degree_spec_nc_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN enough_deg_rel,
		VAL [ SPCMPS < >,
		      SPR  < anti_synsem_min > ] ],
    LKEYS.KEYREL.PRED _enough_x_comp_rel ].

#|
;; Add lexical entry for |enough| + comp, eventually -- FIX
;; most likely with lexical rule that directly adds the VP|CP complement
;;
comp_degree_spec_enough_wcomps_synsem := comp_degree_wcomps_synsem &
  [ LOCAL.CAT [ HEAD.MINORS.MIN enough_deg_rel,
		VAL [ SPCMPS.FIRST [ LOCAL [ CAT s_or_vp_inf_cat,
					     CONT [ HOOK.LTOP #ltop ] ],
				     OPT - ] ] ],
    LKEYS.KEYREL [ PRED _enough_x_comp_rel,
                   ARG2 #ltop ] ].
|#

basic_degree_spec_word := que_word &
  [ SYNSEM basic_lex_degree_spec_synsem &
           [ LOCAL.CONT.RELS.LIST < #keyrel, ... >,
             LKEYS.KEYREL #keyrel ] ].

norm_degree_spec_word := basic_degree_spec_word &
  [ SYNSEM lex_degree_spec_synsem &
           [ LOCAL.CONT [ HCONS <! !>,
			  ICONS <! !> ],
             NONLOC.QUE 0-dlist ] ].

degree_spec_word := norm_degree_spec_word &
  [ SYNSEM.LOCAL.CONT.RELS <! degree_relation !> ].

;; DPF 2013-05-10 - Preserve HS-LEX value from SPEC value, so that degree-specs
;; of degree-specs retain transparency, to block erroneous analyses with
;; double degree specifiers, as in **the way too difficult to hire cat*
;;
basic_adv_degree_spec_lexent := norm_degree_spec_word &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.ALTMIN non_event_rel,
		       VAL [ SPR < [ LOCAL.CAT.VAL.SPCMPS #spc ] >,
			     SPEC.FIRST.LOCAL.CAT.HS-LEX #hslex,
			     SPCMPS #spc ],
		       HS-LEX #hslex ] ].

adv_degree_spec_lexent := basic_adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CONT.RELS <! degree_relation !> ].

; DPF 18-feb-08 - Changed MIN deg_rel to MIN much_or_very_deg_rel to avoid
; spurious spr-hd analysis for e.g. "under Berlin".
av_-_dg_le := adv_degree_spec_lexent &
"""
Degree spec (deg)                
<ex>B is incredibly rich.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_or_very_deg_rel,
                       VAL.SPEC < [ LEX + ] > ] ].

av_-_dg-v_lexent := adv_degree_spec_lexent &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN very_deg_rel,
                       VAL.SPEC < [ LEX #lex ] >,
                       HS-LEX #lex ] ].

av_-_dg-v_le := av_-_dg-v_lexent
"""
Deg, very-type                   
<ex>B is very rich.
"""
.

av_-_dg-m_le := adv_degree_spec_lexent &
"""
Deg, much-type                   
<ex>B is much richer.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN much_deg_rel ].

; This type allows unification with very_deg_rel, while the next does not.
; DPF 22-may-09 - Changed MIN just_only_degree_rel to just_only_very_deg_rel
; to block e.g. "around Kim" as spr-hd.
av_-_dg-jov_le := adv_degree_spec_lexent &
"""
Deg, just-only-very              
<ex>B won just the first race.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_very_deg_rel ].

; DPF 22-may-09 - Added this type for deg specs which can appear both with
; proper names and with 'very' and 'much' -taking heads
av_-_dg-jomv_le := adv_degree_spec_lexent &
"""
Deg, just-only-very-much
<ex>B was notably red(der).
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_degree_rel ].

av_-_dg-jo_le := adv_degree_spec_lexent &
"""
Deg, just-only                   
<ex>B won only the first race.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_deg_rel ].

;; 2020-04-21 - Maybe on for "most" - deg-spec only for det and adv, not NP,
;; so we 
av_-_dg-jo-spr_le := adv_degree_spec_lexent &
"""
Deg, just-only                   
<ex>B won only the first race.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_deg_rel ].

av_-_dg-jo-num_le := adv_degree_spec_lexent &
"""
Deg, just-only, for numbers                   
<ex>B won over fifty races.
"""
  [ SYNSEM.LOCAL.CAT 
		 [ HEAD.MINORS.MIN just_only_degree_rel,
		   VAL.SPEC < [ LOCAL.CAT.HEAD n_or_a_or_adv_or_det &
			        [ MINORS.MIN meas_or_numq_rel ] ] > ] ].
 
av_-_dg-notj_le := adv_degree_spec_lexent &
"""
Deg, not for adjectives: e.g. `twice'
<ex>B is twice as tall.
<nex> *B is twice tall.
"""
  [ SYNSEM.LOCAL.CAT 
		 [ HEAD.MINORS.MIN very_deg_rel,
		   VAL.SPEC < [ LOCAL.CAT.HEAD det_or_adv ] > ] ].

; 'this much' 'this tall'
; DPF 18-mar-06 - To block "*my this tall chairs", allow SPEC to unify HS-LEX
; value '-', so "this tall" will be LEX -, and hence cannot modify 
; prenominally.  While 'tall' does this unification, 'many' does not, so we
; can still get "this many chairs'
;; DPF 16-jul-2010 - Re: 18-mar-06: With revised analysis of degree specs, 
;; instead make the SPEC value PRD + to allow *the chair is this tall* but
;; block **the this tall chair appeared*.
av_-_dg-tt_le := que_word &
"""
Deg, this-that                   
<ex>B isn't that rich.
"""
  [ SYNSEM comp_degree_spec_nc_synsem & 
           [ LOCAL.CAT [ HEAD.MINORS.MIN this_that_deg_rel,
	                 VAL.SPEC < [ LOCAL.CAT.HEAD n_or_a_or_adv_or_det,
				      MODIFD notmod_or_lmod ] >,
                         HS-LEX - ],
	     MODIFD notmod ] ].

; This type requires unification with much_deg_rel, so cannot be used with
; e.g. determiner 'the', as in "straight (into ...)" or "up to (ten ...)"
av_-_dg-jom_le := adv_degree_spec_lexent &
"""
Deg, just-only-much              
<ex>B ran straight into C.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN just_only_much_deg_rel ].

;; For *light/dark blue*, *pale/bright red*
av_-_dg-color_le := adv_degree_spec_lexent &
"""
Deg, for color adjectives
<ex>B is light blue.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN very_deg_rel,
                       VAL.SPEC < [ LEX #lex,
				    --MIN color_rel ] >,
                       HS-LEX #lex ] ].

;; DPF 2017-10-31 - Changed HS-LEX + to bool since + prevents *cats most likely
;; to laugh* and leaving it underspecified as bool still allows "most likely" 
;; in LEX + contexts.
;; DPF 2018-02-20 - Re 2017-10-31: But we still want to block *cats most likely*
;; so make the same move as for ordinary "very", namely to identify HS-LEX of
;; the adverb's SPEC with its own.
;;
av_-_dg-sup_lexent := basic_degree_spec_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN this_that_deg_rel,
			   VAL [ SPR < [ --MIN very_deg_rel ] >,
				 SPEC < [ LOCAL.CAT [ HEAD a_or_adv,
						      HS-LEX #hslex ] ] >,
				 COMPS < >,
				 SPCMPS < > ],
			   HS-LEX #hslex ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX.E [ TENSE no_tense,
					     ASPECT no_aspect ],
				   XARG #xarg ],
			    RELS <! degree_relation &
				    [ LBL #ltop,
				      ARG1 #xarg ] !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     NONLOC.QUE 0-dlist ] ].

av_pp_dg-sup_lexent := basic_degree_spec_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN this_that_deg_rel,
			   VAL [ SPR < [ --MIN very_deg_rel ] >,
				 SPEC < [ LOCAL.CAT.HEAD a_or_adv ] >,
				 COMPS < >,
				 SPCMPS < [ --MIN #cmin & _of_p_sel_rel,
					    LOCAL [ CAT [ HEAD prep & 
                                                        [ PRD -,
                                                          TAM.TENSE nontense ],
							  VAL.COMPS < > ],
						    CONT.HOOK.INDEX 
							non_expl ],
					    NONLOC non-local_none,
					    OPT - ] > ],
			   HS-LEX + ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX.E [ TENSE no_tense,
					     ASPECT no_aspect ],
				   XARG #xarg ],
			    RELS <! degree_relation &
				    [ LBL #ltop,
				      ARG1 #xarg ] !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     NONLOC.QUE 0-dlist,
             LKEYS.--COMPKEY #cmin ] ].

; Set [HS-LEX +] which adj_synsem identifies with the spr's SPEC..HS-LEX,
; which is what the head-spec rule uses to set LEX on phrase, so we block
; '*the lake most beautiful' but allow 'the most beautiful lake'
av_-_dg-sup_le := av_-_dg-sup_lexent &
"""
Deg, superl                      
<ex>The most famous dog won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN superl_rel ].

av_-_dg-sup-lst_le := av_-_dg-sup_lexent &
"""
Deg, superl                      
<ex>The least happy dog won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_or_superl_rel ].


av_pp_dg-sup_le := av_pp_dg-sup_lexent &
"""
Deg, superl, PP-complement
<ex>The most famous dog of all won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_or_superl_rel ].

av_pp_dg-sup-lst_le := av_pp_dg-sup_lexent &
"""
Deg, superl, PP-complement
<ex>The most famous dog of all won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN comp_or_superl_rel ].

av_-_dg-sup-av_le := av_-_dg-sup_lexent &
"""
Deg, superl, for adverbs only                     
<ex>Who sang the most beautifully?
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD adv ] > ].

av_pp_dg-sup-av_le := av_pp_dg-sup_lexent &
"""
Deg, superl, PP-complement, for adverbs only
<ex>Who sang the most beautifully of all?
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD adv ] > ].

; Only for degree specs of determiners: 'not all, not many, not every, not a'
;; But block *we admire not the/some cat* via NEGPOL +.
av_-_dg-det_le := adv_degree_spec_lexent &
"""
Deg, modify det                  
<ex>Not every runner won.
<nex>Not the runner won.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN just_only_degree_rel,
                       VAL.SPEC < [ LOCAL.CAT [ HEAD det_or_partn,
						NEGPOL + ] ] > ] ].

; Degree specs of directional preps: "all over New York"
;; DPF 2012-02-01 - Generalize slightly to locatives: *all at the same time*
;; DPF 2014-07-08 - Generalize further to ordinary PPs: *all alone*,
;; *all out of rice*.  It's true that "all" only occurs with some PPs, but
;; hard to say which ones.  
;;
av_-_dg-pp_le := adv_degree_spec_lexent &
"""
Deg, modify PP               
<ex>B sank well into the sand.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL.SPEC < [ LOCAL.CAT [ HEAD prep,
						VAL.COMPS < > ] ] > ] ].

; 'due' only for directions
av_-_dg-dir_le := adv_degree_spec_lexent &
"""
Deg, 'due north'                 
<ex>B ran due north.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL.SPEC < [ --MIN place_n_rel ] > ] ].

; 'roughly', 'wide(-spread)', 'jam(-packed)'
av_-_dg-ap_le := degree_spec_word &
"""
Deg, modify AP                   
<ex>The race is wide open.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN very_this_that_rel,
                       VAL [ SPEC < [ LOCAL.CAT.HEAD adj ] >,
			     SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
                             SPCMPS #spc ] ] ].

; 'all the'
av_-_dg-adv_le := degree_spec_word &
"""
Deg, modify comparative adv
<ex>They studied all the harder.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL [ SPEC < [ LOCAL.CAT.HEAD adv ] >,
			     SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
                             SPCMPS #spc ] ] ].

; 'any'
av_-_dg-any_le := degree_spec_word &
"""
Deg, just 'any'                  
<ex>B isn't any richer.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL [ SPEC < [ LEX + ] >,
			     SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
                             SPCMPS #spc ] ] ].

; "how tall"
; DPF 21-Jul-03 - Will want opt comp of-PP or indef-NP to get "how good (of) a
; player is he"
; DPF 07-mar-06 - Made semantics analogous to that of "To what degree is Kim
; tall?", thereby relating the degree index to Kim's index.
; DPF 30-sept-06 - Removed ALTMIN no_rel, since positive adj's now have
; ALTMIN norm_rel so 'most beautiful' can be treated as superlative in
; partitives like "the most beautiful arrived."

adv_wh_degree_spec_lexent := basic_degree_spec_word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN degree_rel,
                           VAL [ SPEC < [ LOCAL 
                                          [ CAT.VAL.COMPS *obllist*,
                                            CONT.HOOK.LTOP #sphand ],
                                          NONLOC.SLASH 0-dlist ] >,
				 COMPS < >,
				 SPR.FIRST.LOCAL.CAT.VAL.SPCMPS #spc,
				 SPCMPS #spc ],
			   HS-LEX - ],
                     CONT [ HOOK.XARG #spind,
			    RELS <! [ LBL #hand,
                                      PRED abstr_deg_rel,
                                      ARG0 #arg0 ],
				  #altkeyrel &
                                  [ PRED which_q_rel,
                                    ARG0 #arg0 & ref-ind,
                                    RSTR #harg ],
				  #alt2keyrel &
                                  [ PRED measure_rel,
                                    LBL #sphand,
                                    ARG0.E [ TENSE no_tense,
				             ASPECT no_aspect ],
                                    ARG1 #spind,
                                    ARG2 #arg0 ] !>,
                            HCONS <! qeq & [ HARG #harg,
                                             LARG #hand ] !>,
			    ICONS <! !> ] ],
	     NONLOC.QUE 1-dlist & [ LIST < param > ],
	     LKEYS [ ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

;; Non-WH 'how' as in *How tall you are.*
;; Exclude *how tall* from subord-adj via SPEC..TENSE.
;; And block coord of *who arose and how tall you are* via SF constraint on
;; SPEC's --SIND.SF.
;; And block in conj-mod *[and how tall] you are* by making SPEC's MOD be
;; unexpressed
av_-_dg-v-nwh_le := av_-_dg-v_lexent &
"""
Deg, very-type, only non-wh 'how'
<ex>How tall you are!
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST [ LOCAL.CAT.HEAD [ MOD.FIRST unexpressed,
						       TAM.TENSE real_tense ],
				      --SIND.SF prop ] ].

; How tall
av_-_dg-v-wh_le := adv_wh_degree_spec_lexent &
"""
Deg, WH very-type                
<ex>B saw how rich C is.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN very_deg_rel ].

; How much taller
av_-_dg-m-wh_le := adv_wh_degree_spec_lexent &
"""
Deg, WH much-type                
<ex>B saw how much richer C is
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN much_deg_rel ].

av_pp_dg-as_le := que_word &
"""
Deg, just 'as', PP-as comp       
<ex>B is as rich as C.
"""
  [ SYNSEM as_degree_spec_synsem ].

av_vp_dg-too_le := que_word &
"""
Deg, just 'too', inf VP-CP comp  
<ex>B is too poor to win.
"""
  [ SYNSEM too_degree_spec_synsem ].

av_vpslnp_dg-too_le := que_word &
"""
Deg, 'too' with VP/NP comp       
<ex>B is too big to hide.
"""
  [ SYNSEM too_degree_spec_slash_synsem ].

;; DPF 2020-04-29 - Also use for `such' as in *such detailed images that they
;; could see the numbers*
;;
av_cp_dg-so_le := que_word &
"""
Deg, 'so', CP comp          
<ex>B is so fast that he won.
"""
  [ SYNSEM so_degree_spec_synsem ].

av_cp_dg-so-as_le := que_word &
"""
Deg, just 'so', as-VP comp          
<ex>B is not so rich as to scare you.
"""
  [ SYNSEM so_degree_spec_as_synsem ].

av_pp_dg-more_le := que_word &
"""
Deg, just 'more', PP comp   
<ex>B is less rich than C.
"""
  [ SYNSEM more_degree_spec_synsem &
	   [ LOCAL [ CAT.HEAD.MINORS.ALTMIN more_comp_rel,
		     CONT.RELS <! relation !> ] ] ].

av_pp_dg-less_le := que_word &
"""
Deg, just 'less', PP comp   
<ex>B is less rich than C.
"""
  [ SYNSEM more_degree_spec_synsem &
	   [ LOCAL.CONT.RELS <! relation !> ] ].

av_pp_dg-cmp_le := que_word &
"""
Deg, PP comp   
<ex>B is farther from Kim than Browne.
"""
  [ SYNSEM basic_more_degree_spec_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
			   VAL.SPCMPS.FIRST.LOCAL.CONT.HOOK.INDEX #spind ],
		     CONT.RELS <! [ LBL #lbl, ARG0 #arg ],
				  [ PRED more_comp_rel,
				    LBL #lbl, ARG1 #arg, ARG2 #spind ] !> ] ] ].

av_-_dg-cmp_le := basic_adv_degree_spec_lexent &
"""
Deg, comparative, no comp
<ex>B ran further away.
"""
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN just_only_much_deg_rel,
		   CONT.RELS <! [ LBL #lbl, ARG0 #arg,
				  CFROM #cfrom, CTO #cto ],
			        [ PRED more_comp_rel,
				  LBL #lbl, ARG1 #arg,
				  CFROM #cfrom, CTO #cto ] !> ] ].

; DPF 13-Nov-03 - Constrained SPEC value to be PRD + to prevent "The as tall
; player ..." or "the too beautiful chair ..."
; DPF 16-mar-06 - But this is in conflict with our revised treatment of
; 'many' as an adjective, as in "too many chairs".  So instead constrain
; the SPEC's HS-LEX to be -.
; DPF 31-dec-08 - Require SPEC to be not right-modified, to avoid spurious 
; analysis of "as [tall as Kim]", but allow "as completely crazy as Kim".
;; DPF 2012-09-20 - Removed MODIFD notmod, since this blocked 
;; *Kim arose too soon*, since the npadv rule requires its dtr to be hasmod,
;; and sp-hd-hc rule takes MODIFD value from specifier.
;; DPF 2018-05-25 - Now that we analyze "way too" of *way too old* as spr-hd,
;; the constraint on HS-LEX is in conflict with np-adv entries like *late*,
;; so we don't get *he is way too late*.  FIX someday.
;; DPF 2020-08-04 - Tried blocking scopal adverbs as in "*too possibly" via
;; constraint on SPEC..MOD list, but independent anti* constraints on MOD
;; compete for the list type, and the scopal-nonscopal distinction is in any
;; case too blurry.  Could consider adding constraint SPEC..XARG individual,
;; where one might expect scopal modifiers to have XARG handle, but currently
;; scopal adverbs just pass up their mod target's XARG.
;;
av_-_dg-cmp-so_le := que_word &
"""
Deg, 'so/as/too' no comp         
<ex>B is so fast.
"""
  [ SYNSEM comp_degree_spec_nc_synsem & 
           [ LOCAL.CAT [ HEAD.MINORS.MIN comp_as_too_degree_rel,
	                 VAL.SPEC < [ LOCAL.CAT.HEAD n_or_a_or_adv_or_det,
				      MODIFD notmod_or_lmod ] >,
                         HS-LEX - ],
	     MODIFD.LPERIPH + ] ].

; DPF 12-jul-06 - Changed MIN much_or_very_deg_rel to more_deg_rel
; to block "more many" but still allow "very many"
;; DPF 2018-03-23 - Added SPR..MIN just_only_much_deg_rel to avoid
;; *fairly more cheerful* or *very more cheerful*.
;
av_-_dg-cmp-more_lexent := que_word &
  [ SYNSEM comp_degree_spec_nc_synsem &
           [ LOCAL.CAT [ HEAD.MINORS.MIN more_deg_rel,
			 VAL.SPR.FIRST.--MIN just_only_much_deg_rel ] ] ].

av_-_dg-cmp-more_le := av_-_dg-cmp-more_lexent &
"""
Deg, 'more' no comp         
<ex>B is more cheerful.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN more_comp_rel ].

av_-_dg-cmp-less_le := av_-_dg-cmp-more_lexent
"""
Deg, 'less' no comp         
<ex>B is less rich.
"""
.

av_-_dg-enough_le := que_word &
"""
Deg, just 'enough'               
<ex>B is rich enough.
"""
  [ SYNSEM comp_degree_spec_enough_synsem ].

#|
av_vp_dg-enough_le := que_word &
"""
Deg, just 'enough' plus VP/NP complement
<ex>B is rich enough to admire.
"""
  [ SYNSEM comp_degree_spec_enough_wcomps_synsem ].
|#

av_-_dg-many_le := adv_degree_spec_lexent &
"""
Deg, just 'many more'
<ex>'many more (cats) arrived'
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN much_deg_rel,
                       VAL.SPEC < [ LEX +,
				    LOCAL.CAT [ HEAD compar_adj &
						[MOD < [LOCAL.AGR.PNG.PN 3p]>],
						VAL.COMPS < > ] ] > ] ].

; For measure-np ersatz
; NORM norm_rel prevents these from also appearing in noun_n_cmpnds, 
; leaving only the np-hdn_cpd_c we want for "200m climb"
; DPF 7-mar-05 - Removed MODIFD notmod since this prevented "200m away" from
; undergoing the np_adv_c rule, and its motivation remained obscure.
; DPF 29-mar-05 - Changed MIN to deg_rel so we get "half an hour before Kim
; arrives"
;; DPF 2012-03-03 - Removed identif. of INFLECTD and PRD, since we want to
;; allow *Stocks fell _meas_ne_* which needs to be INFL + but PRD - in order
;; to meet demands of the npadv_meas rule that makes the meas_np adverbial.
;; DPF 2017-05-27 - Changed SPR from unexpressed to ordinary det, so we can
;; get *the 5kg is here*.  
;;
n_-_meas-gen_lexent := noncqrs-hm & generic_lex_entry &
  [ TOKENS.+LIST < [ +CARG #carg ] >,
    SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MINORS [ MIN meas_nom_rel,
                                                  NORM quantity_rel ],
                                         MOD < > ],
                           VAL [ SPR < [ OPT -,
					 LOCAL.CAT [ HEAD det,
						     VAL [ SUBJ < >,
							   SPR *olist* ] ] ],  
				       anti_synsem_min >,
                                 SPEC < > ] ],
                     AGR.PNG.PN 3s,
                     CONT [ HOOK [ LTOP #nhand,
                                   INDEX #nindex & nonconj_ref-ind ],
                            RELS.LIST < #keyrel & named_nom_relation &
					[ PRED meas_np_rel,
					  LBL #nhand,
					  ARG0 #nindex,
					  CARG #carg ], ... >,
                            HCONS <! !>,
			    ICONS <! !> ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             LKEYS [ KEYREL #keyrel ],
	     PHON.ONSET unk_onset ] ].

n_-_meas-gen_le := n_-_meas-gen_lexent &
"""
Measure noun - generic           
<ex>C is generic-meas tall.
"""
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < > ] ],
                     CONT [ RELS <! [ ] !> ] ] ] ].

n_np_meas-gen_le := n_-_meas-gen_lexent &
"""
Deprecated, for measure noun - generic, with NP complement
<ex>Trip 1c - 4-6 days -
"""
  [ SYNSEM [ LOCAL [ CAT [ VAL.COMPS < expressed_synsem &
				       [ OPT -,
					 LOCAL [ CAT nomp_cat_acc_min,
						 CONT.HOOK [ INDEX #cindex ],
						 CONJ cnil ],
					 --SIND #cindex ] > ],
                     CONT [ RELS <! [ CFROM #cfrom, CTO #cto,
				      LBL #hand,
				      ARG0 #index ],
				    prep_notense_relation & 
                                     [ PRED compound_rel,
				       LBL #hand,
				       ARG1 #index,
				       ARG2 #cindex,
				       CFROM #cfrom, CTO #cto ] !> ] ],
	     MODIFD notmod ] ].

n_-_meas-n-gen_le := basic_noun_word & generic_lex_entry &
"""
Measure noun - generic           
<ex>C is 42 generic-meas-noun tall.
<native> n_-_c-meas_le
"""
  [ INFLECTD bool,
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS [ MIN meas_nom_rel,
					 NORM quantity_rel ],
			   VAL.SPR < [ --MIN abstract_q_rel ] > ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! relation !>,
			    HCONS <! !>,
			    ICONS <! !> ],
		     CONJ cnil ],
	     MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation & 
		   [ LBL #ltop,
		     PRED string ],
	     PHON.ONSET unk_onset ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Numbers
;;
;; DPF 14-Apr-01 - Numerals combine with their complements and specifiers as
;; laid out in Smith 2000, but since the specifier-head rule makes the TOP
;; handle of the phrase be that of the spr dtr, we can't have numerals simply
;; identify their LTOP value with their KEY.LBL value or something similar.
;; Hence, numerals combine using the LBL of the attribute ALTMIN, which
;; points to the MIN for simple numerals like "two", but to the plus_rel or
;; the times_rel for more interesting numerals like "hundred".  
;;   The LTOP handle is identified with the SPEC's handle, so when a numeral is
;; built using the specifier-head rule, the resulting LTOP handle will be the 
;; same as the LTOP handle of the head-dtr.  This is useful because of two other
;; regularities:
;;   (1) the MOD's handle is identified with the ALTKEY's handle; and
;;   (2) the intersective modifier-head rule identifies the MOD's handle with
;;       the modifier's LTOP handle.
;; This ensures that the LTOP handle of a numeral modifier will be identified
;; with the ALTKEY's handle, as desired.
;; DPF 2017-10-04 - Not all number adjectives are POSTHD -, since we want
;; *the person third in the line*.  So push this down to cardinals.
;;
; For numerals
anycard_norm_num_synsem := canonical_synsem & basic_zero_arg &
  [ LOCAL [ CAT [ HEAD intadj,
                  VAL.SUBJ < > ],
	    CONT [ HOOK.XARG non_expl,
                   RELS.LIST < integer_relation, ... > ],
	    CONJ cnil ] ].

; DPF 6-Jun-01 - Added MODIFD.LPERIPH - to avoid unwanted reading for 
; "two hundred three chairs".
; But this blocks "two competent programmers", so make [LPERIPH na].
; DPF 28-Apr-03 - This PERIPH feature is overloaded since it does not
; distinguish directionality - the two uses clash for examples like "the
; first chair that I bought arrived" where for ordering of thatless and
; full relatives we want "chair that I bought" to be (right) [PERIPH +] but 
; to avoid double ordinals we want it to be (left) [PERIPH -].  So change to
; two features LPERIPH and RPERIPH.
; DPF 16-oct-03 - Since now making adj+N be [LPERIPH +], change this type so
; it asks for a MOD..LPERIPH bool but projects LPERIPH na so we can still
; block unwanted parse for "two hundred three chairs" but allow "two hundred
; big chairs".
; Pushed this down to cards, not ords, so we can get "the first seven chairs...
; DPF 06-jun-06 - Moved constraint MOD..SPR expressed_synsem down to cards,
; since this wrongly rejected "many second homes", "some third floors".  
; 24-aug-06 - Re: 16-oct-03: Making "three chairs" be LPERIPH na sadly means
; they can appear within N-N compounds, as in "*mountain first hotel".  Happily
; we aren't actually claiming that adj-N be [LPERIPH +] now, so we can go
; back to requiring that these numerical adjectives modify something which
; is LPERIPH - (could probably also be na, but leave out for now), but they
; themselves are LPERIPH +, still preventing recursion.
; DPF 27-jun-10 - Prevent integers from directly modifying measure nouns,
; to avoid spurious ambiguity for "ten inch nails"
; DPF 2010-09-17 - Moved the recently added MOD..NORM norm_or_no_rel down to 
; cardinals, since it blocked e.g. *the first kilometer*
;; DPF 2020-05-15 - Push LPERIPH na_or_+ down to subtypes, so we can leave
;; generic cardinals underspecified, to get *the 1.9 release* while still
;; blocking *the three release*
;;
norm_num_synsem := anycard_norm_num_synsem & zero_arg &
  [ LOCAL 
     [ CAT 
        [ HEAD.MOD 
           < [ LOCAL intersective_mod &
               [ CAT basic_nbar_cat &
		     [ HEAD noun_or_nomger_or_nadj &
			    [ MINORS.MIN nonpro_rel ],
		       VAL.SPR < synsem & [ --MIN quant_or_deg_rel ], ... > ],
		 CONT.HOOK.INDEX #xarg,
                 CONJ cnil ] ] >,
          HC-LEX + ],
       CONT.HOOK [ LTOP #ltop,
		   INDEX #index,
		   XARG #xarg ] ],
    LKEYS.KEYREL [ LBL #ltop,
		   ARG0 #index,
		   ARG1 #xarg ],
    MODIFD notmod_or_rmod ].

; DPF 05-apr-05 - Moved PRD - to norm_card_word since it blocks "Kim was third"

norm_num_word := noncqrs-m-nab &
  [ SYNSEM norm_num_synsem ].

;; some norm_card-words must remain unspecified for CARDINAL
;; DPF 10-Apr-02 - Moved MOD..DIV +* from norm_num_word to norm_card_word
;; since ordinals don't require this: "the eleventh child"
; DPF 27-nov-04 - In fact, DIV value must come from the same source as
; the value for CARDINAL: "twenty ninth" isn't DIV + but "twenty nine" is
; DPF 17-jun-07 - Enabled cardinals to be specifiers of 'more' as in
; 'ten more cats arrived'.
;; DPF 2016-10-16 - For some reason, this type identified its SPCMPS and
;; SPEC..COMPS, but this runs afoul of the more recent head_spec_hc_cmp_phrase
;; which expects no such identity.  Can't just now reconstruct what this
;; identity was for, so drop it, and make SPCMPS < >, then FIX as needed.
;; DPF 2018-03-10 - Changed MOD..LPERIPH from - to na_or_-.
;; DPF 2020-05-18 - Removed MOD..NORM norm_or_no_rel, since this excludes the
;; desired analysis of *those 200 tons are a lucrative target*
;;
norm_card_word := norm_num_word &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD [ MOD < [ MODIFD.LPERIPH na_or_-,
				   LOCAL.CAT.VAL.SPR < expressed_synsem &
                                                  [ --MIN explicit_q_rel] > ] >,
			   PRD -,
			   MINORS.MIN card_rel ],
		    VAL [ SPCMPS < > ],
		    POSTHD - ],
	      CONT.RELS.LIST.FIRST [ PRED basic_card_rel,
				     ARG1 individual ] ] ] ].

;; those cardinals that take no complements may be safely specified as 
;; +CARDINAL, and as plural (since they're normal)
;; DPF 17-may-09 - Moved PNG.PN constraint to AGR, to enable coordination of
;; "one or two cats"

card_only_word := norm_card_word &
  [ SYNSEM.LOCAL.CAT.HEAD [ CARDINAL +,
			    MOD < [ LOCAL.AGR.PNG.PN 3p ] > ] ].

; should be POSTHD -
; These are adjectives only
; DPF 25-apr-04 - Added SPEC < anti_synsem_min > to prevent ordinals from
; undergoing the partitive_num rule, which is designed to handle not only
; cardinal numbers but also superlatives as in "the best arrived", and
; measure phrases ("ten feet of rope"), while excluding ordinary NPs.
; --FIX-- This won't scale up to complex ordinals like "twenty-second"
; which are different from "twenty-two" only in the CARDINAL feature, so
; CARDINAL would have to be introduced higher up than on the type intadj.
; DPF 26-aug-04 - Added variant of partitive rule for cardinals and ordinals,
; (which produces a sign that like common nouns requires a determiner),
; still using SPEC < anti_synsem_min > to distinguish the two.

basic_ord_word := norm_num_word & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ CARDINAL -,
				  MINORS.MIN basic_ord_rel ],
			   VAL [ SPEC < [ LOCAL.CAT [ HEAD basic_adj &
                                                         [ MINORS.ALTMIN 
                                                               superl_rel ],
						      VAL.COMPS #comps ] ] >,
				 SPCMPS #comps ] ],
		     CONT.RELS.LIST.FIRST.PRED basic_ord_rel ],
	     MODIFD.LPERIPH na_or_+ ] ].

ord_word := basic_ord_word & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

;;  Specifiers and modifiers will agree with heads on the value
;; of the head feature CARDINAL -- this allows propagation
;; of such a feature from complements, where (on the current account)
;; the CARDINAL feature gets a value from the lexicon.

;; distribution of CARDINAL:
;;   ordinal lex_entries are CARDINAL -
;;   complement_free lex_entries are CARDINAL +
;;   all lex_entries for "one" are CARDINAL +
;;   other lex_entries are unspecified for CARDINAL
;; Since (the HEAD feature of) the determiner "one" is outside this 
;; hierarchy, it can't appear as a specifier or complement.


;; The sorts below refer only to lexical entries, so there's presumably no
;; harm in making conventions about the order of the RELs on their RELSs
;; No particular order is assumed for any phrase containing these entries.

;; It will be hard to do optional complements here and get the RELSs to
;; come out right.  Another problem with optional complementation is that
;; entries with complements must be -ORD, while their complement-taking
;; counterparts must be underspecified for ORD 
;;   (cf. "twenty" vs. "twenty one" vs. "twenty first")

;; DPF 19-aug-08 - Removed KCMP lex_synsem since the head-complement rule now
;; stamps nonlex_synsem on mother, and this was blocking "hundred fifty". 
;; Instead, use feature LEX +, and see if this is still okay.

complement_free_number := norm_num_word &
			  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

;; DPF 2018-03-10 - Curiously, this type was identifying its MOD..DIV with
;; that of its KCMP's MOD..DIV, but now that we are propagating the MOD's AGR
;; constraint to SPEC in the num-det rule, it's clear that this can't be right
;; since it blocks *twenty-one cats* since we rightly block **one rice* due to
;; the DIV mismatch.  Let's remove this identity, and see if we overgenerate
;; somewhere.
;;
complemented_number := norm_num_word &
  [ SYNSEM 
    [ LOCAL [ CAT [ HEAD.CARDINAL #card,
		    VAL.KCMP [ OPT -,
			       LOCAL [ CAT [ HEAD intadj & [ CARDINAL #card ],
					     VAL [ SPR *olist*,
						   COMPS < > ] ] ],
			       NONLOC.SLASH 0-dlist,
			       --MIN integer_rel,
			       PUNCT.LPUNCT no_punct ] ],
	      CONT [ RELS.LIST < relation, 
				 [ PRED plus_rel, 
				   ARG0 individual,
				   ARG1 individual ], ... > ] ],
      MODIFD.LPERIPH na_or_+,
      LEX + ] ].

; Non-identity stipulated for handle of SPR and handle of CONT in order to
; prevent the regular head-spec rule (non-head-compositional) from applying.
; Need head-compositional since the handle of the phrase "two hundred" must
; be the handle of the times_rel from the head "hundred" (which contains as
; arguments the other two handles).
;; DPF 2015-09-05 - Added CASE real_case to the SPR, now that REPP is producing
;; two generic entries for each decimal number: one ordinary cardinal used
;; here, and a decimal one used in compounds, where CASE is not constrained.
;; DPF 2020-03-24 - Changed SPR..MIN from basic_card_rel to card_or_interval_rel
;; so we can get *1-2 million*
;; DPF 2020-04-12 - Add another anti-synsem element to SPR, so that once we've
;; picked up the normal specifier for e.g. *five million*, we can still
;; coordinate these phrases via attrib-adj coord rule, which insists on still
;; having a specifier that can be constrained to OPT + (see discussion there
;; on why OPT + instead of the expected *olist*).
;;
specified_number := norm_num_word &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < synsem &
                               [ OPT -,
                                 LOCAL 
				  [ CAT [ HEAD intadj & 
					   [ CARDINAL +,
					     CASE real_case,
					     MINORS.MIN card_or_interval_rel ],
					  VAL [ COMPS < >,
						SPR *olist*,
						SPCMPS < > ] ] ],
				 NONLOC non-local_none ],
			       anti_synsem_min >,
	     MODIFD.LPERIPH na_or_+ ] ].
				 
; DPF 01-Feb-03 - Removed the degree specifier, since we don't want to parse
; "*the exactly five chairs arrived".  We'll ignore "the nearly fifty people".
; DPF 10-dec-03 - Made SPR be < anti_synsem_min > so we can still use the 
; normal adjective-coordination rule.  
; DPF 21-sept-04 - But we also want "exactly five people arrived".  Seems to
; support the idea of ambiguous 'five': (1) an adjective which takes no 
; specifier and which always co-occurs with a determiner; and (2) a 
; determiner which can have a degree specifier.  Already have this ambiguity
; for 'one' (necessarily, to get "one chair arrived"), but degree sprs give
; reason to do it consistently for cardinals.  Note that only the cardinals
; would have the determiner entry; ordinals are only adjectives, and don't
; occur with degree specifiers.  So added num_det syntactic rule, and removed
; the idiosyncratic lexical type (and entries) for determiner "one".
; DPF 22-sept-04 - Removed SPEC < anti_synsem_min > which was preventing
; "(exactly) two of the chairs arrived"

unspecified_num := norm_num_word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < anti_synsem_min > ].

; DPF 17-jun-07 - Removed SPEC..COMPS < > since this blocks e.g 'ten more
; cats than dogs', and can't remember why it was here.

unspecified_num_without_complements := complement_free_number & 
                                       unspecified_num &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN const_rel,
		     CONT [ RELS <! const_relation & #keyrel !> ] ],
	     LKEYS.KEYREL #keyrel ] ].

approx_unspecified_num_without_complements := complement_free_number & 
                                              unspecified_num &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
                           VAL.SPEC < anti_synsem_min > ],
                     CONT.RELS <! #keyrel & const_relation & 
				  [ LBL #ltop,
				    ARG0 #arg0 ],
				  #altkeyrel &
                                  [ LBL #ltop,
				    PRED approx_grad_rel,
				    ARG1 #arg0 ] !> ],
	     LKEYS [ KEYREL #keyrel,
		     ALTKEYREL #altkeyrel ] ] ].

unspecified_num_with_complements := complemented_number & unspecified_num &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
			   VAL.KCMP [ LOCAL.CONT.HOOK.LTOP #chandle ] ],
		     CONT [ RELS <! const_relation & #altkeyrel &
                                  [ LBL #khandle ],
                                  #keyrel & 
				  [ ARG2 handle & #khandle,
                                    ARG3 handle & #chandle] !> ] ],
	     LKEYS [ KEYREL #keyrel,
		     ALTKEYREL #altkeyrel ] ] ].

specified_num_without_complements := complement_free_number & 
                                     specified_number &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
			   VAL [ SPR.FIRST.LOCAL.CONT.HOOK [ LTOP #shandle,
							     INDEX event ],
				 SPEC < [ LOCAL.CAT.VAL.COMPS < > ] > ] ],
		     CONT.RELS <! const_relation & #altkeyrel &
                                  [ LBL #khandle ],
				  #keyrel &
                                  [ PRED times_rel,
				    ARG0 individual,
				    ARG1 individual,
                                    ARG2 handle & #shandle,
                                    ARG3 handle & #khandle ] !>  ],
	     LKEYS [ KEYREL #keyrel,
		     ALTKEYREL #altkeyrel ] ] ].

specified_num_with_complements := complemented_number & specified_number & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN const_rel,
			   VAL [ SPR.FIRST.LOCAL.CONT.HOOK [ LTOP #shandle,
							     INDEX event ],
				 SPEC < [ LOCAL.CAT.VAL.COMPS < > ] >,
				 KCMP #kcmp,
				 COMPS < #kcmp &
                                       [ LOCAL.CONT.HOOK.LTOP #chandle ] > ] ],
		     CONT.RELS <! [ LBL #khandle ] & #altkeyrel,
				    #keyrel &
				    [ ARG2 handle & #thandle,
				      ARG3 handle & #chandle ],
				    #alt2keyrel &
				    [ LBL #thandle,
				      PRED times_rel,
				      ARG0 individual,
				      ARG1 individual,
				      ARG2 handle & #shandle,
				      ARG3 handle & #khandle ] !> ],
	     LKEYS [ KEYREL #keyrel,
		     ALTKEYREL #altkeyrel,
		     ALT2KEYREL #alt2keyrel ] ] ].

basic_adj_bare_unspecified_card_lexent := card_only_word & 
                                          unspecified_num_without_complements &
  [ SYNSEM.LKEYS.KEYREL.PRED card_rel ].

;; DPF 2017-12-08 - Tried making LPERIPH + rather than na, to block
;; *black four cats* and *red four more cats*.  But this is wrong:
;; *the original four friends* *the planned seven houses* *the best three cats*
;; But we can still block **tall five more trees* where the LPERIPH value of 
;; *five more* comes from *five*, by making LPERIPH be na_or_+ and further 
;; unifying that value with the LPERIPH of *five*'s SPEC..LPERIPH, since *more*
;; says LPERIPH + to block **tall more cats*.
;;
adj_bare_unspecified_card_lexent := basic_adj_bare_unspecified_card_lexent &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.MODIFD.LPERIPH #lper,
	     MODIFD.LPERIPH na_or_+ & #lper ] ].

adj_bare_unspecified_card_wcomps_lexent := card_only_word & 
                                           unspecified_num_with_complements &
  [ SYNSEM [ LOCAL.CAT.VAL [ KCMP #kcmp,
			     COMPS < #kcmp &
				     [ LOCAL [ CAT.HEAD fractadj,
					       CONJ num-conj ] ] > ],
	     LKEYS.ALTKEYREL.PRED card_rel ] ].

; DPF 12-aug-07 - Add variants to enable named numbers in compounds, as in
; "the 280 freeway", while still blocking spurious parse for "the five cats"

aj_-_i-crd-one_le := adj_bare_unspecified_card_lexent &
"""
Adj, card, 1 digit, no cmp       
<ex>Eight cats ran.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD intadj1,
	     PHON.DIGIT - ] ].

aj_-_i-crd-two_le := adj_bare_unspecified_card_lexent &
"""
Adj, card, 2 digit, no cmp       
<ex>Thirty cats ran.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD intadj2,
	     PHON.DIGIT - ] ].

#|
aj_-_i-crd-thr_le := adj_bare_unspecified_card_lexent &
"""
Adj, card, 3 digit, no cmp       
<ex>1000 cats ran.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD intadj3,
	     PHON.DIGIT - ] ].
|#

aj_-_i-rom-pl_le := basic_adj_bare_unspecified_card_lexent &
"""
Adj, roman numeral, greater than one
<ex>6 is even.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD intadj1 & [ MOD < [ LOCAL.AGR.PNG.PN 3p ]>,
					CASE real_case ],
             MODIFD.LPERIPH + ] ].

aj_-_i-rom-one_le := norm_card_word & unspecified_num_without_complements &
"""
Adj, roman digit I only (also letter *I*)
<ex>We study type I.
<ex>We study type I diabetes.
<nex>We study I.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD intadj1 & [ CARDINAL +,
					  MOD < anti_synsem &
						[ LOCAL.AGR.PNG.PN 3s ] >,
					  CASE real_case ],
		     CONT.RELS.LIST.FIRST.PRED card_rel ],
             MODIFD.LPERIPH + ] ].

aj_np_i-crd-one_le := adj_bare_unspecified_card_wcomps_lexent &
"""
Adj, card, 1 dig, comp           
<ex>Two and a half teams ran.
"""
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].

aj_np_i-crd-two_le := adj_bare_unspecified_card_wcomps_lexent &
"""
Adj, card, 2 dig, comp           
<ex>Twelve and a half teams ran.
"""
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].

;; DPF 2020-05-16 - Added RPERIPH - to enable blocking *hundred years elapsed*
;;
adj_bare_specified_card_lexent := card_only_word & 
                                  specified_num_without_complements &
  [ SYNSEM [ LOCAL [ CAT.VAL.SPEC *anti_list*,
		     CONT.RELS.LIST.FIRST.PRED card_rel ],
             MODIFD [ LPERIPH na,
		      RPERIPH - ] ] ].

aj_-_i-crd-hnd_le := adj_bare_specified_card_lexent &
"""
Adj, card, only 'hundred'        
<ex>Two hundred cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].

aj_-_i-crd-dzn_le := adj_bare_specified_card_lexent &
"""
Adj, card, only 'dozen'          
<ex>Two dozen cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj2- ] ].

aj_-_i-crd-thd_le := adj_bare_specified_card_lexent &
"""
Adj, card, only 'thousand'       
<ex>Two thousand cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].

aj_-_i-crd-mln_le := adj_bare_specified_card_lexent &
"""
Adj, card, only 'million'        
<ex>Two million cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].

aj_-_i-crd-bln_le := adj_bare_specified_card_lexent &
"""
Adj, card, only 'billion'        
<ex>Two billion cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].

aj_-_i-crd-trln_le := adj_bare_specified_card_lexent &
"""
Adj, card, only 'trillion'       
<ex>Two trillion cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj15,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].

aj_-_i-crd-apprx_le := adj_bare_unspecified_card_lexent &
"""
Adj, card, approx without num specifier
<ex>The dozen cats we found ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj2 & 
			    [ PRD -,
			      MOD < expressed_synsem &
				    [ LOCAL.CAT.VAL.SPR 
					< [ --MIN def_q_rel ] > ] >,
			      MINORS.ALTMIN no_rel ],
		       VAL.SPEC *anti_list*,
		       POSTHD - ] ].

;; DPF 2020-04-30 - Changed COMPS.HEAD from intadj to intadj1, to avoid
;; *thirty twenty* while keepingn *thirty two*.
;;
aj_np_i-crd-nsp_lexent := card_only_word & unspecified_num_with_complements &
  [ SYNSEM [ LOCAL.CAT [ HEAD intadj2,
			 VAL [ KCMP #kcmp,
			       COMPS < #kcmp & 
                                     [ LOCAL [ CAT.HEAD intadj1 &
						    [ MINORS.ALTMIN norm_rel ],
                                               CONJ cnil ] ] > ] ],
	     LKEYS.ALTKEYREL.PRED card_rel ] ].

aj_np_i-crd-nsp_le := aj_np_i-crd-nsp_lexent
"""
Adj, crd, 2 dg, comp,no sp       
<ex>Thirty-two cats ran.
"""
.

aj_np_i-ord-nsp_lexent := basic_ord_word & unspecified_num_with_complements &
  [ SYNSEM [ LOCAL.CAT [ HEAD intadj2,
			 VAL [ KCMP #kcmp,
			       COMPS < #kcmp & 
                                     [ LOCAL [ CAT.HEAD intadj &
						    [ MINORS.ALTMIN norm_rel ],
                                               CONJ cnil ] ] > ] ],
	     LKEYS.ALTKEYREL.PRED ord_rel ] ].

aj_np_i-ord-nsp_le := aj_np_i-ord-nsp_lexent
"""
Adj, ord, 2 dg, comp,no sp       
<ex>The thirty-second cat ran.
"""
.

adj_complemented_specified_card_lexent := norm_card_word & 
                                          specified_num_with_complements &
  [ SYNSEM.LKEYS.ALTKEYREL.PRED card_rel ].

aj_np_i-crd-hnd_le := adj_complemented_specified_card_lexent &
"""
Adj, card, only 'hundred'        
<ex>Two hundred ten cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj2-,
                             COMPS.FIRST [ LOCAL.CAT.HEAD intadj2-,
                                           MODIFD.LPERIPH na ] ] ] ].

aj_np_i-crd-thd_le := adj_complemented_specified_card_lexent &
"""
Adj, card, only 'thousnd'        
<ex>Two thousand ten cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj3- ] ] ].

aj_np_i-crd-mln_le := adj_complemented_specified_card_lexent &
"""
Adj, card, only 'million'        
<ex>Two million ten cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj6- ] ] ].

aj_np_i-crd-bln_le := adj_complemented_specified_card_lexent &
"""
Adj, card, only 'billion'        
<ex>Two billion ten cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj12,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj9- ] ] ].

aj_np_i-crd-trln_le := adj_complemented_specified_card_lexent &
"""
Adj, card, only 'trilln'         
<ex>Two trillion ten cats ran.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj15,
                       VAL [ SPR.FIRST.LOCAL.CAT.HEAD intadj3-,
                             COMPS.FIRST.LOCAL.CAT.HEAD intadj12- ] ] ].

;; DPF 2018-03-11 - This type is nearly redundant, but is used for e.g. *0* (see
;; *0 cats appear* with plural agreement), and for *1,,* and other oddly
;; punctuated numbers.  Anyway, changed LPERIPH from na to na_or_+ so we can
;; get *code 0* as title compound.
;;
aj_-_i-crd-unk_le := basic_adj_bare_unspecified_card_lexent & 
		     basic_unknown_word &
"""
Adj, card, 2 dig - unknown       
<ex>B has unknown-card cats.
<native> aj_-_i-crd-two_le
"""
  [ INFLECTD +,
    SYNSEM [ LKEYS.KEYREL.CARG #carg,
	     MODIFD.LPERIPH na_or_+ ],
    TOKENS.+LIST < [ +CARG #carg ] > ].



;; DPF 2018-05-30 - Removed LPERIPH na_or_+ so we can use this type also for
;; *the 8-ball*
;;
aj_-_i-crd-gen_le := basic_adj_bare_unspecified_card_lexent & 
		     generic_ne_lex_entry &
"""
Adj, card, 2 dig - generic       
<ex>B has generic-card cats.
<native> aj_-_i-crd-two_le
"""
  [ SYNSEM [ LKEYS.KEYREL.PRED card_rel ] ].

aj_np_i-crd-gen_le := aj_np_i-crd-nsp_lexent & 
		     generic_lex_entry &
"""
Adj, crd, 2 dg, np comp,no sp       
<ex>Thirty-two cats ran.
<native> aj_np_i-crd-nsp_le
"""
  [ SYNSEM [ MODIFD.LPERIPH na,
	     LKEYS.ALTKEYREL.CARG #carg,
	     PHON.ONSET unk_onset ],
    TOKENS.+LIST < [ +CARG #carg ] > ].    

aj_-_i-two-gen_le := adj_bare_unspecified_card_lexent & generic_lex_entry &
"""
Adj, card, 2 dig - generic       
<ex>B has generic-card cats.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD intadj2,
	     PHON.ONSET unk_onset ] ].

basic_adj_bare_unspecified_ord_lexent := ord_word & 
					 unspecified_num_without_complements.
adj_bare_unspecified_ord_lexent := basic_adj_bare_unspecified_ord_lexent &
  [ SYNSEM.LKEYS.KEYREL.PRED ord_rel ].

aj_-_i-ord-one_le := adj_bare_unspecified_ord_lexent &
"""
Adj, ord, 1 digit, no comp       
<ex>The ninth cat won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD intadj1 ].

aj_-_i-ord-two_le := adj_bare_unspecified_ord_lexent &
"""
Adj, ord, 2 digit, no comp       
<ex>The thirtieth cat won.
"""
  [ SYNSEM.LOCAL.CAT.HEAD intadj2 ].

adj_bare_specified_ord_lexent := ord_word & specified_num_without_complements &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED ord_rel ].

aj_-_i-ord-hnd_le := adj_bare_specified_ord_lexent &
"""
Adj, ord, only 'hundredth'       
<ex>The hundredth cat won.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj3,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
aj_-_i-ord-thd_le := adj_bare_specified_ord_lexent &
"""
Adj, ord, only 'thousandth'      
<ex>The thousandth cat won.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj6,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj3- ] ].
aj_-_i-ord-mln_le := adj_bare_specified_ord_lexent &
"""
Adj, ord, only 'millionth'       
<ex>The millionth cat won.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD intadj9,
                       VAL.SPR.FIRST.LOCAL.CAT.HEAD intadj6- ] ].

aj_-_i-ord-unk_le := basic_adj_bare_unspecified_ord_lexent & 
		     basic_unknown_word &
"""
Adj, ord, 1 digit, unknown       
<ex>The unknown-ordth cat won.
"""
  [ INFLECTD + ].

aj_-_i-ord-gen_le := adj_bare_unspecified_ord_lexent & generic_ne_lex_entry &
"""
Adj, ord, 1 digit, generic       
<ex>The generic-ordth cat won.
<native> aj_-_i-ord-two_le
"""
  [ SYNSEM.PHON.ONSET unk_onset ].

aj_-_i-crd-app_le := card_only_word & 
                     approx_unspecified_num_without_complements &
"""
Adj, card, approx, 2 dig         
<ex>B has thirtyish cats.
"""
  [ SYNSEM [ LOCAL.CAT.HEAD intadj2,
             MODIFD.LPERIPH na,
	     LKEYS.KEYREL.PRED card_rel ] ].

;; the constraints appropriate for all lexical entries for "one"
;; DPF 2-Feb-01 - Removed [ SPEC..OPT - ], since blocked "the one year old boy"
;; and it's not clear what it was for.
;; DPF 17-Nov-01 - Added LPERIPH na like with other numbers.  Don't know why
;; a_one_sing and a_one_plur were marked [LPERIPH -], but need LPERIPH + to 
;; block application of nominal modifier rules to measure_nps including 
;; "an inch"
;; DPF 25-Jun-03 - Tried making this [DIV -] to block "*one tobacco 
;; arrived" but this is the same "one" used in "one dozen chairs arrived".
;; Would want something fancier, where [DIV +] implied plural number,
;; to just exclude mass nouns.
;; DPF 17-may-09 - Moved RELS.ARG1 [ DIV -] to AGR, to enable coord as in
;; "one or two cats arrived"
;; DPF 2017-11-29 - Moved SPR < anti_synsem_min > down to subtypes, so we
;; can exclude adj_one_an_lexent, in order to block "a/an" as heads in
;; head-mod phrases such as *a in the park*.

basic_one_num_synsem := anycard_norm_num_synsem & zero_arg &
  [ LOCAL [ CAT [ HEAD intadj & 
                       [ CARDINAL +,
                         MINORS.MIN card_rel,
			 MOD < [ LOCAL 
				 [ CAT basic_nbar_cat &
				  [ HEAD noun_or_nomger_or_nadj &
					 [ MINORS.MIN nonpro_rel ],
				    VAL.SPR < synsem & 
					     [ --MIN quant_or_deg_rel], ... >],
				   CONT.HOOK.INDEX #index ] ] > ],
		  VAL [ SPEC < [ LOCAL.CAT.VAL.COMPS #comps ] >,
                        SPCMPS #comps ] ],
            CONT [ HOOK [ LTOP #ltop,
			  INDEX #arg0,
                          XARG #index ],
                   RELS.LIST.FIRST.PRED card_rel ] ],
    LKEYS.KEYREL [ LBL #ltop,
		   ARG0 #arg0,
		   ARG1 #index ],
    PUNCT [ LPUNCT no_punct,
            RPUNCT no_punct,
            PNCTPR ppair ] ].

one_num_synsem := basic_one_num_synsem &
  [ LOCAL [ CAT.VAL.SPR < anti_synsem_min >,
	    CONT.RELS.LIST.FIRST.CARG "1" ] ].

;; DPF 2012-08-29 - Added missing OPT - on complement, presumably intended.
;;
one_num_fract_synsem := one_num_synsem & 
  [ LOCAL [ CAT [ HEAD.PRD -,
                  VAL.COMPS < canonical_synsem &
			      [ --MIN fraction_rel & #min,
                                LOCAL [ CAT [ HEAD fractadj,
                                              VAL.COMPS < > ],
                                        CONT.HOOK [ LTOP #fhand,
						    INDEX event ],
					AGR.PNG.PN 3p ],
				OPT -,
                                PUNCT.LPUNCT no_punct ] > ],
            CONT [ RELS <! [ LBL #chand,
			     CFROM #cfrom, CTO #cto ],
			 #keyrel &
                         [ PRED plus_rel,
			   ARG0 individual,
			   ARG1 individual,
                           ARG2 handle & #chand,
                           ARG3 handle & #fhand,
			   CFROM #cfrom, CTO #cto ] !> ] ],
    MODIFD.LPERIPH +,
    LKEYS [ KEYREL #keyrel,
	    --+COMPKEY #min ] ].

;; DPF 2014-04-07 - Changed LPERIPH from + to na_or_+ so we can still get
;; *two hundred one*.

one_word := word &
  [ INFLECTD +,
    SYNSEM basic_one_num_synsem & 
           [ LOCAL.CAT.VAL.SPR < anti_synsem_min >,
	     MODIFD.LPERIPH na_or_+ ] ].

; DPF 29-May-02 - Made adj_one_lexent be HEAD intadj1 not intadj, to
; avoid "let's meet at five one" meaning "five oh one"
; DPF 13-May-03 - Managed to get by with just one entry for adj "one", even
; though we need "forty one chairs" to sustain plural number on the semantic
; index for "one", by making the 3s constraint on the AGR of the modified
; noun, so when "one" is directly a modifier, it will only modify 3s nouns.
; (This simplification also required modifying the part-num rule to unify the
; daughter's MOD..AGR value with the dtr's own AGR.
; DPF 31-May-02 - Added PRD stipulation to distinguish "one" from "a/an" for
; e.g. partitive-num and num-noun rules.
; DPF 30-sept-06 - Removed MOD..INDEX.PNG.PN 3s since this prevents making
; "one hundred" since "hundred" modifies plural noun.
;;
basic_aj_-_i-one_lexent := word &
  [ SYNSEM [ LOCAL [ CAT [ HEAD intadj1 &
                            [ PRD -,
                              MOD < [ --MIN nonpro_rel,
                                      LOCAL intersective_mod &
                                            [ CAT basic_nbar_cat,
                                              CONJ cnil,
                                              AGR.PNG.PN 3s ],
                                      MODIFD.LPERIPH na_or_- ] > ],
                           VAL.COMPS < > ],
		     CONJ cnil,
                     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel ] ].

aj_-_i-one_lexent := basic_aj_-_i-one_lexent & one_word & 
  [ SYNSEM one_num_synsem &
	   [ LOCAL.CAT.HEAD.MOD.FIRST synsem & [ LOCAL.AGR.DIV - ] ] ].

aj_-_i-one_le := aj_-_i-one_lexent &
"""
Adj, card, only 'one', not digit
<ex>One cat ran.
"""
  [ SYNSEM.PHON.DIGIT - ].

aj_-_i-one-d_le := aj_-_i-one_lexent
"""
Adj, card, only 'one', digit
<ex>We spent 1 dollar.
"""
.

aj_-_i-one-frct_lexent := basic_aj_-_i-one_lexent & one_word.

;; DPF 2017-09-15 - For *we received one-half share.*
;;
aj_-_i-one-frct_le := aj_-_i-one-frct_lexent &
"""
Adj, card, "one-half" fract 
<ex>One-half share was received.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < expressed_synsem > ].

aj_np_i-frct-one_lexent := one_word &
  [ SYNSEM one_num_fract_synsem &
           [ LOCAL [ CAT [ HEAD intadj1 & 
                                [ MOD < [ --MIN nonpro_rel,
                                          LOCAL intersective_mod &
                                                [ CAT basic_nbar_cat,
                                                  CONJ cnil ],
                                          MODIFD.LPERIPH - ] > ],
                           VAL.COMPS < lex_synsem >,
                           HC-LEX + ] ] ] ].

aj_np_i-frct-one_le := aj_np_i-frct-one_lexent &
"""
First half of fraction w/'one'   
<ex>One and one third eggs are
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.AGR.PNG.PN 3p ].

; 'a/an' of 'the string is an inch long'
; DPF 21-May-03 - Even though these are PRD + to keep them out of partitives
; and num-nouns, we still don't want them showing up as predicative complements
; and so we make them MOD anti_synsem_min, so they are incompatible with 
; prd_cat.
; DPF 5-jul-04 - While these are MOD < anti_synsem_min >, we still want to 
; prevent them from combining with plural nouns in measure-NP constructions 
; which are indifferent to PRD value, namely as complements of PPs - e.g. to 
; block *Kim arrives in a weeks".  So add AGR constraint to MOD value, which 
; the measure-NP rule already enforces.
; DPF 28-aug-04 - Since no longer using PRD to distinguish types of NPs (see
; note by nomp_cat), constrain these to combine with lexically marked 
; measure-nouns to keep an artificial lid on spurious ambiguity.  So
; allowing "an inch is enough" with MNP, but not "an engineer is enough".
; DPF 12-oct-05 - These were PRD + (see 21-May-03), but this meant we were
; parsing "*Kim found it a" analogous to "Kim found it pleasant".  So instead,
; make these [PRD -] and constrain the rules for partitives and num-dets to 
; exclude anti_synsem MOD values. (The num-noun rule is already blocking due 
; to the ALTMIN value.)
; DPF 26-apr-08 - Re 21-may-03: removed MOD < anti_synsem_min ... > because 
; the num-n_mnp_c rule requires MOD < synsem >.  These no longer undergo
; hdn_np-num_c rule because of ALTMIN no_rel.  
; DPF 27-apr-08 Added MODIFD hasmod to prevent these from undergoing 
; partitive_num rule.
;; DPF 2015-05-09 - Since we now treat sub-one decimals with a subtype of this
;; one, and we want to allow partitives for these (as in *0.5 of NP*), push
;; [MODIFD hasmod] down to subtypes.  Likewise for ALTMIN no_rel.
;; DPF 2017-07-10 - Pushed MOD..--MIN abstr_meas_nom_rel down to most subtypes,
;; to allow the generic decimal entry to undergo the num_det rule for the odd
;; singular *prices rose 0.3 cent*.

adj_one_an_lexent := word &
  [ INFLECTD +,
    SYNSEM basic_one_num_synsem & 
           [ LOCAL.CAT.HEAD intadj1 &
			    [ MOD < [ LOCAL intersective_mod &
					    [ CAT.HEAD noun,
					      AGR [ PNG.PN 3s,
						    DIV - ] ] ] > ] ] ].

; DPF 27-apr-08 - Tried adding MODIFD lmod but this also blocks "a hundred", 
; which we want. So instead, constrain num_det rule
;; DPF 2020-04-24 - Added SPR < anti_synsem_min > so meas-NP *a foot* will still
;; undergo the mnp_deg-adv rule, to give *a foot taller*.
;;
adj_one_prd_lexent := adj_one_an_lexent &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.PRD -,
			   VAL [ SPR < anti_synsem_min >,
				 COMPS < > ] ],
		     CONT.RELS <! #keyrel !> ],
	     LKEYS.KEYREL #keyrel ] ].

;; DPF 2020-04-29 - Added MOD..LPERIPH + to block *tall a foot*
;;
aj_one_nomod_lexent := adj_one_prd_lexent &
"""
Adj, only 'one' cannot modify    
<ex>The cat weighs a kilo.
"""
  [ SYNSEM [ LOCAL [ CAT.HEAD [ MOD < [ LOCAL.CAT.VAL.SPR.FIRST unexpressed,
					MODIFD.LPERIPH +,
					--MIN abstr_meas_nom_rel ] >,
				MINORS.ALTMIN no_rel ],
		     CONT [ HOOK.INDEX.PT zero,
			    RELS.LIST.FIRST.CARG "1" ] ],
	     MODIFD hasmod & [ LPERIPH na ] ] ].

aj_-_i-one-nmd_le := aj_one_nomod_lexent &
"""
Adj, only 'one' cannot modify    
<ex>The cat weighs a kilo.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PHON.ONSET con_or_unk ] >,
		       VAL.SPEC < [ PHON.ONSET con_or_unk ] >,
		       POSTHD + ] ].

aj_-_i-an-nmd_le := aj_one_nomod_lexent &
"""
Adj, only card 'an', no modif    
<ex>The cat weighs an ounce.
"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ PHON.ONSET voc_or_unk ] >,
		       VAL.SPEC < [ PHON.ONSET voc_or_unk ] > ] ].

;; DPF 2017-06-30 - To avoid spurious ambiguity for *3.56 points*, constrain
;; this one to only modify singular nouns.
;;
aj_-_i-one-gen_le := adj_one_prd_lexent & basic_basic_unknown_word &
"""
Adj, generic sub-one fract or decimal, singular agreement, no mod
<ex>The cat weighs 0.3 ounce.
<native> aj_-_i-one-nmd_le
"""
  [ SYNSEM [ LOCAL.CAT.HEAD [ CASE no_case,
			       MOD < anti_synsem & [ LOCAL.AGR.PNG.PN 3s ] > ],
	     LKEYS.KEYREL.CARG #carg ],
    TOKENS.+LIST < [ +CARG #carg ] > ].

; For 'several thousand' 'a few dozen'
; DPF 3-May-08 - Add MOD..NORM norm_rel to block "a few cat" from being
; left member of n-n-cmpnd.

aj_-_i-num_lexent := word &
  [ SYNSEM basic_one_num_synsem &
           [ LOCAL [ CAT [ HEAD intadj1 &
                            [ PRD -,
			      MOD < anti_synsem_min & 
				    [ --MIN abstr_meas_nom_rel,
				      LOCAL [ CAT [ HEAD.MINORS.NORM norm_rel,
						    VAL.SPR.FIRST unexpressed ],
					      AGR [ PNG.PN 3s,
						    DIV - ] ] ] > ],
			   VAL [ SPR < anti_synsem_min >,
				 COMPS < > ] ],
		     CONT.RELS <! #keyrel !> ],
	     LKEYS.KEYREL #keyrel ] ].

;; DPF 2017-11-29 - Removed ALTMIN no_rel because it's inconsistent with
;; newly added constraint on more_adj's specifier, which was added to block
;; *a more* while admitting *one more*.
;;
aj_-_i-num_le := aj_-_i-num_lexent &
"""
Adj, only 'several/a few'        
<ex>Cats weigh several kilos.
"""
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN meas_adj_rel ].
    
aj_-_i-num-plus_le := aj_-_i-num_lexent &
"""
Adj, only 'plus', `minus'        
<ex>Cats weigh five-plus kilos.
"""
  [ INFLECTD + ].

aj_-_i-num-nifl_le := aj_-_i-num_lexent &
"""
Adj, non-inflected, only 'a couple of'        
<ex>Cows weigh a couple of hundred kilos.
"""
  [ INFLECTD -,
    SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN no_rel ].

; 'a/an' of 'a meter and a half of snow'
; DPF 10-dec-03 - The 'and a half' synsem cannot be represented as a COMP
; since it can't be discharged until after 'a/an' has combined with the noun
; using the measure-NP rule, unlike say 'twenty' of 'twenty two foot'.  So
; this synsem is treated as a SPEC value, and is propagated by the MNP rule
; onto the COMPS list of the phrase.
; [HC-LEX -] prevents "*an and a half hours" since MNP rule requires left dtr
; to be LEX +, so get "one and a half hours".
; DPF 05-may-05 - Re 10-dec-03: corrected, and now put the complement on COMPS.

adj_one_fract_lexent := adj_one_an_lexent &
  [ SYNSEM one_num_fract_synsem &
           [ LOCAL [ CAT [ HEAD [ MINORS.ALTMIN no_rel,
				  MOD.FIRST.--MIN abstr_meas_nom_rel ],
			   VAL.COMPS < phr_synsem >,
			   HC-LEX - ],
		     CONT.RELS.LIST.FIRST.CARG "1" ],
             MODIFD hasmod & [ LPERIPH + ] ] ].

aj_np_i-frct-a_le := adj_one_fract_lexent &
"""
Cardinal adj combining with con-N and then fraction
<ex>A day and a half
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET con_or_unk ] > ].

aj_np_i-frct-an_le := adj_one_fract_lexent &
"""
Cardinal adj combining with voc-N and then fraction
<ex>An hour and a half
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PHON.ONSET voc_or_unk ] > ].

; 'a half'
;; DPF 2019-11-20 - Added MOD.FIRST expressed_synsem to block as input to
;; num-det rule as in **a half cats*
;; DPF 2020-04-19 - Removed ALTMIN fraction_rel so we can get partitive as in
;; *3 1/2 arise* or *we saw 20 1/2 bid*.  CHECK.
;; Also, re 2019-11-20: But this blocks *2 1/2 cats appear*, and instead add
;; constrain MOD..AGR..PN on subtypes to block wrong agreement for num-det as
;; in **2 1/2 cat arises*
;; DPF 2020-04-25 - Changed SPR from < > to < anti_synsem_min > so meas-NP
;; with fract can undergo pred mnp_degadv, as in *1/4 point larger*.
;;
fraction_num_synsem := anycard_norm_num_synsem & abstr_lex_synsem &
  [ LOCAL [ CAT [ HEAD fractadj & 
                       [ CARDINAL +,
                         MINORS.MIN fraction_rel ],
                  VAL [ SPR < anti_synsem_min >,
                        COMPS < >,
                        SPEC < [ LOCAL.CAT.VAL.COMPS #comps ] >,
			SPCMPS #comps & < > ],
		  POSTHD - ],
            CONT [ HOOK [ LTOP #lbl,
			  INDEX #arg0,
                          XARG #index ],
                   RELS <! #keyrel &
                         [ PRED fraction_rel,
                           LBL #lbl,
			   ARG0 #arg0,
                           ARG1 #index ] !>,
                   HCONS <! !>,
		   ICONS <! !> ] ],
    LKEYS.KEYREL #keyrel,
    MODIFD.LPERIPH na ].

fraction_word := word &
  [ INFLECTD +,
    SYNSEM fraction_num_synsem &
           [ PUNCT no_punctuation_min ] ].

aj_-_i-frct_le := fraction_word &
"""
Adj, fraction                    
<ex>Two and a half arrived.
"""
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.AGR.PNG.PN 3s ].

aj_-_i-frct-gen_le := fraction_word & generic_ne_lex_entry &
"""
Adj, fraction - generic          
<ex>Two and generic-f arrived.
<native> aj_-_i-frct_le
"""
  [ SYNSEM [ PHON.ONSET unk_onset,
	     LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.AGR.PNG.PN 3p ] ].

; Types for unknown and generic words
basic_generic_lex_entry := word.

; For form-derived generics like an email address
generic_lex_entry := basic_generic_lex_entry &
  [ TOKENS.+LIST < [ +TNT null_tnt ] > ].

generic_ne_lex_entry := generic_lex_entry &
  [ SYNSEM.LKEYS.KEYREL.CARG #carg,
    TOKENS.+LIST < [ +CARG #carg ] > ].

; For POS-tag-derived generics like unknown proper names
basic_basic_unknown_word := basic_generic_lex_entry & nonconj & mcna.

basic_unknown_word := basic_basic_unknown_word &
  [ SYNSEM.PHON.ONSET unk_onset ].

norm_unknown_word := basic_unknown_word &
  [ SYNSEM [ LOCAL.CONT.HOOK.LTOP #ltop,
             LKEYS.KEYREL [ LBL #ltop,
			    PRED #pred ] ],
    TOKENS.+LIST.FIRST.+PRED #pred ].

unknown_word := norm_unknown_word &
  [ INFLECTD + ].

generic_v_np*_trans_lex_entry := unknown_word & basic_main_verb &
  [ SYNSEM np_trans_verb &
	   [ LOCAL [ CAT [ VAL.COMPS < [ OPT + ] > ],
		     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & [ PRED string ] ] ].

v_np*_unk_le := basic_main_verb & norm_unknown_word &
"""

<native> v_np*_le
"""
  [ INFLECTD -,
    SYNSEM np_trans_verb &
	   [ LOCAL [ CAT [ VAL.COMPS < [ OPT + ] > ],
		     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & [ PRED  "generic_v_rel" ] ] ].

;; DPF 2014-12-17 - Changed this generic entry to serve both for uninflected
;; base form and inflected pres-non3sg, parallel to the treatment of normal
;; inflectional rules in the current grammar.  This overcomes a tendency for
;; POS taggers like TnT to assign the base-form "VB" tag much more readily
;; than the pres-non3sg "VPB" tag.
;;
v_np*_bse-unk_le := generic_v_np*_trans_lex_entry &
"""
Cmps NP(opt), generic unk, bse   
<ex>B can unk-verb.
<native> v_n3s-bse_ilr & [ SYNSEM.LOCAL bse_verb ] v_np*_le
"""
  [ SYNSEM.LOCAL bse_or_non3sg_verb ].

v_np*_pr-3s-unk_le := generic_v_np*_trans_lex_entry &
"""
Cmps NP(opt), generic unk, 3sing 
<ex>B unk-verbs.
<native> v_3s-fin_olr v_np*_le
"""
  [ SYNSEM.LOCAL third_sg_fin_verb ].

;; DPF 2017-11-04 - Generalized just like for v_np*_bse-unk_le to serve for
;; both base and pres-non3sg.
v_np*_pr-n3s-unk_le := generic_v_np*_trans_lex_entry &
"""
Cmps NP(opt), generic unk, non3s 
<ex>We unk-verb.
<native>v_n3s-bse_ilr & [ SYNSEM.LOCAL non_third_sg_fin_verb ] v_np*_le
"""
  [ SYNSEM.LOCAL bse_or_non3sg_verb ].

v_np*_pa-unk_le := generic_v_np*_trans_lex_entry &
"""
Cmps NP(opt), generic unk, past  
<ex>We unk-verbed.
<native> v_pst_olr v_np*_le
"""
  [ SYNSEM.LOCAL past_or_subj_verb ].

v_np*_psp-unk_le := generic_v_np*_trans_lex_entry &
"""
Cmps NP(opt), generic unk, psp   
<ex>We have unk-verbed.
<native> v_psp_olr v_np*_le
"""
  [ SYNSEM.LOCAL psp_verb ].

v_np*_prp-unk_le := generic_v_np*_trans_lex_entry &
"""
Cmps NP(opt), generic unk, prp   
<ex>We are unk-verbing.
<native> v_prp_olr v_np*_le
"""
  [ SYNSEM.LOCAL prp_verb ].

v_-_pas-unk_le := unknown_word & basic_main_verb_sans_key & 
"""
No cmps, psv - unknown           
<ex>B was generic-verbed.
<native> v_-_psv_le
"""
  [ SYNSEM passive_unerg_synsem &
           [ LOCAL [ CAT [ HEAD [ MINORS.MIN nonaux_event_rel ],
			   MC na ],
		     CONT.HOOK.LTOP #ltop ],
	     LKEYS.KEYREL [ LBL #ltop,
			    PRED string ] ] ].

; DPF 15-may-08 - Don't identify AGR with HOOK.INDEX, since we want uninflctd
; mass-or-count to be modifiable by plural adjectives, as in "six glump house"
;
generic_n_intr_lex_entry := basic_unknown_word &
  [ SYNSEM unsp_common_noun_synsem &
	   [ LOCAL [ CAT [ HEAD noun & [ MINORS.MIN norm_nom_rel ],
                           VAL.SPR < [ --MIN abstract_q_rel ] > ],
                     CONT.RELS <! #keyrel !> ],
             LKEYS.KEYREL #keyrel & [ PRED string ] ,
	     MODIFD notmod & [ LPERIPH na ],
	     PHON.ONSET unk_onset ] ].

n_-_c-sg-unk_le := generic_n_intr_lex_entry & unknown_word &
"""
Icn for unknown sing.nouns       
<ex>B bought an unk-noun.
"""
  [ SYNSEM noun_nocomp_synsem & 
	   [ LOCAL sing_noun ] ].

n_-_c-sg-gen_le := generic_n_intr_lex_entry & generic_lex_entry &
"""
Icn for generic sing.nouns       
<ex>B bought a generic-noun.
"""
  [ SYNSEM noun_nocomp_synsem & [ LOCAL sing_noun ] ].

n_-_m-unk_le := generic_n_intr_lex_entry & unknown_word &
"""
Mass, unknown                    
<ex>B won noununk.
"""
  [ SYNSEM mass_noun_synsem & [ LOCAL mass_noun ] ].

; DPF 12-may-08 - Let's try restricting this to singular, letting the
; tagger predict plural nouns separately

n_-_mc-unk_lexent := generic_n_intr_lex_entry &
  [ INFLECTD -,
    SYNSEM basic_mass_or_count_nocomp_synsem & 
           [ LOCAL noun_local &
		   [ CAT [ HEAD.--BARE -,
			   VAL.SPR < [ LOCAL.AGR.PNG.PN 3s ] > ],
                     CONT.HOOK.LTOP #ltop,
		     AGR.PNG.PN 3s ],
             LKEYS.KEYREL.LBL #ltop ] ].

n_-_mc-unk_le := n_-_mc-unk_lexent & norm_unknown_word
"""
Mass-count, unknown              
<ex>B won the noununk.
<native> n_-_mc_le
"""
.

n_-_c-pl-unk_le := generic_n_intr_lex_entry & unknown_word &
"""
Icn, unknown plur                
<ex>B won noununks.
<native> n_pl_olr n_-_mc_le
"""
  [ SYNSEM mass_or_count_nocomp_synsem & 
           [ LOCAL plur_noun ] ].

;; DPF 2014-04-15 - Change INFLECTD from + to na_or_+ in order to admit
;; *the 1960s car*
;;
n_-_c-pl-gen_lexent := generic_ne_lex_entry &
  [ INFLECTD na_or_+,
    SYNSEM mass_or_count_nocomp_synsem & 
	   [ LOCAL plur_noun &
		   [ CAT [ HEAD noun & [ MINORS.MIN norm_nom_rel ],
                           VAL.SPR < [ --MIN abstract_q_rel ] > ],
                     CONT [ HOOK [ LTOP #lbl,
				   INDEX #arg0 ],
			    RELS <! #keyrel !> ] ],
             LKEYS.KEYREL #keyrel & named_nom_relation &
		                    [ PRED year_range_rel,
				      LBL #lbl,
				      ARG0 #arg0 ],
	     PUNCT no_punctuation_min,
             MODIFD notmod,
	     PHON.ONSET unk_onset ] ].

n_-_c-pl-gen_le := n_-_c-pl-gen_lexent &
"""
Icn, generic plur used for *'70s*, *1800s*
<ex>Kim arrived in the 1800s.
<native> n_pl_olr n_-_mc_le
"""
  [ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST expressed_synsem ].

; Inflected noun, unmarked for number or div, used for 'ersatz' nouns like
; OSCARCOMPOUND
n_-_mc-ifl_le := nonc-hm & basic_noun_word &
"""
Mass-count noun, inflected, generic, only for NE `OSCARCOMPOUND'
<ex>OSCARCOMPOUND
<native> n_-_mc_le
"""
  [ INFLECTD +,
    SYNSEM noun_nocomp_synsem &
	   [ LOCAL [ CAT.HEAD [ MINORS.MIN norm_nom_rel,
				--BARE - ],
		     CONT [ RELS <! relation !>,
                            HCONS <! !>,
			    ICONS <! !> ] ],
             MODIFD notmod,
             LKEYS.KEYREL reg_nom_relation ] ].

; DPF 12-sept-07 - Restrict these to attributives, since the predicatives
; give rise to too much ambiguity (esp. with depictives and robust-np-sg).
; DPF 11-may-08 - But we need these in predicative position as well, so
; block from depictives via MINORS.NORM
; DPF 24-mar-09 - Don't know why SPR was anti_synsem, but this blocked any
; degree specifiers, including 'very' and 'most'.
; DPF 24-apr-09 - Re 11-may-08: But this blocks adjectives in n_vora_cmpnds,
; sigh, so instead constrain to POSTHD -, still blocking unknown adj 
; depictives, but allowing n-nh_vorj-cpd_c.
; DPF 30-apr-09 - But then unknown adjs can't be the complement of "be".
; So let's just try letting them be depictives, since it's not easy to block. 
; DPF 07-jun-09 - Can't remember what trick motivated the COMPS <anti_synsem>,
; but it does not play well with aj-hdn_adjn_c, since that complement gets 
; passed up from adj to mother.  Let's drop it and see what we lose ...
;; DPF 2011-10-22 - Added MODIFD notmod to avoid spurious application of
;; partitive_intadj rule.
;
aj_-_i-unk_le := unknown_word &
"""
Adj, unknown positive            
<ex>The adjunk dog ran.
<native> aj_-_i_le
"""
  [ SYNSEM adj_onearg_lex_synsem &
           [ LOCAL [ CAT [ HEAD adj & 
			      [ MOD < synsem_min &
				      [ LOCAL 
					[ CAT 
					  [ HEAD basic_nom_or_ttl &
						 [ POSS - ],
					    VAL [ SUBJ < >,
						  SPR.FIRST synsem & 
						    [ --MIN quant_or_deg_rel ],
						  COMPS < > ],
					    MC na ],
					  CONJ cnil ],
					--SIND #ind ] >,
				MINORS.MIN abstr_adj_rel ],
			   VAL [ SPR.FIRST synsem & 
					   [ --MIN more_or_very_deg_rel ],
				 COMPS < > ] ],
		     CONT [ HOOK.XARG #ind,
                            RELS <! #keyrel !> ] ],
             LKEYS.KEYREL #keyrel & [ PRED string,
				      ARG1 #ind ],
	     MODIFD notmod,
	     NONLOC non-local_none ] ].

aj_-_i-cmp-unk_le := unknown_word &
"""
Adj, unknown comparative         
<ex>The compadjunk dog ran.
<native> aj_pp_i-cmp_le & [ SYNSEM.LOCAL.CAT.VAL.COMPS &lt; unexpressed &gt; ]
"""
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind ] >,
                                  MINORS.ALTMIN comp_rel ],
                           VAL [ SPR.FIRST.--MIN much_deg_rel,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
				      PRED string,
                                      ARG1 #ind ],
                                  #altkeyrel &
                                  [ LBL #hand,
                                    ARG1 #ind ] !> ] ],
             LKEYS.ALTKEYREL #altkeyrel & [ PRED more_comp_rel ],
	     MODIFD notmod,
	     NONLOC non-local_none ] ].

;; DPF 2012-09-26 - Constrained HEAD to be superl_adj to avoid spurious ambig
;;
aj_-_i-sup-unk_le := unknown_word &
"""
Adj, unknown superlative         
<ex>The supadjunk dog ran.
<native> aj_-_i-sup_le
"""
  [ SYNSEM adj_synsem &
           [ LOCAL [ CAT [ HEAD superl_adj &
				[ MOD < [ --SIND #ind ] >,
                                  MINORS.ALTMIN superl_rel ],
                           VAL [ SPR.FIRST.--MIN much_deg_rel,
                                 COMPS < > ] ],
                     CONT [ HOOK.XARG #ind,
                            RELS <! [ LBL #hand,
				      PRED string,
                                      ARG0 #arg0,
                                      ARG1 #ind ],
                                  #altkeyrel &
                                  [ LBL #hand,
                                    ARG1 #arg0 ] !> ] ],
             LKEYS.ALTKEYREL #altkeyrel & [ PRED superl_rel ],
	     MODIFD notmod,
	     NONLOC non-local_none ] ].

av_-_i-unk_le := unknown_word & noncqrs &
"""
Adv, int, unknown                
<ex>C arrived advunk.
<native> av_-_i-vp_le
"""
  [ SYNSEM intersect_adverb_synsem & 
            [ LOCAL [ CAT [ HEAD adv &
			       [ MOD < [ LOCAL.CAT.HEAD v_or_g_or_a ] > ],
			    VAL.SPR.FIRST.--MIN more_or_very_deg_rel ],
		      CONT.RELS <! #keyrel !> ],
	      LKEYS.KEYREL #keyrel & [ PRED string ] ] ].

;; Generic quoted word for foreign-word sequences
;;
n_-_gq_le := norm_unknown_word &
"""
Generic quoted word for foreign-word sequences
<ex>the ``chevalier'' award
"""
  [ INFLECTD na_or_+,
    SYNSEM [ LOCAL [ CAT [ HEAD fw & [ MOD < >,
				       PRD -,
				       MINORS.MIN no_rel ],
			   VAL [ SPR < >,
				 SUBJ < >,
				 COMPS < >,
				 SPCMPS < >,
				 SPEC < > ] ],
                     CONT [ HOOK [ LTOP #ltop,
				   INDEX basic_non_expl & #index ],
			    RELS <! #keyrel !>,
			    HCONS <! !>,
			    ICONS <! !> ] ],
	     NONLOC non-local_none,
             LKEYS.KEYREL #keyrel &
		          [ PRED "quoted_rel",
			    LBL #ltop,
			    ARG0 #index,
			    CARG #carg ],
	     PHON.ONSET unk_onset ],
    TOKENS.+LIST < [ +CARG #carg ] > ].

basic_punct_word := basic_word &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD punct_hd & [ PRD -, MOD < >, 
                                             MINORS.MIN punct_rel ],
                           VAL [ SUBJ < >, SPR < >, SPEC < >,
                                 COMPS < expressed_synsem &
                                         [ OPT -, 
                                           LOCAL.CAT.HEAD subst_or_func ] > ]],
                     CONT [ HOOK.INDEX basic_non_expl,
			    RELS <! !>, 
			    HCONS <! !>,
			    ICONS <! !> ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
	     	      REL 0-dlist ],
             LKEYS.KEYREL.PRED punct_rel ] ].

punct_word := basic_punct_word &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < abstr_lex_or_deriv_synsem > ].

basic_punct_right_word := punct_word &
  [ SYNSEM [ LOCAL.CAT [ VAL.COMPS < [ NONLOC.QUE #que ] >,
			 POSTHD + ],
             NONLOC.QUE #que,
             PUNCT [ LPUNCT no_punct,
                     RPUNCT punct_mark ] ] ].

punct_right_word := basic_punct_right_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT.RCLSTR #rclstr,
             PUNCT.RCLSTR #rclstr ] ].

;; DPF 2019-11-25 - COMPS has to be abstr_lex_or_deriv_synsem in order to
;; admit left-italic *⌊/ happy /⌋ cat* where "happy" has to have first undergone
;; attr_adj rule.
;;
basic_punct_left_word := punct_word &
  [ SYNSEM [ LOCAL.CAT [ VAL.COMPS < [ PUNCT.RCLSTR [ RPAREN #rparen,
						      RFP #rfp ],
				       NONLOC.QUE #que ] >,
			 POSTHD - ],
             NONLOC.QUE #que,
             PUNCT [ LPUNCT punct_mark,
                     RPUNCT no_punct,
		     RCLSTR [ RPAREN #rparen,
			      RFP #rfp ] ] ] ].

punct_left_word := basic_punct_left_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.LCLSTR #lclstr ] >,
	     PUNCT.LCLSTR #lclstr ] ].

; Sentence-ending dash, for informal writing
pt_-_s-dash_le := punct_right_word &
"""
Punct, sentence dash             
<ex>B arrived - C left.
"""
  [ SYNSEM.PUNCT.RPUNCT s_dash_punct ].

; Sentence-ending threedots
pt_-_3dots-rgt_le := punct_right_word &
"""
Punct, three dots S-final        
<ex>B arrived ...
"""
  [ SYNSEM.PUNCT.RPUNCT 3dots_punct ].
    

#|
pt_-_dbl-hyphn_le := punct_right_word &
"""
Punct, double hyphen             
<ex>B arrived -- C left.
"""
  [ SYNSEM.PUNCT [ RPUNCT hyphen_dbl,
                   PNCTPR no_ppair ] ].
|#

;; DPF 2019-11-21 - Removed PNCTPR no_ppair since we also want to use this dash
;; with *to* of  *day-to-day*, where hcomp doesn't want no_ppair on head.
;;
pt_-_hyphn-rgt_le := punct_right_word &
"""
Punct, single hyphen             
<ex>B - the winner - arrived.
"""
  [ SYNSEM.PUNCT.RPUNCT hyphen_sgl ].
                                 
colon_copula_synsem := norm_two_arg_subst &
  [ LOCAL [ CAT [ HEAD verb &
		       [ VFORM fin,
			 MOD < >,
			 MINORS.MIN be_v_id_rel,
			 PRD -,
			 AUX -,
			 INV -,
			 TAM #tam & [ ASPECT [ PRF -,
					       PROGR - ] ] ],
		  POSTHD -,
		  HC-LEX -,
		  VAL [ SUBJ < canonical_synsem & #subj &
			       [ --MIN nom_or_mnp_rel,
				 LOCAL [ CAT nomp_cat_min &
					     [ HEAD.CASE nom ],
					 CONJ cnil ],
				 --SIND #id1ind & non_expl-ind,
				 OPT - ] >,
			SPR < anti_synsem_min >,
			COMPS #comps & 
			      < [ --MIN nom_or_mnp_rel,
				  LOCAL [ CAT nomp_cat_min & 
					      [ HEAD.MOD < >,
						VAL.SPEC *cons* ],
					  CONT.HOOK.LTOP #ltop,
					  CONJ cnil ],
				  --SIND #id2ind & non_expl-ind,
				  NONLOC non-local_none,
				  OPT - ] > ] ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #event & [ E #tam ],
			  XARG #id1ind ],
		   RELS <! #keyrel !>,
		   HCONS <! !>,
		   ICONS <! !> ],
	    CONJ cnil,
	    AGR.PNG png & [ PN 3 ],
	    ARG-S < #subj . #comps > ],
    NONLOC non-local_none,
    PUNCT [ LPUNCT no_punct,
	    RPUNCT colon_punct ],
    MODIFD hasmod,
    LKEYS.KEYREL #keyrel & arg12_relation &
	  [ PRED _colon_v_id_rel,
	    LBL #ltop,
	    ARG0 #event,
	    ARG1 #id1ind,
	    ARG2 #id2ind ] ].

; For colon copula with NP subject, as in "Owners: Abrams and Browne"
v_np_colon_le := mcna &
"""
Cmps NP(obl), only colon         
<ex>Owners: C and D
"""
  [ INFLECTD +,
    ALTS.ADVADD -,
    SYNSEM colon_copula_synsem ].

colon_copula_nb_synsem :=  basic_two_arg &
  [ LOCAL [ CAT [ HEAD verb &
		       [ VFORM fin,
			 MOD < >,
			 MINORS.MIN be_v_id_rel,
			 PRD -,
			 AUX -,
			 INV -,
			 TAM #tam & [ TENSE real_tense,
				      ASPECT [ PRF -,
					       PROGR - ] ] ],
		  POSTHD -,
		  VAL [ SUBJ < >,
			SPR < synsem_min & 
			      [ --MIN norm_nom_rel,
				LOCAL [ CAT nbar_cat &
					    [ VAL.SPCMPS < >,
					      HEAD.CASE nom ],
					CONT.HOOK [ LTOP #nltop,
						    INDEX #nind ],
					AGR [ PNG.PN 3p,
					      DIV - ],
					CONJ cnil ],
				--SIND #id1ind & non_expl-ind,
				NONLOC non-local_none,
				OPT - ] >,
			COMPS < [ --MIN nom_or_mnp_rel,
				  LOCAL [ CAT nomp_cat_min & 
					      [ HEAD.MOD < >,
						VAL.SPEC *cons* ],
					  CONT.HOOK.LTOP #ltop,
					  CONJ cnil ],
				  --SIND #id2ind & non_expl-ind,
				  NONLOC [ SLASH 0-dlist,
					   REL 0-dlist ],
				  OPT - ] > ],
		  MC + ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #event & [ E #tam ],
			  XARG #id1ind ],
		   RELS <! #keyrel, 
			 #altkeyrel &
			 [ PRED udef_q_rel,
			   ARG0 #nind & ref-ind,
			   RSTR #rstr ] !>,
		   HCONS <! qeq & [ HARG #rstr, LARG #nltop ] !>,
		   ICONS <! !> ],
	    CONJ cnil,
	    AGR.PNG png & [ PN 3 ] ],
    NONLOC non-local_none,
    PUNCT [ LPUNCT no_punct,
	    RPUNCT colon_punct ],
    MODIFD notmod,
    LKEYS [ KEYREL #keyrel &
		   [ PRED _colon_v_id_rel,
		     LBL #ltop,
		     ARG0 #event,
		     ARG1 #id1ind,
		     ARG2 #id2ind ],
	    ALTKEYREL #altkeyrel ] ].

; For colon copula with nbar subject, as in "Owner: Abrams"
; Only for uninflected nouns, since cannot force inflection on singular nbars.
v_np_colon-nb_le := hc-to-phr &
"""
Cmps NP(obl), nbar-sbj - colon   
<ex>Owner: C and D
"""
  [ INFLECTD +,
    SYNSEM colon_copula_nb_synsem ].

colon_copula_nb_nb_synsem := basic_two_arg &
  [ LOCAL [ CAT [ HEAD verb &
		       [ VFORM fin,
			 MOD < >,
			 MINORS.MIN be_v_id_rel,
			 PRD -,
			 AUX -,
			 INV -,
			 TAM #tam & [ TENSE real_tense,
				      ASPECT [ PRF -,
					       PROGR - ] ] ],
		  POSTHD -,
		  VAL [ SUBJ < >,
			SPR < synsem_min & 
			      [ --MIN norm_nom_rel,
				LOCAL [ CAT nbar_cat &
					    [ VAL.SPCMPS < > ],
					CONT.HOOK [ LTOP #nltop,
						    INDEX #nind ],
					AGR [ PNG.PN 3p,
					      DIV - ],
					CONJ cnil ],
				--SIND #id1ind & non_expl-ind,
				NONLOC non-local_none,
				OPT - ] >,
			COMPS < [ --MIN reg_nom_rel,
				  LOCAL [ CAT nbar_cat & 
					      [ HEAD.MOD < >,
						VAL.SPCMPS < > ],
					  CONT.HOOK [ LTOP #ctop,
						      INDEX #cind ],
					  CONJ cnil ],
				  --SIND #id2ind & non_expl-ind,
				  NONLOC [ SLASH 0-dlist,
					   REL 0-dlist ],
				  OPT - ] > ],
		  MC + ],
	    CONT [ HOOK [ LTOP #ltop,
			  INDEX #event & [ E #tam ],
			  XARG #id1ind ],
		   RELS <! #keyrel & [ CFROM #cfrom, CTO #cto ],
			 [ PRED udef_q_rel,
			   ARG0 #nind & ref-ind,
			   RSTR #rstr,
			   CFROM #cfrom, CTO #cto ],
			 #altkeyrel &
			 [ PRED udef_q_rel,
			   ARG0 #cind & ref-ind,
			   RSTR #crstr ] !>,
		   HCONS <! qeq & [ HARG #rstr, LARG #nltop ],
			  qeq & [ HARG #crstr, LARG #ctop ]!>,
		   ICONS <! !> ],
	    CONJ cnil,
	    AGR.PNG png & [ PN 3 ] ],
    NONLOC non-local_none,
    PUNCT [ LPUNCT no_punct,
	    RPUNCT colon_punct ],
    MODIFD notmod,
    LKEYS [ KEYREL #keyrel &
		   [ PRED _colon_v_id_rel,
		     LBL #ltop,
		     ARG0 #event,
		     ARG1 #id1ind,
		     ARG2 #id2ind ],
	    ALTKEYREL #altkeyrel ] ].

; For 'owner: young consultant'
v_nb_colon-nb_le := hc-to-phr &
"""
Cmps Nbar(obl), nbar-sbj - colon 
<ex>Owner: young manager
"""
  [ INFLECTD +,
    SYNSEM colon_copula_nb_nb_synsem ].

;; For idioms with a simple transitive verb, such as *kick the bucket*
;;
v_np_idm_lexent := main_verb_mliszt & 
  [ SYNSEM np_trans_verb &
	   [ LOCAL.CAT [ VAL.COMPS < [ OPT - ] > ] ],
    IDIOM + ].

never_unify_lex := word &
  [ SYNSEM.LOCAL.CAT [ HEAD fw & [ MINORS.MIN never_unify_rel,
				   MOD < > ],
		       VAL [ SPR < >,
			     SUBJ < >,
			     COMPS < > ] ] ].

never_unify_le := never_unify_lex &
"""
For overwriting to block existing lex entries, as in educ
"""
  [ INFLECTD -,
    ARGS < never_unify_lex &
	   [ INFLECTD + ] > ].

;; DPF 2014-08-01 - Added type for a generic "bridging" lexical entry to fill
;; lexical gaps in the chart when doing robust full-forest treebanking
;;
x_-_bridge_le := noncqrs & mcna &
"""
Generic `bridging' lexical entry for robust parsing
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD bridge_head & [ MINORS.MIN never_unify_rel,
						MOD < > ],
			   VAL [ SUBJ < >,
				 SPR < >,
				 COMPS < >,
				 SPCMPS < > ] ],
		     CONT [ HOOK [ LTOP #ltop,
				   INDEX #ind ],
			    RELS <! #keyrel !>,
			    HCONS <! !> ] ],
	     LEX +,
	     LKEYS.KEYREL #keyrel & [ LBL #ltop,
				      PRED #pred,
				      ARG0 #ind ],
	     PHON.ONSET unk_onset ],
    TOKENS.+LIST < [ +CLASS bridge_class, +PRED #pred ] >,
    INFLECTD na ].

;; Patches for experiment with Pacman bridging
;;
;; Prevent bridged analysis of *the cat*
basic_det_word :+ [ SYNSEM.--BRDG na ].
aj_-_i-att-nsp_le :+ [ SYNSEM.--BRDG na ].
norm_adj_word :+ [ SYNSEM.--BRDG na ].

punct_right_clause_word := punct_right_word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT.RPUNCT clause_or_pair_or_no_punct,
             PUNCT [ PAIRED no_ppair,
		     RPUNCT clause_punct ] ] ].

pt_-_period_le := punct_right_clause_word &
"""
Punct, period
<ex>B arrived.
"""
  [ SYNSEM.PUNCT.RPUNCT.PSF punct-prop-comm ].


pt_-_qmark_le := punct_right_clause_word &
"""
Punct, question mark
<ex>B arrived?
"""
  [ SYNSEM.PUNCT.RPUNCT.PSF punct-ques ].

pt_-_bang_le := punct_right_clause_word &
"""
Punct, bang
<ex>B arrived!
"""
  [ SYNSEM.PUNCT.RPUNCT.PSF punct-prop-comm ].

;; DPF 2020-07-22 - Tried changing COMPS..RPUNCT from pair_or_no_punct to
;; clause_or_pair_or_no_punct so we can be more robust about misplaced periods
;; as in "We arrived on Nov. 20., happily".  But this leads to systematic
;; unwanted ambiguity for "Acme Inc., the ...".  So undo here, and overwrite
;; for educ to gain more robustness.
;;
pt_-_comma_le := punct_right_word &
"""
Punct, comma
<ex>B arrived, yesterday.
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT.RPUNCT pair_or_no_punct,
             PUNCT [ PNCTPR no_ppair,
	  	     PAIRED no_ppair,
		     LPUNCT no_punct,
		     RPUNCT comma_punct ] ] ].

pt_-_comma-informal_le := punct_right_word &
"""
Punct, comma, informal
<ex>B knows, we arrived.
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT.RPUNCT pair_or_no_punct,
             PUNCT [ PNCTPR ppair,
	  	     RPUNCT rbcomma_punct ] ],
    GENRE nonformal ].

pt_-_semicolon_le := punct_right_word &
"""
Punct, semicolon
<ex>B arrived; we left.
"""
  [ SYNSEM.PUNCT [ PAIRED no_ppair ,
		   RPUNCT semicol_punct &
                          [ PSF prop-or-pol-ques-or-comm ] ] ].


pt_-_rparen_le := basic_punct_right_word &
"""
Punct, right parenthesis
<ex>B arrived (today)
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT [ PAIRED no_ppair,
					       LCLSTR.LPAREN - ],
	     PUNCT [ RPUNCT rparen_punct,
		     RCLSTR.RPAREN na_or_+ ] ] ].

pt_-_lparen_le := basic_punct_left_word &
"""
Punct, left parenthesis
<ex>B arrived (today)
"""
  [ SYNSEM [ PUNCT [ LPUNCT lparen_punct,
		     LCLSTR.LPAREN na_or_+ ] ] ].

pt_-_dqright_le := basic_punct_right_word &
"""
Punct, right double quotes
<ex>B arrived "today"
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT [ PAIRED no_ppair,
					       LPUNCT no_punct,
					       RCLSTR.RPAREN #rparen ],
	     PUNCT [ RPUNCT dq_punct,
		     RCLSTR [ RITAL +,
			      RPAREN #rparen ] ] ] ].

;; DPF 2020-05-12 - Constrain ORTH.RB to ensure attachment of right dq before
;; left one.
;;
pt_-_dqleft_le := punct_left_word &
"""
Punct, left double quotes
<ex>B arrived "today"
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT.LPUNCT pair_or_no_punct,
	     PUNCT [ LPUNCT dq_punct,
		     RCLSTR.RITAL - ] ] ].

pt_-_sqright_le := basic_punct_right_word &
"""
Punct, right single quote
<ex>B arrived 'today'
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT [ LPUNCT no_punct,
					       RCLSTR.RPAREN #rparen ],
	     PUNCT [ RPUNCT sq_punct,
		     RCLSTR [ RITAL +,
			      RPAREN #rparen ] ] ] ].

pt_-_sqleft_le := punct_left_word &
"""
Punct, left single quote
<ex>B arrived 'today'
"""
  [ SYNSEM [ PUNCT [ LPUNCT sq_punct,
		     RCLSTR.RITAL - ] ] ].

pt_-_asterisk-pref_le := punct_left_word &
"""
Punct, asterisk prefix
<ex>The *cat arrived.
"""
  [ SYNSEM.PUNCT.LPUNCT asterisk_punct ].

;; DPF 2019-11-20 - These next four are not tested yet.
;;
pt_-_italleft_le := punct_left_word &
"""
Punct, left italics
<ex>The ⌊/ cat /⌋ arrived.
"""
  [ SYNSEM [ PUNCT [ LPUNCT lital_punct,
		     RCLSTR.LITAL + ],
	     LOCAL.CAT.VAL.COMPS.FIRST.PUNCT.RCLSTR.RITAL - ] ].

pt_-_italright_le := basic_punct_right_word &
"""
Punct, right italics
<ex>The ⌊/ cat /⌋ arrived.
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT [ LPUNCT lital_or_no_punct,
					       RPUNCT #rpunct,
					       RCLSTR.RPAREN #rparen ],
	     PUNCT [ LPUNCT lital_or_no_punct,
		     RPUNCT #rpunct,
		     RCLSTR [ RFP +,
			      RPAREN #rparen,
			      RITAL + ] ] ] ].

pt_-_drop-italleft_le := punct_left_word &
"""
Punct, left italics
<ex>The ⌊/ tall /⌋ cat arrived.
"""
  [ SYNSEM [ PUNCT.LPUNCT no_punct_dropped,
	     LOCAL.CAT.VAL.COMPS.FIRST.PUNCT.RCLSTR [ IGNOREQ -,
						      RITAL - ] ] ].

pt_-_drop-italright_le := basic_punct_right_word &
"""
Punct, right italics
<ex>The ⌊/ tall /⌋ cat arrived.
"""
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.FIRST.PUNCT [ LCLSTR #lclustr,
					       LPUNCT no_punct,
					       RPUNCT #rpunct &
						      clause_or_no_punct,
					       RCLSTR.RPAREN #rparen ],
	     PUNCT [ LCLSTR #lclustr,
		     LPUNCT lital_or_no_punct,
		     RPUNCT #rpunct,
		     RCLSTR [ RFP -,
			      RPAREN #rparen,
			      IGNOREQ +,
			      RITAL - ] ] ] ].

;; 2020-05-12 - Block in vmod phrase via NORM no_rel.
;;
adv_word_internal_punct := word_or_punct_rule &
  [ ORTH [ LB bracket_null, RB bracket_null ],
    INFLECTD +,
    SYNSEM [ PHON.ONSET.--TL #tl,
	     LOCAL [ CAT.HEAD.MINORS [ MIN adv_rel,
				       NORM no_rel ],
		     CONT [ HOOK.LTOP #ltop,
			    RELS <! #keyrel !> ],
		     CONJ cnil ],
	     NONLOC non-local_none,
	     PUNCT no_punctuation_min,
	     LKEYS.KEYREL #keyrel & [ LBL #ltop,
				      CFROM #from,
				      CTO #to ] ],
    ORTH [ CLASS #class, FROM #from, TO #to, FORM #form ],
    TOKENS [ +LIST #tl & < [ +CLASS #class, +FROM #from, +FORM #form ] , ... >,
	     +LAST.+TO #to ] ].

;; For *(b)* of *You can (a) stay or (b) leave.*
;;
av_-_s-vp-intpnct_le := adv_word_internal_punct &
  [ SYNSEM scopal_vp_adverb_synsem &
       [ LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD v_or_g_or_a,
					      VAL [ SUBJ *synlist*,
						    COMPS < > ] ],
				  MODIFD [ LPERIPH na_or_-,
					   RPERIPH na_or_- ] ] >,
		     MC na ] ] ].

av_-_s-cp-pr-intpnct_le := adv_word_internal_punct &
  [ SYNSEM scopal_s_adverb_nospec_synsem &
	   [ LOCAL.CAT [ POSTHD -,
			 HEAD.MOD < [ LOCAL.CAT.MC bool ] > ] ] ].
