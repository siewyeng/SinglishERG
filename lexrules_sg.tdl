;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2018
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  lexrules.tdl
;;;
;;;  Inflectional affixes and derivational lexical rules
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;
;;;  $Id: lexrules.tdl 7479 2010-02-21 23:11:30Z danf $


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Inflectional affixes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verbal inflections

non_fin_verb := local & 
  [ CAT.HEAD verb ].

; Need to constrain MOD value for PRP verbs.  Also for passive participles.

;; Verbal affix for present and passive participles, which can modify N-bars
;; DPF (7-Apr-99) Removed POSTHD - since the head_complement rule now passes
;; up the value of POSTHD from the head-dtr, so we need to leave it unmarked
;; to get "managers interviewed by Abrams" on the passive-by reading, and also
;; to still get "the interviewed managers"

;; Present participles and passives are both marked as PRD +, to block e.g. 
;; "the destroyed by Sandy chair" or "the talking to Kim consultant", but then
;; to get these participles alone in attributive position, we need a 
;; generalization of the attributive-adjective lexical rule below.
;; DPF 19-Feb-01 - To avoid massive unwanted ambiguity as in "Kim is sleeping"
;; restrict the MOD value to [AUX -].  
;; DPF 24-Mar-01 - Added SUBJ..SLASH 0-dlist to avoid spurious gaps.
;; DPF 18-Aug-01 - Removed [SUBJ.OPT -] to allow participle phrases without
;; subjects to be no-copula clauses, as in "arriving tomorrow".
;; DPF 24-Sep-01 - Added [MOD..TENSE real_tense as hack to block participles
;; from modifying nocop VPs, as in "partial clearing" - works since nouns have
;; underspecified TAM.
;; DPF 18-Apr-03 - From 19-Feb-01 - This also blocks "I am available starting
;; on Monday"
;; DPF 27-Apr-03 - Note that in blocking ambiguity for "Kim is sleeping"
;; (see 19-Feb-01), we also prevent an analysis for "Kim is happy driving",
;; so probably want to remove this constraint once parse ranking can carry the
;; load, given that there are also contexts where we want "Kim is, sleeping"
;;
verb_participle_affix := local &
  [ CAT [ HEAD verb & [ PRD + ],
	  VAL.SUBJ < synsem &
		     [ LOCAL.AGR #agr,
		       NONLOC.SLASH 0-dlist ] >,
	  HC-LEX - ],
    AGR #agr ].

prp_verb := non_fin_verb & verb_participle_affix &
  [ CAT.HEAD [ VFORM prp,
	       TAM.ASPECT [ PROGR + ] ] ].

; DPF 27-May-01 - Removed [ASPECT.PRF +] since this form is also used for
; passives, and since the auxiliary "have" already imposes PRF + on the
; relevant event.
; DPF 11-Nov-03 - Gave up on using past-participle form as input for passive,
; since this lack of constraint on PROGR created too much trouble for 
; generation, since "Kim has arrived" didn't say [PROGR -] so we could get
; 'Kim is being hired'.  One disadvantage is that we have to stipulate
; duplicate irregular passive forms for the irregular past participles.
; DPF 25-Oct-06 - Removed PROGR - since we want to parse "having arrived",
; and since the 11-Nov-03 difficulty has been resolved.

psp_verb := non_fin_verb &
  [ CAT [ HEAD [ VFORM psp,
                 TAM.ASPECT.PRF +,
		 PRD - ],
	  VAL.SUBJ < [ OPT - ] > ] ].

; DPF 12-May-00 - bse_verb needs to have [ MOD nbar ] to enable coordination
; of imperative and declarative clauses, as in "Leave and I will follow you"
; DPF 17-Oct-01 - Made ASPECT be no_aspect rather than no_aspect* in order to
; let K2Y distinguish true base-VPs from participles.
; DPF 7-Nov-03 - Remember that bse_verb can't have TENSE no_tense (which would
; be convenient for generation) since it can combine with "do" as in "did the
; dog bark?"
; DPF 12-aug-07 - Removed constraint < SUBJ unexpressed_reg > since we want
; to parse "Kim suggested we be early".

bse_or_non3sg_verb := local &
  [ CAT [ HEAD [ VFORM fin_or_bse_or_imp,
                 PRD -,
		 TAM.ASPECT no_aspect,
                 --ADDIN [ ADDPN -3s,
			   ADDTAM indic_tam & [ TENSE present ] ] ],
          POSTHD +,
	  VAL.SUBJ < synsem & [ OPT -,
                                LOCAL [ CAT.HEAD.CASE nom,
                                        CONT nom-obj,
                                        CONJ cnil,
                                        AGR #agr ] ] > ],
    AGR #agr ].

; Only used for unknown verbs
bse_verb := non_fin_verb & bse_or_non3sg_verb &
  [ CAT.HEAD.VFORM bse ].

bse_singlish_verb := local &
"""
CSY 17-9-2020 for Singlish, no inflection verbs (take away no_aspect)
optional SUBJ, took away person number
<ex>he eat already.
"""
  [ CAT [ HEAD [ VFORM fin,
                 PRD -,
                 --ADDIN [ ADDTAM indic_tam & [ TENSE present ] ] ],
          POSTHD +,
	  VAL.SUBJ < synsem & [ OPT +,
                                LOCAL [ CAT.HEAD.CASE nom,
                                        CONT nom-obj,
                                        CONJ cnil,
                                        AGR #agr ] ] > ],
    AGR #agr ].


; Since finite verbs can project relative clauses, we introduce [MOD < nbar >]
; here, and make sure that no other projections of finite verbs can be
; adjuncts, through constraints on the head-adjunct phrase type.
; DPF 4-Mar-01 - Removed [CONT.MSG no_msg] from SUBJ, to allow e.g.
; "me hiring you bothered him"

basic_fin_verb := local &
  [ CAT [ HEAD verb &
               [ PRD -,
		 VFORM fin ],
	  POSTHD +,
	  VAL.SUBJ < synsem & [ LOCAL [ CAT.HEAD.CASE nom,
                                        CONJ cnil ] ] > ] ].

fin_verb := basic_fin_verb & 
  [ CAT.VAL.SUBJ < [ OPT - ] > ].

pres_verb := fin_verb & 
  [ CAT.HEAD.TAM indic_tam &
		 [ TENSE present,
		   ASPECT no_aspect ] ].

; DPF 06-mar-06 - Can't identify SUBJ's --SIND..PN and AGR..PN since we now
; have sentential subjects where the --SIND value is a handle which does not
; have a PNG attribute.  Instead, make SUBJ's AGR..PN unify with verb's.

past_or_subj_verb := fin_verb &
  [ CAT [ HEAD.TAM past_or_subj_tam,
          VAL.SUBJ.FIRST.LOCAL.AGR.PNG.PN #pn ],
    AGR.PNG.PN #pn ].

; DPF 30-Sept-05 - Tempted to make --SIND..PN 3s to improve generator 
; efficiency (not proposing 3sg verb when argument is plural).  But this
; desire clashes with assumption that syntactic AGR and semantic INDEX are
; not always identical, e.g. for treatment of numerals as in "Six is even."
; where the semantics of the adjective "six" has a plural index, but the
; hdn_np-num_c rule makes a syntactically singular nominal out of it.  So we
; (currently) have to live with the extra work in generation.  Or maybe
; we add PNG to restrictor, since it rarely helps given above assumption
; about potential mismatch.

third_sg_fin_verb := pres_verb &
  [ CAT.VAL.SUBJ < [ LOCAL.AGR.PNG.PN 3s ] >,
    AGR.PNG png & [ PN 3s ] ].

; Only used for unknown verbs
non_third_sg_fin_verb := pres_verb & bse_or_non3sg_verb &
  [ CAT.VAL.SUBJ < [ LOCAL local & [ CONT nom-obj ] ] >,
    AGR.PNG png & [ PN -3s ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Nominal inflections

noun_local := local &
  [ CONT.HOOK.INDEX nonconj_ref-ind ].

sing_or_plur_noun := noun_local.

sing_noun := sing_or_plur_noun &
  [ CAT [ HEAD noun_or_ttl,
          VAL.SPR.FIRST.LOCAL.AGR [ PNG.PN 3s,
				    DIV - ] ],
    CONT.HOOK.INDEX [ PNG png & [ PN 3s ],
                      DIV - ] ]. 

;; DPF 2020-05-17 - Don't need to stamp INDEX.DIV + here since it is already
;; thus constrained in almost all subtypes of basic_basic_mass_noun_synsem,
;; except for `time' as in *a long time*
;;
mass_noun := noun_local &
  [ CAT [ HEAD noun_or_ttl,
          VAL.SPR < [ LOCAL.AGR [ PNG.PN 3s,
                                  DIV + ] ] > ],
    CONT.HOOK.INDEX [ PNG png & [ PN 3s,
                                  GEN neut ] ] ]. 

mass_count_noun := noun_local &
  [ CAT [ HEAD noun_or_ttl & [ --BARE - ],
          VAL.SPR < [ LOCAL.AGR.PNG.PN 3s ] > ],
    CONT.HOOK.INDEX.PNG png & [ PN 3s ] ].

;; DPF 2020-01-14 - Added AGR..PN 3p since --SIND and AGR are not always
;; reentrant for plurals as they are for singulars.
;;
plur_noun := sing_or_plur_noun &
  [ CAT [ HEAD noun_or_ttl,
          VAL.SPR < [ LOCAL.AGR [ PNG.PN 3p,
                                  DIV + ] ] > ],
    AGR.PNG.PN 3p,
    CONT.HOOK.INDEX [ PNG.PN 3p,
		      IND +,
                      DIV + ] ].

;; As a hack to prevent inflected nouns in certain constructions, add this:
noninfl_noun_local := noun_local.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Adjectival inflections
;;
;;  May-96: Martina

pos_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ --MIN very_deg_rel ] > ] ].


er_comp_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ --MIN much_deg_rel ] > ] ].


est_super_adj := local &
  [ CAT [ HEAD adj,
          VAL.SPR < [ --MIN def_explicit_q_rel,
                      OPT - ] > ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Place holder affix for -ly

-ly := local & [ CAT.HEAD no_head ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  (Non-inflectional) lexical rules
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; AAC - INFLECTD added so that the relationship between inflectional 
;;; morphology and lexical rules can be represented declaratively
;;;
;;; lex_rule_infl turns uninflected things into inflected ones
;;; but otherwise does inheritance
;;; everything else requires inflected forms
;;; ND-AFF ('needs affix') is used to determine whether a rule has an overt
;;; suffix which triggers the spelling-change rules.
;; DPF 2016-11-07 - Preserve chart-dependency identities for --+COMPKEY,
;; --+OCOMPKEY, and --+ARGIND through lexical rules, so that derived entries 
;; do not allow leakage.  For example, *put together* was allowing other 
;; *put* verb-particle entries in via attr_verb_part lexical rules, which had 
;; lost the --+COMPKEY constraint.
;; DPF 2020-05-23 - Move identif of --+ARGIND down to subtypes, since at least
;; one lexical rule, v_pas-cp_lexrule, needs to change, since its input requires
;; an expletive-it subj, but the derived form instead takes a CP subject, and
;; if --+ARGIND is preserved, chart dependencies will exclude the derived edge,
;; since no expletive "it" is in the chart for a sentence such as
;; *that she would win was expected by everyone*
;;
basic_lex_rule_supermost := word_or_lexrule &
  [ ND-AFF bool,
    DTR sign & [ IDIOM #idiom,
                 DIALECT #dialect,
		 ALTS #alts,
                 SYNSEM [ LOCAL local & 
				[ CONT [ RELS [ LIST #rfirst,
						LAST #rmiddle ],
					 HCONS [ LIST #hcfirst,
						 LAST #hcmiddle ],
					 ICONS [ LIST #icfirst,
						 LAST #icmiddle ] ] ],
			  LKEYS [ --+COMPKEY #ckey,
				  --+OCOMPKEY #ockey ] ] ],
    IDIOM #idiom,
    DIALECT #dialect,
    ALTS #alts,
    SYNSEM canonical_lex_or_phrase_synsem &
           [ LOCAL local &
                   [ CONT [ RELS [ LIST #rfirst,
                                   LAST #rlast ],
                            HCONS [ LIST #hcfirst,
                                    LAST #hclast ],
			    ICONS [ LIST #icfirst,
                                    LAST #iclast ] ] ],
	     LKEYS [ --+COMPKEY #ckey,
		     --+OCOMPKEY #ockey ] ],
    ORTH [ TO #to,
	   FORM #form ],
    ARGS.FIRST.ORTH [ TO #to,
		      FORM #form ],
    C-CONT [ RELS [ LIST #rmiddle,
                    LAST #rlast ],
             HCONS [ LIST #hcmiddle,
                     LAST #hclast ],
	     ICONS [ LIST #icmiddle,
                     LAST #iclast ] ] ].

lex_rule_supermost := basic_lex_rule_supermost &
  [ SYNSEM abstr_lex_synsem,
    TOKENS #tokens,
    ORTH.CLASS #class,
    ARGS.FIRST [ ORTH.CLASS #class,
		 TOKENS #tokens ] ].

; DPF 14-Aug-99 - Reorder appending of RELS from above since treatment of 
; fragments looks for the first scope hole from left to right in RELS, and 
; the first definition below gives different results for "October first" and 
; "the first of October".
; DPF 22-May-00 - But lexical rules in general may want to change categories,
; and the output's properties should conform to the type; for example, the
; rule for partitives wants to have the output be a noun, so the first element
; on RELS should be a nom_rel, not the quant_rel which the DTR would supply.
; So we go back to the original appending model, and leave the proper
; treatment of scope holes in fragments for later solutions.

basic_lex_rule_basic := lex_rule_supermost & word_or_nonpunct_rule &
  [ DTR [ SYNSEM [ LOCAL.CONJ cnil,
                   PUNCT #punct & [ LPUNCT no_punct,
				    RPUNCT no_punct ] ],
	  GENRE #genre ],
    SYNSEM [ LOCAL.CONJ cnil,
             PUNCT #punct,
	     PHON.ONSET #onset ],
    GENRE #genre,
    ARGS.FIRST.SYNSEM.PHON.ONSET #onset ].

lex_rule_basic := basic_lex_rule_basic &
  [ DERIVED + ].

;; DPF 2014-08-19 - Make dtr be word_or_nonpunct_rule  to prevent inflectional 
;; rules from applying spuriously after the italics rules (or other punctuation
;; rules) have applied.
;;
basic_lex_rule_infl_affixed := basic_lex_rule_basic & word_or_infl_rule &
  [ KEY-ARG #keyarg,   
    SYNSEM #synsem,
    ARGS < #dtr >,
    DTR #dtr & word_or_nonpunct_rule &
	       [ INFLECTD -,
                 KEY-ARG #keyarg,   
                 SYNSEM #synsem ],
    C-CONT.RELS <! !> ].

lex_rule_infl_affixed := basic_lex_rule_infl_affixed &
  [ INFLECTD + ].

norm_lex_rule := lex_rule_basic &
  [ DTR word_or_lexrule & #stem &
	[ SYNSEM [ LOCAL [ CAT [ MC #mc,
				 HC-LEX #hclex ] ],
		   LKEYS.--+ARGIND #argind ],
	  KEY-ARG #keyarg ],
    SYNSEM [ LOCAL [ CAT [ MC #mc,
                           HC-LEX #hclex ] ],
	     LKEYS.--+ARGIND #argind ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    INFLECTD + ].

lex_rule := norm_lex_rule &
 [ DTR.INFLECTD + ].

;;
;;  Forms derived from inflected verbs
;;

; ERB (05-10-97) Before we had a special rule hcomp_yn_root for matrix polar
; questions.  Now, the unique head complement rule is taking over this job.
; To do this, we must put the int_m_rel onto the inverted auxiliaries (see also
; sai_synsem).  The original objection to this was that the inverted
; auxiliaries are used for things other than matrix questions (i.e., negative
; inversion).  However, a) we don't currently have an analysis of negative
; inversion, and b) it's not clear that they are the same auxiliaries.  The
; most obvious test -- 1st person aren't -- is not available since the
; contracted auxiliaries are in general disallowed in negative inverstion
; (polarity effect?).
;
; At the moment this is allowing "Will who sleep?" and "Will Kim see who?"
; (actually two parses of the latter).  This is fine, except that this is not
; producing the apropriate semantics.  In fact, all ynq (matrix and
; subordinate) are not currently specified for PARAMS.  I think this will be
; easier to fix once we have a) lexical threading and b) an implementation of
; the analysis of echo questions, so I am leaving it for later.
 
; DPF (10-Jan-99) Added SUBJ value identified with dtr's SPR value (usually
; < anti_synsem > which never unifies with real synsem), in order to allow 
; adjunct extraction to still apply to inverted sentences such as "When is 
; Kim happy" where "is Kim happy" is built by two applications of the head_comp
; rule.  By identifying SUBJ with dtr's SPR, we can maintain lexical control
; over modifiability, in particular blocking spurious modification of 
; auxiliary "do", both in noninverted and inverted clauses.
; DPF 22-Apr-00 - Added reentrancy for VFORM on DTR and mother - don't know
; why this was omitted before.  It's needed to block spurious parse for e.g. 
; "Could you sleep please"
; DPF 5-Jul-02 - Removed re-entrancy of SYNSEM..SUBJ..INDEX with dtr's, since
; it was wrecking coordination of "did Kim win or did Sandy win, since the
; SUBJ..INDEX got identified for both.  So what do we give up?
 
; ERB (2003-10-13) Making a supertype to keep mal_sai as close to sai as
; possible.

basic_sai := lex_rule_basic &
  [ ORTH #orth,
    DTR 
     [ ORTH #orth,
       SYNSEM 
        [ LOCAL [ CAT [ HEAD verb &
                             [ VFORM fin & #vform,
			       MINORS #minors ],
                        VAL [ SUBJ < #subj & canonical_synsem &
                                     [ LOCAL [ CAT nomp_cat_nom ] ] >,
                              COMPS #comps,
                              SPR #spr,
			      SPCMPS #spcmps,
                              KCMP #keycomp ] ],
		  AGR #agr ],
          NONLOC #nonloc,
	  MODIFD #modif,
	  LKEYS [ KEYREL [ CFROM #cfrom, CTO #cto ],
		  --+ARGIND #argind ] ] ],
    SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				  MINORS #minors ],
			   VAL [ COMPS < #subj & [ OPT - ]
					 . #comps >,
				 SPR #spr,
				 SPCMPS #spcmps,
				 SUBJ < anti_synsem >,
				 KCMP #keycomp ] ],
		     AGR #agr ],
	     NONLOC #nonloc,
	     MODIFD #modif,
	     LKEYS [ KEYREL [ CFROM #cfrom, CTO #cto ],
		     --+ARGIND #argind ] ],
    C-CONT.ICONS <! !> ].

; DPF 28-mar-05 - Now propagate AUX from daughter, since we need cop-id to
; be unmarked for AUX, so it can be modified by PPs, as in "where is Kim the
; king?"
; DPF 20-oct-09 - In fact, we won't propagate AUX so we can also get e.g.
; "how old will Kim be on Tuesday", where we're still trying to avoid spurious
; ambiguity by not attaching PPs to AUX + phrases, but we need to in this
; inverted sentence construction because there is no "lower" VP to attach the
; modifier to.
;; DPF 2016-08-02 - We want to have inverted auxiliaries be marked as 
;; non-elliptical unless they have undergone the ellipsis rule, in order to 
;; block *So did Kim arise.*  Hence split this rule into two, one for 
;; non-ellipsis and one for ellipsis, and stamp ALTMIN non_ellipt_rel on
;; the dtr of the first.

sai := basic_sai & norm_lex_rule &
  [ SYNSEM basic_sai_synsem &
	   [ LOCAL [ CAT [ HEAD [ MOD < [ --MIN no_rel,
					  LOCAL intersective_mod &
					      [ CAT.VAL.SPR *cons* ] ] >,
				  TAM #tam ],
			   MC na,
			   POSTHD + ],
		     CONT.HOOK #hook ] ],
    DTR [ SYNSEM.LOCAL [ CAT.HEAD [ INV +,
				    TAM #tam ],
			 CONT.HOOK #hook ],
	  ALTS.SAI + ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

sai_nonell_lexrule := sai &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN non_ellipt_rel ].

sai_ell_lexrule := sai &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN ellipsis_rel,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

;; DPF 2012-09-10 - Changed MOD..NONLOC non-local_none to REL,QUE 0-dlist,
;; to allow non-empty SLASH, as in *on the other hand, had they stayed, Kim
;; would have cried*

cond_sai := basic_sai & 
  [ SYNSEM basic_sai_synsem &
	   [ LOCAL.CAT 
	      [ HEAD [ MOD < synsem &
			   [ LOCAL scopal_mod &
				   [ CAT [ HEAD verb &
						[ MOD < anti_synsem_min > ],
					   VAL [ SUBJ *anti_list*,
						 COMPS < > ],
					   MC #mc ],
				     CONT.HOOK [ LTOP #modltop,
						 INDEX #modind ],
				     CONJ cnil ],
			     NONLOC [ REL 0-dlist,
				      QUE 0-dlist ] ] >,
		       TAM subjnct_tam,
		       MINORS #minors ],
		MC #mc,
		HC-LEX #hclex ],
	     NONLOC non-local_none ],
    DTR word_or_lexrule & #stem &
	[ SYNSEM [ LOCAL [ CAT [ HEAD [ INV +,
					TAM.MOOD basic_subjunctive,
					MINORS #minors ],
				 VAL.COMPS *substlist*,
				 HC-LEX #hclex ],
			   CONT.HOOK.LTOP #dltop ],
		   LKEYS.KEYREL [ CFROM #from, CTO #to ] ],
	  KEY-ARG #keyarg,
	  ALTS.CSAI + ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    INFLECTD +,
    C-CONT [ HOOK [ LTOP #lbl,
		    INDEX #modind ],
	     RELS <! subord_relation &
		   [ LBL #lbl,
		     PRED "_if_x_then_rel",
		     ARG0 [ E [ TENSE no_tense,
				ASPECT no_aspect ] ],
		     ARG1 #main,
		     ARG2 #subord,
		     CFROM #from, CTO #to ] !>,
	     HCONS <! qeq & [ HARG #main,
			      LARG #modltop ],
		      qeq & [ HARG #subord,
			      LARG #dltop ] !> ] ].

;; DPF 2020-07-17 - This derived entry needs to also "liberate" the 
;; --ADDIN.ADDPN properties of the clause it modifies, to avoid 
;; "The dog bark, didn't it?". But note that it can't expose the ADDTAM, since
;; we want "The dog is barking, isn't it" where the derived-ellipsis "isn't" 
;; in the tag has TAM..PROGR -.
;; 
tag := lex_rule_basic &
  [ ORTH #orth,
    INFLECTD +,
    DTR #stem &
	[ ORTH #orth,
	  SYNSEM sai_synsem &
	       [ LOCAL [ CAT [ HEAD verb &
                                    [ TAM #tam,
                                      MINORS [ MIN #min,
                                               ALTMIN ellipsis_rel ] ],
			       VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX.PNG #png ]>,
                               HC-LEX #hclex ],
                         CONT.HOOK [ LTOP #tltop,
                                     INDEX #index,
                                     XARG #xarg ],
                         AGR #agr ],
                 NONLOC #nonloc & non-local_none,
		 LKEYS [ KEYREL [ CFROM #from, CTO #to ],
			 --+ARGIND #argind ] ] ],
    SYNSEM tag_synsem &
     [ LOCAL [ CAT [ HEAD [ TAM #tam,
			    MINORS.MIN #min,
			    MOD < [ LOCAL [ CAT.HEAD.--ADDIN.ADDPN #pn,
					    AGR.PNG.PN #pn,
					    CONT.HOOK [ LTOP #mltop,
							XARG #subjind ] ] ] > ],
		     VAL.COMPS.FIRST synsem & 
                                  [ LOCAL [ CAT nomp_cat_nom_min,
                                            CONT.HOOK.INDEX #xarg &
                                                [ PNG #png ],
                                            CONJ cnil ],
                                    OPT - ], 
                         HC-LEX #hclex ],
                   CONT.HOOK.INDEX #index,
                   AGR #agr ],
           NONLOC #nonloc,
	   LKEYS [ KEYREl [ CFROM #from,
			    CTO #to ],
		   --+ARGIND #argind,
		   ALTKEYREL [ CFROM #from,
			       CTO #to ] ] ],
    C-CONT [ HOOK.LTOP #ltop,
             RELS <! [ LBL #ltop,
                       PRED ne_x_rel,
                       ARG0 event,
                       ARG1 #mltop,
                       ARG2 #tltop,
		       CFROM #from, CTO #to ],
                     [ LBL #ltop,
                       PRED id_rel,
                       ARG0.E.TENSE no_tense,
                       ARG1 #subjind,
                       ARG2 #xarg,
		       CFROM #from, CTO #to ] !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #stem > ].


; DPF 31-Jul-99 - Removed [INV -] from DTR, since it blocked entry for
; "Is that also important?"
; DPF 1-Jun-01 - Removed DTR..SUBJ canonical_synsem, since prevents relative
; clauses headed by these, as in "messages that are not valid fail".
; DPF 3-Jun-01 - Made DTR..VFORM fin rather than fin* to avoid V+ADV analysis
; of "be not happy"
; DPF 13-Sep-01 - Copy attributes of HEAD from dtr to mother, to make sure that
; dtr is [AUX +] but mother is [AUX +*] so it will still coordinate with nonaux
; ERB 2003-10-13 Make supertype to keep mal_adv_addition as close as possible.
; DPF 19-apr-05 - Block adv_addition rule from applying to negated auxiliaries,
; since these (uniquely) have ALT2KEYREL.PRED neg_rel, while the positive ones
; are unconstrained.
; DPF 25-nov-05 - Removed AUX + from mother, since it was preventing adjunct-
; extraction for e.g. "In Berlin, Browne is also Abrams"
; DPF 08-oct-06 - Note that this rule does not correctly get the scope right
; for "must not" which idiosyncratically gives the modal scope over the
; the neg_rel.  Can't simply split rule, since would have to overwrite the
; qeq in the lexical entry for "must" to insert neg_rel in scope chain.  So
; probably need to manually add separate "must not" lexical entry and block
; application of this rule to "must".  Then what about non-neg adverbs with
; "must"?  FIX someday.
;; DPF 2012-12-21 - Removed dtr's ALT2KEYREL.PRED never_unify_rel,
;; since this blocked e.g. *Kim isn't always Abrams*
;; DPF 2020-05-23 - One might think to block output of this rule as input to 
;; subj-aux inversion, but in fact that order is needed for *when is a rose not
;; a rose?*
;;
basic_adv_addition := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
          ALTS.ADVADD +,
	  SYNSEM auxverb_or_itcleft_synsem &
               [ LOCAL [ CAT [ HEAD verb &
				    [ VFORM #vform & fin,
				      TAM #tam,
				      AUX #aux,
				      INV #inv,
				      MOD #mod,
				      PRD #prd,
				      MINORS #minors  ],
			       VAL [ SUBJ #subj & < synsem >,
				     COMPS #comps & *substlist*,
				     SPR #spr ],
			       POSTHD #ph ],
			 CONT [ HOOK #hook &
                                     [ INDEX #vindex,
                                       XARG #xarg ] ],
                         CTXT #ctxt ],
		 NONLOC #nonloc ] ],
    SYNSEM basic_aux_verb &
	 [ LOCAL 
	   [ CAT 
	     [ HEAD verb & [ VFORM #vform,
			     TAM #tam,
			     AUX #aux,
			     INV #inv,
			     MOD #mod,
			     PRD #prd,
			     MINORS #minors & [ ALTMIN #altmin ] ],
               VAL [ SUBJ #subj,
		     COMPS *cons* &
			  < [ LOCAL local &
			     [ CAT [ HEAD basic_lexadv &
                                     [ MOD < [ LOCAL [ CONT.HOOK #hook,
						       CAT [ HEAD.MINORS.ALTMIN 
									#altmin,
							     VAL.SUBJ #subj]]]>,
				       TAM #tam ],
                                     VAL.COMPS < > ],
                               CONT [ HOOK.LTOP #advltop ] ],
                              LEX +,
			      OPT - ] . #comps >,
		     SPR #spr ],
	       POSTHD #ph ],
	     CONT [ HOOK [ LTOP #advltop,
                           INDEX #vindex,
                           XARG #xarg ] ],
	     CTXT #ctxt ],
	   NONLOC #nonloc ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2013-11-08 - Split this rule into two, one for "not" and one for the
;; rest, since only "not" can be added to an elliptical aux verb, while they
;; can all appear with verbs that have overt complements.  Thus *we should not*
;; but not *we should never*, *we should both*, etc.

adv_addition := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS *cons* ].

adv_add_neg_ellipt := basic_adv_addition &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.MINORS.MIN neg_rel ].

;; VP Ellipsis
;; We can't let this rule apply to the infinitival "to", since we would then
;; have no way of blocking the NP "the book to", where "to" first underwent
;; this rule, then the subject-extraction rule (needed for ordinary infinitival
;; relatives), and then the usual infinitival relative rule.  So instead we
;; create a separate lexical entry for the elided form of "to", and make it
;; MOD < >.
;; DPF 24-Jun-01 - Made DTR be TAM.ASPECT nonprg to prevent "Kim is being".
;; DPF 31-May-02 - This may not have been enough, so tried adding VFORM 
;; fin_or_bse.
;; DPF 28-Nov-03 - But then we don't get "Kim has been", so removed it; now
;; we should block "kim is being with the ASPECT.PROGR - constraint.
;; DPF 11-mar-05 - Removed AUX + since now restricting PPs to modify only
;; [AUX -] VPs.
;; DPF 2011-08-23 - For now, exclude elided verbs in inverted conditionals,
;; even though they can be okay at least in S-initial position, in context:
;; [We hadn't left the door open.] *Had we, the flies would have entered.*
;; But it's hard to find good examples in S-final position:
;; ... *? The files would have left, had we.*
;; And there is spurious ambiguity for e.g. *Who did we know were programmers?*
;; DPF 2016-12-02 - Try changing dtr's COMPS.FIRST from canonical_or_unexpressed
;; to just unexpressed, so that we can prevent robust auxiliaries such as
;; has_aux_finc_rbst from also undergoing ellipsis.
;;
vp_ellipsis := lex_rule &
  [ ORTH #orth,
    ALTS.CSAI -,
    DTR [ ORTH #orth,
          ALTS.VPELLIP +,
	  SYNSEM basic_aux_verb &
	   [ LOCAL 
             [ CAT 
               [ HEAD verb &
                      [ MOD #mod,
                        PRD #prd,
                        INV #inv,
			AUX +,
                        TAM #tam & [ ASPECT.PROGR - ],
                        VFORM #vform,
                        MINORS.MIN #min ],
                 POSTHD #ph,
                 VAL [ SUBJ #subj,
                       SPR #spr,
                       COMPS < unexpressed &
			       [ LOCAL [ CAT.HEAD subst,
                                         CONT.HOOK 
                                                  [ LTOP #chand,
                                                    INDEX #cind ] ],
				 NONLOC.SLASH 0-dlist ], ... > ] ],
	       CONT.HOOK [ LTOP #hand,
			   INDEX #ind ],
               CTXT #ctxt ],
             LKEYS [ KEYREL.PRED #keyrelpred,
                     ALT2KEYREL #alt2keyrel ],
             NONLOC #nonloc ] ],
    SYNSEM basic_aux_verb &
	 [ LOCAL [ CAT [ HEAD verb & 
                              [ MOD #mod,
                                PRD #prd,
                                INV #inv,
                                TAM #tam,
                                VFORM #vform,
                                MINORS [ MIN #min,
                                         ALTMIN ellipsis_rel ] ],
                         POSTHD #ph,
			 VAL [ SUBJ #subj & 
				    [ FIRST.NONLOC [ QUE #que, REL #rel ] ],
			       SPR #spr,
			       COMPS < > ] ],
                   CONT [ HOOK [ LTOP #hand,
                                 INDEX #ind ] ],
                   CTXT #ctxt ],
           LKEYS [ KEYREL.PRED #keyrelpred,
                   ALTKEYREL #altkeyrel & arg1_relation &
                               [ LBL #chand,
                                 PRED ellipsis_rel,
                                 ARG0 #cind & non_conj_sement ],
                   ALT2KEYREL #alt2keyrel ],
           NONLOC #nonloc & [ QUE #que, REL #rel ] ],
    C-CONT [ RELS <! #altkeyrel !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

vp_ellipsis_ref := vp_ellipsis &
  [ DTR.SYNSEM.LOCAL [ CAT.VAL.COMPS < [ --SIND #cind ] >,
                       CONT.HOOK.XARG non_expl-ind & #sind ],
    SYNSEM [ LOCAL.CONT.HOOK.XARG #sind,
	     LKEYS.ALTKEYREL [ PRED ellipsis_ref_rel,
			       ARG0 #cind,
			       ARG1 #sind ] ] ].
                   
; DPF 25-jul-05 - Block there-copula from undergoing ellipsis, since the
; (raising) predicative copula can also take a there-subject when elided.
; DPF 20-feb-10 - But blocking the there-copula meant that we had to have
; a bogus over-unification type `be_v_prd-or-there_rel' for tag questions
; like `There is a cat, isn't there', and eventually disadvantages of this
; unmotivated type emerged.  So go back to allowing this rule to apply to
; there-copula as well.
;; DPF 2012-06-12 - The INDEX value was wrongly reentrant with the ARG0 of 
;; the ALTKEYREL: this worked for the expletive-it ordinary copula `be' 
;; which has no RELS, but not for the there-copula which adds its own
;; _be_v_there_rel.  Fix this by unifying the ellipsis-rel's ARG0 with
;; the index of the first complement on the dtr.
;
vp_ellipsis_expl := vp_ellipsis &
  [ DTR.SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN be_v_there-or-prd_rel,
                             VAL [ SUBJ < [ --SIND expl-ind & #sind ] >,
                                   COMPS.FIRST synsem &
					[ --SIND #cindex ] ] ],
		 LKEYS [ KEYREL.LBL #lbl,
			 --+ARGIND #subjind ] ],
    SYNSEM [ LOCAL.CONT.HOOK.XARG #sind,
	     NONLOC [ QUE 0-dlist,
		      SLASH 0-dlist ],
	     LKEYS [ ALTKEYREL [ LBL #lbl,
				 PRED ellipsis_expl_rel,
				 ARG0 #cindex ],
		     --+ARGIND #subjind ] ] ].

;; For contracted (positive) auxiliaries that are not inverted, and hence
;; require their complement to be canonical, to avoid *Kim 'll*
;;
contracted_aux_noninv_lexrule := norm_lex_rule &
 [ DTR #dtr & 
       [ ORTH #orth,
	 INFLECTD na,
         SYNSEM #synsem & [ LOCAL.CAT.HEAD verb ] ],
   ORTH #orth,
   INFLECTD +,
   ALTS.SAI -,
   SYNSEM #synsem &
	  [ LOCAL.CAT.VAL.COMPS.FIRST canonical_synsem ],
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ],
   ARGS < #dtr > ].

;; Need to work on generalizing the semantics - since we derive this entry
;; from the past participle, we have to discard the tense information from
;; the input - not clear yet how to do this in general.  For now we assume
;; that transitive verbs introduce a single relation, bound to the KEYREL
;; attrib.

; This incorrectly orders the by_pp before all remaining comps - wrong for
; double-NP verbs, and incomplete for verbs with other oblique arguments,
; since this allows only one order.  But this latter is a general problem.
; DPF 3-Nov-01 - Removed [CONT..E-INDEX.E.ASPECT perf*] since this allows wrong
; generation.  Why was it here?
; DPF 28-jun-07 - Made ALTMIN event_dim_rel, to prevent application of
; the vp_sbrd-prd-ell_c rule to passive VPs.
; DPF 19-jun-09 - Added parent type word_or_infl_rule so drop_ital rules
; will also apply to passive verb forms.

basic_passive_verb_lexrule := lex_rule_basic & word_or_infl_rule &
  [ INFLECTD +,
    DTR #dtr &
        [ ALTS.PASSIVE +,
          INFLECTD -,
	  SYNSEM verb_synsem &
               [ LOCAL [ CAT [ HEAD verb &
                                    [ VFORM pas,
                                      TAM [ TENSE #tense,
                                            MOOD #mood ],
                                      MINORS.MIN #min ],
                               VAL [ SPCMPS #spcmps ],
			       MC #mc ],
			 CONT.HOOK [ LTOP #hand,
                                     INDEX #index ],
                         CONJ cnil,
			 CTXT #ctxt ],
                 LKEYS [ KEYREL #keyrel,
			 --COMPKEY #cmin,
                         --+COMPKEY #pluscmin,
                         --OCOMPKEY #ocmin,
                         --+OCOMPKEY #plusocmin ],
		 NONLOC #nonloc ] ],
    SYNSEM basic_passive_synsem &
	 [ LOCAL verb_participle_affix &
		 [ CAT [ HEAD verb & [ TAM [ TENSE #tense,
                                             MOOD #mood ],
                                       MINORS.MIN #min ],
			 VAL [ SPCMPS #spcmps ],
			 MC #mc ],
                   CONT.HOOK [ LTOP #hand,
                               INDEX #index,
                               XARG #xarg ],
		   CTXT #ctxt ],
	   NONLOC #nonloc,
           LKEYS [ KEYREL #keyrel,
		   --COMPKEY #cmin,
                   --+COMPKEY #pluscmin,
                   --OCOMPKEY #ocmin,
                   --+OCOMPKEY #plusocmin ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! topic & [ IARG1 #index,
				IARG2 #xarg ] !> ],
    ARGS < #dtr > ].


;; DPF 13-05-09 - The reentrancy of DTR..SUBJ..NONLOC and COMPS.FIRST..NONLOC 
;; (that is, identifying the dtr's NP NONLOC with the mother's PP-by NONLOC)
;; is a bad idea, since there are more general constraints on SLASH that
;; conflict, meaning that we were not parsing e.g. *happily, Kim is being
;; admired*.
;; DPF 2020-03-24 - Added COMPS..--MIN and ..OPT as per trunk
norm_passive_verb_lexrule := basic_passive_verb_lexrule &
  [ DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ --SIND #subjind, 
					NONLOC #snonloc ] >,
			       COMPS [ FIRST.LOCAL.CONT.HOOK.XARG #compxarg ] ],
    SYNSEM passive_synsem &
           [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.XARG #compxarg ] >,
			     COMPS.FIRST [ LOCAL.CONT.HOOK.INDEX #subjind,
					   --MIN _by_p_cm_rel,
					   OPT +,
					   NONLOC #snonloc ] ] ] ].

;; DPF 15-06-06 - Restrict result's COMPS.REST to *nolexlist* in order to block
;; spurious analysis of *was looked by Kim up*.
;; DPF 2015-09-10 - Re 15-06-06: But this blocks *was considered creative*. We
;; also can't usse *indeplist* instead (it would block *known as ...*.  So 
;; define new list type *satlist* which requires COMPS to be saturated, thus
;; excluding just particles.
;;
v_pas-norm_lexrule := norm_passive_verb_lexrule &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS.REST *satlist*,
	     LKEYS.--+ARGIND #argind ],
    DTR.SYNSEM.LKEYS.--+ARGIND #argind ].

;; DPF 2020-05-23 - This is at least one lexical rule that does not pass up
;; its LKEYS.--+ARGIND from its dtr, since the dtr wants an expl-it subj, but
;; the derived form does not.
;;
v_pas-cp_lexrule := norm_passive_verb_lexrule.

v_pas-dat_lexrule := basic_passive_verb_lexrule &
  [ SYNSEM.LKEYS.--+ARGIND #argind,
    DTR.SYNSEM.LKEYS.--+ARGIND #argind ].

; 'was referred to as ...'
;;
;; DPF 2017-03-01 - Removed selected_rel constraint on first comp's --MIN,
;; since this blocked *Kim was lied to* and *Kim was spoken to* where these
;; lexical entries select for a contentful PP.  Might revisit those verbs, but
;; let's see how this works out.  FIX??
;; DPF 2020-07-02 - We might still want to block as input v_prd verbs such as 
;; "stayed for" which don't select for any specific preposition.  Tried adding
;; PRD -. but this also blocks "was spoken to".  So instead, take advantage of
;; subj_equi_prd_verb constraining its prd-complement to be AUX -, and add
;; surprising AUX + here.
;;
prep_passive_verb_lexrule := basic_passive_verb_lexrule &
  [ DTR.SYNSEM [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind, 
					NONLOC #snonloc ] >,
				 COMPS [ FIRST phr_synsem &
					     [ LOCAL [ CAT [ HEAD prep &
								  [ AUX + ],
							     VAL.COMPS < > ],
						       CONT #objcont ],
					       NONLOC #ononloc,
					       --SIND #objind,
					       --MIN #min ],
					 REST #comps ] ],
		 LKEYS [ KEYREL #keyrel,
			 --+ARGIND #argind ] ],
    SYNSEM prep_passive_synsem &
           [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
					  --SIND #objind,
					  NONLOC #ononloc ] >,
				 COMPS [ FIRST [ --MIN #min ],
				   REST [ FIRST [ LOCAL.CONT.HOOK.INDEX #sind,
						  NONLOC #snonloc ],
					  REST #comps ] ] ] ],
		     CONT.HOOK.XARG #objind ],
		 LKEYS [ KEYREL #keyrel,
			 --+ARGIND #argind ] ] ].

;; 'was done away with'
;; `was checked up on'
;;
ptcl_prep_passive_verb_lexrule := basic_passive_verb_lexrule &
  [ DTR.SYNSEM [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind, 
					  NONLOC #snonloc ] >,
				 COMPS [ FIRST abstr_lex_synsem &
					     [ --MIN #min1 & selected_rel,
					       LOCAL.CAT.HEAD prep,
					       OPT - ],
					 REST [ FIRST phr_synsem &
					        [ --MIN #min2 & selected_rel,
						  LOCAL [ CAT [ HEAD prep,
								VAL.COMPS < > ],
							  CONT #objcont ],
						  NONLOC #ononloc,
						  --SIND #objind,
						  OPT - ],
						REST #comps ] ] ],
		 LKEYS [ KEYREL #keyrel,
			 --+ARGIND #argind ] ],
    SYNSEM ptcl_prep_passive_synsem &
           [ LOCAL 
	     [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
				    --SIND #objind,
				    NONLOC #ononloc ] >,
			   COMPS [ FIRST.--MIN #min1,
				   REST 
				   [ FIRST.--MIN #min2,
				     REST [ FIRST [ LOCAL.CONT.HOOK.INDEX #sind,
						    NONLOC #snonloc ],
					    REST #comps ] ] ] ] ],
	       CONT.HOOK.XARG #objind ],
	     LKEYS [ KEYREL #keyrel,
		     --+ARGIND #argind ] ] ].

; "this chapter has been added to" (dtr has opt NP complement)
; or verb+NP+particle
;;
basic_prep_passive_trans_verb_lexrule := basic_passive_verb_lexrule &
  [ DTR.SYNSEM 
     [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind, 
				NONLOC #snonloc ] >,
		       COMPS [ FIRST [ LOCAL.CAT.HEAD noun,
				       NONLOC #ononloc ],
			       REST [ FIRST [ --MIN #min & 
						    selected_rel,
					      LOCAL [ CAT.HEAD prep,
						      CONT #objcont ] ],
				      REST #comps ] ] ],
       LKEYS [ KEYREL #keyrel,
	       --+ARGIND #argind ] ],
    SYNSEM prep_passive_synsem &
        [ LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CONT #objcont,
				       --SIND #objind,
				       NONLOC #ononloc ] >,
			      COMPS [ FIRST [ --MIN #min ],
				    REST [ FIRST [ LOCAL.CONT.HOOK.INDEX #sind,
						   NONLOC #snonloc ],
					   REST #comps ] ] ] ],
		  CONT.HOOK.XARG #objind ],
	  LKEYS [ KEYREL #keyrel,
		  --+ARGIND #argind ] ] ].

;; For *the collection was added to*
prep_passive_trans_verb_lexrule := basic_prep_passive_trans_verb_lexrule &
 [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS [ FIRST.OPT +,
				    REST.FIRST [ LOCAL.CAT.VAL.COMPS < >,
						 --SIND #objind ] ],
   SYNSEM.LOCAL.CONT.HOOK.XARG #objind ].

;; For *the answer could be looked up*
;; DPF 2016-11-07 - The dtr's second complement (the particle) was wrongly
;; constrained to have a non-empty COMPS, blocking *the kit was put together*.
;; So instead constrain type to abstr_lex_synsem.
;;
prep_passive_ptcl_verb_lexrule := basic_prep_passive_trans_verb_lexrule &
 [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS [ FIRST [ OPT -,
					    LOCAL.CONT.HOOK.INDEX #objind ],
				    REST.FIRST abstr_lex_synsem &
					  [ NONLOC.SLASH 0-dlist ] ],
   SYNSEM.LOCAL.CONT.HOOK.XARG #objind ].

;;; For *was made an example of*, *was made fun of*
;; Exclude dative-shifted verbs as input.
;;
np_prep_passive_verb_lexrule := basic_passive_verb_lexrule &
  [ DTR [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ < [ --SIND #sind, 
					    NONLOC #snonloc ] >,
				   COMPS [ FIRST [ LOCAL.CAT.HEAD noun,
						   OPT - ],
					   REST [ FIRST phr_synsem &
					         [ --MIN #min2 & selected_rel,
						   LOCAL [ CAT [ HEAD prep,
						 		VAL.COMPS < > ],
						 	  CONT #objcont ],
						   NONLOC #ononloc,
						   --SIND #objind,
						   OPT - ],
						  REST #comps ] ] ],
		 LKEYS [ KEYREL #keyrel,
			 --+ARGIND #argind ] ],
	  ALTS.DATIVE - ],
   SYNSEM np_prep_passive_synsem &
           [ LOCAL 
	     [ CAT.VAL [ SUBJ < [ LOCAL.CONT #objcont,
				  --SIND #objind,
				  NONLOC #ononloc ] >,
			 COMPS [ FIRST.--SIND #compind,
				 REST [ FIRST.--MIN #min2,
					REST [ FIRST 
						[ LOCAL.CONT.HOOK.INDEX #sind,
						  NONLOC #snonloc ],
					       REST #comps ] ] ] ],
	       CONT.HOOK.XARG #objind ],
	     LKEYS [ KEYREL #keyrel & [ ARG2 #compind ],
		     --+ARGIND #argind ] ] ].


;; This has the same problem as the passive lexical rule.  Since we derive the
;; gerund from the present particple, we somehow have to filter out the
;; progressive relation.

;; DPF 27-May-99 - We block extraction from gerunds, at least for efficiency.
;; DPF 27-May-99 - POSS-ING gerunds are given a non-empty SUBJ value so they
;; can be modified by ordinary PPs and non-sentential adverbs, but the synsem
;; value is the hack 'anti_synsem' which is also used for the SPR value of 
;; verbs, for similar reasons.
;; DPF 27-May-99 - Try combining the two verbal gerund rules into one.
;; DPF 02-June-99 - We also block the auxiliary verbs "being, having, doing",
;; to avoid identity copula analyses for "Kim is being good" or "Kim is having
;; hired Sandy".
;; DPF 31-Jul-99 - Make gerund_rel like nominalize_rel in identifying its
;; handle with the verb_rel's, rather than taking the verb's handle as arg.
;; DPF 24-Jun-01 - Added REL 0-dlist to block "interviewing that" as gerund NP
;; with rel-pro "that".  This is overly strong for pied piping, as in "I met
;; some people talking to whom was pleasant", but we would need to distinguish
;; at least rel-pro "that" (and maybe "who") from "whom" - maybe later.
;; DPF 8-Nov-01 - The decision to block extraction from verbal gerunds means
;; we don't get "Which books are you interested in buying".
;; DPF 21-Jul-03 - Removed PT notpro from mother's index - not clear
;; why it was there, but it blocked "my arriving surprised kim".
;; DPF 23-aug-04 - Added SLASH 0-dlist, like for nominal gerunds, to further
;; enforce Ross's complex-NP constraint.
;; DPF 23-aug-04 - Regarding 02-June-99 comment, we now more generally use
;; SORT to block spurious analysis for "kim is being good", just like for
;; "Kim is arriving", so we remove the [AUX -] constraint, which means we
;; once again can get "after being hired, Kim smiled"
;; Changed SYNSEM nonpro_onearg_synsem to SYNSEM basic_one_arg so as to
;; leave the LEX value underspecified, so we can avoid bare-vger for 
;; unadorned verbal gerunds.
;; DPF 26-aug-07 - Restrict DTR..SUBJ..HEAD noun to avoid making gerunds
;; for locative inversion verbs like "going"
;; ... Eventually changed to a phrasal analysis of verbal gerunds, as we should
;; have all along.

;; DPF (12-Jul-98) In order to allow prenominal adjectives for nominal gerunds,
;; as in "regular tasting of wine is healthy", we have to treat the specifier
;; of the gerund as obligatory, since prenominal adjectives distinguish proper
;; from common nouns based on the optionality (or absence) of the specifier.
;; So these gerunds have to undergo the bare plural rule if no determiner is
;; present, which means they also have to be DIV +.
;; DPF 26-Mar-01 - Added [ALTMIN relation] to mother, to avoid having verbal
;; gerunds as, e.g., modified by "per/a person".
;; DPF 22-Apr-01 - Removed DIV + since we're getting a systematic
;; ambiguity between bare nominal gerunds and bare verbal gerunds.  This means
;; we'll block "hiring of consultants is important", but that's okay for now.
;; DPF 30-Aug-01 - But we also lose "loud singing is discouraged", which is
;; not okay, so we put DIV + back on mother.
;; DPF 23-Sep-01 - Used to have [ALTMIN relation] to block gerunds appearing as
;; left members of noun-noun compounds, but this also blocked them as heads of
;; compounds as in "chair buying is fun".  So eliminate this constraint, and
;; allow nominal gerunds on both sides of compounds, as in "email routing list"
;; or "weekend shopping regulations" - and block pres-participles as adjectives
;; to avoid apparently spurious ambiguity for e.g. "shopping trip".  But 
;; consider "the hiring consultant" which is ambiguous between the one who
;; does the hiring and the one who advises on hiring - maybe differing 
;; intonation suggests two distinct analyses, not spurious.  But block for now.
;; DPF 10-Nov-01 - Made nominal gerunds have head type nomger so they can be
;; distinguished from non-derived nouns (e.g. so modifiers like "per" don't
;; attach).
;; DPF 26-aug-04 - Note that we leave the output of the nominal-gerund rule
;; unmarked for INFLECTD so it can appear as the left member of n-n-cmpnds.
;; DPF 13-jul-06 - Added DIV + to SPR, to avoid spurious ambiguity with
;; nbar_coord_asym_rule.
;; DPF 2017-02-20 - Re 24-Jun-01: Since nominal and verbal gerunds are distinct,
;; we can now let nominal ones with a complement preserve the REL value of that
;; complement, to admit *Rome, the founding of which was important, flourished*,
;; and since relative *which* and *that* are now distinguished, we still don't
;; get unwanted *Rome, the founding of that was important, flourished*.
;; DPF 2017-11-07 - Constrain XARG of dtr to be non-expletive, to avoid 
;; *our being here* with there-copula `being'.
;; DPF 2018-03-12 - Added LPERIPH na to block spurious n-j-n analysis for
;; *bank holding company* assuming N-N *holding company*.
;;
nominal_gerund := lex_rule_basic &
  [ ORTH #orth & [ FROM #from, TO #to ],
    DTR word_or_lexrule & #dtr &
        [ ORTH #orth,
          INFLECTD +,
	  ALTS.NGER +,
	  SYNSEM basic_verb_synsem &
	       [ LOCAL local &
                       [ CAT [ HEAD verb &
                                    [ VFORM prp,
				      AUX - ],
			       VAL.SUBJ < [ NONLOC #snonloc ] >,
                               MC #mc,
                               HC-LEX #hclex ],
			 CONT [ HOOK [ LTOP #vhand,
                                       INDEX.SF prop,
				       XARG non_expl-ind ] ],
                         CONJ cnil,
			 CTXT #ctxt ],
                 LKEYS [ KEYREL.ARG0.E [ TENSE no_tense,
                                         ASPECT.PRF - ],
			 --+ARGIND #argind,
                         --COMPKEY #cmin,
                         --OCOMPKEY #ocmin ],
		 NONLOC [ QUE #que,
			  SLASH 0-dlist ] ] ],
    SYNSEM nonpro_nomod_synsem &
	   [ LOCAL local &
	     [ AGR #ind,
	       CAT 
	       [ HEAD nomger & [ MINORS.MIN nominalize_rel ],
		 VAL [ SUBJ < >,
		       SPR < [ LOCAL local &
				     [ CAT [ HEAD det,
					     VAL [ SUBJ < >,
						   SPR *olist*,
						   COMPS < > ] ],
                                       AGR.PNG #png ],
                               --SIND #ind & [ PNG #png,
                                               DIV + ],
			       NONLOC #snonloc,
			       OPT - ] >,
		       SPCMPS < > ],
                 MC #mc,
                 HC-LEX #hclex ],
               CONT [ HOOK [ LTOP #hand,
                             INDEX #ind & [ PNG png & [ PN 3s,
                                                        GEN neut ],
                                            DIV +,
                                            PT notpro ] ] ],
               CONJ cnil,
               CTXT #ctxt ],
             LKEYS [ KEYREL #keyrel & nominalize_relation &
                              [ LBL #hand,
                                ARG0 #ind,
                                ARG1 #vhand,
				CFROM #from, CTO #to ],
		     --+ARGIND #argind,
		     --COMPKEY #cmin,
                     --OCOMPKEY #ocmin ],
	     NONLOC [ SLASH 0-dlist,
		      QUE #que ],
             MODIFD notmod & [ LPERIPH na ] ],
    C-CONT [ RELS <! #keyrel !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #dtr > ].

;; DPF 2016-11-09 - Like for the intrans_pp variant below, generalized dtr's
;; SYNSEM value from intrans_subst to abstr_lex_synsem.  Similarly for the
;; transitive variant.

intrans_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM abstr_lex_synsem &
	       [ LOCAL.CAT.VAL [ SUBJ < synsem_min >,
				 COMPS #comps & < > ] ],
    SYNSEM [ LOCAL.CAT.VAL.COMPS #comps,
	     NONLOC.REL 0-dlist ] ].

; DPF 23-may-07 - Since virtually all PP complements of nouns are optional,
; remove the OPT value from the dtr's specification of the PP.
; DPF 20-jun-07 - Restrict these to PPs, not particles, to avoid spurious
; gerunds for e.g. "leaving" from "leave+in"
; DPF 26-aug-07 - Re 23-may-07: Still want to require that verbs with
; empty PP complements still require them. So propagate OPT value from DTR's
; COMP to mother.
;; DPF 2016-10-03 - Changed DTR.SYNSEM from unsat_two_arg_subst to
;; abstr_lex_synsem so we can also get derived verbs such as *overloading*
;; to be input, where the synsem type is derived_verb_synsem.
;;
intrans_pp_nominal_gerund := nominal_gerund &
  [ DTR.SYNSEM abstr_lex_synsem &
	       [ LOCAL.CAT.VAL.COMPS < phr_synsem &
                                       [ LOCAL #local & 
                                               [ CAT.HEAD prep ],
                                         MODIFD #modif,
                                         PUNCT #punct,
                                         OPT #opt,
					 --MIN #min ] . #comps > ],
    SYNSEM [ LOCAL.CAT.VAL.COMPS < [ LOCAL #local,
                                     NONLOC [ SLASH 0-dlist,
                                              REL #rel,
				  	      QUE #que ],
                                     MODIFD #modif,
                                     PUNCT #punct,
                                     OPT #opt,
				     --MIN #min ] . #comps  >,
             NONLOC [ REL #rel,
		      QUE #que ] ] ].

;; This is too restrictive.  It only forms nominal gerunds from strictly
;; transitive verbs.  So, it doesn't give you "Kim's putting of food on the
;; table" or "Kim's warning of Sandy that it would rain" or "Kim's giving of
;; raisins to the ants".  
;;  To avoid ambiguity with the intransitive nominal gerund, we make the PP
;; obligatory.
;; DPF 19-Feb-01 - But this is too restrictive: blocks "Hiring is difficult"
;; DPF 22-Feb-01 - Added restriction on --COMPKEY (and --OCOMPKEY) to prevent 
;; verb-particle verbs (with "selected_rel" complements) from undergoing rule.
;; DPF 26-Mar-01 - Make the OPT value of the of-PP complement be same as that
;; of the verb's complement NP.
;; DPF 23-Sep-01 - But this prevents e.g. "hiring is important".  So make the
;; value OPT +, which seems true for nominal gerunds.
;; DPF 03-Apr-03 - Constrained PP-comp to be [SLASH 0-dlist] (and REL and QUE)
;; Long-standing bug.  Sigh.
;; DPF 22-Jul-03 - Added constraint COMPS <expressed_synsem> to remove spurious
;; ambiguity for "My hiring" as we do for ordinary n_ppcomp lexical entries.
;; DPF 11-oct-05 - Try preserving optionality of complement from dtr to mother.
;; DPF 4-nov-05 - But this prevents N-N compounds where the first is notionally
;; an argument of the second (from a strictly transitive verb), as in 
;; "cat chasing is popular."  So let's try another approach, where we allow
;; transitive verbs to undergo this rule as long as there is not an alternative
;; entry like a v_prep_dir_le which would compete.  The underlying idea is
;; that there should be a single lexical entry with an underspecification 
;; for prep-dir and strict-transitive, but we currently have to express this as
;; an explicit disjunction with two lexical entries.  This approach doesn't yet
;; do so well with causative/inchoative alternations, where the two verbs
;; introduce different predicates, and we can't easily get to the 
;; underspecified sense.  For now, we'll exclude the causative variant here, 
;; and expect some post-processing to do the right thing with the semantics of
;; e.g. "cat shipping" to get from the overly specific "_ship_v_1_rel" to one 
;; possible reading where there is a "_ship_v_cause_rel".
;; DPF 27-aug-07 - Re 22-Feb-01: This constraint on --OCOMPKEY is overly
;; restrictive, since it blocks gerunds for verbs with an optional second
;; complement (like "recommend").  Instead, require that the REST of the 
;; COMPS list be *olist*, and add ALTS.NGER + to still block unwanted gerunds
;; for causatives.

trans_nominal_gerund := nominal_gerund &
  [ DTR [ SYNSEM abstr_lex_synsem &
	       [ LOCAL.CAT.VAL [ COMPS < synsem & 
					 [ LOCAL [ CAT nomp_cat_acc_min,
						   CONJ cnil ],
					   --SIND #index ] . *olist* >,
				 SUBJ < synsem_min > ],
                 LKEYS.--COMPKEY independent_rel ] ],
    SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ --MIN _of_p_sel_rel,
                                       LOCAL [ CAT basic_pp_cat,
                                               CONT.HOOK [ LTOP #ltop,
                                                           INDEX #index ],
                                               CONJ cnil ],
                                       NONLOC [ SLASH 0-dlist,
                                                REL #rel,
						QUE #que ] ] >,
                     CONT.HOOK.LTOP #ltop ],
	     NONLOC [ REL #rel,
		      QUE #que ] ] ].

; DPF 13-Oct-02 - Added COMPS < > to SPEC..SYNSEM, to avoid spurious ambiguity
; for e.g. "Friday evening"
;; DPF 2019-11-08 - Not clear why we had mother's XARG reentrant with SPEC..LTOP
;; but it seems wrong, and is inconsistent with assumptions in robust extension
;; as in *June 3rd* contrasted with *June 3*.  So remove, and check (FIX?)
;;
date_det_lexrule := lex_rule &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD noun,
                                 VAL.COMPS *olist* ],
			   CTXT #ctxt ],
                   LKEYS [ KEYREL #altkeyrel,
                           --COMPKEY #cmin,
                           --OCOMPKEY #ocmin ],
		   NONLOC #nonloc ] ],
    SYNSEM lex_synsem &
	   [ LOCAL [ CAT [ HEAD det,
                           VAL [ SUBJ < >,
				 SPR < >,
                                 COMPS < >,
				 SPEC < [ LOCAL [ CAT.VAL.COMPS < >,
                                                  CONT.HOOK.LTOP #nltop ],
                                          --SIND #ind ] >,
				 SPCMPS < > ] ],
                     CONT.HOOK.INDEX #ind & ref-ind,
		     CTXT #ctxt ],
             LKEYS [ KEYREL #keyrel &
                            [ PRED def_explicit_q_rel,
                              ARG0 #ind,
                              RSTR #rhand ],
                     ALTKEYREL #altkeyrel &
                               [ LBL #mltop,
                                 ARG0 #spind ],
                     --COMPKEY #cmin,
                     --OCOMPKEY #ocmin ],
	     NONLOC #nonloc & [ SLASH 0-dlist,
                                   REL 0-dlist,
                                   QUE 0-dlist ],
	     MODIFD hasmod ],
    C-CONT [ RELS <! #keyrel &
		     [ CFROM #from, CTO #to ],
                     prep_relation &
                     [ LBL #nltop,
                       PRED of_p_rel,
                       ARG0.E [ TENSE no_tense, ASPECT no_aspect ],
                       ARG1 #ind,
                       ARG2 #spind,
		       CFROM #from, CTO #to ],
                     [ PRED def_implicit_q_rel,
                       ARG0 #spind & ref-ind,
                       RSTR #mhand,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nltop ],
                      qeq & [ HARG #mhand,
                              LARG #mltop ] !>,
	     ICONS <! !> ] ].

; "October": NP => Determiner
;          "(in) October" => "October first"

month_det_lexrule := date_det_lexrule &
  [ DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN mofy_rel,
                 LKEYS.KEYREL.PRED mofy_rel ],
    SYNSEM.LOCAL.CAT [ HEAD [ MINORS [ MIN defdate_q_rel,
				       ALTMIN mofy_rel ],
                              MOD < > ],
                       VAL [ SPEC < [ --MIN dofm_or_interval_rel ] >,
                             SPCMPS < > ] ] ].

; "Tuesday": NP => Determiner
;          "(on) Tuesday" => "Tuesday morning"
; DPF 13-aug-09 - Restrict dtr to singular: "*Tuesdays morning"
;
weekday_det_lexrule := date_det_lexrule &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS [ MIN def_explicit_q_rel,
					 ALTMIN dofw_rel ],
				MOD < > ],
			 VAL.SPEC < [ --MIN day_part_rel ] > ] ],
    DTR.SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN dofw_rel,
			 AGR.PNG.PN 3s ],
                 LKEYS.KEYREL.PRED dofw_rel ] ].

;; *13th of July* from *July 13th*
dom_ppof_lexrule := lex_rule_basic &
  [ INFLECTD bool,
    ORTH #orth,
    DTR word_or_lexrule & #stem &
	[ ORTH #orth,
	  INFLECTD -,
	  SYNSEM [ LOCAL [ CAT [ HEAD #head & partn &
				      [ MINORS.MIN dofm_ord_rel ],
                                 VAL.COMPS < #comp >,
				 MC #mc ],
			   CONT.HOOK #hook,
			   CTXT #ctxt ],
                   LKEYS [ KEYREL #keyrel,
			   --+ARGIND #argind,
                           --COMPKEY #cmin,
                           --OCOMPKEY #ocmin ],
		   NONLOC #nonloc ],
          KEY-ARG #keyarg ],
    SYNSEM basic_lex_synsem &
	   [ LOCAL 
	     [ CAT 
	       [ HEAD #head,
		 VAL [ SUBJ < >,
		       SPR < expressed_synsem &
                              [ LOCAL.CAT [ HEAD det & 
						 [ MINORS.MIN quant_rel ],
                                            VAL [ SUBJ < >,
                                                  SPR *olist* ] ],
                                LEX +,
				OPT - ] >,
		       COMPS < [ LOCAL [ CAT [ HEAD prep &
					        [ MINORS [ MIN _of_p_sel_rel,
							   ALTMIN mofy_rel ] ],
					       VAL.COMPS < > ],
					 CONT.HOOK.INDEX #cind ],
				 NONLOC non-local_none,
				 OPT - ],
			       #comp >,
		       SPEC < >,
		       SPCMPS < > ],
		 MC #mc,
		 HC-LEX + ],
	       CONT.HOOK #hook,
	       CTXT #ctxt ],
	     LEX -,
             LKEYS [ KEYREL #keyrel& [ ARG1 #cind ],
		     --+ARGIND #argind,
                     --COMPKEY #cmin,
                     --OCOMPKEY #ocmin ],
	     NONLOC #nonloc & [ SLASH 0-dlist,
                                   REL 0-dlist,
                                   QUE 0-dlist ],
	     MODIFD hasmod ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; Relate transitive predicative adjectives to their intransitive attributive
; counterparts

attr_adj_lexrule := basic_lex_rule_supermost & 
  [ ORTH #orth,
    DERIVED +,
    DTR word_or_lexrule & #stem &
	[ ORTH #orth,
	  INFLECTD +,
	  ALTS.ATTRJ +,
	  SYNSEM basic_pred_adj_synsem &
	         [ LOCAL [ CAT [ HEAD [ MOD #mod,
                                        MINORS.MIN #min ],
				 VAL [ SUBJ #subj,
				       SPR #spr,
                                       COMPS *olist*,
				       SPCMPS #spcmps ],
				 MC #mc,
				 HC-LEX #hclex ],
			   CONT.HOOK #hook,
			   CONJ cnil,
                           CTXT #ctxt ],
		   NONLOC #non-local,
		   MODIFD #modif,
		   PUNCT #punct & [ LPUNCT no_punct,
				    RPUNCT no_punct ],
		   LKEYS.--+ARGIND #argind ],
	  GENRE #genre,
	  KEY-ARG #keyarg ],
    SYNSEM attr_adj_constr_synsem &
	  [ LOCAL [ CAT [ HEAD adj &
                               [ MOD #mod,
                                 MINORS.MIN #min ],
			  VAL [ SUBJ #subj,
				SPR #spr,
				SPCMPS #spcmps ],
			  MC #mc,
			  HC-LEX #hclex ],
		    CONT.HOOK #hook,
		    CONJ cnil,
		    CTXT #ctxt ],
	    NONLOC #non-local,
	    MODIFD #modif,
	    PUNCT #punct,
	    LKEYS.--+ARGIND #argind,
	    PHON.ONSET #onset ],
    KEY-ARG #keyarg,
    ARGS < #stem & [ SYNSEM.PHON.ONSET #onset ] >,
    INFLECTD +,
    GENRE #genre,
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].


;; Makes "admired" into an attributive adjective, as in "the admired hero"
;; DPF 22-Feb-01 - Added restriction of 'independent_rel' on --COMPKEY (and 
;; --OCOMPKEY) to prevent verb-particle verbs (with "selected_rel" complements)
;; from undergoing rule.
;; DPF 22-May-01 - But this did not generalize to blocking other unwanted
;; subcat variants, like S-comp-taking "checking".  So instead constrain
;; dtr's SYNSEM to be passive_or_unacc_subst, and require the --COMPKEY to be
;; no_rel.  This allows only intransitive (past-participle) verbs or passive 
;; transitive verbs to undergo this rule.
;; DPF 31-Jul-01 - Removed attr_adj_synsem from output since it didn't work.
;; What was I thinking?  Also removed MOD..SPR..MIN explicit_q_rel from
;; output, since this blocks "hired consultants arrive".  What was it for?
;; DPF 23-Sep-01 - Tempting to restrict this rule to only passives, since now 
;; handling pres-participles as nominal gerunds in noun-noun compounds.  (We
;; don't yet enable unaccusative participles as in "the fallen leaf".)  But as
;; noted above, what about two readings for "the hiring consultant" - one seems
;; to be n-n compound, the other an attrib adj, so maybe need both?  Block for
;; now.
;; DPF 25-Nov-01 - Changed SYNSEM.HEAD to be verb* rather than adj*, to allow
;; "The recently purchased chair arrived"
;; DPF 3-Jan-02 - Added hack unary length limit on RELS for input, to block 
;; application of rule to v-np-pp verbs like "send" (cf. 'Do you offer a 
;; printed catalog')
;; For now, allow only intransitive and transitive verb participles to appear
;; as attributive modifiers - block e.g. subj-equi variants to avoid spurious
;; ambiguity for 'the starting point'
;; DPF 14-dec-03 - Consider removing LPERIPH na, since it prevents NPs with
;; one of these guys from appearing in appositive constructions: "the singing 
;; bear Kim".  Not clear what work it does.  FIX.
;; DPF 27-jan-04 - Changed LPERIPH on mother from na to +, to enable these
;; as modifiers in compounds, as in "Fedex tracking number".  Can't remove the
;; constraint entirely (see above) since it serves to block unwanted
;; appositive analyses for examples like "Kim interviewed Sandy".
;; DPF 21-aug-04 - Added SPEC < > to prevent these from being modified by
;; posthead PP - always a dead-end attachment.
;; DPF 10-mar-05 - Re 25-Nov-01: Now allowing adverbs to modify adjectives as
;; well, so make output be HEAD adj, which also allows us now to coordinate
;; these as in "the admired and hated politicians" (didn't parse before).
;; DPF 28-mar-05 - Restored LPERIPH bool in order to prevent these inside
;; N-Adj-N compounds, since there is an alternative analysis of e.g.
;; 'company tracking number' where 'tracking number' is an N-N compound.
;; DPF 16-sept-05 - Try blocking SPR for these, to avoid e.g. "*a very hired
;; consultant"
;; DPF 5-nov-05 - It's tempting to relax SYNSEM..MOD..MIN from nom_nbar_rel to 
;; reg_nom_rel in order to also allow "the retired Abrams", but this leads to
;; unpleasant spurious ambiguity as in "Abrams has hired Browne."  Let's try
;; a specialized variant of this rule for proper names which requires that
;; they then have a non-empty specifier.
;; DPF 13-nov-05 - Re: 16-sept-05, but this also prevents "most visited",
;; so instead constrain SPR to only allow this-that ones, which include
;; comparative/superlative deg-specs.
;; DPF 13-may-06 - Re: 3-Jan-02 - this constraint no longer blocks application
;; to v-np-pp verbs since lexical semantics is no longer complex, and it
;; blocks desired application to lexical passives like "untrafficked", which
;; do have decomposed semantics.  So remove it.
;; DPF 16-feb-15 - Removed DTR..INDEX.E.TENSE no_tense because we want to allow
;; the un-prefixing rule to derive a predicative adj from this, as in
;; *the cat is unchanged*
;; DPF 2016-10-16 - This rule was quite reasonably requiring its dtr to be a 
;; verb which is [PRF -], but trouble arises because we want this output to then
;; be able to undergo the un- prefix rule, which makes an adjective such as
;; *unemployed* which can either be attributive or predicative, and when
;; predicative, it may well appear in a PRF + context, as in 
;; *has been unemployed*.  So instead constrain the dtr to be VFORM pas_or_prp.
;; Also, we can't stamp SF prop on the index of the output, since we also want
;; *was Kim unemployed?*.  Check the effect of removing this on generation. FIX
;; DPF 2017-08-21 - Add POSTHD reentrancy to dtr, at least to avoid spurious 
;; analysis for educ entries such as died_a1_post_mal which is marked POSTHD +.
;;
basic_attr_verb_part_lexrule := lex_rule_basic &
  [ ORTH #orth,
    DTR [ ORTH #orth,
	  SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                      [ VFORM pas_or_prp,
                                        PRD +,
                                        AUX - ],
				 POSTHD #ph,
				 VAL.SUBJ < [ --SIND #ind & non_expl,
                                              LOCAL.CAT.HEAD noun ] > ],
                           CONT [ HOOK [ LTOP #ltop,
                                         INDEX #event ] ],
                           CTXT #ctxt ],
                   NONLOC #non-local,
		   LKEYS.--+ARGIND #argind,
		   MODIFD #modif ] ],
    SYNSEM adj_synsem_lex_constr &
     [ LOCAL [ CAT [ HEAD.PRD -,
		     POSTHD - & #ph,
		     MC na ],
	       CTXT #ctxt ],
       MODIFD #modif,
       LKEYS.--+ARGIND #argind,
       NONLOC #non-local ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event,
                    XARG #ind ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; CSY 13-9-2020 - rule to allow predicative adj to take subjects
pred_adj_subj_lexrule:= lex_rule_basic &
  [ ORTH #orth,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #arg1,
    DTR aj_-_i-prd_le & [ ORTH #orth,
			  SYNSEM.LOCAL.CAT.HEAD.MOD #arg1 ] ].
	

; DPF 22-may-09 - Had changed MOD..--MIN to nbar_or_num_rel for some
; SciBorg-related reason, but can't recall now, and don't really like
; 'chased one' as an NP with num-noun 'one'
;

attr_verb_part_nbarmod_lexrule := basic_attr_verb_part_lexrule & lex_rule &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ --MIN gen_nom_nbar_rel ] >,
	     LEX + ] ].

attr_verb_part_lexrule := attr_verb_part_nbarmod_lexrule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    DTR.SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
		 LKEYS.--COMPKEY independent_rel ] ].

; transitive -ing verbs
; DPF 25-aug-07 - Block causative -ing forms to avoid spurious ambiguity for
; e.g. "the shrinking window"
;;
attr_verb_part_tr_lexrule := attr_verb_part_nbarmod_lexrule &
  [ ALTS.VADJ +,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    DTR.SYNSEM 
	[ LOCAL.CAT [ HEAD [ VFORM prp,
			     MINORS.ALTMIN role_rel ],
		      VAL.COMPS 
			   < unexpressed &
			     [ --MIN independent_rel,
			       LOCAL.CAT [ HEAD n_or_p,
					   VAL.SPR *olist* ] ] . *norplist* > ],
	  LKEYS.--COMPKEY independent_rel ] ].

attr_verb_part_psv_lexrule := attr_verb_part_nbarmod_lexrule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    DTR [ SYNSEM [ LOCAL.CAT [ HEAD.VFORM pas,
			       VAL.COMPS < unexpressed &
					   [ --MIN selected_rel ] . *olist* > ],
		   LKEYS.--COMPKEY independent_rel ],
	  ALTS.ATTRJ + ],
    C-CONT.RELS <! !> ].

;; For e.g. *the dried out cloth* *the written up report* (often with hyphens)
;; DPF 2013-09-25 - Constrain mother to be LEX - but HC-LEX + in order to block
;; ungrammatical *the dried cloth out*.
;;
attr_verb_part_ptcl_psv_lexrule := basic_attr_verb_part_lexrule &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ --MIN gen_nom_nbar_rel ] >,
			 VAL.COMPS < #comp >,
			 MC #mc,
			 HC-LEX + ],
	     LEX - ],
    DTR word_or_lexrule & #stem &
	[ INFLECTD +,
	  SYNSEM.LOCAL.CAT [ HEAD.VFORM pas,
			     VAL.COMPS [ FIRST #comp & [ OPT -,
							 --MIN selected_rel ],
					 REST *cons* ],
			     MC #mc ],
          KEY-ARG #keyarg,
	  ALTS.ATTRJ + ],
    C-CONT.RELS <! !>,
    KEY-ARG #keyarg,
    ARGS < #stem >,
    INFLECTD + ].


; For "the bewitching Abrams"
; DPF 30-sept-06 - The DTR..VFORM prp constraint prevents e.g. "the newly
; built Paris", so remove and see what happens to added ambiguity.
;; DPF 2016-09-15 - The constraint MOD..SPR expressed_synsem blocks 
;; *spoken English*.  But removing it means we would get an undesirable
;; analysis for *Abrams is hiring Browne*, so we'll further split these
;; rules each into two, one for passives and one for pres-part.
;; DPF 2017-09-16 - Added OPT - to enable blocking of spurious ambig when these
;; appear as pred subord phrases, as in *they arrived unprepared*.
;; DPF 2019-10-22 - Re 2016-09-15: But we also want bare-NP *sparkling Ds*, so
;; further split the named-mod -ing variants into singular and plural head. Sigh
;;
attr_verb_part_namemod_lexrule := basic_attr_verb_part_lexrule & lex_rule &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MOD < [ --MIN named_rel ] >,
 			 VAL.COMPS < > ],
	     LEX +,
	     OPT - ],
    DTR.SYNSEM.LKEYS.--COMPKEY independent_rel ].

attr_verb_part_intr_namemod_lrule := attr_verb_part_namemod_lexrule &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

attr_verb_part_intr_namemod_lexrule := attr_verb_part_intr_namemod_lrule &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM pas ].

;; DPF 2020-03-24 - Added MOD..PN 3s as per trunk
;;
attr_verb_part_intr_namemod_prp_lexrule := attr_verb_part_intr_namemod_lrule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.VAL.SPR < expressed_synsem >,
					  AGR.PNG.PN 3s ] ] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM prp ].
		       
;; DPF 2020-03-24 - Added type as per trunk.
attr_verb_part_intr_namemod_pl_prp_lexrule := attr_verb_part_intr_namemod_lrule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN 3p ] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM prp ].

attr_verb_part_tr_namemod_lrule := attr_verb_part_namemod_lexrule &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < unexpressed &
                                     [ LOCAL.CAT.HEAD n_or_p ] > ].

attr_verb_part_tr_namemod_lexrule := attr_verb_part_tr_namemod_lrule &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM pas ].

;; DPF 2020-03-24 - Added MOD..PN 3s as per trunk.
attr_verb_part_tr_namemod_prp_lexrule := attr_verb_part_tr_namemod_lrule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.VAL.SPR < expressed_synsem >,
					  AGR.PNG.PN 3s ] ] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM prp ].
		       
;; DPF 2020-03-24 - Added type as per trunk.
attr_verb_part_tr_namemod_pl_prp_lexrule := attr_verb_part_tr_namemod_lrule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.AGR.PNG.PN 3p ] >,
    DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM prp ].

;; DPF 2016-02-23 - Let's finally add a rule to produce -ly adverbs from 
;; adjectives
;; DPF 2020-07-17 - Before reactivating this rule, need to revise it so that
;; the new EP on the mother (one not present on the dtr) is introduced via
;; C-CONT rather than simply inherited from the mother's synsem type.  This
;; is necessary (or at least useful) in enabling at least the ACE generator
;; to account properly for the sources of EPs (either in lexemes or in the
;; C-CONT of rules).
;;
#|
adj_to_adv_lexrule := lex_rule_basic &
  [ DTR #dtr & [ ALTS.JTOR +,
		 SYNSEM basic_adj_abstr_lex_synsem &
			[ LOCAL.CAT [ HEAD adj,
				      VAL.COMPS *olist* ],
			  LKEYS.--+ARGIND #argind ] ],
    SYNSEM basic_basic_adverb_synsem &
	       [ LOCAL.CAT [ VAL.COMPS < >,
			     POSTHD + ],
		 LKEYS.--+ARGIND #argind ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #dtr > ].

adj_to_adv_int_lexrule := adj_to_adv_lexrule &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL int_mod_local ] >,
    SYNSEM basic_intersect_adverb_synsem &
	   [ LOCAL.CONT.RELS <! #keyrel & adv_relation !>,
	     LKEYS.KEYREL #keyrel & [ ARG1 #xarg ] ],
    C-CONT.HOOK.XARG #xarg ].
|#

;; The partitive construction rule introduces a new type of relation: 
;; part_of_rel, which contains the semantic information of the partitive.
;; The features of the relation, a subtype of nom_rel, were
;; - LBL, 
;; - ARG0, the index of the NP,
;; - SET, the handle of the PP complement, defining the set of which the head 
;;        determines a subset,
;; - NPREP,the index of the PP complement of the head, which is actually the
;;        index of the NP complement of that PP.
;; The idea is that there is a difference between, for example, "some books", 
;; and "some of the books". In the first case, "books" can refer to a subset
;; of the set of all the existing books, and "some" quantifies over the 
;; set of all existing books. In the second case, "some" refers to a subset of
;; the set of books defined by "the books": that set cannot refer to the 
;; universal set of all existing books. The relation "part_of_rel" tries to
;; capture that notion of subset of a certain set (defined by the context, or 
;; the determiner of the NP complement): the subset has an index 
;; (ARG0), and the defined set is referred to by "SET", which is the handle of
;; the prepositional phrase, and also the handle of the determiner of the 
;; prepositional complement.  We thus give partitives a complex lexical
;; semantics, including both the part_of_rel and the original quantifier
;; relation, with its usual attributes.

;; A problem which remains is to get the right agreement with the right head.
;; At the moment, the index of the head is the same as the index of the 
;; original determiner. As an example, "all" can be mass or plural, and is 
;; going to agree with a singular or a plural verb, whatever its complement is
;; ("all of the cake", "all of the students"). If we decide to have the index
;; of the construction being the index of the complement noun, what about 
;; "each" ? "Each of the boys" will agree with a plural only, when it should
;; agree with a singular. On the other hand, there is also the problem of 
;; "all of the oats are", plural when "all" is the mass determiner here: 
;; agreement is determined, here, by the plural form of the complement noun.
;; DPF 2015-09-20 - Changed INDEX from overt_non_expl-ind to nonconj_overt-ind
;; to block right-node-raising analysis of *all of the cats*
;; DPF 2016-07-03 - Let's try preserving the NEGPOL value from dtr to mother,
;; to keep the difference between *any of the cats* and *some of the cats*
;;
basic_part_constr := lex_rule &
 [ ORTH #orth,
   ALTS.DETPART +,
   DTR [ ORTH #orth,
         SYNSEM basic_part_det_synsem & 
	  [ LOCAL.CAT [ HEAD.MINORS.MIN #min,
                        VAL.SPCMPS #spcmps,
			NEGPOL #negpol ],
            LKEYS.KEYREL #relation,
	    NONLOC [ QUE #que ] ] ],
   SYNSEM partitive_noun_synsem & 
     [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN #min,
		     VAL [ SPR.FIRST unexpressed,
			   SPCMPS #spcmps ],
		     NEGPOL #negpol ],
	       CONT.HOOK.INDEX nonconj_overt-ind ],
       LKEYS [ KEYREL #keyrel,
               ALTKEYREL #relation ],
       NONLOC [ QUE #que ] ],
   C-CONT [ RELS <! #keyrel !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

part_nocomp_constr := basic_part_constr &
 [ SYNSEM partitive_noun_nocomp_synsem &
          [ LOCAL [ CAT.VAL.COMPS #comps,
                    AGR.DIV #div ],
	    NONLOC.SLASH #slash ],
   DTR.SYNSEM [ LOCAL [ CAT.VAL.COMPS #comps,
			AGR.DIV #div ],
		NONLOC.SLASH #slash ] ].

part_ppof_agr_constr := basic_part_constr &
 [ DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN explicit_quant_agr_q_rel,
                          VAL [ KCMP #kcomp & [ NONLOC.SLASH #slash ],
                                COMPS #comps ] ],
   SYNSEM basic_partitive_noun_ppof_synsem &
        [ LOCAL [ CAT.VAL [ KCMP #kcomp & [ LOCAL.AGR.PNG.PN #pn ],
                            COMPS < #kcomp . #comps > ],
		  CONT.HOOK.INDEX basic_non_expl-ind,
                  AGR.PNG.PN #pn ],
	  NONLOC.SLASH #slash ] ].
          
part_ppof_noagr_constr := basic_part_constr &
 [ DTR.SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN explicit_quant_or_udef_noagr_q_rel,
                            VAL [ KCMP #kcomp &
                                       [ LOCAL.CAT.HEAD.MINORS.ALTMIN #min,
					 NONLOC.SLASH #slash ],
                                  COMPS #comps ] ],
                      AGR #agr ],
   SYNSEM basic_partitive_noun_ppof_synsem &
        [ LOCAL [ AGR #agr,
                  CAT [ HEAD.MINORS.MIN #min,
                        VAL [ KCMP #kcomp,
                              COMPS < #kcomp . #comps > ] ],
		  CONT.HOOK.INDEX nonconj_indiv ],
	  NONLOC.SLASH #slash ] ].

; NP-particle alternation (e.g. "look up the answer/look the answer up"
; Stamp canonical_synsem on NP of output to avoid spurious parse for extraction
; of the NP, as in "Which problem did Kim figure out?"
;; DPF 2011-08-20 - Curious observation: If we don't include the (desirable)
;; re-entrancy for --COMPKEY in this rule, we get an asymmetry between the 
;; LKB and PET for the sentence *Throw away paper or other rice.* -- namely, 
;; the LKB quicly produces three analyses, while PET fails to terminate.  
;; Further, PET is happy as long as the rule vp_cr-cc_c is commented out.  
;; FIX? - Maybe diagnose this someday.
;; DPF 2012-08-21 - Identified --ADDIN on mother and dtr, to avoid spurious
;; analysis with mismatched subj-verb agreement, as in *she turn in homework*.
;; Sigh.

basic_NP_particle_lexrule := lex_rule &
 [ ORTH #orth,
   ALTS.NPPART +,
   DTR [ ORTH #orth,
         SYNSEM basic_NP_particle_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod,
				 PRD #prd,
				 --ADDIN #addin ],
                          POSTHD #ph,
			  VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt2,
					  LOCAL.CONT.HOOK #chook,
                                          NONLOC #nloc2 ] .
                                        < [ OPT #opt1,
                                            --MIN #cmin,
                                            NONLOC #nloc1 ] . #comps > >,
                                KCMP #kcmp ],
                          MC #mc,
                          HC-LEX #hclex  ],
		    CONT [ HOOK #hook,
			   RELS #rels ],
		    CTXT #ctxt ],
	    NONLOC #nonlocal,
            LKEYS #lkeys ] ],
   SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod,
				 PRD #prd,
				 --ADDIN #addin ],
                          POSTHD #ph,
                          VAL [ SUBJ #subj,
                                COMPS < [ OPT #opt1,
                                          --MIN #cmin,
                                          NONLOC #nloc1 ] . 
                                        < canonical_synsem &
                                          [ OPT #opt2,
					    LOCAL.CONT.HOOK #chook,
                                            NONLOC #nloc2 ] . #comps > >,
                                KCMP #kcmp ],
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK #hook,
			   RELS #rels ],
                    CTXT #ctxt ],
            NONLOC #nonlocal,
            LKEYS #lkeys ],
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

NP_particle_lexrule := basic_NP_particle_lexrule &
  [ SYNSEM generic_particle_np_verb ].

; --OCOMPKEY is not the same for ditrans and to-trans.

dative_shift_lexrule := lex_rule_basic &
 [ ORTH #orth,
   INFLECTD -,
   DTR #dtr & 
       [ ORTH #orth,
         INFLECTD -,
	 ALTS.DATIVE +,
         SYNSEM ditrans_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod ],
                          VAL.SUBJ #subj,
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ] ],
                    CONJ cnil,
                    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
                    ALTKEYREL #altkeyrel,
		    --+ARGIND #argind,
                    --COMPKEY #cmin ],
            NONLOC #nonlocal ] ],
   SYNSEM empty_to_trans_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod ],
			  VAL [ SUBJ #subj,
				COMPS < [ OPT - ], [ OPT - ] > ],
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ] ],
                    CONJ cnil,
		    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
                    ALTKEYREL #altkeyrel,
		    --+ARGIND #argind,
                    --COMPKEY #cmin ],
	    NONLOC #nonlocal ],
   ARGS < #dtr >,
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

;; Verbs with expletive-it subject and direct object alternate with second
;; complement as CP or VP:
;; *It annoyed him that we left*
;; *It annoyed him to shave himself* 
;;
verb_it_cp_vp_lexrule := lex_rule_basic &
 [ ORTH #orth,
   INFLECTD -,
   DTR #dtr & 
       [ ORTH #orth,
         INFLECTD -,
         SYNSEM expl_it_subj_np_cp_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod ],
                          VAL.SUBJ #subj,
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ] ],
                    CONJ cnil,
                    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
                    ALTKEYREL #altkeyrel,
		    --+ARGIND #argind,
                    --COMPKEY #cmin ],
            NONLOC #nonlocal ] ],
   SYNSEM expl_it_subj_np_vp_verb &
	  [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				 TAM #tam,
				 AUX #aux,
				 INV #inv,
				 MOD #mod ],
			  VAL.SUBJ #subj,
                          MC #mc,
                          HC-LEX #hclex ],
                    CONT [ HOOK [ LTOP #ltop,
                                  INDEX #ind ] ],
                    CONJ cnil,
		    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
                    ALTKEYREL #altkeyrel,
		    --+ARGIND #argind,
                    --COMPKEY #cmin ],
	    NONLOC #nonlocal ],
   ARGS < #dtr >,
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

; Converts e.g. int-adj 'twenty' to minute-noun for 'twenty (minutes) to nine'
; Currently does not allow 'twenty-two to nine' - would need to append COMPS
; more carefully.
;; DPF 2017-09-28 - Constrain to only cardinals, to avoid *first of*.
;;
basic_minute_lex_rule := lex_rule_basic &
 [ ORTH #orth,
   DTR word_or_lexrule & #dtr & 
       [ ORTH #orth,
         SYNSEM norm_num_synsem &
	  [ LOCAL [ CAT [ HEAD intadj2- &
                             [ MOD < [ LOCAL.CONT.HOOK [ LTOP #arghand,
			                                 INDEX #minst ] ] >,
			       CARDINAL + ],
                          VAL.COMPS < >,
			  MC #mc,
			  HC-LEX #hclex ],
                    CTXT #ctxt ],
            LKEYS [ KEYREL [ LBL #arghand,
			     CFROM #cfrom, CTO #cto ],
		    --+ARGIND #argind ],
	    PHON.ONSET con_or_voc,
	    NONLOC #nonlocal ] ],
   SYNSEM basic_minute_noun_synsem &
	  [ LOCAL [ CTXT #ctxt,
		    CAT [ MC #mc,
			  HC-LEX #hclex ],
		    CONT.HOOK #hook ],
            LKEYS [ KEYREL #keyrel & [ LBL #arghand,
				       ARG0 #minst,
				       CFROM #cfrom, CTO #cto ],
		    --+ARGIND #argind,
		    ALTKEYREL #altkeyrel ],
	    NONLOC #nonlocal ],
   C-CONT [ HOOK #hook,
	    RELS <! #keyrel & [ LBL #mhand ], #altkeyrel & [ RSTR #rhand ] !>,
	    HCONS <! qeq & [ HARG #rhand, LARG #mhand ] !> ],
   INFLECTD +,
   ARGS < #dtr > ].

minute_noprep_lexrule := basic_minute_lex_rule &
 [ SYNSEM [ LOCAL [ CAT [ HEAD.CASE no_case,
			  VAL.COMPS < > ], 
		    CONT.HOOK.INDEX #mind ],
	    LKEYS.KEYREL.ARG0 #mind ] ].

minute_prep_lexrule := basic_minute_lex_rule &
 [ SYNSEM minute_noun_wcomp_synsem ].

; *three twenty p.m.*
;; DPF 2016-08-026 - Instead of identifying INFL -, change mother to na_or_-,
;; as we need for *the ten thirty departure* where the head-comp rule requires
;; the head to be na_or_+.
;; DPF 2017-09-04 - In order to make the CFROM/CTO on minute_rel match those
;; of the number phrase that is the complement of this hour word, we would have
;; to have these values be accessible in HOOK somewhere, since the expression
;; might be *three twenty-two* where there is no LKEYS.KEYREL for *twenty-two*.
;; For now, just make these two rels have the same CFROM/CTO as the hour_rel.
;; DPF 2020-03-24 - Added COMPS..SPR *olist* as per trunk.
;; DPF 2020-07-17 - Changed this rule to not inherit from lex_rule_supermost
;; because the mother's INDEX has to be the ARG0 of the plus_c_rel added in
;; C-CONT, which has to be the first rel on RELS (as assumed in 
;; count_noun_synsem), but lex_rule_supermost's append strategy would make 
;; the first rel on the mother be the first rel of the dtr.
;;
hour_np_lexrule := word_or_nonpunct_rule &
  [ SYNSEM basic_hour_synsem &
	   [ PUNCT #punct,
	     PHON.ONSET #onset,
	     LOCAL [ CAT [ HEAD noun,
			   VAL [ COMPS < [ LOCAL [ CAT [ HEAD intadj2,
							 VAL [ COMPS *olist*,
							       SPR *olist* ] ],
						   CONJ cnil,
						   CONT.HOOK [ LTOP #mlbl,
							       XARG #minind ] ],
					   OPT -,
					   NONLOC.SLASH 0-dlist,
					   PUNCT.LPUNCT no_punct ],
					 #ampmcomp >,
				 KCMP #ampmcomp,
				 SPR < [ LOCAL.CONT.HOOK [ LTOP #clbl,
							   XARG #cind ] ] > ] ],
	     CONT [ HOOK #hook & [ INDEX.IND + ],
                    RELS [ LIST #rfirst,
			   LAST #rlast ],
		    HCONS [ LIST #hcfirst,
			    LAST #hclast ],
		    ICONS 0-dlist ] ] ],
    C-CONT [ HOOK #hook & [ INDEX #cind ],
	     RELS [ LIST #rfirst &
			 < [ PRED plus_c_rel,
			     LBL #clbl,
			     ARG0 #cind,
			     ARG1 #index,
			     ARG2 #minind ],
			   [ PRED udef_q_rel,
			     ARG0 #cind,
			     RSTR #rhand,
			     CFROM #cfrom, CTO #cto ],
			   [ PRED minute_n_rel,
			     LBL #mlbl,
			     ARG0 #minind & ref-ind,
			     CFROM #cfrom, CTO #cto ],
			   [ PRED def_implicit_q_rel,
			     ARG0 #minind,
			     RSTR #rmhand,
			     CFROM #cfrom, CTO #cto ] . #rmiddle >,
		    LAST #rmiddle ],
	     HCONS [ LIST #hcfirst & < qeq, qeq & [ HARG #rhand, LARG #clbl ],
			  qeq & [ HARG #rmhand, LARG #mlbl ] . #hcmiddle >,
		     LAST #hcmiddle ],
	     ICONS 0-dlist ],
    IDIOM #idiom, DIALECT #dialect, ALTS #alts, GENRE #genre, 
    INFLECTD na_or_-,
    ORTH #orth,
    DERIVED +,
    TOKENS #tokens,
    ARGS < [ ORTH #orth,
	     IDIOM #idiom, DIALECT #dialect, GENRE #genre, ALTS #alts, 
	     INFLECTD -,
	     TOKENS #tokens,
	     SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MINORS.MIN numbered_hour_rel],
				    VAL.COMPS < synsem > ],
			      CONT [ HOOK.INDEX #index,
				     RELS [ LIST #rmiddle,
					    LAST #rlast ],
				     HCONS [ LIST #hcmiddle,
					     LAST #hclast ] ],
			      CONJ cnil,
			      AGR.PNG.PN 3s ],
		      PHON.ONSET #onset,
		      PUNCT #punct & [ LPUNCT no_punct,
				       RPUNCT no_punct ] ] ] > ].

; DPF 28-jun-07 - Restricted dtr to HEAD a_or_adv to block partitive dets
; like "a bit".  Also made mother's SPCMPS < >.

; For "A large enough cat arrived."

;; DPF 2013-09-27 - Constrain dtr to be norm_adj_lex_synsem in order to
;; block as input deverbal adjectives: *we brought a baked enough cake*
;; DPF 2017-10-29 - Removed HC-LEX + on output, since we want both *a tall 
;; enough tree* (where HC-LEX on *tall* needs to be +), and also *a building 
;; tall enough to see* (where HC-LEX on *tall enough* needs to be -).
;;
basic_enough_addition := lex_rule_basic &
  [ ORTH #orth,
    INFLECTD +,
    DTR word_or_lexrule & #stem &
	[ ORTH #orth,
	  INFLECTD +,
	  ALTS.ENOUGH +,
	  SYNSEM 
           [ LOCAL [ CAT [ HEAD #head & a_or_adv &
                                [ MINORS.MIN independent_mod_rel,
                                  AUX - ],
                           VAL [ SUBJ #subj,
                                 COMPS *olist*,
                                 SPR.FIRST synsem &
				   [ LOCAL [ CAT.HEAD.MINORS.MIN very_deg_rel,
					     CONT.HOOK #sphook ] ] ],
			   MC #mc ],
		     CONT.HOOK #hook,
                     CTXT #ctxt ],
             NONLOC #nonloc,
	     MODIFD #modif,
	     LKEYS #lkeys ],
	  KEY-ARG #keyarg ],
    SYNSEM [ LOCAL 
	    [ CAT 
	     [ HEAD #head & [ MINORS.ALTMIN non_event_rel ],
               VAL [ SUBJ #subj,
		     COMPS *cons* &
		     [ FIRST [ --MIN enough_deg_rel,
			       LOCAL local &
				     [ CAT [ HEAD adv &
						  [ MOD < > ],
					     VAL.SPEC 
					       < [ LOCAL.CONT.HOOK #hook ] > ],
				       CONT.HOOK #sphook ],
			       LEX +,
			       OPT - ] ],
		     SPR < anti_synsem >,
		     SPCMPS < > ],
	       MC #mc ],
	      CONT.HOOK #hook,
	      CTXT #ctxt ],
	     NONLOC #nonloc & non-local_none,
	     MODIFD #modif,
	     LKEYS #lkeys ],
    KEY-ARG #keyarg,
    C-CONT [ RELS <! !>,
	     ICONS <! !> ],
    ARGS < #stem > ].

; *Kim is competent enough*
enough_addition_nocomps := basic_enough_addition &
  [ ARGS < [ SYNSEM.LEX #lex ] >,
    SYNSEM [ LOCAL.CAT.VAL.COMPS < synsem >,
	     LEX #lex ],
    C-CONT.HCONS <! !> ].

; *Kim is competent enough to hire*
;; DPF 2018-03-09 - Constrain this one only to adjectives, since can't find
;; examples like *?Kim ran quickly enough to admire* with a VP/NP following
;; *quickly enough*.  Contrast with adj: *that tree is tall enough to see
;; from here*.
;; DPF 2020-03-24 - Added SYNSEM..HC-LEX - as per trunk.
;; DPF 2020-04-29 - Re 2020-03-24: But the adj-N rule for e.g. *tall enough cat*
;; requires adj to be LEX +, so leave HC-LEX unconstrained.  
;; DPF 2020-04-30 - Would like to block *a tall enough to see building* while
;; preserving *a tall enough building to see*, but neither HC-LEX nor POSTHD
;; offer viable avenues.  In principle, would need the VP to provide a value
;; to its head-comp phrase that is incompatible with being an adj in adj_N,
;; such as LEX - or POSTHD +, but *tall* can't effect that, since with either
;; NP, the VP will unify its constraints into *tall*.  Briefly tried having
;; the hcomp rule propagate either HC-LEX or POSTHD from its nonhd, but both
;; features are too much in play for other constructions.
;;
#|
enough_addition_wcomp := basic_enough_addition &
  [ SYNSEM.LOCAL 
	    [ CAT [ HEAD basic_adj,
		    VAL.COMPS < [ LKEYS.KEYREL.ARG2 #arg2 ],
			      synsem &
			      [ LOCAL [ CAT s_or_vp_inf_cat,
					CONT.HOOK.LTOP #vltop,
					CONJ cnil ],
				NONLOC.SLASH 1-dlist &
				      <! [ CAT np_cat_acc_min &
					       [ HEAD [ MINORS.MIN norm_nom_rel,
							MOD < > ] ],
					   CONT.HOOK.INDEX #xarg ] !>,
				OPT -,
				PUNCT.LPUNCT no_punct ] > ],
	      CONT.HOOK.XARG #xarg ],
    C-CONT.HCONS <! qeq & [ HARG #arg2,
			    LARG #vltop ] !> ].
|#

basic_enough_addition_wcomp := basic_enough_addition &
  [ SYNSEM.LOCAL.CAT [ HEAD basic_adj,
		       VAL.COMPS < [ LKEYS.KEYREL.ARG2 #arg2 ],
				   synsem &
				   [ LOCAL [ CAT.NH-LEX -,
					     CONT.HOOK.LTOP #vltop,
					     CONJ cnil ],
				     OPT -,
				     PUNCT.LPUNCT no_punct ] > ],
    C-CONT.HCONS <! qeq & [ HARG #arg2,
			    LARG #vltop ] !> ].

enough_addition_wcomp := basic_enough_addition_wcomp &
  [ SYNSEM.LOCAL 
	    [ CAT [ VAL.COMPS < [ ],
				[ LOCAL.CAT s_or_vp_inf_cat,
				  NONLOC.SLASH 1-dlist &
				    <! [ CAT np_cat_acc_min &
					     [ HEAD [ MINORS.MIN norm_nom_rel,
						      MOD < > ] ],
					 CONT.HOOK.INDEX #xarg ] !> ] > ],
	      CONT.HOOK.XARG #xarg ] ].


;; DPF 2020-30-24 - Added type as per trunk.
;; DPF 2020-04-29 - Generalized COMPS..CAT from s_or_vp_inf_cat to also
;; admit finite CPs, as in *old enough that he can participate*
;; DPF 2020-04-30 - Prevent *the sleepy enough to sleep cat* by making adj's
;; POSTHD be assigned as + by its second complement, so it is not yet
;; constrained for *sleepy enough* to give *sleepy enough cat*.
;;
#|
enough_addition_wcomp_nogap := basic_enough_addition &
  [ SYNSEM.LOCAL 
	    [ CAT [ HEAD basic_adj,
		    VAL.COMPS < [ LKEYS.KEYREL.ARG2 #arg2 ],
			      synsem &
			      [ LOCAL [ CAT [ HEAD comp & 
						   [ VFORM fin_or_inf,
						     MOD *anti_list* ],
					      VAL.COMPS < >,
					      POSTHD +,
					      NH-LEX -,
					      MC na_or_- ],
					CONT.HOOK.LTOP #vltop,
					CONJ cnil ],
				NONLOC.SLASH 0-dlist,
				OPT -,
				PUNCT.LPUNCT no_punct ] > ] ],
    C-CONT.HCONS <! qeq & [ HARG #arg2,
			    LARG #vltop ] !> ].
|#
enough_addition_wcomp_nogap := basic_enough_addition_wcomp &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ ],
				 [ LOCAL.CAT [ HEAD comp & [ VFORM fin_or_inf,
							     MOD *anti_list* ],
					       VAL.COMPS < >,
					       POSTHD +,
					       MC na_or_- ],
				   NONLOC.SLASH 0-dlist ] > ].

; For "eyed" of "wide-eyed"
;
;; DPF 2015-04-05 - Removed DTR..SPR.FIRST unexpressed since this prevents
;; *four-legged* where card words require their MOD to be SPR expressed, to
;; avoid spurious analysis for *four cats* since we make card *four* into det.
;; Not clear what this constraint was blocking, but it was added since 1214.
;;
noun_adj_lexrule := lex_rule_basic &
  [ DTR word_or_lexrule & #stem &
        [ INFLECTD -,
          SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                      [ MOD < >,
                                        MINORS.MIN n-ed_rel ],
				 VAL #val &
                                      [ SUBJ < >,
                                       SPR < synsem &
					     [ --MIN quant_or_deg_rel ] >,
                                       COMPS < > ] ],
                           CONT.HOOK [ LTOP #nltop,
                                       INDEX #nind ],
                           CTXT #ctxt ],
		   LKEYS.--+ARGIND #argind,
		   NONLOC #non-local,
		   MODIFD.LPERIPH #lper ],
          KEY-ARG #keyarg ],
    SYNSEM [ LOCAL [ CAT [ HEAD n-ed &
                                [ MOD < >,
                                  MINORS [ MIN norm_nom_rel,
                                           ALTMIN no_rel,
                                           NORM norm_rel ] ],
                           VAL #val ],
		     AGR #nind,
                     CTXT #ctxt ],
             NONLOC #non-local,
	     LKEYS.--+ARGIND #argind,
             MODIFD notmod & [ LPERIPH #lper ] ],
    C-CONT [ HOOK [ LTOP #nltop,
                    INDEX #nind ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    INFLECTD + ].

tough_adj_lrule := lex_rule_basic &
  [ DTR word_or_lexrule & #stem &
        [ INFLECTD #infl,
	  ORTH #orth,
          SYNSEM norm_adj_atrans_synsem &
		 [ LOCAL [ CAT [ VAL [ SPR.FIRST.--MIN #min,
				       COMPS.REST.REST #compsrest ],
				 HC-LEX #hclex ],
		           CONT.HOOK [ LTOP #ltop,
                                       INDEX #ind ],
                           CTXT #ctxt ],
		   LKEYS.--+ARGIND #argind,
		   NONLOC #non-local ],
	  ALTS.TOUGH +,
          KEY-ARG #keyarg ],
    SYNSEM basic_tough_adj_atrans_synsem &
	[ LOCAL [ CAT [ HEAD adj & [ MINORS.ALTMIN non_ellipt_rel ],
			 VAL [ SPR.FIRST synsem &
					 [ --MIN #min,
					   LOCAL.CAT.HS-LEX #hslex ],
			       COMPS.REST.REST #compsrest ],
		         HC-LEX #hclex,
			 HS-LEX #hslex ],
		  CTXT #ctxt ],
	  MODIFD notmod,
	  LKEYS.--+ARGIND #argind,
	  NONLOC #non-local ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    ORTH #orth,
    INFLECTD #infl ].

tough_adj_lexrule := tough_adj_lrule &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [], [] >,
    SYNSEM tough_adj_atrans_synsem ].

tough_adj_compar_lexrule := tough_adj_lrule &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [], [], [] >,
    SYNSEM tough_adj_atrans_compar_synsem ].

;; DPF 2012-12-01 - Identified missing PUNCT on dtr and mother, to prevent
;; e.g. spurious application of the paired_bracket rule.
;; DPF 2020-04-29 - Exclude proper names via ALTMIN, to avoid for generic 
;; proper nouns as with *President*.  Sigh.
;;
basic_pre_noun_adj_lexrule := lex_rule_supermost & word_or_nonpunct_rule &
  [ DTR word_or_lexrule & #stem &
        [ INFLECTD +,
          SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MOD < > ],
				 VAL [ SUBJ < >,
				       SPR < synsem & 
					     [ --MIN quant_or_deg_rel ] >,
				       COMPS #comps ] ],
			   CONT.HOOK [ LTOP #nhand,
                                       INDEX #nind ],
			   AGR.PNG.PN 3s,
			   CONJ cnil ],
		   NONLOC #nonloc,
		   PUNCT #punct & [ LPUNCT dq_or_sq_or_lital_or_no_punct ],
		   LKEYS [ KEYREL [ CFROM #cfrom, CTO #cto ],
			   --+ARGIND #argind ],
		   PHON.ONSET #onset ],
	  KEY-ARG #keyarg ],
    SYNSEM adj_synsem_lex_rule &
	   [ LOCAL [ CAT [ HEAD.MOD.FIRST.LOCAL.CONT.HOOK [ LTOP #ltop,
							    INDEX #modind ],
			   VAL [ SPR.FIRST anti_synsem_min,
				 COMPS #comps ] ],
		     CONT.HOOK #hook,
		     CONJ cnil ],
             NONLOC #nonloc,
	     PUNCT #punct,
	     LEX +,
             MODIFD notmod,
	     LKEYS.--+ARGIND #argind,
	     PHON.ONSET #onset ],
    C-CONT [ HOOK #hook & [ LTOP #ltop,
			    INDEX #ind ],
             RELS <! [ PRED "_pre-_a_ante_rel",
		       LBL #ltop,
                       ARG0 #ind,
		       ARG1 #nind,
		       ARG2 #modind,
		       CFROM #cfrom, CTO #cto ],
		     [ PRED udef_q_rel,
                       ARG0 #nind & ref-ind,
                       RSTR #rhand,
		       CFROM #cfrom, CTO #cto ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !>,
	     ICONS <! !> ],
    KEY-ARG #keyarg,
    ARGS < #stem >,
    DERIVED +,
    INFLECTD + ].

pre_noun_adj_lexrule := basic_pre_noun_adj_lexrule &
  [ DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN gen_nom_nbar_rel,
			   VAL.COMPS < > ] ].

pre_propn_adj_lexrule := basic_pre_noun_adj_lexrule &
  [ DTR [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN abstr_named_rel,
	  TOKENS.+LIST.FIRST.+CLASS.+CASE mixed ] ].

; Converts bipartite nouns which are prescriptively [IND -] ("*many sunglasses
; were broken") into less constrained variants which are used for more robust
; parsing.  (All ignoring the type/individual contrast which the ERG currently
; doesn't distinguish.)

bipart_lexrule := lex_rule_supermost & word_or_nonpunct_rule &
  [ INFLECTD -,
    DERIVED +,
    ORTH #orth,
    GENRE prescrip,
    KEY-ARG #keyarg,
    DTR n_-_bipart_le & #stem &
        [ INFLECTD -,
          ORTH #orth,
	  SYNSEM [ LOCAL #local,
                   NONLOC #nonloc,
                   PUNCT #punct & [ LPUNCT no_punct,
                                    RPUNCT no_punct ],
                   LKEYS #lkeys,
		   PHON.ONSET #onset ],
          KEY-ARG #keyarg ],
    SYNSEM [ LOCAL #local &
                   [ CONT.HOOK.INDEX.IND - ],
             NONLOC #nonloc,
             LKEYS #lkeys,
             PUNCT #punct,
	     PHON.ONSET #onset ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #stem > ].


; 'Kim arrived, said Abrams'
; DPF 18-jul-07 - Restrict inverted subj to non-pronominal, to avoid spurious
; parse for e.g. "Kim knew she was afraid"
; In lexrules.tdl
; ; DPF 18-apr-08 - Also restrict subj to NORM norm_rel to exclude CP-WH NPs
; as in "remembered who arrived"
;; DPF 2012-10-20 -  Added SF prop to mother to prevent an inverted main-verb
;; S from being mistaken for a WH-phrase in the CP->NP rule.
;; DPF 2014-11-17 - Re 18-jul-07: But the ambiguity is there just as much for
;; "Kim knew the cat was afraid", and we want *the cat, said he*, so remove
;; this constraint, and accept the (real) ambiguity.
;; DPF 2017-10-31 - Constrain inverted subj to exclude gerunds to avoid spurious
;; abmig for e.g. *agreed-inv [[to sell its headquarters] [building here]*
;; DPF 2020-05-23 - Constrain inverted subj to have empty SLASH.
;
inverted_quote_lexrule := lex_rule_basic &
 [ ORTH #orth,
   INFLECTD +,
   DTR #dtr & 
       [ ORTH #orth,
         INFLECTD +,
	 ALTS.INVQ +,
         SYNSEM cp_comp_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          VAL [ SUBJ < #subj & canonical_synsem &
                                       [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
					 NONLOC [ SLASH 0-dlist,
						  QUE 0-dlist ] ] >,
				COMPS #comps,
                                KCMP #keycomp ],
                          HC-LEX #hclex ],
                    CONT.HOOK #hook & [ INDEX.SF prop ],
                    AGR #agr,
                    CTXT #ctxt ],
            LKEYS #lkeys,
            NONLOC #nonlocal,
	    PHON.ONSET #onset ] ],
   SYNSEM quoting_verb_inv_synsem &
          [ LOCAL [ CAT [ HEAD #head &
			       [ TAM #tam,
                                 --ADDIN [ ADDTAM #tam,
					   ADDPN #pn ] ],
                          VAL [ COMPS < #subj . #comps >,
                                KCMP #keycomp &
                                      [ LOCAL.CAT.HEAD verb ],
				SPCMPS < > ],
                          HC-LEX #hclex ],
                    CONT.HOOK #hook & [ XARG.SORT entity ],
                    AGR #agr & [ PNG.PN #pn ],
		    CTXT #ctxt ],
            LKEYS #lkeys,
	    NONLOC #nonlocal,
	    PHON.ONSET #onset ],
   ARGS < #dtr >,
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

;; *he said "Yes."* from *he said "we should".*
;; and also *"Yes," he said.* from (derived) *"we should," he said.*
;;
cp_frag_lexrule := lex_rule_basic &
 [ ORTH #orth,
   INFLECTD -,
   DTR #dtr & 
       [ ORTH #orth,
         INFLECTD -,
         SYNSEM cp_comp_verb &
	  [ LOCAL [ CAT [ HEAD #head,
                          VAL [ SUBJ #subj & < canonical_synsem &
                                       [ LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
					 NONLOC.QUE 0-dlist ] >,
				COMPS.FIRST.LOCAL.CAT.HEAD subst,
				KCMP [ LOCAL.CAT.HEAD.VFORM fin,
				       --SIND.SF prop ] ],
                          HC-LEX #hclex ],
                    CONT.HOOK #hook & [ INDEX.SF prop ],
                    AGR #agr,
                    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
		   --+ARGIND #argind ],
            NONLOC #nonlocal,
	    PHON.ONSET #onset ] ],
   SYNSEM cp_frag_intrans_verb &
          [ LOCAL [ CAT [ HEAD #head,
                          VAL.SUBJ #subj,
                          HC-LEX #hclex ],
                    CONT.HOOK #hook,
                    AGR #agr,
		    CTXT #ctxt ],
            LKEYS [ KEYREL #keyrel,
		    --+ARGIND #argind ],
	    NONLOC #nonlocal,
	    PHON.ONSET #onset ],
   ALTS.CPFRAG +,
   ARGS < #dtr >,
   C-CONT [ RELS <! !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

;; Punctuation rules
;
; Making mother be SYNSEM lex_punct_synsem prevents spurious application of
; derivational rules that are constrained by synsem type.  Assumes that
; right punctuation will attempt to attach to each derivational stage of
; a lexical entry - maybe not pretty, but can't be helped since PUNCT has
; to be inside SYNSEM, so can't identify synsems of hd-dtr and mother.

basic_punctuation_rule := lex_rule_supermost & word_or_punct_rule &
  [ ND-AFF +,
    KEY-ARG #keyarg,   
    DERIVED #derived,
    DTR #dtr,
    ARGS < #dtr &
           [ KEY-ARG #keyarg,
	     DERIVED #derived,
	     SYNSEM [ OPT #opt,
                      LEX #lex,
                      LOCAL #local,
                      NONLOC #nonloc,
                      MODIFD #mod,
                      --SIND #sind,
                      PUNCT [ LPUNCT lital_or_pair_or_no_punct,
			      RPUNCT.PSF #psf ],
		      PHON #phon,
		      LKEYS #lkeys,
		      --BRDG #brdg ] ] >,
    SYNSEM lex_punct_synsem &
           [ OPT #opt,
             LEX #lex,
             LOCAL #local,
             NONLOC #nonloc,
             MODIFD #mod,
             --SIND #sind,
	     PUNCT.RPUNCT.PSF #psf,
	     PHON #phon,
	     LKEYS #lkeys,
	     --BRDG #brdg ],
    C-CONT.RELS <! !> ].

punctuation_rule := basic_punctuation_rule &
  [ INFLECTD #infl & na_or_+,
    SYNSEM.PUNCT [ RCLSTR #rclstr ],
    GENRE #genre,
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ RCLSTR #rclstr ],
             GENRE #genre ] > ].

punctuation_clause_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT clause_punct ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].  

punctuation_period_rule := punctuation_clause_rule &
  [ SYNSEM.PUNCT.RPUNCT.PSF punct-prop-comm ].

punctuation_qmark_rule := punctuation_clause_rule &
  [ SYNSEM.PUNCT.RPUNCT.PSF punct-ques ].

;; DPF 2016-10-16 - PSF was punct-prop-comm, but this excludes questions, as in
;; *will they win; and will we lose?*
;;
punctuation_semicol_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT semicol_punct &
                          [ PSF prop-or-pol-ques-or-comm ] ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].

w_semicol_rule := punctuation_semicol_rule.
w_double_semicol_rule := punctuation_semicol_rule.

punctuation_colon_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT colon_punct ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].

generic_punctuation_comma_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ RCLSTR #rclstr ],
    GENRE #genre,
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ RPUNCT pair_or_no_punct,
                            RCLSTR #rclstr ],
             GENRE #genre ] > ].

basic_punctuation_comma_rule := generic_punctuation_comma_rule &
  [ SYNSEM.PUNCT.LPUNCT #lpunct,
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpunct & no_punct ] > ].

punctuation_comma_rule := basic_punctuation_comma_rule &
  [ SYNSEM.PUNCT [ PNCTPR no_ppair,
                   PAIRED no_ppair,
                   RPUNCT comma_punct ] ].

punctuation_comma_sandwich_rule := basic_punctuation_comma_rule &
  [ SYNSEM.PUNCT [ PNCTPR no_ppair,
                   PAIRED no_ppair,
                   RPUNCT comma_punct ] ].

punctuation_rparen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT rparen_punct & [ PSF #pred ],
                   RCLSTR [ RPAREN na_or_+,
			    RFP #rfp,
			    RITAL #rital,
			    LITAL #lital ] ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT clause_or_pair_or_no_punct &
                                   [ PSF #pred ],
			    RCLSTR [ RFP #rfp,
				     RITAL #rital,
				     LITAL #lital ] ],
	     GENRE #genre ] >,
    GENRE #genre ].

w_rparen_rule := punctuation_rparen_rule.
w_comma-rp_rule := punctuation_rparen_rule.
w_rbrack_rule := punctuation_rparen_rule.

;; DPF 2019-03-31 - Added LPAREN na_or_+ so that the normal binary phrase can
;; require the right dtr to have either no left paren or paired parens, by
;; unifying LPAREN and RPAREN.
;;
punctuation_lparen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT lparen_punct,
                   RPUNCT #rpunct,
                   PNCTPR #pnctpr,
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ RPUNCT #rpunct,
                            PNCTPR #pnctpr,
                            RCLSTR #rclstr ],
             GENRE #genre ] >,
    GENRE #genre ].

w_lparen_rule := punctuation_lparen_rule.
w_lbrack_rule := punctuation_lparen_rule.

; DPF 03-jun-10 - Changed LPUNCT from dq_or_no_punct to no_punct to avoid
; spurious ambiguity for *"cat"*
;;
punctuation_dqright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                   RPUNCT dq_punct & [ PSF #pred ],
		   RCLSTR [ RPAREN #rp,
			    RFP #rfp,
			    IGNOREQ #iq,
			    RITAL + ],
		   PAIRED #paired,
		   PNCTPR #pnctpr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct,
                            RPUNCT.PSF #pred,
			    RCLSTR [ RPAREN #rp,
				     RFP #rfp,
				     IGNOREQ #iq ],
			    PAIRED #paired,
			    PNCTPR #pnctpr ],
             GENRE #genre ] >,
    GENRE #genre ].

punctuation_dqleft_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT dq_punct,
                   RPUNCT #rpunct,
                   RCLSTR #rclstr,
		   PAIRED #paired,
		   PNCTPR #pnctpr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT pair_or_no_punct,
			    RPUNCT #rpunct &
	     		           comma_or_rbc_or_clause_or_pair_or_no_punct,
                            RCLSTR #rclstr,
			    PAIRED #paired,
			    PNCTPR #pnctpr ],
             GENRE #genre ] >,
    GENRE #genre ].
    
punctuation_sqright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT sq_punct & [ PSF #pred ],
                   RCLSTR [ RPAREN #rp,
			    RFP #rfp,
			    IGNOREQ #iq,
			    RITAL + ] ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT comma_or_clause_or_no_punct &
                                   [ PSF #pred ],
                            RCLSTR [ RPAREN #rp,
				     RFP #rfp,
				     IGNOREQ #iq ] ],
             GENRE #genre ] >,
    GENRE #genre ].
    
punctuation_sqleft_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT sq_punct,
                   RPUNCT #rpunct,
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ RPUNCT #rpunct,
                            RCLSTR #rclstr ],
             ALTS.SQPNCT +,
             GENRE #genre ] >,
    GENRE #genre ].
    
punctuation_hyphen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT hyphen_sgl & [ PSF #pred ],
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT no_punct &
                                   [ PSF #pred ],
                            RCLSTR #rclstr ],
             GENRE #genre ] >,
    GENRE #genre ].
    
w_hyphen_rule := punctuation_hyphen_rule.
w_threedot_rule := punctuation_hyphen_rule.

;; DPF 2017-09-18 - For tokens with leading hyphen, such as *chmod -rw*
;; But exclude these in prefixing rules such as pre-booked
punctuation_lefthyphen_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT hyphen_sgl,
                   RPUNCT #rpunct,
                   PNCTPR #pnctpr,
                   RCLSTR #rclstr ],
    ARGS < [ INFLECTD #infl,
             SYNSEM.PUNCT [ LPUNCT no_punct,
			    RPUNCT #rpunct,
                            PNCTPR #pnctpr,
                            RCLSTR #rclstr ],
             GENRE #genre ] >,
    GENRE #genre ].

w_lefthyphen_rule := punctuation_lefthyphen_rule.

punctuation_bang_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT clause_punct &
                          [ PSF punct-prop-comm ] ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT clause_or_pair_or_no_punct ] ] > ].
    
punctuation_asterisk_rule := punctuation_rule &
  [ SYNSEM.PUNCT #punct,
    ARGS < [ SYNSEM.PUNCT #punct ] > ].
    
w_asterisk_rule := punctuation_asterisk_rule.
w_asterisk_pre_rule := punctuation_asterisk_rule.

punctuation_comma_informal_rule := basic_punctuation_comma_rule &
  [ INFLECTD +,
    SYNSEM.PUNCT [ PNCTPR ppair,
                   RPUNCT rbcomma_punct ],
    GENRE nonformal ].
    
punctuation_period_robust_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT clause_punct ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].
    
; DPF 14-feb-08 - Note that we can't make ARGS..RPUNCT be 
; clause_or_pair_or_no_punct since this makes the rule circular for
; generation (adding arbitrary numbers of question marks).  We want
; to analyze multiple qmarks, but not generate them. So we'll have to
; have a separate rule to admit ?? (or !?) which we can exclude for
; generation.

punctuation_clmark_qmark_rule := punctuation_rule &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED no_ppair,
                   RPUNCT clause_punct &
                          [ PSF punct-ques ] ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct & no_punct,
                            RPUNCT pair_or_no_punct ] ] > ].
    
w_qqmark_rule := punctuation_clmark_qmark_rule.
w_qmark-bang_rule := punctuation_clmark_qmark_rule.
w_qmark-period_rule := punctuation_clmark_qmark_rule.

punctuation_italleft_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT lital_punct,
                   RPUNCT #rpunct,
                   RCLSTR #rclstr ],
    ARGS < word_or_infl_or_punct_rule &
	   [ INFLECTD #infl,
	     SYNSEM [ PUNCT [ RPUNCT #rpunct & 
				     comma_or_rbc_or_clause_or_no_punct,
			      RCLSTR #rclstr & [ RITAL - ] ] ],
             GENRE #genre ] >,
    GENRE #genre ].
    
punctuation_italright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM.PUNCT [ LPUNCT #lpunct & lital_or_no_punct,
                   RPUNCT #rpunct,
		   RCLSTR [ RPAREN #rparen,
			    RFP +,
			    RITAL + ] ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM [ PUNCT [ LPUNCT #lpunct,
			      RPUNCT rparen_or_clause_or_no_punct & #rpunct,
			      RCLSTR.RPAREN #rparen ] ],
             GENRE #genre ] >,
    GENRE #genre ].

;; DPF 29-mar-10 - Don't remember why dtr was constrained to word_or_infl_rule,
;; but it blocks e.g. *``(For* so remove it and see what happens. 
;; DPF 08-apr-10 - Well, the above constraint ensures that these two rules
;; apply in only one order when a single token is marked with both left and
;; right.  Otherwise we get two derivations for the dropped-italic analysis
;; of e.g. ⌊/in/⌋
;; So for now, we'll sacrifice the tokens like *``(For*, until a better
;; solution emerges to control the interaction of these two rules.
;; DPF 2016-09-18 - Now that we've added IGNOREQ + on right-drop rule's mother
;; (needed separately for handling foreign-word sequences), let's use it to
;; enforce left-before-right dropping rules to avoid spurious ambiguity.
;; DPF 2016-10-12 - Re 2016-09-18: And hence let's drop the constraint on
;; dtr being word_or_infl_or_punct_rule, since it was also blocking the attrib
;; adj analysis of *the ⌊/complete cat/⌋*.
;;
punct_drop_italleft_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM [ PUNCT [ LPUNCT no_punct_dropped,
		     RPUNCT #rpunct,
		     RCLSTR #rclstr ] ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM [ PUNCT [ RPUNCT #rpunct & no_punct,
			      RCLSTR #rclstr & [ IGNOREQ -,
						 RITAL - ] ],
		      PHON.ONSET con_or_voc ],
             GENRE #genre ] >,
    GENRE #genre ].
    
punct_drop_italright_rule := basic_punctuation_rule &
  [ INFLECTD #infl,
    SYNSEM [ PUNCT [ LPUNCT #lpunct,
		     RPUNCT #rpunct,
		     RCLSTR [ RPAREN #rparen,
			      RFP -,
			      IGNOREQ +,
			      RITAL - ] ] ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM [ PUNCT [ LPUNCT #lpunct & no_punct,
			      RPUNCT #rpunct & clause_or_no_punct,
			      RCLSTR.RPAREN #rparen ],
		      PHON.ONSET con_or_voc ],
             GENRE #genre ] >,
    GENRE #genre ].
    
; DPF 09-aug-09 - Restrict these prefixing rules to native entries, since
; there is little benefit in decomposition of unknown words, and it's hard
; to get the PHON.ONSET right for native (con) vs generic (unk)
;; DPF 2010-10-10 - Consider *reschedule* which has an optional complement,
;; even though *schedule* has an obligatory one.  FIX?
;; DPF 2018-05-14 - For now, assume all prefixes are non-scopal, instead
;; for verbs presenting the ARG0 of the prefix's predication as the derived 
;; word's INDEX, and for nouns and adjectives preserving the input's INDEX.
;;
basic_derivational_prefix_rule := lex_rule_supermost & word_or_nonpunct_rule &
  [ INFLECTD #infl,
    DTR word_or_lexrule & #stem &
	[ INFLECTD #infl,
	  SYNSEM [ LOCAL [ CONT.HOOK [ LTOP #lbl,
				       INDEX #index,
				       XARG #xarg ],
			   AGR #agr,
			   CONJ cnil,
			   CTXT #ctxt ],
                   PUNCT #punct & [ LPUNCT no_punct,
                                    RPUNCT no_punct ],
		   NONLOC #nonloc,
		   LKEYS [ KEYREL [ CFROM #from, CTO #to ],
			   --+ARGIND #argind ],
		   PHON.ONSET con_or_voc ],
          KEY-ARG #keyarg,
          GENRE #genre ],
    SYNSEM [ LOCAL [ CONT.HOOK [ LTOP #lbl,
                                 XARG #xarg ],
		     AGR #agr,
		     CONJ cnil,
		     CTXT #ctxt ],
	     PUNCT #punct,
	     NONLOC #nonloc,
	     LKEYS [ KEYREL [ CFROM #from, CTO #to ],
		     --+ARGIND #argind ] ],
    GENRE #genre,
    KEY-ARG #keyarg,
    ARGS < #stem >,
    C-CONT [ RELS <! [ LBL #lbl,
		       ARG1 #index,
		       CFROM #from, CTO #to ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

derivational_prefix_rule := basic_derivational_prefix_rule &
  [ DTR.SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CAT #cat ].

verb_prefix_rule := derivational_prefix_rule &
  [ INFLECTD +,
    DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ AUX - ],
			   VAL.SUBJ.FIRST synsem ],
    SYNSEM derived_verb_synsem & [ LKEYS.KEYREL #keyrel ],
    C-CONT.RELS <! #keyrel !> ].

;; Output verb is (strictly) transitive, even if input is not transitive
;; DPF 2020-03-13 - But the semantics isn't right yet - FIX, and in the meantime
;; just treat out- as ordinary verb-prefix rule, so won't get e.g. 
;; *outslept his brother*
;;
out_prefix_rule := basic_derivational_prefix_rule &
  [ INFLECTD -,
    DTR.SYNSEM [ LOCAL.CAT [ HEAD #head & verb & [ AUX - ],
			     VAL [ SUBJ #subj & [ FIRST synsem ],
				   SPR #spr,
				   SPEC #spec,
				   SPCMPS #spcmps,
				   COMPS *norplist* ],
			     MC #mc,
			     HC-LEX #hclex ] ],
    SYNSEM np_trans_verb & [ LOCAL [ CAT [ HEAD #head,
					 VAL [ SUBJ #subj,
					       SPR #spr,
					       SPEC #spec,
					       SPCMPS #spcmps,
					       COMPS < [ --SIND #cind,
							 OPT - ] > ],
					 MC #mc,
					 HC-LEX #hclex ],
				   CONT.HOOK.INDEX #index & non_conj_event ],
			   LKEYS.KEYREL #keyrel & [ ARG0 #index,
						    ARG2 #cind ] ],
    C-CONT.RELS <! #keyrel !> ].

v_v-co_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

v_v-counter_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

v_v-mis_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_mis-_a_error_rel" ] !> ].
; v_v-out_rule := out_prefix_rule &
v_v-out_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_out-_a_1_rel" ] !> ].

v_v-over_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_over-_a_1_rel" ] !> ].

v_v-under_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_under-_a_1_rel" ] !> ].

v_v-pre_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_pre-_a_ante_rel" ] !> ].

v_v-re_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_re-_a_again_rel" ] !> ].
v_v-self_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_self-_a_1_rel" ] !> ].

v_v-un_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_un-_a_rvrs_rel" ] !> ].

v_v-cross_rule := verb_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_cross-_a_1_rel" ] !> ].

basic_noun_prefix_rule := derivational_prefix_rule &
  [ DTR.SYNSEM.LOCAL [ CAT.HEAD basic_noun &
				[ MINORS.MIN non_proper_rel ],
		       CONT.HOOK.INDEX #index ],
    SYNSEM basic_noun_synsem & [ LOCAL.CONT.HOOK.INDEX #index ] ].

noun_prefix_rule := basic_noun_prefix_rule &
  [ INFLECTD + ].

;; For e.g. *the counter-narcotics team*
;;
noun_prefix_noninfl_rule := basic_noun_prefix_rule &
  [ SYNSEM.LOCAL noninfl_noun_local,
    DTR.SYNSEM.LOCAL noninfl_noun_local ].	  

n_n-co_rule := noun_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

n_n-co-ni_rule := noun_prefix_noninfl_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

n_n-counter_rule := noun_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

n_n-counter-ni_rule := noun_prefix_noninfl_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_counter-_a_anti_rel" ] !> ].

n_n-mini_rule := noun_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_mini-_a_1_rel" ] !> ].

n_n-mini-ni_rule := noun_prefix_noninfl_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_mini-_a_1_rel" ] !> ].


;; DPF 16-02-16 - Can't identify CAT values, since we want the un-prefixing
;; rule to change PRD value of daughter from - to bool, in order to get intended
;; analysis of *the cat is unchanged*
;; DPF 2016-10-11 - To avoid spurious reordering of attrib and this rule for
;; e.g. *unhappy* or *nonlinear*, tried to restrict dtr to exclude lex-rule.
;; But this is wrong, since we want un- rule to apply to the result of passive,
;; as in *unintended*.  So let's try constraining dtr to be PRD +, forcing the
;; attrib-adj lexical rule to apply afterward.
;; No, the rule converting passive V to adj constrains the output to be PRD -,
;; of course, to avoid adj analysis for *Kim was hired*.  So if we were going to
;; use PRD here, it would have to be PRD -, but we are already using the PRD
;; contrast to allow post-mod for a few adjectives such as *available*, and we
;; still want *the seat is unavailable*, where this input *available* would 
;; have to be PRD +.  It might appear that the source of the spurious ambiguity
;; in ordering is because this rule was not preserving PRD from dtr to mother.
;; But while we want the adj *evaluated* to be PRD - (to avoid ambiguity), the 
;; analysis we want for *he was unevaluated* must have *unevaluated* as not 
;; PRD -.
;; So instead, let's make the attr-adj rule have its output be of a synsem
;; type that is not compatible with basic_lex_synsem, and hence it will
;; have to apply after the adj-prefix rules.
;; DPF 2017-11-08 - The rule was identifying its MOD with dtr's MOD, but since
;; instances of this type, such as j_j-un, can have as dtr a derived passive 
;; participle (which excludes pronouns as targets for modification), we were 
;; blocking *it is unchanged*.  So instead made derived_adj_synsem inherit from
;; norm_adj_synsem, which gives it normal MOD constraint, and further restrict
;; dtr here to exclude MOD..MIN named_rel, to avoid the MOD..named_rel variants
;; of deverbal adjectives.
;;
adj_prefix_rule := basic_derivational_prefix_rule &
  [ DTR word_or_lexrule &
	[ SYNSEM [ LOCAL [ CAT [ HEAD basic_adj & 
				      [ MINORS #minors,
					MOD.FIRST.--MIN non_proper_rel ],
				 VAL #val,
				 HC-LEX #hclex,
				 HS-LEX #hslex ],
			   CONT.HOOK.INDEX #index ],
		   OPT #opt ] ],
    SYNSEM derived_adj_synsem & 
	   [ LOCAL [ CAT [ HEAD [ MINORS #minors ],
			   VAL #val,
			   HC-LEX #hclex,
			   HS-LEX #hslex ],
		     CONT.HOOK.INDEX #index ],
	     OPT #opt ] ].

j_j-co_rule := adj_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED "_co-_a_with_rel" ] !> ].

j_j-un_rule := adj_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_un-_a_neg_rel" ] !> ].

j_j-non_rule := adj_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET con,
   C-CONT.RELS <! [ PRED neg_rel ] !> ].

j_j-over_rule := adj_prefix_rule &
 [ ND-AFF +,
   SYNSEM.PHON.ONSET voc,
   C-CONT.RELS <! [ PRED "_over-_a_1_rel" ] !> ].


dependency_annotation_lexrule := lex_rule_supermost & word_or_punct_rule &
  [ ND-AFF +,
    KEY-ARG #keyarg,   
    INFLECTD #infl,
    SYNSEM #synsem,
    ARGS < #dtr &
           [ KEY-ARG #keyarg,
	     INFLECTD #infl,
	     SYNSEM #synsem,
             GENRE #genre ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    GENRE #genre,
    DTR #dtr ].

;; DPF 2014-04-23 - In response to multiple requests for a subtyping of the
;; inflectional rule type, I'm adding the following subtypes, to provide a
;; one-to-one association of inflectional rules and the types that they
;; instantiate.  Likewise for the derivational prefixing rules above.

n_pl_inflrule := lex_rule_infl_affixed.
v_3s-fin_inflrule := lex_rule_infl_affixed.
v_psp_inflrule := lex_rule_infl_affixed.
v_pst_inflrule := lex_rule_infl_affixed.
v_prp_inflrule := lex_rule_infl_affixed.
v_prp-nf_inflrule := lex_rule_infl_affixed.
v_n3s-bse_inflrule := lex_rule_infl_affixed.
n_sg_inflrule := lex_rule_infl_affixed.
n_ms_inflrule := lex_rule_infl_affixed.
n_ms-cnt_inflrule := lex_rule_infl_affixed.
;; DPF 2020-03-30 - Changed INFLECTD + to na_or_+ to get *$10 Cabernet*
;n_pl-cur_inflrule := lex_rule_infl_affixed.
n_pl-cur_inflrule := basic_lex_rule_infl_affixed &
  [ INFLECTD na_or_+ ].
;; DPF 2020-04-17 - Also need singular variant for *the $1 book*
n_sg-cur_inflrule := basic_lex_rule_infl_affixed &
  [ INFLECTD na_or_+ ].

;; DPF 2020-05-02 - Discharge weak brackets for multitoken lexical entries such 
;; as *Yahoo !* where the tokenizer has separated the suffixed character, and
;; for *HK $*, where a rule in tmr/split.tdl has added weak brackets to force
;; use of the multi-token entry, avoiding stranding of *$*.
;; DPF 2020-05-07 - Changed SYNSEM from lex_synsem to basic_lex_synsem so we
;; can also get robust *Once ,* lex entry to go through.
;; DPF 2020-07-22 - For simple single token entries (excluding the punctuation
;; mark), such as "Yahoo !", it is enough to assume that the TOKENS list is
;; exactly two elements long, where we check that each of those two has a
;; non-empty right delimiter (+TRAIT.+RD), and this would also work for a
;; prefixed punctuated lexical entry if we had any (e.g. "! Yahoo").  But for
;; an entry such as "et al ." the TOKENS list has more than two elements, and
;; we can't easily generalize to just check the last two elements of a list of
;; arbitrary length (TDL doesn't give us a way to do that).  So for now add
;; subtypes of this rule for two-token and three-token entries, just for suffix
;; punctuation, and defer the search for a more general solution.  FIX someday.
;;
basic_multitoken_bracket_rule := basic_lex_rule_supermost & word_or_punct_rule &
  [ INFLECTD #infl,
    KEY-ARG #keyarg,   
    DERIVED +,
    GENRE #genre,
    ORTH [ LB #lb, RB #rb, LD #ld, CLASS #class,
	   RD bracket_null ],
    SYNSEM #synsem & basic_lex_synsem,
    DTR #dtr,
    ARGS < #dtr &
           [ INFLECTD #infl & na_or_+,
	     KEY-ARG #keyarg,   
	     DERIVED -,
             GENRE #genre,
	     SYNSEM #synsem,
	     ORTH [ LB #lb, RB #rb, LD #ld, CLASS #class,
		    RD bracket_nonnull ] ] >,
    C-CONT.RELS <! !> ].

;; For two-token lexical entry including punct token such as "Yahoo !"
multitoken_bracket_rule := basic_multitoken_bracket_rule &
  [ ARGS < [ TOKENS.+LIST < [ +TRAIT.+RD bracket_nonnull ], 
			    [ +TRAIT.+RD bracket_nonnull ] > ] > ].

;; For three-token lexical entry including punct token such as "et al ."
multitoken_3_bracket_rule := basic_multitoken_bracket_rule &
  [ ARGS < [ TOKENS.+LIST < [ ],
			    [ +TRAIT.+RD bracket_nonnull ], 
			    [ +TRAIT.+RD bracket_nonnull ] > ] > ].
