;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;
;;;  Copyright (c) 1994-2018
;;;    Dan Flickinger, Rob Malouf, Emily M. Bender
;;;    see LICENSE for conditions
;;;
;;;  syntax.tdl
;;;
;;;  The grammar rules for English
;;;
;;;  Created: Rob Malouf, 3-Nov-1994
;;;
;;;  $Id: syntax.tdl 7479 2010-02-21 23:11:30Z danf $



;;
;;  Phrase structure schemata
;;

; Headed phrases must obey the Head Feature Principle and the Revised Marking
; Principle.  They do not all obey the NLFP with respect to QUE, but it
; appears that all CLAUSE phrases account for QUE on mother and non-head-dtr.
; Hence moved the QUE coreference to NON-CLAUSE.  Headed phrases also identify
; the value of AGR on mother and head daughter, unlike e.g. the coordination 
; schemata which identify HEAD but not AGR.  
;; DPF 2012-03-23: Interestingly, this identification of AGR might shed some
;; light on which daughter is the head in the proper-name phrase |Kim Browne|
;; since |[Kim and Mary] Browne| shows plural agreement when it's the subject.
;; We have been treating these proper-name compounds pretty much like other
;; nominal compound phrases, all of which have the right dtr as the head.
;; FIX, one way or the other.
;; DPF 2017-11-17: And note that we currently don't treat titles as heads in
;; |Mr. Browne|, but for |Mr. and Mrs. Browne| we want the NP to have plural
;; number, so if this generalization about headed phrases is right, then the
;; title will have to be the head of the NP.

headed_phrase := phrase & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD head & #head,
			   HC-LEX #hclex ],
		     AGR #agr,
		     CONJ #conj ],
	     PHON.ONSET #onset ],
    HD-DTR.SYNSEM.LOCAL local &
		 [ CAT [ HEAD #head,
                         HC-LEX #hclex ],
                   AGR #agr,
		   CONJ #conj ],
    ARGS.FIRST.SYNSEM.PHON.ONSET #onset ].


non_headed_phrase := phrase.

; Most but not all phrases have SYNSEM phr_synsem; head_complement constructions
; have their SYNSEM type determined by the head-dtr.

phrasal := phrase &
  [ SYNSEM phr_synsem ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments a la Ivan's
; relative clause paper) to the mother.  

head_nexus_rel_phrase := headed_phrase &
  [ SYNSEM.NONLOC.REL #rel,
    HD-DTR.SYNSEM.NONLOC.REL #rel ].

head_nexus_que_phrase := headed_phrase &
  [ SYNSEM.NONLOC.QUE #que,
    HD-DTR.SYNSEM.NONLOC.QUE #que ].

head_nexus_phrase := head_nexus_rel_phrase & head_nexus_que_phrase.

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head_nexus_phrase for
; treatment of REL and QUE.

head_valence_phrase := head_nexus_phrase &
  [ SYNSEM.NONLOC.SLASH #slash,
    HD-DTR.SYNSEM.NONLOC.SLASH #slash ].

; (Almost) all phrases are either unary or binary.
;; DPF 2018-07-16 - Added hack ORTH.FIRST bool so the bracket rules won't apply
;; even when using generalization (with ACE) where the circular diff lists that
;; should block such a configuration can get ignored.
;;
basic_unary_phrase := phrase &
  [ SYNSEM [ LOCAL [ CONT [ RELS *diff-list* &
				 [ LIST #first,
				   LAST #last ],
			    HCONS *diff-list* &
				 [ LIST #scfirst,
				   LAST #sclast ],
			    ICONS *diff-list* &
				 [ LIST #icfirst,
				   LAST #iclast ] ] ],
	     PHON.ONSET #onset ],
    ORTH [ TO #to,
	   FIRST bool ],
    C-CONT [ RELS [ LIST #first,
                    LAST #middle ],
	     HCONS [ LIST #scfirst,
                     LAST #scmiddle ],
	     ICONS [ LIST #icfirst,
                     LAST #icmiddle ] ],
    ARGS < sign & [ SYNSEM [ LOCAL local &
				   [ CONT [ RELS *diff-list* &
						 [ LIST #middle,
						   LAST #last ],
					    HCONS *diff-list* &
						 [ LIST #scmiddle,
						   LAST #sclast ],
					    ICONS *diff-list* &
						 [ LIST #icmiddle,
						   LAST #iclast ] ] ],
			     PHON.ONSET #onset ],
		    IDIOM #idiom,
                    DIALECT #dialect,
                    GENRE #genre,
		    ORTH.TO #to ] >,
    IDIOM #idiom,
    DIALECT #dialect,
    GENRE #genre ].

unary_phrase := basic_unary_phrase &
  [ INFLECTD +,
    ARGS < [ INFLECTD + ] > ].

generic_binary_phrase := non_unary-rule &
  [ SYNSEM [ LOCAL.CONT [ RELS *diff-list* &
			      [ LIST #first,
				LAST #last ],
                          HCONS *diff-list* &
			      [ LIST #scfirst,
				LAST #sclast ],
			  ICONS *diff-list* &
			      [ LIST #icfirst,
				LAST #iclast ] ] ],
    ORTH.TO #to,
    C-CONT [ RELS *diff-list* & 
		   [ LIST #first,
		     LAST #middle1 ],
	     HCONS *diff-list* &
		   [ LIST #scfirst,
		     LAST #scmiddle1 ],
	     ICONS *diff-list* &
		   [ LIST #icfirst,
		     LAST #icmiddle1 ] ],
    ARGS < sign & [ SYNSEM [ LOCAL local &
                                   [ CONT [ RELS *diff-list* &
                                                 [ LIST #middle1,
                                                   LAST #middle2 ],
                                            HCONS *diff-list* &
                                                 [ LIST #scmiddle1,
                                                   LAST #scmiddle2 ],
					    ICONS *diff-list* &
                                                 [ LIST #icmiddle1,
                                                   LAST #icmiddle2 ] ] ] ],
                    IDIOM #idiom,
                    DIALECT #dialect,
                    GENRE #genre ],
	   sign & [ SYNSEM [ LOCAL local &
                                   [ CONT [ RELS *diff-list* &
						[ LIST #middle2,
						  LAST #last ],
                                            HCONS *diff-list* &
						[ LIST #scmiddle2,
						  LAST #sclast ],
					    ICONS *diff-list* &
						[ LIST #icmiddle2,
						  LAST #iclast ] ] ] ],
		    ORTH.TO #to,
                    IDIOM #idiom,
                    DIALECT #dialect,
                    GENRE #genre ] >,
    IDIOM #idiom,
    DIALECT #dialect,
    GENRE #genre ].

;; Placeholder to allow for robust specialization
;;
basic_binary_phrase := generic_binary_phrase & phrase.

;; DPF 2019-03-31 - Exclude unpaired left paren on right dtr, to force paired
;; paren constituents.
;; DPF 2019-09-06 - Re 2019-03-31: But this is too simplistic, since once the
;; parens are paired, their marks should disappear.  Otherwise, we fail on e.g.
;; |Kim is (two days) older| because |(two days) older| is the second dtr of
;; |is (two days) older|, but its positive LPAREN value does not match its
;; zero RPAREN value which comes from |older|.  Would need a non-branching
;; paren-cancelling rule like the paired bracket rule.  FIX someday.
;; DPF 2020-03-30 - Note that this PAIRED identity also blocks
;; |Kim and [cats, who slept,] arrived|.  FIX sooner.
;; DPF 2020-04-01 - Okay, let's remove this identity, and CHECK.
;; DPF 2020-05-08 - One consequence is that we now unwantedly get
;; |[cats, not only] arise|
;;
#|
norm_binary_punct_phrase := basic_binary_phrase &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   PAIRED #paired,
                   RCLSTR #rclstr ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct ] ],
           [ SYNSEM.PUNCT [ PAIRED #paired,
                            RCLSTR #rclstr ] ] > ].
|#
norm_binary_punct_phrase := basic_binary_phrase &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RCLSTR #rclstr ],
    ARGS < [ SYNSEM.PUNCT [ LPUNCT #lpunct ] ],
           [ SYNSEM.PUNCT.RCLSTR #rclstr ] > ].

binary_punct_phrase := norm_binary_punct_phrase &
  [ SYNSEM.PUNCT.RPUNCT #rpunct,
    ARGS < [ ],
           [ SYNSEM.PUNCT.RPUNCT #rpunct ] > ].

binary_phrase := binary_punct_phrase &
  [ INFLECTD +,
    ARGS < [ INFLECTD + ],
           [ INFLECTD + ] > ].

basic_binary_headed_phrase := headed_phrase & basic_binary_phrase &
  [ NH-DTR sign ].

binary_headed_phrase := basic_binary_headed_phrase & binary_phrase.

binary_rule_left_to_right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary_rule_right_to_left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head_only := unary_phrase & headed_phrase &
  [ HD-DTR #head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #head > ].

basic_head_initial := basic_binary_headed_phrase &
  [ HD-DTR #head,
    NH-DTR #non-head,
    ARGS < #head, #non-head > ].

head_initial := basic_head_initial &
  [ NH-DTR.SYNSEM.LOCAL.CONJ cnil_or_numconj ].

head_initial_infl := head_initial & binary_headed_phrase.

head_final := basic_binary_headed_phrase &
  [ SYNSEM.PUNCT [ PAIRED #paired,
                   RCLSTR #rclstr ],
    HD-DTR #head & [ SYNSEM.PUNCT [ PAIRED #paired,
                                    RCLSTR #rclstr ] ],
    NH-DTR #non-head & [ SYNSEM.LOCAL.CONJ cnil ],
    ARGS < #non-head, #head > ].

head_final_infl := head_final & binary_headed_phrase.

; C-CONT is the semantic contribution of the phrase itself.  The handle and
; index of the phrase come from the handle and index of C-CONT (which are
; possibly but not necessarily identified with the handle and index of one of
; the daughters).  The liszt of the phrase is the append of the liszt of
; C-CONT and the liszts of the daughters.

head_compositional := headed_phrase &
  [ C-CONT.HOOK #hook,
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ].

nonhead_compositional := basic_binary_headed_phrase &
  [ C-CONT.HOOK.LTOP #ltop,
    NH-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop ].

non_clause := head_nexus_phrase &
  [ SYNSEM.LOCAL.CAT.MC na ].

; ERB (05-10-97) The immediate subtypes of clause are now rel_cl and
; non_rel_clause.  The latter groups together decl, imp, and (wh_)interrog,
; which are similar in that they can't serve as modifiers and have empty REL
; values.  That type used to be (misleadingly) named msg_clause.  The
; remaining constraint (MSG message) has been moved to the type clause
; where it belongs.

basic_clause := phrase &
  [ SYNSEM.LOCAL [ CAT.VAL [ COMPS < >,
			     SPCMPS < > ],
                   CONJ cnil ] ].

; DPF 15-sept-07 - Added hack --ADDIN feature to enable us to only use one
; inflected verb form for base and pres-non3sg.  See how it goes...

clause := basic_clause &
  [ SYNSEM.LOCAL [ CAT.HEAD [ TAM #tam,
                              --ADDIN [ ADDTAM #tam,
                                        ADDPN #pn ] ],
                   AGR.PNG.PN #pn ] ].

; DPF 12-Nov-03 - Renamed this from mc_phrase to mc_fillhead_phrase since
; they're the only ones inheriting from it, and it's a good place to add
; the following constraint:
; DPF 12-Nov-03 - Experimentally, make the XARG of this type be the XARG
; of the head-dtr, in order to support "on Tuesday who arrived" where the
; PP should share the handle of the VP (as if it had been extracted).
; DPF 24-oct-05 - But while the XARG for wh-subj phrases is the right handle,
; it's not for non-subj wh-phrases, so we push this constraint down to the
; two subtypes, adjusting appropriately
; DPF 06-mar-06 - Without messages, we don't need (or want) this XARG hack.

mc_fillhead_phrase := headed_phrase & clause &
  [ SYNSEM [ LOCAL.CAT.MC +,
	     NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist ] ] ].

; The [MC bool] constraint lives here rather than on clause because we want
; to treat relative clauses as clauses, but we need to distinguish them as the
; only clauses which can serve as modifiers.  That is, on the one hand we need
; to distinguish relative clauses from ordinary finite subj_head declaratives, 
; where both have a non-empty MOD value, but only the former can appear in a
; head-modifier phrase; and on the other hand we need to distinguish
; extracted-subject finite clauses from ordinary finite S/NP clauses, since 
; only the latter can be the dtr in a thatless-relative construction.  So the
; head-adjunct rule for nouns says the adjunct must be [MC na], and the 
; thatless_rel rule says the dtr must be [MC +].
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 26-Mar-03 - Removed reentrancy with HD-DTR..LTOP
; DPF 27-May-03 - Added reentrancy of HD-DTR's E-INDEX and C-CONT's, at least
; for coordination of S's where we want to attend to precedence relations of
; the coordinated events, which conjunctions pick up from E-INDEX not INDEX.

basic_non_rel_clause := head_nexus_rel_phrase & basic_clause & 
                        head_compositional.
non_rel_clause := basic_non_rel_clause & clause.

; DPF 26-Jan-01 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
;; DPF 2017-09-04 - Moved PRD - constraint down to subtype, in order to allow
;; non-matric subj-head to have PRD + for verbal gerunds, as in 
;; |me arriving surprised him|.

; CSY - changed HEAD basic_verb_or_frag to v_or_a for adj to head sentence
basic_decl_phrase := basic_non_rel_clause & phrasal &
  [ SYNSEM.LOCAL.CAT [ HEAD v_or_a &
                            [ INV - ],
                       MC bool ],
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #hdtop,
                                    INDEX #hdind ],
    C-CONT [ HOOK [ LTOP #hdtop,
                    INDEX #hdind ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].


decl_phrase := basic_decl_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

; Added [SYNSEM..SPR < >] on imp to preserve intended constraints on modifiers
; which only attach to VP and N-bar.
; DPF 13-May-00 - Added [DTR..SUBJ..CASE acc] to prevent ordinary finite
; verbs from serving as heads, now that we want to be able to later conjoin
; imperatives and finite clauses.
; DPF 13-May-00 - Added [DTR..CONT.HOOK.INDEX ref-ind] to prevent expl-there.
; DPF 22-Feb-01 - Removed above-mentioned [SPR < >], since we've decided to 
; allow sentence-initial PP-modifiers for WH-questions (see 11-Dec-00 below),
; and we still want to be able to coordinate imperatives and WH-questions, as
; in "Give me that book and what is its title?"
; DPF 20-Oct-01 - Replaced SUBJ < > with *olist* since we were blocking e.g.
; 'Tell me your bank's name and where is it?", and made the HD-DTR's SUBJ
; be unexpressed_reg so this cannot have as input an inverted phrase.
; Also replaced INV - with -* for the same example.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 04-mar-06 - Re 22-Feb-01: without messages, we need SPR < > to block
; spurious ambiguity for "arrive on monday."  Give up on odd S-coordination
; for now.
; DPF 06-sept-07 - Can't reconstruct why we divided into the two subrules
; with and without slash.  The cooccurrence with MC seems like it should be
; fully predictable.  So let's try collapsing these again, and see what
; happens.
; DPF 23-mar-10 - Restrict dtr to non_conj_event to avoid spurious ambiguity
; for "arise and leave."
;; DPF 2012-02-20 - Restrict SLASH to *modlist*, to prevent spurious analysis
;; of e.g. |politicians believe| with object fronting.
;; DPF 2015-04-01 - Re 23-mar-10: But this prevents imperatives with right-node
;; raising, and in |admire and hire Kim!|, where there is no alternative
;; aaalysis.  So have to live with the extra ambiguity for imperatives with
;; normal VP coord.
;; DPF 2017-11-01 - Identify VFORM on mother and dtr, so the VP can be sensitive
;; to modifiers that don't want imperatives, such as "last night".
;; DPF 2020-03-20 - Removed the recent constraint phr_synsem on mother, since
;; it blocks e.g. |Arise!|.  Let's see why it was added ...
;;
imp_phrase := basic_non_rel_clause & head_valence_phrase & head_only &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                [ INV -,
                                  VFORM #vform & imp_vform,
                                  TAM [ TENSE present,
                                        ASPECT no_aspect,
                                        MOOD indicative ] ],
                           VAL [ SUBJ *olist* & < anti_synsem_min >,
                                 SPR < >,
                                 COMPS < > ],
                           MC bool ],
                     CONT.HOOK.INDEX.SF basic-comm ],
	     NONLOC.SLASH.LIST *modlist*,
             LEX #lex,
	     PUNCT #punct ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM #vform ],
                                  MC na,
                                  VAL [ SUBJ < unexpressed_reg &
                                              [ --SIND #inst & ref-ind & 
						       [ PNG.PN 2 ],
						LOCAL.CONT.HOOK.INDEX #inst ]>,
					COMPS < > ] ],
                            CONT.HOOK [ LTOP #hdtop,
                                        INDEX #hdind ] ],
                    LEX #lex,
                    NONLOC.QUE 0-dlist,
                    PUNCT #punct & [ RPUNCT.PSF basic-comm & #sf ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #hdtop,
                    INDEX #hdind & [ SF #sf ] ],
             RELS <! [ PRED pronoun_q_rel,
		       RSTR #rhand,
		       ARG0 #inst,
		       CFROM #from, CTO #to ],
		     [ LBL #prohand,
		       PRED pron_rel,
		       ARG0 #inst & full_ref-ind &
			   [ PT zero,
			     SORT entity ],
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #prohand ] !>,
	     ICONS <! !> ] ].

; ERB (05-10-97) There is no longer a subtype of interrog for polar questions,
; as a result of streamlining the hd-cmp_u_c family (subordinate polar questions
; didn't inherit from the old ynq type anyway).  So interrog and its sole
; subtype wh_interrog could be collapsed into each other, but it seems clearer
; to have them separate.  I don't know what the effect of losing the constraint
; on SLASH in matrix polar questions will be.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
;; DPF 2013-02-13 - Don't pass up --SLTOP from hd-dtr to mother, since some
;; interrogative phrases are filler-head.

interrog := head_nexus_rel_phrase & clause & phrasal &
  [ SYNSEM [ LOCAL.CONT.HOOK [ LTOP #ltop,
			       INDEX #index & [ SF ques ],
			       XARG #xarg ],
             NONLOC.SLASH 0-dlist ],
    HD-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #ltop,
				    INDEX #index,
				    XARG #xarg ] ].

; Restrict NH-DTR to be [HEAD subst] to avoid trying non-partitive
; determiner "whose" as filler in filler-head-wh rules.  Assume all
; wh-interrog phrases are [MOOD ind_or_mod_subj].
; DPF 29-Aug-00 - But the above [ HEAD subst ] blocked "How often did kim win",
; so removed it. 
; DPF 20-sept-04 - Removed NH-DTR..RPUNCT no_punct since we want to allow e.g.
; "Which consultant, if hired, would work?" where the first comma attaches to
; the WH-NP.
; DPF 22-jul-05 - Changed NH-DTR..RPUNCT from rbc_or_pair... to 
; comma_or_rbc_or_pair... so the above example will still work.
; DPF 23-nov-09 - Don't recall what work [SF basic-wh-ques] is doing, so
; returning to simply [SF ques], in order to allow embedded inverted Qs as
; in "Kim asks me, where is abrams?"
;; DPF 2017-12-23 - The constraint NH-DTR..PNCTPR ppair prevents analysis of
;; e.g. |[why, in Paris,] did we dance?|, so let's remove it, and remind
;; ourselves of why it was here.
;;
wh_interrog := interrog & binary_headed_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD verbal &
                          [ TAM.MOOD indicative ],
                   CONT.HOOK.INDEX.SF ques ],
    NH-DTR.SYNSEM [ NONLOC.QUE 1-dlist,
                    PUNCT [ RPUNCT comma_or_rbc_or_pair_or_no_punct ] ] ].

; This type has subtypes for filler_head.  If we assumed only
; finite subj_head phrases, and explicitly made the relevant filler_head
; phrases be finite (which we do), we wouldn't have to stipulate VFORM here.

wh_interrog_fin := wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD verb & [ VFORM fin ],
		       VAL.SUBJ *olist*,
		       MC bool ] ].

; DPF (28-Apr-99) Need this construction to get simple yes-no questions like
; "Did Kim fall", while keeping the phrase "did Kim devour" with an empty
; MSG so it can be the head of "What did Kim devour", where this filler-head
; rule introduces the interrogative message.
; DPF 26-Jan-01 - Made HEAD.INV be +* to allow coord of inv and non-inv Ss.
; DPF 13-May-01 - Added [HD-DTR..VFORM fin] - was missing.
; DPF 12-Apr-02 - Made SYNSEM..SUBJ re-entrant with HD-DTR..SUBJ
; DPF 14-Feb-05 - Experimentally, make the XARG of this type be 
; the LTOP of the head-dtr, in order to support "on Tuesday, did kim arrive?"
; where the PP should share the handle of the VP (as if it had been extracted).
; DPF 14-mar-05 - Make hd_yesno_c not be a unary headed phrase in order to have
; it not be AUX +, so can still have PP-modifiers.  This means having to 
; duplicate the relevant links usually supplied by head_only_phrase.
; DPF 04-mar-06 - For now, block "Did who arrive?" since don't have a clear
; notion of what the semantics should be in our message-free universe, and
; don't want same semantics for this and "Who arrived?".
; DPF 06-mar-06 - Re: 14-Feb-05: Without messages, we don't need (or want) 
; this XARG hack.
;; DPF 2011-05-26 - Re 12-Apr-02: But this prevents embedded yes-no questions
;; such as |he asks, did we arrive?|.  So instead make SUBJ of mother be < >.
;; DPF 2012-07-26 - Re 2011-05-26: But < > prevents s-initial subordinate
;; modifers, as in |Given the response, should we stay?|. So change to
;; SUBJ < anti_synsem_min >.
;;
inv_subj_phrase := head_only &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ INV +,
                                         VFORM fin,
                                         MOD < anti_synsem_min >,
                                         MINORS #mins ],
                           VAL [ SUBJ < anti_synsem_min >,
                                 SPR < >,
                                 SPEC < >,
                                 COMPS < > ],
                           MC + ],
                     CONJ #conj & cnil,
                     AGR #agr,
                     CONT [ HOOK [ INDEX.SF #pred ] ] ],
             NONLOC [ SLASH #slash,
                      REL #rel,
                      QUE 0-dlist ],
	     PUNCT #punct ],
    HD-DTR #hddtr,
    ARGS < #hddtr &
           [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ INV +,
                                                  VFORM fin,
                                                  MINORS #mins ],
                                    MC na,
                                    VAL [ SUBJ < anti_synsem_min >,
                                          SPR *olist*,
                                          COMPS < > ] ],
                              AGR #agr,
                              CONJ #conj,
                              CONT [ HOOK [ INDEX #index &
                                                 [ E.TENSE real_tense ] ] ] ],
                      NONLOC [ SLASH #slash,
                               REL #rel & 0-dlist,
                               QUE 0-dlist ],
		      PUNCT #punct & [ RPUNCT.PSF #pred ] ] ] >,
    C-CONT [ HOOK.INDEX #index & [ SF #pred ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

yesno_phrase := interrog & inv_subj_phrase & head_compositional &
  [ C-CONT.HOOK.INDEX.SF pol-ques ].

inv_decl_phrase := inv_subj_phrase & non_rel_clause &
  [ SYNSEM [ NONLOC.SLASH 0-dlist,
	     PUNCT.RPUNCT comma_or_clause_or_pair_or_no_punct ],
    HD-DTR.SYNSEM [ LOCAL.CAT.NEGPOL +,
		    MODIFD lmod ],
    C-CONT.HOOK.INDEX.SF prop ].

; Since MOD is a head feature, and projections of finite verbs can be relative
; clauses, we introduce the [MOD nbar] property directly on finite verbs, 
; rather than in the rel_cl phrase type as before.  Then we have to be sure 
; that finite VPs do not appear as postnominal modifiers, and likewise for 
; declarative S's.  The former is blocked because the head-adjunct rule 
; requires that the adjunct be [SUBJ *olist*].  The latter we block by 
; requiring that the adjunct in a head-adjunct phrase be [MC na], while making 
; declarative head_subj phrases be [MC bool].  Thus relative clauses must also 
; be [MC na].
;
; DPF 27-May-99 - Avoid making rel_cl a headed_phrase, so it can be marked as
; [PRD +] even though its 'head' daughter is necessarily {PRD -].  Will be
; easier with defaults.
; DPF 15-Apr-00 - Removed REL 0-dlist from rel_cl, so we can distinguish
; relative clauses from other clauses; e.g., to avoid allowing "I am out on t"
; as a (non-strict) root.  
; DPF 22-May-02 - Added MOD..SPR..ALTMIN explicit_quant_or_udef_noagr_q_rel
; to prevent relative clauses from modifying NP-adv's like "there" as in 
; "there to be a bookcase" while still allowing e.g. "someone to fix the sink"
; DPF 30-May-02 - But this also blocks noun-noun-compound heads, since they
; are ALTMIN no_rel as a separate hack (see n_n_compound notes).  So undo this
; constraint, and figure out something else for "there to be a bookcase".
; DPF 27-Nov-02 - Added MOD..MIN basic_nom_rel to exclude measure-NPs from
; being modified by rel clauses.
; DPF 28-Nov-02 - HOOK comes only from C-CONT: INDEX from MOD, LTOP from HDTR.
; DFP 15-Nov-03 - Removed PRD + default, since we now want to distinguish 
; non_wh_inf_subj relative clauses (which can appear as complements of 'be') 
; from the rest, ; so now make most relative clause types PRD -, and only the 
; above type PRD +.  Also removed PRD + constraint on n_adj_int_phrase's 
; non-hd dtr, in pursuit of same goal.
; Since these are only restrictive relatives, prevent comma separating them
; from head noun.
; DPF 8-apr-05 - Replaced MOD..CAT nbar_cat_min with basic_nbar_cat, not
; restricting SPR to < synsem > because we want to allow "here where Abrams
; works" but still block "from happy here".  That is, prenom adjs impose a
; stronger constraint on their modifiee than postnom modifiers, so can't use
; the same CAT value for both.
;; DPF 2012-02-18 - Removed stamping of SF prop on mother, since this should
;; be (and is) done in the rule combining the relative clause with its head
;; noun.  Leaving it off here means we can parse |who is to arrive?| where
;; we treat the purposive phrase as an infinitival relative.
;;
basic_rel_cl := sign &
  [ SYNSEM 
    [ LOCAL 
      [ CAT 
        [ HEAD verb &
               [ INV -,
                 TAM.MOOD indicative,
                 MOD < synsem &
                       [ LOCAL intersective_mod &
			       [ CAT [ HEAD noun_or_nomger,
				       VAL [ SPR.FIRST synsem_min & 
						       [ --MIN quant_or_deg_rel ] ],
				       MC na ] ],
			 PUNCT.RPUNCT comma_or_rbc_or_pair_or_no_punct,
			 OPT - ] > ],
	  VAL.SPCMPS < >,
          POSTHD +,
          MC na ],
        CONJ cnil ],
      PHON.ONSET #onset ],
    ARGS.FIRST.SYNSEM.PHON.ONSET #onset ].

rel_cl := basic_rel_cl & clause & phrasal &
  [ SYNSEM [ LOCAL.CAT.HEAD.VFORM fin_or_inf,
             NONLOC [ QUE 0-dlist,
                      REL 0-dlist ] ] ].

; We prevent PP adjunct extraction from feeding thatless_rel rule by requiring
; that the gap be [ MOD < > ], to block "the man kim slept walks." To handle
; "I remember the time Kim fell" maybe we can make the words "time" and
; "place" take an S/PP complement, not treat them as thatless_rels.  Also, 
; to block "*Sandy likes the man walks" and "*Sandy likes the man who thinks 
; went home", we require the S/NP to be [ MC + ], which excludes subject
; extraction for that daughter.

; The dtr is required to be [MC +] in order to block subject-extracted S/NPs
; from being admitted as relative clauses.  This constraint would be removed
; for those dialects which accept examples like "There's a man wants to talk to
; you waiting outside."

; ERB (14-12-97) I am trying to get the non-finite ones to work and to
; have only one type that will make both "The man Kim likes" and "The
; man to talk to" (but not "The man to talk to Sandy".)  The new
; constraints are: on the head-dtr HEAD verb, VFORM fin_or_inf, and
; SUBJ list(pro).  I also need to make to_c_prop HEAD verb and 
; MC +.  The latter is because we want to require MC + of the head-dtr
; to exclude subject extraction as above, adn to exclude that-declaratives
; from being the head-dtr of this cx.  (To avoid a really ugly second
; parse for "The man that Kim likes.")

; ERB (14-12-97) to_c_prop doesn't have to be a verb.  non_wh_rel_cl
; can just say HEAD verbal -- that-decls will be ruled out because they
; are MC -.  To_c_prop has to be MC + anyway because we need the
; MC + on the head-dtr in order to bar subj extractions from this
; cx.

; ERB (19-01-98) MC + moved to appropriate subtype.  See notes below.

; ERB (19-01-98) Part of what's keeping to_c_prop from serving directly
; as a modifier without first building a non_wh_rel is that hadj requires
; SUBJ *olist* and pro_ss is OPT -.  This means that non_wh_rel_cl can't
; copy up the SUBJ requirement.  I don't know what exactly the constraints
; are on the other valence features, so I am just copying them up for now.
; (Previously all of VAL was identified.)
; DPF (21-Apr-98) Make SYNSEM.COMPS be < > on mother and *olist* on daughter.

; DPF (26-05-98) Added [MOD < [ NONLOC.QUE 0-dlist] >] to the mother, to 
; block thatless relatives modifying WH-partitives, as in the unwanted NP 
; "how many books are t"

; DPF (06-Sept-98) Added reg_nom_rel constraint on MOD..MIN
; to avoid infinitival relatives modifying temporal nouns as in "we should 
; meet next week to celebrate".  
; DPF (27-Jan-99) Updated this to non_temp_nom_rel.
; DPF 09-Jan-00 - Added HD-DTR..MODIFD notmod_or_rmod to block 
; adverb-initial relative clauses as in "The book apparently Sandy bought is 
; new"
; DPF 17-Mar-01 - Moved [ MOD..MIN non_temp_nom_rel ] to inf_non_wh_rel_cl rule
; only, since we want phrases like "the day he arrived".
; DPF 20-Mar-01 - Added MOD..MODIFD notmod_or_lmod to prevent thatless-rels
; from modifying already-modified nominals, especially with a full relative
; clause: *the book that I bought you have is long"
; DPF 26-Mar-01 - But this is too strong, also blocking "the city in Germany I 
; wanted to visit was Berlin".  So instead use RPERIPH feature.
; DPF 11-Sept-01 - Added [MOD..SPR synsem] to block e.g. 'there to be arriving'
; DPF 24-Apr-03 - Also removed MOD..MIN non_temp_nom_rel from inf_non_wh_rel_cl
; since it prevents e.g. 'a good time to meet would be tomorrow'  We'll see 
; what it was blocking.

; (ERB 2003-08-08) Add a type for instrument infinitival relatives,
; like "the Fedex number to return my package.  These are similar
; to ordinary infinitival relatives, except that we need to hallucinate
; a SLASH value and a _with_p_rel, and make the index of the SLASH
; be the ARG2 of the _with_p_rel.  Since non_wh_rel_cl introduces
; a SLASH value, the new type can't inherit from it directly.  Add
; a supertype basic_non_wh_rel_cl that has the rest of the constraints
; from non_wh_rel_cl.  Hmmm... it seems that there might be no need
; for that slash value, as non_wh_rel_cl just takes the MIN and INDEX
; and zeros it out.  I have no idea what we'd put in for that KEYREL, and
; the INDEX can be identified with the ARG2 of the_with_p_rel.
; (ERB 2003-08-11) Move constraint on HOOK.LTOP down to daughters,
; since I'm having the instr_inf_non_wh_rel_cl introduce the prpstn_m_rel.
;; DPF 2011-08-15 - Re 09-Jan-00: Since we now propagate MODIFD from VP to S
;; (in order to keep visibility of right-modif for first dtr in S-gapping
;; construction), change constraint on the dtr to be LPERIPH na_or_-, and
;; make adj-head-scopal rule stamp LPERIPH + on mother.
;; DPF 2017-03-02 - To avoid having these appear as complements in the 
;; head-marker-event (vs head_marker_s) rule, change SUBJ from just < > to
;; *anti_null*.
;;
basic_non_wh_rel_clause := unary_phrase & rel_cl &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM #vform,
				  TAM #tam,
				  AUX #aux,
				  INV #inv,
				  MOD < [ NONLOC.QUE 0-dlist,
                                          MODIFD.RPERIPH na_or_- ] >,
				  --ADDIN #addin,
                                  MINORS.MIN #min ],
			   VAL [ SUBJ *anti_null*,
				 SPR < >,
				 COMPS < > ] ],
		     AGR #agr ],
	     PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verbal &
					 [ VFORM #vform,
					   TAM #tam,
					   AUX #aux,
					   INV #inv,
					   --ADDIN #addin,
                                           MINORS.MIN #min ],
				    VAL.COMPS < > ],
			      AGR #agr,
			      CONJ cnil ],
                      NONLOC [ QUE 0-dlist,
                               REL 0-dlist ],
		      MODIFD.LPERIPH na_or_-,
                      PUNCT #punct & [ LPUNCT dq_or_sq_or_no_punct ] ] ] > ].

basic_non_wh_rel_cl := basic_non_wh_rel_clause &
  [ SYNSEM.NONLOC.SLASH 0-dlist ].

; DPF 05-sept-05 - Added identity of MOD..SPR..ALTMIN and SLASH..SPR..ALTMIN 
; to make visible properties that block e.g. 'six cabins have been' where 
; 'have been' underwent np_adv_c extraction (extradj-t)

non_wh_rel_cl := basic_non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD 
     [ MOD < [ --MIN #mmin,
              LOCAL [ CAT.VAL.SPR.FIRST [ LOCAL.CAT.HEAD.MINORS.ALTMIN #amin ],
		      CONT.HOOK.XARG #xarg ],
               --SIND #ind ] > ],
    C-CONT.HOOK.XARG #ind,
    ARGS < [ SYNSEM 
            [ LOCAL.CONT.HOOK.INDEX.SF prop-comm,
              NONLOC.SLASH 1-dlist &
              [ LIST < [ CAT 
                         [ HEAD noun &
                                [ PRD -,
                                  MOD < >,
                                  MINORS.MIN #mmin ],
                           VAL [ SPR < [ LOCAL.CAT.HEAD.MINORS.ALTMIN #amin ]>,
                                 COMPS < > ] ],
                         AGR #ind,
                         CONT.HOOK [ INDEX #ind,
				     XARG #xarg ] ] > ] ] ] > ].

; ERB (19-01-98) As much as it hurts, I don't think it is possible
; to avoid differentiating a inf and fin non_wh_rel_cl.  The facts of
; (Standard American) English seem to be that finite non-wh relatives
; do not allow extraction of the highest subject, but non-finite ones
; do:
;
; (1) Kim likes the book Sandy bought.
; (2) *Kim likes the person buys books.
; (3) Kim found a book to buy for Sandy.
; (4) Kim found a person to buy Sandy a book.
;
; A simple hack involving case won't work, because embedded subjects
; can be extracted in the finite case:
;
; (5) Sandy likes the program Kim thinks works.
;
; Another tack is to treat (3) and (4) above differently, where
; the to in (3) is to_c_prop and the to in (4) is to_c_nonprop.
; The motivation for this is that the former allows a discourse
; PRO interpretation, while the latter doesn't, so it is tempting
; to says that the latter doesn't involve PRO at all.  The idea is
; that to_c_prop builds a non_wh_rel which can then serve as a 
; modifier, while to_c_nonprop has a MOD value to start off with,
; and can be a modifier directly once it builds a hd-cmp_u_c.  To_c_nonprop
; would bind the index of its MOD value to that of its subject.
;
; However, this is unsatisfactory for several reasons.  First, the
; ones like (4), built with to_c_nonprop, have no message for the
; relative.  Second, since MOD is a head feature now, to_c_prop must
; also be MOD < nbar > .  Once this is true, there is no obvious way to
; keep it from serving directly as a modifier without building a
; non_wh_rel. Finally, we run into problems with lexical SLASH
; amalgamation.  Something has to be said about the subject value of
; to_c_nonprop, otherwise it runs the risk of having a non-terminated
; SLASH value.  However, on the one hand, to_c_nonprop is the to of
; raising constructions, so sometimes its SUBJ must be able to be
; canonical_synsem, and on the other, on this analysis, it can also
; head modifiers in which its SUBJ goes unexpressed.  To take care
; of the latter, something must be said in the lexical entry, but
; unexpressed is not compatible with canonical_synsem.
;
; The only other possibility I can see is to let the subject extraction
; apply lower, as in to [like Sandy] in [a person to like Sandy], but
; this requires letting subject extraction apply to base forms, which
; would most likely be a royal mess.
;
; In sum, given the facts of SAE and the rest of the grammar as
; it is, (3) and (4) must be built with the same to.  In (3) there
; is an extracted complement and in (4) there is an extracted 
; subject.  In the case of infinitival non_wh_rels, the grammar
; doesn't care.  In the case of finite ones, it does.
;
; DPF 10-dec-03 - Restricted MOD nbar-synsem to QUE 0-dlist, to block in-situ
; wh-modifiers preceding thatless relatives like 'a friend of whom I approved' 
; DPF 13-nov-05 - Added NORM no_rel to prevent these from appearing in 
; comparatives/equatives, as in "kim arrives as soon as browne arrives."
; DPF 19-apr-08 - Removed ARGS..INDEX non_conj_event since this blocks
; "books Kim admires and reads"
; DPF 10-aug-09 - Removed MOD..NORM norm_rel, since this prevented e.g.
; "the interview we had".  We'll see what if anything it was blocking.
;; DPF 2017-08-16 - Constrained dtr to be non-conjoined, since we don't want
;; analysis of |the cat that we admire and that Kim hates| where the "that"s
;; are complementizers, and we also want to block the NP
;; |*the cats either we love or we hate|.
;; Note that we still overgenerate for 
;; |the cat that we admire and that Kim hates| (with compl for second `that'),
;; but this will be harder to block since we need to allow conjoined S after
;; the first `that' in order to get one of the good readings for
;; |the cat whose tail we admire and Kim hates| where it's the tail Kim hates.
;; Alas, we'll also wrongly get this reading for 
;; |the cat whose tail we admire and that Kim hates| (using compl `that')
;; but not clear yet how to block this, without having separate S-coord
;; rules to preserve on the mother that the right conjunct was HEAD comp.
;; FIX someday.
;; DPF 2017-09-12 - Re 2017-08-16: Pushed this non-conjoined constraint down
;; to the normal subtype so we can avoid having it on the modgap variant,
;; so we can still accept |the day he arose and arrived appeared|
;; DPF 2017-09-14 - Re 13-nov-05: Let's try removing this, since it conflicts
;; with analysis of it-clefts as in |it was on Kim we relied|, so we'll see if
;; other constraints now prevent these in |Kim arrives as soon as Pat arrives|.
;; DPF 2017-09-26 - Re 2017-09-12 - But even on the normal subtype, the
;; constraint is too strong, since it fails to get |the book we bought and sold|
;; so instead we take advantage of conjoined S's being stamped as CASE non_nom,
;; and require the dtr here to be CASE no_case.
;; DPF 2020-04-10 - Use XARG.SORT entity-or-event to block WH-S subjects, as in 
;; |candidate [[who we should hire] bothers]|
;; DPF 2020-08-26 - Re 10-aug-09: This [NORM norm_rel] was blocking that-less
;; relative modifying singular deictic, to get contrast between 
;; "*This he bought was nice" but  "Those he bought were nice".  FIX.
;;
basic_fin_non_wh_rel_cl := basic_non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD 
                 [ PRD -,
                   MOD < [ MODIFD.RPERIPH -,
			   PUNCT.RPUNCT dq_or_sq_or_no_punct ] >,
                   MINORS [ ALTMIN #altmin ] ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD verb &
                                       [ VFORM fin,
                                         MINORS.ALTMIN #altmin,
                                         MOD < [ LOCAL.CAT nbar_cat_min,
                                                 NONLOC.QUE 0-dlist ] >,
					 CASE no_case ],
                                  VAL.SUBJ < anti_synsem_min >,
				  POSTHD +,
                                  MC - ],
                            CONT.HOOK [ LTOP #ltop,
                                        INDEX #event &
                                             [ E.TENSE real_tense ],
					XARG.SORT entity-or-event ] ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
	     HCONS <! !>,
	     ICONS <! !> ] ].

fin_non_wh_rel_cl := basic_fin_non_wh_rel_cl & non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ --MIN nonpro_or_refl_or_num_rel ] >,
    C-CONT.RELS <! !> ].

; DPF 19-jul-07 - Added MINORS.ALTMIN no_rel to prevent these from undergoing
; the subconj_prdp unary rule.

;; DPF 2012-12-21 - Constrained dtr's XARG.SORT to exclude do-index, to avoid
;; spurious parses with do-be entry for `be', as in wsj20d:22063009
;;
basic_inf_non_wh_rel_cl := basic_non_wh_rel_clause &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN no_rel,
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD comp & [ VFORM inf ],
			    CONT.HOOK.XARG.SORT basic-entity-or-event ]  ] >,
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

inf_non_wh_rel_cl := basic_inf_non_wh_rel_cl & non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD -,
			    MOD < [ --MIN nonpro_or_refl_or_num_rel ] > ],
    ARGS < [ SYNSEM.LOCAL [ CAT.VAL.SUBJ *cons*,
			    CONT.HOOK.LTOP #ltop ] ] >,
    C-CONT [ HOOK.LTOP #ltop,
             RELS <! !> ] ].

; DPF 26-Nov-03 - Added MODIFD notmod_or_rmod to enable blocking of spurious
; analysis for purposive "kim is probably to remain"
;; DPF 2012-08-01 - After conversation with EMB, decided to drop the
;; expected_event_v_rel from C-CONT, since not all subject relatives have
;; this reading, and the line is blurry about when they should:
;; |there is evidence to support that view|
;; |the first company to sell widgets|
;; DPF 2012-11-09 - But this is not quite enough, since we need someplace to
;; hang the tense information for |He was to arrive|.  So put back the EP,
;; but rename it to the more neutral `eventuality_rel', to avoid introducing
;; an often spurious notion of expectation.
;; DPF 2016-01-31 - I seemed to briefly think we should allow this type to 
;; have a non-empty SLASH, but cannot reproduce the motivation, so block it for
;; now, to avoid spurious ambiguity for |the cat to arise arrived|
;;
inf_non_wh_subj_rel_cl := basic_inf_non_wh_rel_cl &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ --SIND #ind ] >,
	     NONLOC.SLASH #slash ],
    ARGS < [ SYNSEM [ LOCAL [ CAT.VAL.SUBJ < synsem >,
                              CONT.HOOK [ LTOP #vpltop,
					  XARG #ind ] ],
		      NONLOC.SLASH #slash,
                      MODIFD notmod_or_rmod,
		      --MIN non_ellipt_rel ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event,
		    XARG #ind & non_expl-ind ],
             RELS <! arg1_relation &
                     [ LBL #ltop,
                       PRED eventuality_rel,
                       ARG0 #event & non_conj_event,
                       ARG1 #vpltop,
		       CFROM #from, CTO #to ] !> ] ].

; (ERB 2003-08-08) Type for instrumental infinitival relative clauses.
; See notes at basic_non_wh_rel_cl above.  Consider adding a type
; to capture similarities between constraints on this type and 
; inf_non_wh_rel_cl.

; (ERB 2003-08-08) Switch to nonprop to phrases so that I can still
; get at the handle for the verb relation within the clause (which
; should be the ARG1 of the with_p_rel).  The other options (using
; to_c_prop_le) were to cheat and get that handle through the KEYREL
; (illegal per the alegbra) or to introduce a slash value on the
; VP (?), which raises the problem of keeping those VP/NPs out of
; every other context.  
;
; This requires also switching from *prolist* to < synsem > as
; the constraint on the SUBJ of the daughter.  Maybe need to
; constrain NONLOC values of this synsem?  -- that seemed
; to reduce supurious ambiguity some.
;
; Indeed, I need to make it < unexpressed > in order to constrain
; the NONLOC values properly and keep the elided 'to' out of this
; construction.
; DPF 8-jun-04 - Added ARGS..MIN nonaux_event_rel to exclude elided "to", as
; in "the tenth to the eleventh"
;; DPF 2018-02-13 - Added ALTMIN no_rel to prevent these from being dtrs in
;; subconj_prdp_ellip rule.

instr_inf_non_wh_rel_cl := basic_non_wh_rel_cl &
  [ SYNSEM [ LOCAL.CAT.HEAD [ PRD -,
                              MOD < [ --SIND #index & ref-ind ] >,
			      MINORS.ALTMIN no_rel ] ],
    ARGS < [ SYNSEM phr_synsem &
                    [ LOCAL [ CAT [ HEAD comp & 
					 [ VFORM inf,
					   MINORS.MIN nonaux_event_rel ],
				    VAL.SUBJ < synsem > ],
			      CONT.HOOK [ LTOP #handle,
					  INDEX #event,
					  XARG #xarg ] ],
                      NONLOC.SLASH 0-dlist ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #handle,
                    INDEX #pind & [ SF prop-comm ],
                    XARG #xarg ],
             RELS <! prep_relation &
		   [ LBL #handle,
                     PRED with_p_rel,
                     ARG0 #pind,
		     ARG1 #event,
		     ARG2 #index,
		     CFROM #from, CTO #to ] !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

;; For |the day we arrived|
;; DPF 2017-09-30 - Changed HEAD noun to HEAD basic_noun so we can get
;; |anywhere we arrive|
;; DPF 2018-06-01 - For now, restrict to non-slashed head nominal.
;;
modgap_rel_cl := basic_non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD basic_noun,
				  NONLOC.SLASH 0-dlist,
				  --MIN modable_rel,
				  --SIND #mind ] >,
    ARGS < [ SYNSEM 
            [ LOCAL.CONT.HOOK.INDEX.SF prop-comm,
              NONLOC.SLASH 1-dlist &
              [ LIST < mod-local &
		       [ CAT.HEAD mobile & [ MOD < synsem > ],
                         CONT.HOOK [ LTOP #sltop,
				     INDEX #slind & [ SORT location ],
				     XARG #xarg ] ] > ] ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT.RELS <! prep_relation &
                   [ LBL #sltop,
		     PRED loc_nonsp_rel,
		     ARG0 #slind & [ E [ TENSE no_tense,
					 ASPECT no_aspect ] ],
		     ARG1 #xarg & event_or_index,
		     ARG2 #mind & [ SORT basic-entity-or-event ],
		     CFROM #from, CTO #to ] !> ].

fin_modgap_rel_cl := modgap_rel_cl & basic_fin_non_wh_rel_cl.

inf_modgap_rel_cl := modgap_rel_cl & basic_inf_non_wh_rel_cl &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD -,
    ARGS < [ SYNSEM.LOCAL [ CAT.VAL.SUBJ *cons*,
			    CONT.HOOK.LTOP #ltop ] ] >,
    C-CONT.HOOK.LTOP #ltop ].

; DPF 2-Jul-02 - Added MOD..RPERIPH - to block analysis of "Abrams hired"
; while allowing "anyone hired"
; DPF 25-aug-04 - Removed ARGS..MODIFD notmod_or_rmod since this blocked e.g.
; 'the consultants recently hired by Abrams'
; DPF 3-mar-05 - Added [LEX -] to prevent 'dog chased'.  Now treat
; 'anyone hired' like 'anyone angry' and live with the resulting spurious
; ambiguity of 'anyone angry at Kim'
; DPF 3-Feb-06 - Re: 2-Jul-02, this blocks 'Kim, hired by Abrams, arrived'
; so remove from here, and expect to treat this properly once we add
; non-restrictive relatives.
;; DPF 2012-02-18 - Tempted to relax [MOD..MIN basic_nonpro_rel], since it
;; blocks |you, admired by all, should be happy|.  But too much ambiguity
;; for pronoun followed by -ed verb, when no comma delimiters, so leave as 
;; is for now.
;; DPF 2012-12-21 - Constrain SPCMPS in case this erroneously appears as 
;; something's SPR.
;; DPF 2014-10-20 - Re 2012-02-18: Moved this nonpro constraint to the 
;; non-paired n-adj-relcl type, so we can get both |you, admired by all, ...|
;; and |the house which, viewed from above, seemed large ...|
;; DPF 2020-04-15 - Removed dtr's INDEX..PRF -, since this blocked
;; |the child, having slept, arose|
;;
red_rel_cl := unary_phrase & basic_rel_cl &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [ --SIND #ind ] >,
                                  PRD -,
                                  MINORS.MIN #min,
                                  VFORM #vform ],
                           VAL [ SUBJ *anti_null*,
                                 SPR < >,
                                 COMPS < >,
				 SPCMPS < > ] ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      REL 0-dlist,
                      QUE 0-dlist ],
             LEX #lex,
	     PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
					 [ VFORM non_fin & #vform,
					   PRD +,
                                           MINORS.MIN #min ],
				    VAL [ SUBJ < unexpressed_reg >,
                                          COMPS < > ] ],
			      CONT [ HOOK [ LTOP #vpltop,
                                            INDEX #vpind &
                                                 [ E.TENSE no_tense ],
                                            XARG #ind ] ],
			      CONJ cnil ],
                      NONLOC [ SLASH 0-dlist,
                               QUE 0-dlist,
                               REL 0-dlist ],
                      LEX #lex,
                      PUNCT #punct &
			    [ LPUNCT lital_or_pair_or_comma_or_no_punct ] ] ] >,
    C-CONT [ HOOK [ LTOP #vpltop,
                    INDEX #vpind & [ SF prop ],
                    XARG #ind ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 26-jun-03 - Added rule for making participial phrases into virtual
; subordinate phrases, as in "kim arrived devouring chocolate' analogous to 
; "Kim arrived while devouring chocolate"
; For now, exclude passives using VFORM: too much annoying ambiguity for 
; too little value.
; DPF 10-dec-03 - Tried restricting the  mother to POSTHD +, but this loses
; 'looking at Abrams, kim smiled" - would like to disallow pre-VP modification,
; but not yet clear how to do that.
; DPF 22-apr-04 - Corrected handle-linking to get the right semantics
; (making "kim arrived singing" analogous to "Kim arrived while singing").
; This rule should be generalized to include at least depictive adjectives
; and maybe also passive participles if we can find an argument that we need
; both analyses for e.g. "kim arose assisted by her nurse" - but cf. "Kim
; arose unassisted (by her nurse)" which suggests "assisted" may be adjectival,
; so maybe we don't have to open the door to also let in passives here.
; DPF 18-jul-04 - Added MOD..MSG message to reduce ambiguity, as in
; 'Kim is interviewing'
; DPF 27-jul-04 - Try allowing passives, but require that these phrases be
; preceded by a comma to reduce ambiguity.
; DPF 20-aug-04 - Generalize this rule to allow depictive adjectives as well,
; as in "Kim left, angry at Sandy", but split into two, in order to enforce
; comma separation from modified phrase.
; DPF 30-sept-04 - Since we want "Having arrived, Kim arose." but still want
; to block "*Kim is having arrived", we can't require the dtr to be PRD +,
; so here we compromise, and allow sentence-initial "having..." but not (yet)
; sentence-final, since it isn't clear how to exclude non-predicative adjs.
; DPF 7-mar-05 - Removed identification of MOD..AGR and ARGS..CONT.XARG, which 
; was motivation by e.g. "Seeing Kim, we left", but is incompatible with 
; expletive main clauses, like "Given his record, it was obvious that he would 
; be convicted."
; DPF 12-mar-05 - Constrained XARG of dtr to be non_expl-ind, to exclude 
; expletive it-taking phrases, such as "Kim arrived, possible that Abrams 
; arose"
; DPF 29-mar-05 - Re 18-jul-04, this blocks e.g. "After measuring the height
; using a ruler, we emerged", so let's try removing this hack to see if we
; can live with the added (necessary) ambiguity.
; DPF 27-sept-05 - Try making SPR empty for these phrases, to avoid ambiguity
; for e.g. "just laughing" where was attaching to mother as well as daughter.
; DPF 18-jul-07 - Consistent with blocking of PP modifiers to auxiliaries,
; let's try imposing same restriction on depictives, to avoid spurious
; ambiguity for e.g. "Kim would appear prominent."
; DPF 06-sept-07 - Add constraint on MOD..MOD to exclude attachment of 
; these subconj phrases to relative clauses, to avoid spurious analysis for
; e.g. "the cat we should be connected arrives."
; DPF 30-jun-09 - Re 30-sept-04: Now that "having arrived" is not marked for
; PRD, restore PRD + on dtr, in order to prevent reduced-relative VPs from
; being dtr in this rule (as they are PRD -).
; DPF 2010-09-17 - Removed C-CONT..INDEX non_conj_event, since we are now
; (correctly) unifying the phrase's INDEX with that of the modifiee, which
; might of course be conjoined, as in "Kim was happy and surprised, winning."
;; DPF 2016-10-04 - Pushed MOD..RPERIPH - down to subtypes, since we want at
;; least the prdp-pas variant to allow na_or_- so we admit
;; |we must, given the arguments, agree with Kim|.

subconj_prdp_phr := unary_phrase &
  [ SYNSEM basic_subconj_synsem &
           [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT.HEAD.MOD *anti_list*,
					  --SIND #modind,
					  OPT - ] >,
				  PRD -,
                                  MINORS.NORM no_rel ],
                           VAL [ COMPS < >,
				 SUBJ *anti_null*,
                                 SPR < >,
				 SPCMPS < > ] ],
                     CONJ #conj ],
             NONLOC [ SLASH 0-dlist,
                      REL 0-dlist,
                      QUE 0-dlist ],
	     MODIFD hasmod,
	     --SIND #modind,
             LEX #lex,
	     PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD v_or_a & 
                                         [ TAM.TENSE no_tense,
                                           MOD < [ LOCAL intersective_mod ] >,
					   PRD + ],
                                    VAL [ SUBJ *olist*,
                                          SPR *olist*,
                                          COMPS < > ],
                                    MC na,
                                    POSTHD + ],
                              CONT [ HOOK [ LTOP #vpltop,
                                            INDEX.SF prop,
                                            XARG non_expl-ind ] ],
			      CONJ cnil & #conj ],
		      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                               QUE 0-dlist,
                               REL 0-dlist ],
                      LEX #lex,
		      PUNCT #punct ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK.INDEX #modind,
	     RELS.LIST < relation &
                         [ PRED subord_rel,
                           ARG2 #subord,
			   CFROM #from, CTO #to ], ... >,
             HCONS <! qeq, qeq & [ HARG #subord,
                                   LARG #vpltop ] !>,
	     ICONS <! !> ] ].

; DPF 23-aug-04 - Further divide the s-initial variant to require a comma for
; the adjectival ones, though not for the verbal ones, to avoid unwanted
; analysis for "happy dogs bark" but allow "arriving in Paris we smiled",
; and further to exclude pre-VP modification.  And further exclude extraction,
; to avoid unwanted analysis for 
; "the women [SBCNJ evaluated [S/NP their own staffs]]".
; DPF 14-feb-07 - Changed MOD..SUBJ *olist* to *ocons* to avoid spurious
; analysis for "Browne was hired to fire Abrams."
; DPF 08-apr-08 - Removed MODIFD notmod_or_rmod to allow 
; "Happy, eager, Kim arose."
; DPF 04-sep-09 - Restrict MOD..SUBJ to < anti_synsem_min >, to block pre-VP
; modification.
;; DPF 2013-09-27 - Removed MOD..MC na_or_+ since this blocked e.g.
;; |we found that given enough effort, we could succeed|
;; DPF 2016-10-04 - Re 23-aug-04: But imposing SLASH 0-dlist prevents the
;; analysis we want for |In Paris, following the party, we celebrated|.  So
;; remove, and note that the unwanted analysis is now blocked for other reasons
;; for |the women evaluated their own staffs|
;; DPF 2016-10-26 - Re 2016-10-04: It's doubtful that we want to impose an
;; RPERIPH - constraint on the pre-modifying subtypes, since they should not
;; care about their mod target's right periphery.  And this currently blocks
;; |halting, we arose to shout.|  So remove, and monitor for possible FIX?
;;
subconj_prdp_init_phr := subconj_prdp_phr &
  [ SYNSEM [ LOCAL.CAT [ POSTHD -,
                         HEAD.MOD < [ LOCAL [ CAT [ HEAD verb,
                                                    VAL.SUBJ 
						         < anti_synsem_min > ]],
				      PUNCT.RPUNCT.PSF #pred ] > ],
             PUNCT [ LPUNCT pair_or_no_punct,
                     RPUNCT comma_or_pair_or_no_punct ] ],
    C-CONT [ HOOK [ LTOP #sltop,
                    INDEX.SF #pred ],
             RELS <! [ LBL #sltop ] !> ] ].
                         
;; DPF 2018-06-01 - For efficiency, block extraction from head
;;
subconj_prdp_a_init_phr := subconj_prdp_init_phr &
  [ SYNSEM [ LOCAL.CAT [ POSTHD -,
			 HEAD.MOD.FIRST.NONLOC.SLASH 0-dlist ],
             PUNCT.RPUNCT comma_punct ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adj &
                                   [ PRD +,
				     MOD < synsem >,
				     MINORS.NORM norm_rel ] ] > ].

subconj_prdp_v_init_phrase := subconj_prdp_init_phr &
  [ SYNSEM.LOCAL.CAT.POSTHD -,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD verb &
                                   [ VFORM pas_or_prp ] ] > ].

; DPF 13-sept-07 - Restrict to RPUNCT comma_punct for lexical VPs, to avoid 
; extra ambiguity for e.g. "hired consultants arrived"
; (But add this constraint in constructions.tdl, so more easily changed).
subconj_prdp_v_init_lex := subconj_prdp_v_init_phrase &
  [ ARGS < [ SYNSEM.LEX + ] > ].

subconj_prdp_v_init_phr := subconj_prdp_v_init_phrase &
  [ ARGS < [ SYNSEM.LEX - ] > ].

; Avoid spurious reading for "Kim is arriving" by requiring the modified
; phrase to be ALTMIN non_ellipt_rel, excluding elided auxiliaries.  Separate
; variant includes elided VPs if modified is RPUNCT comma_or_pair_punct.
; DPF 29-mar-05 - Also restrict final passives to preceding comma,
; Also try restricting these final guys to VP-modifying only, but still
; keep semantics consistent with (and as baroque as) that for "the dog
; barked when arriving", where the when-clause must provide an outermost
; message since it can't know if it will modify a VP or an S; in the latter
; case it must supply a message to preserve the convention that there is
; always a message at the top.
;; DPF 2015-03-12 - Changed MOD..SUBJ *synlist* to MOD..SPR < synsem_min, ...>,
;; in order to admit |we arose, said Kim, arriving|.  The problem was that
;; filler-hd  requires hd-dtr to be [SUBJ *anti_list*].
;; DPF 2016-07-03 - Changed [MOD..ALTMIN non_ellipt_rel] to 
;; MOD..MIN noncop_event_rel, to  allow |Kim could drunk| while still blocking 
;; spurious |Kim was drunk|.
;; DPF 2018-03-08 - Added MOD..MC na_or_- to restrict attachment to VP at
;; least in main clauses.  Can't make it just na since in inverted quotes such
;; as |they arrived, reported Kim, relieved.|, the phrase |reported Kim| will
;; be MC - as the head of the filler-head construction.
;; DPF 2018-05-25 - Changed MOD..ALTMIN from norm_rel back to non_ellipt_rel,
;; for significant efficiency gain (10%), at the cost of one item in Redwoods:
;; cb:2200 "... improve the code far more quickly than you could unaided."
;; FIX someday, perhaps with ubertagging.
;;
subconj_prdp_final_phr := subconj_prdp_phr &
  [ SYNSEM.LOCAL.CAT 
                  [ POSTHD +,
                 HEAD.MOD < [ LOCAL.CAT [ HEAD.MINORS [ MIN noncop_event_rel,
							ALTMIN non_ellipt_rel ],
					    VAL.SPR < synsem_min, ... >,
					    MC na_or_- ],
				 MODIFD [ LPERIPH na_or_-,
					  RPERIPH na_or_- ] ] > ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.PRD + ] >,
    C-CONT [ HOOK.LTOP #sltop,
             RELS <! [ LBL #sltop ] !> ] ].

subconj_prdp_prp_phr := subconj_prdp_final_phr &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.VFORM prp,
                      PUNCT.LPUNCT lparen_or_no_punct ] ] > ].

;; DPF 2012-12-17 - Removed the MOD..SLASH 0-dlist constraint, since it wrongly
;; blocked examples like |Here, they arrived admired.|
;; DPF 2012-12-29 - Re 2012-12-17: But allowing the head to be slashed also
;; admits unwanted RNR analyses for e.g. wsj20d:22080002: 
;; |bids were __ submitted and bids were at __ 10%|
;; So restore no-slash for now, and re-evaluate (FIX) later.
;; DPF 2016-09-26 - Re 2012-12-20: Removing this wrong constraint again, and
;; accept the unlikely RNR analysis of |Kim is admired and is chased the cat|.
;;
subconj_prdp_pas_phr := subconj_prdp_final_phr &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.VFORM pas,
		      OPT + ] ] > ].

subconj_prdp_adj_phr := subconj_prdp_final_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD basic_adj & [ MINORS.NORM norm_rel ],
		      OPT +,
                      PUNCT.LPUNCT pair_or_no_punct ] ] > ].

subconj_prdp_ellip_phr := subconj_prdp_phr &
  [ SYNSEM.LOCAL.CAT [ POSTHD +,
                       HEAD.MOD < [ LOCAL.CAT [ HEAD.MINORS.ALTMIN ellipsis_rel,
						MC na_or_- ],
				    MODIFD [ LPERIPH na_or_-,
					     RPERIPH - ],
                                    PUNCT.RPUNCT comma_or_pair_punct &
                                                 [ PSF #pred ] ] > ],
    C-CONT [ HOOK [ LTOP #sltop,
                    INDEX.SF #pred ],
             RELS <! [ LBL #sltop ] !> ],
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD [ PRD +,
				       MINORS.ALTMIN norm_rel ],
		      OPT + ] ] > ].

; For predicative 'small clause' modifiers: "Kim sang, the voice surprisingly
; clear"
;; DPF 2012-02-18 - To exclude infinitival relatives as right dtr, added
;; [ALTMIN norm_rel].
;; DPF 2012-09-30 - Also extend here the OPT + hack used to exclude some
;; predicative phrases as depictives, such as in |He arrived a year earlier|
;; DPF 2012-12-21 - Generalized left dtr's HEAD from noun to basic_noun in
;; order to admit |we arose, some terrified|
;; DPF 2015-03-17 - Removed left-dtr's CASE acc since we want to allow
;; |we arrived, I happy and you sad|
;; DPF 2016-01-25 - The RPUNCT on the mother's MOD value can't just be
;; comma_or_clause because the modifier phrase might be a parenthetical, as
;; in |we arose (Kim arriving)|.  We have no good way to say with one rule
;; that either the modified phrase is puncuation marked or the modifyier
;; phrase is parenthesized.  Maybe split into two rules?  FIX.
;; DPF 2016-02-03 - Added NORM no_rel to first dtr, to prevent foreign words
;; (output of lexical rule) from appearing here, to avoid spurious analyses
;; in |the abbreviation ["in" for "inches"]|
;; DPF 2016-07-04 - Added MOD..LEX na_or_- to exclude lexical CP targets such
;; as |what| as in |what Kim happy|
;; DPF 2016-09-16 - Along the way, added MOD.FIRST expressed_synsem to second
;; dtr, but not clear why, and unfortunately it prevented |Kim being angry|
;; so remove, and see if we can recall why it was added.  FIX?
;; DPF 2016-09-18 - Re 2016-02-03: Reconsidered this hack for foreign words:
;; too strong, so remove NORM on mother of the fw lexical rule, and also from
;; the left dtr of this rule, allowing us once again to admit |we speak two
;; languages, the other being Spanish|.
;; DPF 2016-10-27 - Re 2012-12-21: But we also want predicative modifiers marked
;; as non-noun-modifying, such as |on| in |we left, the stove still on|.  So
;; remove the identity of HEAD for first dtr and second dtr's MOD, and constrain
;; the second dtr's MOD to be HEAD n_or_v.
;; DPF 2016-12-16 - Changed mother's MOD..RPERIPH from - to na_or_-, since we
;; want to admit |we arrive to arise, the cat being our friend|.
;; DPF 2017-09-05 - Constrained left dtr to be SORT norm-entity-or-event in 
;; order to block WH-clauses there, as in |who are fifteen to twenty feet tall|
;; DPF 2017-09-06 - Re 2016-01-25: Okay, did the split into two rules, to avoid
;; spurious analyis for |Jerome has fifty dollars he saved.|
;; DPF 2017-10-09 - Re 2017-09-05: But this blocks |the idea being that we win|,
;; so remove, since anyway we do want to allow (nominalizations of) WH-clauses 
;; as first argument, as in |we cheered, who won being the source of our joy|.
;; DPF 2018-04-21 - The surprising SUBJ *anti_null* on the mother blocks these
;; in the head_marker phrase we would need for |we left, Kim angry and Chiang
;; furious|.  So let's try just making it the empty list, and see what might
;; go wrong.
;; DPF 2018-04-21 - Also generalized right dtr's RPUNCT to allow no_punct, so
;; we can get the example above where the first conjunct is not right-punct-
;; marked.
;; DPF 2018-06-01 - For efficiency, it is tempting to prevent these as 
;; VP-modifying, since they rarely occur between the subject and the VP.  But
;; they do appear with some frequency in the first conjunct of a conjoined VP,
;; as in |they made a donation, most of it as cash, and were thanked| (see
;; wsj01d:20187008).  We also do see them as pre-VP modifiers, as in
;; |the child, his arms flailing, fell off the fence|.  So instead let's split
;; this type into pre- and post-modifying, and make the pre-mod be comma-marked.
;;
np_pred_phr := non_headed_phrase & binary_phrase &
  [ SYNSEM basic_subconj_synsem &
	   [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT [ HEAD verb &
							   [ MOD *anti_list* ],
						      MC #mc ],
					  MODIFD [ LPERIPH na_or_-,
                                                   RPERIPH na_or_- ],
					  LEX na_or_-,
					  NONLOC.SLASH 0-dlist,
					  PUNCT.RPUNCT 
					  clause_or_semi_or_comma_or_no_punct &
					  		 [ PSF #sf ] ] >,
				  PRD -,
				  MINORS.NORM no_rel ],
			   VAL [ SUBJ < >,
				 SPR < >,
				 COMPS < >,
				 SPCMPS < > ],
			   MC #mc ],
		     AGR #agr,
		     CONJ cnil ],
	     NONLOC non-local_none_phr & #nonloc ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD basic_noun &
					 [ MINORS.ALTMIN non_freerel_q_rel,
					   CASE real_case,
					   --BARE - ],
				    VAL [ SPR *olist*,
					  COMPS *olist* ] ],
			      CONT.HOOK.INDEX #modind,
			      CONJ cnil ],
		      NONLOC non-local_none_phr,
		      PUNCT.RPUNCT no_punct ] ],
	   [ SYNSEM [ LOCAL [ CAT [ HEAD subst &
				    [ MOD < [ LOCAL intersective_mod &
					      [ CAT [ HEAD n_or_v,
						      VAL.SPR < synsem > ] ],
					      --SIND #modind ] >,
				      MINORS.ALTMIN norm_rel,
				      PRD + ],
				    VAL [ SUBJ *synlist*,
					  SPR *olist*,
					  COMPS < >,
					  SPCMPS < > ],
				    POSTHD + ],
			      AGR #agr,
			      CONT.HOOK [ LTOP #modltop,
					  INDEX #rind,
					  XARG #modind ],
			      CONJ cnil ],
		      NONLOC #nonloc,
		      OPT +,
		      PUNCT.RPUNCT 
			     comma_or_rbc_or_clause_or_pair_or_no_punct ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX #rind & [ SF #sf ] ],
	     RELS <! relation &
		   [ LBL #ltop,
		     PRED subord_rel,
		     ARG2 #subord,
		     CFROM #from, CTO #to ] !>,
             HCONS <! qeq, qeq & [ HARG #subord,
                                   LARG #modltop ] !>,
	     ICONS <! !> ] ].

; The version of the Non-local Feature Principle here assumes that there will
; only be one value on the SLASH list.  To handle multiple gaps, we'll need
; more general set-manipulation functions.  This version also doesn't use a
; distinction between INHERITED and TO-BIND non-local features.  Instead, it
; treats non-local features like valence features.

; ERB (17-10-96) in order to get "Kim knows who to ask" under the current
; hacks (i.e., no PRO), I need a head_filler_phrase that takes something like
; "to ask" (i.e., VFORM in, SUBJ nomp) as its head.  So I am making a
; separate parallel type that will only be inherited by the embedded wh
; nonfinite questions.

; N.B. Since all head_filler constructions inherit from type clause, which
; inherits from head_compositional, this type does not (though it could,
; redundantly).

; Added [ SUBJ *prolist* ] constraint to NH-DTR, to ensure termination
; of the QUE and REL attributes now that we're doing lexical threading, and
; PPs (among others) wouldn't otherwise know if they were QUE empty or not.
;
; (DPF 23-Aug-98) But if we make the SUBJ *prolist*, then we can't get 
; extraction of raising predicates, as in "how does Kim look", since the
; subject of the "how" adjective is identified with that of "look".  Hence
; we move this constraint to the extracted-adjunct rule, since it seems to
; hold true for adjuncts, but not for complements.
; DPF 23-Sept-99 - Made mother be POSTHD +, to avoid clauses as prenominal
; modifiers.
; DPF 11-Dec-00 - Removed SPR < > from mother, to allow sentence-initial PP
; modifiers for WH-questions.
; DPF 03-nov-03 - Moved SPR < > to head_filler_phrase so it does
; not hold for relative clause head-filler phrases, to block analysis for e.g.
; 'when we arrive in Berlin' as RELS+PP.
; DPF 18-jun-04 - Replaced parent basic_binary_phrase with binary_phrase to
; get PUNCT attributes inherited.  This predicts the INFLECTD features that
; were stipulated, but also adds propagation of GENRE, which might cause
; surprises.
; DPF 21-jul-04 - Moved HD-DTR.QUE 0-dlist from this type to the non-fin and
; non-wh subtypes, in order to allow in-situ WH phrases in combination with
; WH phrases, as in "who hired whom", and to allow ?-punctuation (which also
; introduces a non-empty QUE in order to trigger sb-hd_q_c with interrogative
; semantics for "Abrams hired Browne?").
; DPF 18-feb-08 - Removed ARGS.FIRST..SUBJ *antisyn_or_prolist* to see what
; work it was doing ... (it is getting in the way).
;; DPF 2018-03-07 - Re 18-feb-08: We need to constrain the filler's SUBJ to
;; be *olist* in order to block |[admired him] arose|.

; CSY 17-12-2020 - comment out HEAD verbal
;     5-1-2020 - uncommented
basic_head_filler_phrase := binary_punct_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
				 SPCMPS < > ],
			   POSTHD + ],
		     CONJ cnil ],
	     NONLOC.SLASH 0-dlist,
             PUNCT.PNCTPR #ppair ],
    ARGS < [ SYNSEM [ LOCAL #slash & local &
			    [ CAT.VAL [ COMPS *olist*,
					SUBJ *olist* ],
			      CTXT.ACTIVATED + ],
		      NONLOC.SLASH 0-dlist ] ],
           [ SYNSEM [ LOCAL [ CAT [; HEAD verbal,
                                    VAL.COMPS < > ],
                              CONT.HOOK [ INDEX.--TPC + ] ],
		      NONLOC [ SLASH 1-dlist &
					[ LIST [ FIRST #slash,
						 REST < > & #last ],
					  LAST #last ],
                               REL 0-dlist ],
                      PUNCT [ LPUNCT lparen_or_dq_or_comma_or_no_punct,
                              PNCTPR #ppair ] ] ] > ].

; DPF 21-jul-04 - Removed parent head_nexus_que_phrase since this didn't allow
; multiple-wh clauses like "who hired whom", and it wrongly implied that there
; would be filler-head constructions where the mother still had a non-empty
; QUE value.

head_filler_phrase := basic_head_filler_phrase & head_final & binary_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < >,
             NONLOC.QUE 0-dlist ],
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.SPR *olist* ], sign > ].

basic_head_filler_phrase_fin := head_filler_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ VFORM fin_or_imp,
                                            TAM.TENSE real_tense ],
                              VAL.SUBJ *olist* ] ].

head_filler_phrase_wh_fin := basic_head_filler_phrase_fin & head_final_infl &
  [ NH-DTR.SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
		    PUNCT.RPUNCT comma_or_rbc_or_pair_or_no_punct ],
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM fin ].

head_filler_phrase_inf := head_filler_phrase & head_final_infl &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD verbal & [ VFORM inf ],
                    NONLOC.QUE 0-dlist ],
    NH-DTR.SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
		    PUNCT.RPUNCT comma_or_pair_or_no_punct ] ].

; N.B. Since all head_subj_phrase constructions inherit from type clause,
; which inherits from head_compositional, this type does not (though it could,
; redundantly).
;
; 1-May-96 (DPF) Restricted head to be verb only, to block spurious parses
; where NP modifed by PP was also analyzed as its subject.
; 12-Jun-96 (RPM) Allow verbal gerunds to head head/subj phrases.
; DPF (28-Apr-99) Added INV - to head-dtr, since most auxiliary verbs are
; underspecified for INV.
; DPF 27-May-99 - Constrained subj to be unslashed, in order to block, e.g.
; "the consultant that kim hired slept fell".
; DPF 23-Sept-99 - Made mother be POSTHD +, to avoid clauses as prenominal
; modifiers.
; DPF 26-Jan-01 - Changed HEAD.INV + to HEAD.INV +* to allow for coordination
; of inverted and non-inverted sentences.  Worry that this swap has been made
; before, but next time we'll know why.
; DPF 2-Feb-01 - Changed SPR of mother to *olist*, to allow coordination with
; head-filler phrases which are [ SPR < anti_synsem > ].
; DPF 20-Oct-01 - Changed SUBJ of mother to *olist*, to allow coordination with
; imperatives which are SUBJ *olist* so they can coordinate with interrogs.
; DPF 18-Nov-04 - Removed NH-DTR..SLASH.LIST < > since this was unnecessary
; (see 27-May-99), and blocked "People who think we arrive arise".
; DPF 10-may-05 - We won't block comma-marked subjects at present, since in
; informal text genres, they sometimes occur (as in the first two examples in
; Rondane :).  Maybe consider for an example of genre-specific constraints,
; excluding such marking in edited text.
;; DPF 2011-12-13 - Removed identity of whole MODIF value on mother and head
;; dtr (cf. |Still, I happily arrived|), instead only preserving the RPERIPH
;; value.
;; DPF 2017-09-16 - Moved mother's CASE non_nom down to main-clause subtype,
;; since we analyze verb gerunds such as in |me admiring Oslo surprised her|
;; via |me admiring Oslo| as a subj-hd phrase.
;; DPF 2017-11-19 - Added *obllist* to mother's SPR, to force verbal gerunds
;; that pick up a subject as in |you chasing the cat| rather than a specifier 
;; as in |your chasing the cat| to then undergo the bare_vger rule which
;; supplies a quantifier for the nominalize_rel's ARG0.
;; DPF 2018-05-30 - Re 18-Nov-04: Don't understand that comment, but while it
;; is tempting to exclude all extraction from subjects, it's not possible:
;; consider |Europe has many citizens, of whom five million __ live in Norway|
;; where the complement of-PP is extracted from the partitive subject.
;;
; 19-11-2020 took away *obllist* and in hd dtr removed SPR.REST to leave SPR
basic_head_subj_phrase := head_nexus_rel_phrase & head_final_infl & phrasal &
			  head_compositional &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
				 SPR #spr,; & *obllist*,
				 SUBJ *olist* & < anti_synsem_min >,
				 SPEC #spec,
				 SPCMPS < > ] ],
                     CONJ cnil & [ LCHEAD #lch ] ],
	     MODIFD.RPERIPH #rperiph,
             PUNCT.PNCTPR #ppair ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ COMPS < >,
				      SPR #spr,
                                      SPEC #spec ],
                                MC na ],
		    MODIFD.RPERIPH #rperiph,
                    PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
                            PNCTPR #ppair ] ],
    NH-DTR.SYNSEM canonical_synsem &
		 [ LOCAL [ CAT [ HEAD subst,
				 VAL [ SUBJ *olist_or_prolist*,
				       COMPS < >,
				       SPR *olist* ] ],
			   CONJ.LCHEAD #lch ],
        	   NONLOC [ REL 0-dlist ],
                   PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
                           RPUNCT comma_or_rbc_or_pair_or_no_punct ] ] ].

head_subj_phrase := basic_head_subj_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #synsem >,
    NH-DTR.SYNSEM #synsem & [ PUNCT.PNCTPR ppair ] ].

; A head/comps phrase is a phrase that combines a head with something selected
; for by the COMPS feature.  Head/comps phrases come in two denominations:
; head/comp phrases and head/marker phrases.  A head/comp phrases is like the
; usual VP rule, and its head (and therefore the whole phrase) must be CONJ
; cnil.  A head/comp phrase is unmarked for MC, but will inherit a MC
; specification from its head daughter.  Head/marker phrases takes the place
; of the P&S94 head/marker rule.  The head must be lexical (i.e., of type
; "word") and CONJ non-cnil. 
;
; DPF 10-Aug-99 - Moved the propagation of ALTMIN from head_marker-phrase up to
; head_comp_or_marker_phrase.
; DPF 2-Jun-02 - Added HS-LEX -* (see discussion of HS-LEX): needed to distinguish
; "*the children very angry arrived" from "the children very angry at kim arrived"
; DPF 23-Apr-03 - Added propagation of MODIFD value from head to mother,
; reminded by spurious ambiguity for "thirty twenty-two chairs arrive"
; DPF 13-Oct-03 - Removed HS-LEX - from mother, since it prevented coordination
; of adjectives, which are HS-LEX +
;; DPF 2020-04-30 - Re 23-Apr-03: For |clear evidence we needed that Kim won|,
;; would need to lose the MODIFD rmod of |evidence we needed| in order to allow
;; |clear| to attach after CP-comp is picked up.  But there are other obstacles
;; here, and this loss of constraint seems dangerous, so seek FIX someday.
;;
basic_head_comp_or_marker_phrase := basic_binary_phrase &
  [ SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ MC #mc,
			   VAL [ SUBJ #subj,
				 SPR #spr,
                                 SPEC #spec,
                                 SPCMPS #spcomps ],
			   NEGPOL #negpol ] ],
	     MODIFD #modifd,
             PUNCT.PNCTPR #ppair ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD subst_or_func,
				    MC #mc,
				    VAL [ SUBJ #subj,
					  SPR #spr,
					  SPEC #spec,
					  SPCMPS #spcomps ],
				    NEGPOL #negpol ] ],
		      MODIFD #modifd ] ],
	   [ SYNSEM.PUNCT.PNCTPR #ppair ] > ].

;; DPF 2018-11-28 - Propagate CTXT from head-dtr to mother, for example to
;; block extraction for but-PP in |but the place they played|
;;
head_comp_or_marker_phrase := basic_head_comp_or_marker_phrase &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS #comps,
		   CTXT #ctxt ],
    ARGS < [ SYNSEM.LOCAL [ CAT.VAL.COMPS < #synsem . #comps >,
	                    CTXT #ctxt ] ],
	   [ SYNSEM #synsem ] > ].

; ERB (03-10-96) hcomp_nc is no longer marked as non-clause because some of them
; are "clauses" in the sense of having a message (e.g., "Kim wants [to leave]").
; This is actually in need of revision: we are probably going to need to 
; distinguish between to-headed hcomp_ncs which are selected by equi predicates 
; or otherwise have PRO subjects and whether-headed hcomp_ncs on the one hand, 
; and all other instances on the other with a restriction equivalent to SUBJ 
; list(PRO) in order to block "To rain is difficult" etc.  I think this should 
; be possible without resorting to anything like VFORM whether to identify cases
; -- see Ivan's interrogatives paper.

; ERB (05-10-97) In order for one single hd-cmp_u_c rule to build things like "how
; about on Friday", the restriction HEAD subst needs to be removed from this
; rule, or else root-marker needs to inherit from subst.  I am opting for the
; former.

; DPF (25-Aug-98) The head_comp_phrase is not marked POSTHD + since we want to
; build "twenty-one" using this rule, but still allow it to serve as a
; prenominal modifier  as in "twenty-one books".  So instead we use the PRED
; feature to distinguish prenominal from postnominal modifiers, and conspire to
; make all PRED - entries have an empty COMPS list.  
; DPF 01-Feb-03 - Generalized CONJ value to cnil_or_numconj, to allow this
; rule to build "and three" as in "two hundred and three".
; DPF 10-dec-03 - But now the mrk-nh_atom_c rule is taking care of these guys.
; DPF 10-jul-04 - Tried making complement LPUNCT no_punct to avoid 
; 'Kim hired, Abrams'. But this fails for "January 1st, 1984".  So remove, 
; and expect heads to declare the expected LPUNCT value for their complements.
; DPF 17-jul-04 - Let's try making the head LPUNCT no_punct, to avoid e.g.
; 'Kim, hired, Sandy.'
; DPF 25-aug-04 - Can't have [HD-DTR..RPUNCT no_punct] since for two-compl
; verbs, the first complement might contain an appositive ending in a comma,
; as in "Kim sent [Abrams, the manager,] to Browne.  So it seems that we
; have to live with ambiguity of "Kim sent Abrams, the manager."
; DPF 7-mar-05 - Changed parent type from head_initial_infl to head_initial
; since we want "the Berlin - Paris route" where "Berlin - Paris" is built
; compositionally but is still compatible with [INFL -].  Keep nonhd-dtr as
; INFLECTD +.
; DPF 31-mar-05 - Re 25-aug-04, tried changing hdn-np_app-pr_c rule to underspecify 
; RPUNCT value, so this HCOMP rule can return to excluding a comma-marked head,
; which should help with spurious ambiguity.  But if hdn-np_app-pr_c rule drops the
; information from its RPUNCT, no longer know if it was marked with final comma,
; or clause_punct, etc - unacceptable, so we'll just live with generating
; 'Kim handed Abrams, the book.'
; DPF 28-jun-07 - Made phrase be SYNSEM nonlex_synsem to prevent PPs from
; being complements of v_p_le verbs, given that we now depend on the SYNSEM
; type to distinguish P from PP for these particle guys.
; DPF 15-sept-07 - Re 7-mar-05: But leaving INFLECTD underspecified means we
; always build spurious edges for e.g. 'hire Abrams' which don't go very far,
; but are unwanted.  So let's try requiring the two dtrs to both be INFLECTD +
; but leave the mother unspecified, so we still get "paris - berlin" as a
; left dtr of compound but avoid building uninflected "hire Abrams'
;; DPF 2020-04-30 - Re 23-Apr-03: For |clear evidence we needed that Kim won|,
;; would need to lose the MODIFD rmod of |evidence we needed| in order to allow
;; |clear| to attach after CP-comp is picked up.  But need to preserve MODIFD
;; from head, for example to keep track of which phrases can undergo npadv rule,
;; which requires dtr to be hasmod.  Try to FIX somehow, but not yet.
;; DPF 2020-04-30 - Added NH-DTR..NH-LEX constraint to enable blocking of
;; |a tall enough to see building| while keeping |a tall enough building to see|
;; (see enough_addition lexical rule type for more discussion).
;;
basic_head_comp_phrase := basic_head_comp_or_marker_phrase & head_initial &
			  binary_punct_phrase & head_valence_phrase &
			  head_compositional &
  [ SYNSEM nonlex_synsem &
           [ LOCAL [ CAT [ POSTHD #ph,
                           HS-LEX #hslex ],
		     CONJ cnil ],
	     MODIFD #modifd,
	     LEX #lex ],
    INFLECTD #infl,
    HD-DTR [ INFLECTD na_or_+ & #infl,
             SYNSEM [ LOCAL [ CAT [ POSTHD #ph,
				    HC-LEX #lex,
				    HS-LEX #hslex ] ],
		      MODIFD #modifd,
                      PUNCT [ LPUNCT comma_or_hyphen_or_pair_or_no_punct,
                              RPUNCT comma_or_rbc_or_colon_or_pair_or_no_punct,
                              PNCTPR ppair ] ] ],
    NH-DTR [ INFLECTD +,
	     SYNSEM.LOCAL.CAT.NH-LEX #lex ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

head_comp_phrase := basic_head_comp_phrase & head_comp_or_marker_phrase.

;; DPF 2012-03-23 - Changed nh-dtr to be nonlex_synsem rather than phr_synsem,
;; since we want to allow |Kim made possible the whole approach|, but we still
;; want to avoid lexical edges being reordered.
;; DPF 2012-10-20 - Tried restricting NH-DTR..HEAD from verbal_or_a_or_p to 
;; a_or_p to also exclude VPs and clauses, but this would also block obj_equi
;; passives, as in |Kim was urged to arise by Abrams|. So undo.
;; DPF 2016-11-20 - Re 2012-03-23: Remove nonlex_synsem, since we want
;; |the water was made salty by the rock|, but constrain to COMPS *olist*
;; so we avoid spurious analysis for |Kim looked up the consultant|
;; DPF 2016-12-13 - Constrain the nh-dtr to be MIN independent_rel, to avoid
;; spurious analysis of |we took back the cat| where |back| is a lexical PP.
;; DPF 2017-02-05 - But this blocks |B was given to C by D|. So undo.
;; DPF 2018-06-02 - Exclude there-copula via XARG.
;;
head_second_comp_phrase := basic_head_comp_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comp1 & phr_synsem & canonical_synsem &
				 [ LEX - ] . #comps >,
    HD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ AUX -,
				       INV - ],
				VAL.COMPS < #comp1 . < #comp2 . #comps > > ],
			  CONT.HOOK.XARG non_expl ],
    NH-DTR.SYNSEM #comp2 & [ LOCAL.CAT [ HEAD verbal_or_a_or_p & 
					   [ MOD *olist*,
					     MINORS [ ALTMIN non_ellipt_rel ] ],
					 VAL [ SUBJ *synlist*,
					       COMPS *olist* ] ],
			     NONLOC.SLASH 0-dlist ] ].

; DPF 18-jun-04 - For now, stipulate propagation of PUNCT, since this type
; doesn't inherit from binary_phrase (due to INFLECTD?).  But maybe can make
; this a binary_phrase?
; DPF 24-may-05 - We put the PAIRED value of the nh-dtr into 'storage' in the
; head-marker phrase's PNCTPR attribute, which is not used during the
; construction of the coordinate phrase.  Then the top-coord rule 'retrieves'
; this value from its right conjunct's PNCTPR and makes it once again the
; value of PAIRED on the full conjoined phrase.  Affected example:
; only want the hdn-aj_rc_c rule (and not the hdn-aj_rc-pr_c rule) to build the
; rel clause in 'Devito manages a programmer Abrams interviewed and Browne 
; hired.' 
; DPF 22-jul-05 - This move creates a little problem for the odd lexical
; entry "etc." which acts syntactically like a head-marker phrase.  But then
; "etc.?" should undergo the qmark infl rule, leaving it with a non-empty
; PAIRED value, and then it won't conjoin properly because that PAIRED value
; should be 'stored' in PNCTPR.  For now, add lexical entry for "etc.?"
;; DPF 20-03-30 - Pushed down identification of PNCTPR on mother and NH-DTR to
;; subtype excluding head_marker_phrase_atomic, so we can get
;; |[both Kim, who dances,] and Browne|
;;
basic_basic_head_marker_phrase := head_comp_or_marker_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   HC-LEX #hclex,
                           HS-LEX #hslex ],
		     CONJ #conj,
		     AGR #agr ],
	     NONLOC #nonlocal,
	     MODIFD #modif,
	     LEX #lex,
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct,
                     PAIRED #paired,
		     RCLSTR #rclstr ] ],
    ARGS < [ SYNSEM [ PUNCT [ LPUNCT #lpunct,
			      RPUNCT hyphen_sgl_or_rbc_or_rparen_or_no_punct,
			      PAIRED #paired ],
		      LOCAL [ AGR #agr,
			      CONT.HOOK #hook,
			      CONJ #conj ],
		      LEX na_or_- ] ],
	   sign &
	   [ SYNSEM [ LOCAL.CAT [ HEAD #head,
				  HC-LEX #hclex,
				  HS-LEX #hslex ],
		      NONLOC #nonlocal,
		      MODIFD #modif,
		      LEX #lex,
		      PUNCT [ RPUNCT #rpunct,
			      RCLSTR #rclstr ] ] ] >,
    C-CONT.HOOK #hook ].

basic_head_marker_phrase := basic_basic_head_marker_phrase &
  [ SYNSEM.PUNCT.PNCTPR #pnctpr,
    ARGS.REST.FIRST.SYNSEM.PUNCT.PAIRED #pnctpr ].

head_marker_phrase_event := basic_head_marker_phrase &
  [ INFLECTD +,
    SYNSEM.LOCAL [ CONT.HOOK.INDEX conj_event & [ SF #iforce ],
                   CAT.POSTHD #ph,
		   CONJ complex-conj & [ CREL #rel ],
		   AGR #agr ],
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD non_noun_or_adv,
                            CONJ complex-conj & [ CREL #rel ] ],
             INFLECTD + ],
	   [ SYNSEM.LOCAL [ CAT [ HEAD non_noun_or_adv &
                                     [ MINORS.MIN event_or_degree_or_no_rel ],
				  VAL.COMPS *olist*,
                                  POSTHD #ph ],
                            CONT.HOOK.INDEX [ SF #iforce ],
			    CONJ cnil_or_numconj,
                            AGR #agr ],
             INFLECTD + ] >,
    C-CONT.RELS <! !> ].
    
; DPF 13-oct-05 - While two-part phrasally headed phrases typically conjoin 
; with a comma-marked left conjunct, lexically-headed phrases do not, so 
; use the same CPUNCT constraint as for nominal phrases to restrict commas
; to informal ones for simple lexical coordination.
; DPF 31-oct-05 - VP and S coordination may allow informal commas after the 
; conjunction as in "Kim arrived and, Sandy arose", especially with 'dangling'
; conjuncts as in "Or, you can stay."
;; DPF 2011-06-12 - Removed NH-DTR..POSTHD + since this prevents pre-head
;; adverbs from conjoining, as in "we quickly and quietly arose".  Can't 
;; recall yet what it was doing for us... Ah, it's meant to avoid spurious
;; ambiguity with the rule for coordinating attrib adjectives.  Now have to
;; reconstruct why that specialized rule is desirable.  Let's try doing
;; without it.
;; DPF 2017-02-22 - To avoid spurious ambig for conjunction of e.g infinitival
;; relative clauses, tried constraining SPR to be non-empty, but this excludes
;; coordinating ordinary infinitivals as in |we tried to arise and to depart|,
;; So instead changed SUBJ value on non-wh relative clauses (see note there).
;;
; All except clauses
;; DPF 2017-05-22 - Removed constraint MC na_or_- on second dtr, since this
;; prevents coord of subord clauses modifying main clauses, as in
;; |when we arise and after they arrive, he will leave|.  Instead, identify
;; MC of mother and second dtr.
;;
head_marker_phrase_e_phr := head_marker_phrase_event &
  [ SYNSEM.LOCAL.CAT.MC #mc,
    ARGS < [ SYNSEM.LOCAL [ CONT.HOOK.LTOP #ltop,
                            CONJ.CREL.ARG2 #index ] ],
	   [ SYNSEM.LOCAL [ CAT [ VAL.SUBJ *synlist*,
				  MC #mc ],
			    CONT.HOOK [ LTOP #ltop,
			                INDEX #index ] ] ] >,
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

; For clause coordination, where we need qeq for each conjunct.
; DPF 02-jul-09 - Removed NH-DTR..MC bool since this prevented coord of
; relative clauses, which are MC na.
;; DPF 2014-10-13 - Since basic_s_coord_top_phr identifies mother's HEAD
;; with LCONJ-DTR's head, we can't identify ADDTAM of the second dtr here with
;; the mother's E.TAM, because this blocks coord of two S's with differing
;; aspect, as in |we arose and they have arrived|.
;; DPF 2015-03-13 - Removed ARGS < word_or_lexrule, ...> since we also want
;; |we arise and yet we arrive| where |and yet| is neither word nor lexrule.
;; Instead, constrain first dtr's CONJ to be lex-conj.
;; DPF 2016-11-01 - Removed identity of dtr's HEAD.TAM and ARGS..INDEX.E
;; because these are not always the same, e.g. in |and we have, I believe, won|.
;; The INDEX.E should always be constrained without this, anyway.
;; DPF 2018-03-12 - Note that by identifying the nonhd's ADDPN with its AGR..PN
;; we fail to coordinate subjunctive clauses such as 
;; |he demands that she arrive and that he arise| since we get away with using
;; the single base_or_non3sg verb form by on occasion not unifying AGR, such as
;; for the subjunctive complementizer |that| as in |we demand that he arise|.
;; FIX someday.
;;
head_marker_phrase_s_phr := head_marker_phrase_event &
  [ SYNSEM.LOCAL.CAT.MC #mc,
    ARGS < [ SYNSEM.LOCAL.CONJ lex-conj & [ CREL.ARG2 #rindex ] ],
	   [ SYNSEM.LOCAL [ CAT [ HEAD verbal &
				       [ TAM #tam,
					 --ADDIN [ ADDTAM #tam,
						   ADDPN #pn ] ],
				  VAL [ SUBJ *anti_list*,
					SPR < > ],
				  MC #mc,
				  POSTHD + ],
			    AGR.PNG.PN #pn,
			    CONT.HOOK [ LTOP #ltop,
					INDEX #rindex ] ] ] >,
    C-CONT [ HOOK.LTOP #ltop,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 31-may-06 - To get pre-head adv-coord as in "historically and 
; culturally important", make nh-dtr's HEAD be a_or_adv.
;; DPF 2011-06-12 - Re 31-may-06: But since we're using the PP-coord rule 
;; for adverbs as well, don't need (or want) this accommodation.
;;
head_marker_phrase_a_lex := head_marker_phrase_event &
  [ SYNSEM.LOCAL [ CAT.POSTHD -,
		   CONJ.CPUNCT ppair ],
    ARGS < [ ALTS alts_min,
	     SYNSEM [ LOCAL.CONJ.CREL.ARG2 #rtop,
		      PUNCT.RPUNCT hyphen_sgl_or_no_punct ] ],
	   [ SYNSEM [ LOCAL [ CAT [ HEAD adj,
				    POSTHD - ],
			      CONT.HOOK.LTOP #rtop ],
		      MODIFD notmod_or_lmod ] ] >,
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 6-Dec-02 - Added ident. of HD-DTR..KEYREL.ARG2 with NHD..INDEX
; here in the construction since nouns can no longer identify their E-INDEX
; with their INDEX (which was wrong anyway, since the E-INDEX should be of
; type event).  A related re-entrancy appears for the left daughter in the
; nom_coord_rule definition.
; DPF 10-may-05 - Added CPUNCT ppair on mother to block comma-marked
; left conjunct in simple two-part nominal coordination: 
; '*Abrams, and Browne arrived'. This constraint is ignored in any
; multi-part coordination.
; DPF 30-jul-05 - But as noted elsewhere, this also prevents coordination
; of longer NPs.  So we let those in using informal_comma_punct.
; DPF 29-sept-05 - To allow "The friendliness and helpfulness of Norwegians
; is apparent", we don't identify AGR.PNG with HOOK.INDEX.PNG on this basic
; type, but only for NPs.  Thus we'll allow "the dog and cat is barking.",
; which is undesirable, but then we'll also get "my friend and confidante is
; here." which we also want.

basic_head_marker_phrase_nom := basic_head_marker_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS.NORM #norm,
                   CONT.HOOK.INDEX conj_non_expl-ind,
                   CONJ [ CPUNCT ppair,
			  CREL #crel ],
                   AGR [ PNG #png,
                         DIV #div ] ],
    ARGS < [ SYNSEM [ LOCAL [ AGR [ PNG #png,
				    DIV #div ],
			      CONJ complex-conj & [ CREL #crel &
							 [ ARG2 #ind ] ] ],
		      PUNCT.RPUNCT hyphen_sgl_or_rbc_or_rparen_or_no_punct ] ],
	   [ SYNSEM.LOCAL [ CAT.HEAD n_or_p & [ MINORS.NORM #norm ],
			    CONT.HOOK.INDEX #ind & ref-ind,
			    CONJ cnil_or_numconj ] ] > ].

; DPF 26-aug-04 - Generalized NH-DTR.HEAD from noun to noun_or_nomger to
; get e.g. "His singing and dress were unusual".  Restrict nbar coord to
; HOOK.INDEX 3per, since we're not enforcing full PNG constraint (see
; above.
; DPF 01-sep-07 - Restrict NH-DTR..MIN to gen_nom_nbar_rel to exclude
; detless-pp nouns like "level"
;; DPF 2012-02-01 - Re: 26-aug-04 on basic_nom_coord_rule, about SORT:
;; We still want to assign some SORT value on the mother, to avoid spurious
;; locative relative clause modifiers as in |*the book and bicycle that I slept|
;; So identify conj-index's SORT with that of right dtr.

head_marker_phrase_nbar := basic_head_marker_phrase_nom &
  [ INFLECTD #infl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.PN 3,
				   SORT #sort ],
    ARGS < [ INFLECTD + ],
	   [ INFLECTD #infl,
             SYNSEM.LOCAL [ CAT [ HEAD noun_or_nomger &
                                       [ MINORS.MIN gen_nom_nbar_rel ],
                                  VAL.SPR.FIRST synsem & 
				                [ --MIN abstract_q_rel,
						  LOCAL.CAT.HEAD det ] ],
                            CONT.HOOK [ LTOP #ltop,
                                        INDEX #ind ] ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS <! [ PRED udef_q_rel,
                       ARG0 #ind & [ SORT #sort ],
                       RSTR #rstr,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! qeq & [ HARG #rstr,
                              LARG #ltop ] !>,
	     ICONS <! !> ] ].

; DPF 20-Sept-06 - Since we no longer make 'and' be [PN 3p] in order to get
; 'their cleverness and zest for life is legendary", we now use the lexical
; constraint stored in CONJ.CPNG for 'and' to block "*Abrams and Browne is ..."
; while still allowing "Abrams or Browne is ..."
;;
head_marker_phrase_nom := basic_head_marker_phrase_nom &
  [ INFLECTD #infl,
    SYNSEM.LOCAL [ CONT.HOOK [ LTOP #ltop,
			       INDEX.PNG #png ],
                   AGR.PNG #png ],
    ARGS < [ INFLECTD +,
	     SYNSEM.LOCAL [ CAT.HEAD.MINORS.NORM norm_rel,
			    CONJ.CPNG #png ] ],
	   [ INFLECTD #infl,
	     SYNSEM.LOCAL [ CAT.VAL.SPR *olist*,
			    CONT.HOOK.LTOP #ltop ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; For 'both', 'neither', etc.
head_marker_phrase_atomic := basic_basic_head_marker_phrase & 
			     binary_punct_phrase &
  [ INFLECTD #infl,
    ARGS < [ SYNSEM [ LOCAL.CONJ atomic-conj,
		      PUNCT.RPUNCT hyphen_sgl_or_no_punct ] ],
	   [ INFLECTD #infl,
	     SYNSEM.LOCAL.CONJ cnil_or_numconj ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; Skip an optional complement as long as there is still another obligatory
; complement on the list (here assumed to be the second complement, since it's
; hard and perhaps unnecessary to allow the obligatory one to appear in an
; arbitrary position).
; DPF (27-Apr-99) Note that this formulation unfortunately does not get
; "Kim bet Abrams won" with the first two optional complements missing, since
; the rule forces the complement after the omitted one to be expressed.
; DPF 7-Apr-01 - Added MC reentrant with head-dtr's MC value.
; DPF 7-Apr-01 - Removed POSTHD + since it prevented pre_S if-clauses.
; DPF 22-May-01 - Instead, pass up POSTHD from dtr to mother.
; DPF 18-Dec-01 - Moved ALTMIN identity from this type to the non-noun 
; subtypes, to allow noun-opt-comp to override, in order to prevent n-n-cmpnd
; from feeding that rule, while allowing that rule to feed n-n-cmpnd.
; DPF 2-June-2 - Moved ALTMIN identity back since have better mechanism for
; blocking the above feedingg relationship for compounds.

basic_head_opt_comp_phrase := head_valence_phrase & basic_unary_phrase & 
                              head_compositional &
  [ INFLECTD #infl,
    SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
                                 SPEC #spec,
                                 SPCMPS #spcmps,
				 COMPS #comps ],
			   MC #mc,
                           POSTHD #ph,
                           HS-LEX #hslex ],
                     CONJ cnil,
		     AGR #agr ],
	     LEX #lex,
	     OPT #opt,
             MODIFD #mod,
	     PUNCT #punct ],
    HD-DTR #head & 
           [ INFLECTD #infl,
             SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
					  SPR #spr,
                                          SPEC #spec,
                                          SPCMPS #spcmps,
					  COMPS.REST #comps ],
                                    MC #mc,
                                    POSTHD #ph,
                                    HS-LEX #hslex ],
			      AGR #agr ],
		      LEX #lex,
		      OPT #opt,
                      MODIFD #mod,
                      PUNCT #punct &
			    [ LPUNCT lital_or_pair_or_comma_or_no_punct ] ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #head > ].

; DPF 28-jun-07 - Added event_or_hour_rel as temporary solution to puzzle
; about making "three twenty" (clocktime) discharge its optional complement
; even though it is built using hd-cmp_u_c which now stamps nonlex_synsem on the
; mother, but the noun-optcomp rule wants the dtr to be basic_lex_synsem
; in order to avoid spurious ambig with noun-noun compounds like "book cover"
; So for now, we let "three twenty" go through the non-noun optcomp rule.
; DPF 06-apr-08 - Removed HD-DTR..INDEX non_conj_event because this blocks
; conjoined VP in CP-phrase, since the complementizer shares its INDEX with
; the VP.
head_opt_comp_phrase := basic_head_opt_comp_phrase &
  [ SYNSEM nonlex_synsem,
    HD-DTR [ INFLECTD +,
             SYNSEM.LOCAL [ CAT [ HEAD.MINORS.MIN event_rel,
				  VAL.COMPS.FIRST unexpressed_reg & 
						  [ OPT + ] ],
			    CONT.HOOK.INDEX event ] ] ].

; DPF 21-Mar-01 - Removed SPR..MIN abstract_q_rel since this blocked pumping
; for partitives, as in "very little arrived"
; Changed HEAD from noun to n_or_p for "worth"
; DPF 3-Jun-02 - Constraint of lex_synsem on dtr prevents noun-noun-cmpnds
; from undergoing this rule, to avoid spurious ambiguity for e.g. "book cover",
; forcing hdn_optcmp_c to apply before compounding.  Identify ALTMIN of mother and
; dtr to block e.g. "*the almost all books arrive" (and then move this identity
; back up to parent opt_comp phrase type).
; DPF 9-Oct-02 - Added re-entrancy of LEX on mother and dtr in order to allow
; n_hour_le's to be unmarked for synsem type, but propagate their (unusual)
; [LEX -*] specification to block "an eleven meeting" but still allow "an 
; eleven pm meeting".
;; DPF 2018-07-16 - Removed mysterious identification of ORTH on dtr and mother,
;; since now blocking unwanted application of bracket rules to unary phrases by
;; making all unary phrases ORTH.FIRST bool.
;;
noun_opt_comp_phrase := basic_head_opt_comp_phrase &
  [ SYNSEM basic_lex_synsem,
    HD-DTR [ SYNSEM lex_or_nonlex_synsem &
		    [ LOCAL.CAT [ HEAD supnoun,
				  VAL.COMPS [ FIRST unexpressed_reg & 
						    [ OPT +,
						      NONLOC [ SLASH 0-dlist,
							       QUE 0-dlist,
							       REL 0-dlist ] ],
					      REST *nogaplist* ] ] ] ] ].

; ERB (19-01-98) If to_c_prop can undergo subject extraction (see notes
; near non_wh_rel) then this can't require HEAD v_or_p.  That constraint
; will be moved to extracted_comp_phrase.  Extrasubj will say 
; HEAD verbal.
; DPF 10-Jun-99 Changed SYNSEM..MOOD from indicative to ind_or_mod_subj, since
; we weren't getting "Abrams would have hired Browne"
; DPF 26-Nov-03 - Identified MODIFD value of mother and daughter, to preserve
; e.g. whether a VP has been pre-modified so we can still block "probably to
; remain" as the spurious analysis of purposive infinitival in "Kim is 
; probably to win"
;; DPF 2016-02-07 - Preserve POSTHD from head-dtr to mother, motivated by need
;; to block inverted-quote verb headed clauses from feeding cl_adv rule, as in
;; |Kim denies Browne|
;; DPF 2018-04-14 - Now that we are using a change of type of the value of 
;; PUNCT to distinguish verbal from nominal gerunds (see comment by 
;; `norm_punctuation' in fundamentals.tdl), head_only no longer identifies
;; PUNCT of mother and dtr, so the subtypes of basic_unary_phrase have to
;; determine PUNCT of the mother.
;;
extracted_arg_phrase := head_nexus_phrase & unary_phrase &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HC-LEX -,
			   POSTHD #ph,
			   VAL.SPCMPS < > ],
                     CONT.HOOK.INDEX.--TPC +,
		     CONJ cnil ],
	     NONLOC.SLASH #slash,
             MODIFD #modif ],
    HD-DTR #head &
	   [ SYNSEM [ LOCAL [ CAT.POSTHD #ph,
			      CONJ cnil ],
		      NONLOC.SLASH #slash,
		      MODIFD #modif ] ],
    ARGS < #head & [ INFLECTD + ] > ].

; DPF (28-Apr-99) Added identity of MSG for mother and head-dtr, since it
; wasn't being propagated.

; *** We still need special extraction rules for fronting CPs and VPs.
; DPF 31-May-07 - Generalized COMPS gap to include S complements, by
; making 'verb' (but not 'comp') be subtype of 'mobile', and adding 
; constraint that the gap's SUBJ be *anti_list* to exclude VPs.
; DPF 09-aug-07 - Preserve LEX feature from dtr to mother, to be able to
; detect lexical VP/NP so we can avoid spurious imperatives as in
; "consultants interview".
; DPF 18-feb-08 - Re 31-May-07: But we don't want to exclude S-bar
; complements from extraction, given eg. "That we had won, everyone knew."
; So changed to make 'comp' also a subtype of 'mobile'
; DPF 2010-10-01 - Re: 09-aug-07: Changed LEX on mother to value of HC-LEX 
; on dtr, so we get |for and with Abrams|, now that we're doing right-node
; raising.  We'll accept the ambiguity for |consultants interview|, since 
; we have no principled reason to block it, given |this movie see right away|.
;; DPF 2016-10-24 - We were constraining HD-DTR..INDEX to be non_conj_sement,
;; presumably to avoid spurious ambiguity somehow with coordination and 
;; extraction.  But this blocked extraction of a conjoined NP complement of
;; an empty prep, as in |Kim and Browne, we rely on|, since the index of the
;; PP/NP would be the index of the conjoined NP.
;; One reason for the constraint was to prevent spurious application of the
;; right-node-raising rule, which requires its dtr to be INDEX conj_ind, so
;; we blocked an RNR analysis of |is to arise|.  But in fact we should be
;; requiring |to arise| to constrain its own INDEX to be non_conj_event, which
;; then blocks the RNR rule anyway. Similarly, we want to get 
;; |how happy and wise is Kim?| where the xcmp phrase's index is the conjoined
;; event of the filler.
;; Still, we get a spurious parse for |kim is happy and wise| because the 
;; complement's index is conj_event, which is all the RNR rule wants. So take
;; advantage of the fact that extracted_arg_phrase stamps TPC + on the mother's
;; index, but this is not propagated through coordination, so the RNR rule can
;; require its dtr's head to be INDEX.--TPC -.
;; Alas, not quite right: since the index is shared for dtr and mother, the
;; resulting phrase is also --TPC -, but this means we can't later extract an
;; adjunct, as in |today we hired and fired him|, because the adj-extraction
;; rule also stamps --TPC + on the head.  So we need a different solution:
;; we'll use AUX - on the dtr of the RNR rule; see note there.
;; DPF 2017-11-16 - Re 31-May-07: Since we also want to enable extraction of 
;; passive VPs as in |how deeply divided had the country become| and 
;; |so deeply divided we have become|, remove this constraint on extracted 
;; comp's SUBJ.
;; DPF 2017-11-23 - Generalize dtr's HEAD to subst to include nouns, so we
;; can get |the mountain of which we have pictures| and |books in which we
;; have a strong interest|
;;
extracted_comp_phrase := extracted_arg_phrase & head_compositional &
  [ SYNSEM canonical_synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS #comps ],
			   MC #mc,
                           HC-LEX - ] ],
	     PUNCT [ LPUNCT #lpunct,
		     RPUNCT #rpunct,
		     PNCTPR #pnctpr,
		     PAIRED #paired,
		     RCLSTR #rclstr ],
	     LEX #hclex ],
    HD-DTR [ SYNSEM 
	       [ LOCAL [ CAT [ HEAD subst,
			       VAL [ SUBJ #subj,
				     SPR #spr,
				     COMPS < gap &
					     [ LOCAL arg-local &
                                               [ CAT [ HEAD mobile &
                                                          [ MINORS.MIN #min ] ],
                                                 CONT.HOOK [ INDEX #ind ] ],
                                               --SIND #ind & non_expl,
                                               --MIN #min,
					       NONLOC.SLASH #slash ]
					     . #comps > ],
			       MC #mc,
			       HC-LEX #hclex ] ],
		 NONLOC.SLASH #slash,
		 PUNCT [ LPUNCT #lpunct,
			 RPUNCT #rpunct,
			 PNCTPR #pnctpr,
			 PAIRED #paired,
			 RCLSTR #rclstr ] ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; Assume only finite clauses have explicit subjects that can be extracted, and
; restrict these to indicative verbs (not subjunctives). 

; ERB (19-01-98) We are assuming that there is subject extraction
; in "just the teacher [to talk to Sandy]" so the VFORM must be 
; loosened here.  See notes near non_wh_rel.  Also, HEAD verbal.
; What's to block whether from undergoing subject extraction?
; (cf. *Sandy Kim knows whether to elect Clinton president.)
; DPF (27-Apr-98) Made HD-DTR..HEAD be strict_type to block non-verbal heads
; from unifying (e.g. "red")
; DPF (1-Apr-99) Made mother be SPR < > to block spurious modification by PPs.
; DPF 27-sept-04 - Re: 19-01-98, this relaxation of VFORM incorrectly predicts
; that e.g. '*Kim, it is possible to arrive' is well-formed, analogous to
; 'Kim, it is possible to hire.'  So constrain the infinitival subtype here
; to only produce phrase type that will be used for relative clauses, by
; requiring that the SUBJ be < unexpressed & OPT - >.
; DPF 12-nov-05 - Re: 1-Apr-99, changed this to SPR < anti_synsem_min > since
; we do want to allow pre-modification of these phrases, at least in relative
; clauses, and anyway the usual head_adj_int rule requires the head to be
; MSG no_msg, so we no longer need the SPR < > constraint for this.
;; DPF 2013-02-14 - Removed unif of HOOK.--SLTOP with HD-DTR's SUBJ..INDEX
;; since this is inconsistent with VPs that are already scopally modified, as
;; in |the dog which probably won arose|.
;;
extracted_subj_phrase := extracted_arg_phrase & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.TAM indic_tam,
                           VAL.SPR < >,
                           MC - ],
                     CONT.HOOK.INDEX.SF prop-or-ques ],
	     NONLOC.SLASH #slash,
	     LEX -,
	     PUNCT #punct ],
    HD-DTR.SYNSEM 
             [ LOCAL.CAT [ HEAD verbal & [ VFORM fin_or_inf,
					   PRD - ],
                           VAL [ SUBJ < gap &
			                [ LOCAL arg-local &
                                                [ CAT.HEAD.MINORS.MIN #min,
                                                  CONT.HOOK [ INDEX #ind ] ],
					  NONLOC.SLASH #slash,
                                          --MIN #min,
                                          --SIND #ind & non_expl ] >,
                                 COMPS < > ],
                           MC na ],
	       PUNCT #punct ] ].

; DPF 28-Nov-02 - HOOK comes only from C-CONT in decl, since it introduces
; a message.
; DPF 12-Nov-03 - Experimentally, make the XARG of this phrase be the LTOP
; of the head-dtr, in order to support "on Tuesday who arrived" where the
; PP should share the handle of the VP (as if it had been extracted).
; DPF 06-mar-06 - Without messages, we don't need (or want) this XARG hack.

extracted_subj_phrase_fin := extracted_subj_phrase & decl_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD.TAM indic_tam,
                         VAL.SUBJ *anti_null* ],
                   CONT [ HOOK.INDEX.SF prop-or-ques ] ],
    HD-DTR.SYNSEM.LOCAL.CAT [ HEAD.VFORM fin,
                              VAL.SUBJ < expressed_non_canonical &
					 [ LOCAL.CAT.HEAD.CASE nom ] > ] ].

; For specifiers of nouns (det and non-det), adjectives and prepositions.
; Also for specifiers of determiners, as in "almost all".  Needs to be modified
; to also allow "exactly which books".
; DPF 3-Oct-99 - Added rentrancy for hd-dtr's HEAD value and the SPEC..HEAD of
; the non-hd-dtr, to allow e.g. the degree-specifier "that" to appear with
; adverbees but not PPs.
; DPF 10-Feb-01 - Changed mother's ALTMIN to come from head-dtr rather than
; nonhead-dtr, in order to get right semantics for "Kim 's" of "Kim's book".
; Couldn't find the reason (if any) why we were getting it from the nonhead.
; DPF 16-Oct-01 - The reason we need it from the head is compositional 
; numerals, where the ALTMIN of the head contains the 'highest' rel (often 
; times_rel or plus_rel).
; DPF 13-May-01 - Changed HD-DTR..COMPS < > back to *olist*, since adj's
; cannot always discharge their optional complement (especially since that
; would mean the pred-copula would have to require its complement to be
; COMPS < >, which means VP's would have to always discharge theirs, which
; would eliminate the utility of the *olist* in general.
; DPF 17-Dec-01 - Made POSTHD of mother be determined by specifier dtr,
; in order to get contrast of "*every book very old was sold" and "every book
; less than six months old was sold"
; DPF 2-Jun-02 - Removed parent "phrasal" since the LEX feature of head-spec
; phrases is now determined by the feature HS-LEX of head-dtr, analogous to
; HC-LEX feature.  See introduction of HS-LEX in fundamentals.tdl.
; DPF 24-Apr-03 - Why is head-dtr [MC na]?  This prevents e.g. "I went just to
; see kim".  Also blocks "I arrived two weeks after kim left".  Remove, and
; see what happens.
; DPF 26-aug-04 - FIX? make NH-DTR be INFLECTD +?  No, can't, since need this
; rule for "ten foot high (wall)"  But make it so for head_spec_phrase.
; DPF 7-mar-05 - Changed from INFLECTD + on mother and head-dtr to simply
; identifying INFL, since we want "the Berlin - Paris route" where
; "Berlin - Paris" is built compositionally but is still compatible with 
; [INFL -].  But make the head_spec_phrase still be hd-dtr INFLECTD +.
; DPF 29-oct-06 - Changed [MC na] on mother, since this prevented use of
; sp-hd_hc_c for colon-copula with nbar-spr, so now inherit value from 
; head-dtr.
; DPF 2010-09-16 - Changed newly added NH-DTR..SPR *olist*  to *unexplist*
; since there are several spr-hd constructions in which the specifier dtr 
; still itself has an unsaturated specifier, as in |year after year|, where 
; `after' is taken to be the head.  The *unexplist* ensures that the NH-DTR
; has sealed off its SPCMPS list (which can come from its own SPR, here
; unexpressed).
;; DPF 2013-05-10 - Identified HS-LEX of mother and head-dtr, to preserve the
;; property through multiple applications of the hd-spr rule, as in |far too|
;; of |*far too difficult to admire cats arrived|.
;; DPF 2016-08-07 - Re DPF 7-mar-05: Let's try identifying INFLECTD of the
;; two dtrs, to avoid spurious ambiguity for |ten to twelve| where the hour
;; word `ten' should undergo inflection in |ten to twelve suits me| but not
;; in |the ten to twelve meeting has started|.  See if something goes awry, FIX?
;; DPF 2016-10-15 - Re 2016-08-07: Okay, one problem is with 
;; |the ten meter high cat| where |ten meter| is necessarily INFL -, but |high|
;; is INFL +.  So undo that INFL identity, and reconsider |ten to twelve|, but
;; first fix the other thing:
;; Re 2010-09-16: Now that we want this bracketing for |May [23-25]|, the SPR
;; of |23-25| is not compatible with its own SPR list being unexpressed.  So
;; let's leave the spr-N subtype as is (with the SPR's SPR as *olist*), and
;; on the non-N subtype, we can't just make SPCMPS empty, because the analysis
;; of |as happy as Kim| has spr |as| combine first with |happy|, with a nonempty
;; SPCMPS.  So let's revisit lexical types where a head takes a spr which may
;; itself allow an optional spr from which the head gets its SPCMPS value, to
;; ensure that we seal off the SPCMPS list for all such types.  FIX as needed.
;;
;; Now back to |ten to twelve|: For dofm |to|, have it constrain its SPR to
;; still have a non-empty COMPS list, so it can't undergo the optcomp rule, and
;; hence retains as visible its LOCAL type which |to| requires to be
;; noninfl_noun_local, avoiding spurious ambig for |June 10 - 12|.  
;; This hack doesn't work for hour nouns, since we want both 
;; |ten to twelve| and also |ten fifteen to twelve|.  
;; Conclusion: we'll live with the ambiguity for now but it looks like we 
;; really want INFLECTD to be a SYNSEM feature so lexical heads can constrain 
;; it on sprs and comps.  Cf. the various places where we currently use the
;; constraint [LOCAL noninfl_noun_local].
;; DPF 2018-01-07 - Tempted to add SLASH 0-dlist to nonhd-dtr, presuming we 
;; never want to extract from a specifier, but in fact free relative determiner
;; "whatever" has a non-empty SLASH, so we can't do this in the phrase type.
;;
basic_head_spec_phrase := head_valence_phrase & head_final & 
                          binary_punct_phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
                                 SPR #spr ],
                           MC #mc,
			   HS-LEX #lex,
                           POSTHD #ph,
			   NEGPOL #negpol ] ],
	     MODIFD #modif,
             LEX #lex,
             PUNCT.PNCTPR #ppair ],
    HD-DTR [ INFLECTD #infl,
             SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                    VAL [ SUBJ #subj,
                                          COMPS #comps,
                                          SPR < #synsem & 
                                                canonical_synsem . #spr > ],
                                    MC #mc,
                                    HS-LEX #lex,
                                    POSTHD #hdph,
				    NEGPOL #hdnegpol ],
                              CONT.HOOK #hdhook,
                              CONJ cnil ],
                      LEX #hdlex,
                      MODIFD #hmodif,
                      PHON #phon,
                      --MIN #min,
                      --SIND #semind,
                      PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
                              PNCTPR #ppair ] ] ],
    NH-DTR [ SYNSEM #synsem &
                   [ LOCAL [ CAT [ VAL 
                                   [ SPEC < [ LOCAL [ CAT [ HEAD #head,
                                                            VAL.COMPS #comps,
                                                            POSTHD #hdph,
							    NEGPOL #hdnegpol ],
                                                      CONT.HOOK #hdhook ],
                                              LEX #hdlex,
                                              MODIFD #hmodif,
                                              PHON #phon,
                                              --MIN #min,
                                              --SIND #semind ] > ],
                                   POSTHD #ph,
				   NEGPOL #negpol ] ],
                     MODIFD #modif,
                     PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
                             RPUNCT rbc_or_pair_or_no_punct ] ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 15-Sept-03 - Added NH-DTR.MOD < > to exclude numbers
; DPF 06-mar-06 - Added XARG handle as hack to prevent degree specifiers as
; in "a little earlier".  But abandoned this hack, and now try constraining
; NH-DTR..HEAD det.
;; DPF 2012-06-15 - Added SUBJ *olist* to mother, to block spurious structure
;; for verbal gerunds where both the specifier and the subject get picked up,
;; as in |there's anything's admiring kim arrived.|
;; DPF 2013-06-13 - Removed INFLECTD + on HD-DTR, to allow |the May five test|,
;; instead identifying PRD and INFLECTD on mother to still block spurious
;; non-inflected analysis of |the cat's house|
;; DPF 2014-04-14 - Re 2013-06-13 - But this is expensive, since it produces
;; rampant ambiguity for ordinary Det-N phrases, never exploited.  So undo,
;; and look for another solution for admitting |the May five test|, perhaps
;; by shifting |May five| to hd-sp_hc_c variant of the construction.
;; DPF 2020-04-27 - Added HD-DTR..INDEX.PT notpro to block |the a foot| with
;; measure-NP |a foot|, contrasted with good |the two feet| or |the one foot|.
;; (aj_i-one-nmd_le causes its meas-NP to be INDEX.PT zero.}
;;
head_spec_phrase := basic_head_spec_phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC #spec,
			   SUBJ *olist*,
                           COMPS #spcmps,
			   SPCMPS < > ],
    HD-DTR [ INFLECTD +,
             SYNSEM.LOCAL [ CAT [ VAL [ COMPS < >,
					SPEC #spec ] ],
			    CONT.HOOK.INDEX overt_non_expl-ind & [ PT notpro ],
			    AGR #agr ] ],
    NH-DTR [ INFLECTD +,
             SYNSEM.LOCAL [ CAT [ HEAD det & [ MOD < > ],
				  VAL [ SPR *olist*,
					SPEC < synsem &
					       [ LOCAL [ CAT.HEAD supnoun,
							 AGR #agr ] ] >,
					SPCMPS #spcmps ],
				  MC na ],                                   
			    CONT.HOOK #hook & [ INDEX individual_min ] ] ],
    C-CONT.HOOK #hook ].

; For numbers and degree specifiers, and also for x_to_y adjectives, as in
; 'the mid to upper nineties'
;; DPF 18-jul-2010 - Split this into two: one for heads with no complements,
;; as in |more beautiful|, and one for heads with one, as in |much more|.
;; Note that we need to allow for multiple "postponed" complements, as with
;; combination of degree specifiers like |so| or |too|, with comparative |more|
;; Complex example: |so much more beautiful than Kim that they fainted|
;; Also: 
;; |a much more beautiful cat than Kim|
;; |so much taller than Kim that they fainted|
;; But for now, restrict the rule with complements to only comparative
;; complements (than/as), to avoid spurious ambiguity for "very happy to sing".

basic_head_spec_hc_phrase := basic_head_spec_phrase & head_compositional &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC #spec,
	     --MIN #min ],
    HD-DTR.SYNSEM [ LOCAL.CAT.VAL.SPEC #spec,
		    --MIN #min ],
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN compos_spec_rel ].

head_spec_hc_phrase := basic_head_spec_hc_phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS #comps,
			   SPCMPS #spcomps ],
    HD-DTR.SYNSEM.LOCAL.CAT.VAL [ COMPS < >,
				  SPCMPS #spcomps ],
    NH-DTR.SYNSEM.LOCAL.CAT.VAL.SPCMPS #comps ].

head_spec_hc_cmp_phrase := basic_head_spec_hc_phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS #comps & < #comp . #spcomps >,
			   SPCMPS #comps ],
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < synsem & #comp & 
					[ OPT -,
					  --MIN than_or_as_comp_rel ] >,
    NH-DTR.SYNSEM.LOCAL.CAT.VAL.SPCMPS #spcomps ].

; The SYNSEM value of the head of a head/modifier phrase is token-identical to
; the MOD value of the adjunct daughter.  Additionally, the adjunct daughter
; must be complement-saturated.  The SLASH value is not set in the basic
; schema, but rather in each of the subtypes: in head_mod_phrase_simple the
; SLASH value is passed up from both daughters, but in the
; extracted_adj_phrase the SLASH value of the mother is effectively the
; adjunct that would have modified the head.
; 
; DPF (6-Sept-98) Constrained HD-DTR to have empty QUE as well as REL, to 
; block adverbs modifying "how", "where", etc.  
; DPF (4-Mar-99) But this unfortunately also blocks "which consultant who fell"
; since making "consultant" be QUE empty means via lexical threading that its
; specifier must also be QUE empty.  So we would have to find some other way of
; blocking modifiers of "where" etc, but perhaps the generalization is wrong
; anyway; consider "right where", "exactly when" "just how".

; DPF 25-Aug-99 - Removed CONJ cnil from HD-DTR, to allow "oh, and your name"
; DPF 6-Apr-01 - Mysteriously, it seems that we have not been copying up ALTMIN
; from head-dtr to mother for head-mod phrases.  It showed up in failure to 
; notice that "first seven" had a non-empty ALTMIN, which was intended to 
; block this as left member of n-n-compound.

;; DPF 10-Feb-01 - Removed REL 0-dlist from head-dtr, since (a) head-nexus 
;; phrases pass the REL value from the head dtr to the mother; and (b) this 
;; was blocking e.g. "the chair whose first three legs fell off arrived" 
;; where the adj-N construction forces REL 0-dlist rather than passing up the 
;; spr's REL.
; DPF 2-Jun-02 - Added HS-LEX - (see discussion of HS-LEX) - needed if want to 
; distinguish "*the children singing are famous" from "the children singing in
; Berlin are famous" - may not be desirable.
; DPF 30-Apr-03 - The reentrancy of E-INDEX in head-dtr and C-CONT is dubious
; at best, and gives rise to the odd result that in "Kim sleeps in Berlin"
; both the ARG0 and the ARG1 attributes of the _in_rel are identified.  This
; looks like a possible violation at least in spirit of the semantic algebra,
; so why is it here?  More research is needed.
; DPF 25-Jun-03 - Restored [CONJ cnil] on mother (cf 25-Aug-99), since don't
; want "and Browne hired" as a head-adj constituent.
; DPF 09-may-04 - Removed HD-DTR..MIN independent_rel since it prevents e.g.
; 'Kim relies you know on Sandy'
; DPF 14-mar-05 - Added identity of POSTHD on hd-dtr and mother, to block
; e.g. adj "in" from subconj_prdp as in "kim arrived [in [on Tuesday]]"
; DPF 12-apr-08 - Re 25-Jun-03: Moved cnil down to head_adj_phrase, so
; can still get pre-head modifiers as in "yes, and Kim"
; DPF 30-jun-09 - We don't want to inherit from head_nexus_rel_phrase because
; this blocks pied-piping in relative clauses, as in 
; "books the covers of which ...".  So instead append the RELS of the two
; dtrs.

head_mod_phrase := headed_phrase &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
				 SPR #spr,
                                 SPEC #spec,
                                 SPCMPS #spcmps ],
                           POSTHD #ph,
                           HS-LEX - ],
		     CONJ cnil_or_lexconj ],
             MODIFD hasmod ],
    HD-DTR.SYNSEM.LOCAL.CAT [ VAL [ SUBJ #subj,
				    SPR #spr,
                                    SPEC #spec,
                                    SPCMPS #spcmps ],
                              POSTHD #ph ] ].

; Added restriction on adjunct's specifier to prevent unsaturated nouns
; (like 'afternoon') from serving as modifiers before they pick up their
; specifiers.

; head_mod_phrase_simple takes the MSG value from its non-head dtr's 
; MSG.  Most modifiers identify their message with their
; modifiee's message, but tags don't.  (Modifiers cannot simply identify their
; own message with that of their modifiee, since some signs (like "not")
; can be either a modifier or an argument, and hence need a message value 
; independent of that of their modifiee.

; SLASH of mother is append of SLASH lists for the two daughters.  In principle
; this allows distinct slash values on the two daughters, without enforcing
; parasitic gaps.  So we restrict the LIST.REST value of SLASH on the mother to
; be the empty list -- a hack which works in PAGE since not strictly typed, but 
; what we really want to say is that SLASH on the mother is either a singleton 
; list, or the empty list.

;; 15-Jun-98 Removed this hack, since it doesn't work in the LKB, and is wrong
;; anyway, failing to generalize to e.g. head-complement structures, which
;; present the same problem of distinct SLASH values coming from each of the
;; two daughters.

;; Removed identification of hddtr's MSG with mother's - wrong for tags,
;; at least.  Should be handled independently by each modifier.

;; DPF 26-Feb-99 - Added [ MIN independent_rel] to NH-DTR to distinguish
;; modifier phrases from verb-particle constructions, where the particle's
;; MIN is specialized to a subtype of 'selected_rel'.

;; DPF 7-Apr-99 - Moved C-CONT..INDEX to the scopal and intersective variants,
;; since intersectives take their index from the head-dtr, while scopals take
;; it from the non-head-dtr.  The crucial case for intersectives is for
;; participial modifiers of nouns, like "manager interviewing Browne" where
;; the index of the modifier is an event variable.

;; DPF 7-Jun-99 - Removed REL 0-dlist from nonhead, to allow slashed finite
;; rels to keep the REL value on their mother, so it can be distinguished from
;; ordinary clauses.

;; DPF 8-May-00 - MC of the mother is now determined by the modifier dtr, not
;; the head-dtr, in order to make discourse adverbs like "yes" produce MC +
;; phrases. 

;; DPF 10-Feb-01 - Removed REL 0-dlist from mother, since (a) head-nexus 
;; phrases get the REL value from the head dtr; and (b) this was blocking e.g.
;; "the chair whose first three legs fell off arrived" where the adj-N
;; construction forces REL 0-dlist rather than passing up the spr's REL.
; DPF 3-Jul-02 - Added re-entrancy of HD-DTR..LEX and NH-DTR..MOD..LEX
; to enable modifiers to constrain the lex/phr distinction of the modifiee.
; DPF 26-Apr-03 - Added identification of XARG for head-dtr and non-hd-dtr for
; scopal modifier rules, which was already done for the (non-nominal)
; intersective modifier rules - the adj_n_int_phrase cannot make this identity
; since nouns declare the XARG value to be 'nothing'.
; DPF 03-nov-03 - Changed MC propagation back to coming from head-dtr, since
; want to be able to attach modifiers (which might be MC na) to main clauses,
; as in "Kim laughed, especially because sandy stayed".
; DPF 06-mar-06 - Re 26-Apr-03: XARG of nouns is no longer 'nothing', but
; still don't want to identify XARG of two dtrs in intersective modification 
; rules, since the modifier's XARG can be identified with the INDEX of the
; head-dtr.
;; DPF 2018-02-12 - Constrained NH-DTR..MOD.FIRST to be expressed_synsem,
;; so we can exclude e.g. PP+PP copredication phrase which is only used in
;; non-modification structures including the copula and locative inversion.
;; DPF 2018-03-25 - Re 03-nov-03: For tag questions, we want the SF ques to come
;; from the modifier, but since the INDEX for the clause comes from the head,
;; the head clause must be MC - (because the subj-head main-clause rule 
;; identifies SF with the RPUNCT.PSF). So for scopal modifiers, MC will be 
;; determined by the modifier, normally passing up the MC value of the phrase 
;; it modifies.
;;
basic_head_mod_phrase_simple := head_mod_phrase & basic_binary_headed_phrase &
                                norm_binary_punct_phrase &
  [ HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                  VAL #val,
                                  POSTHD #ph,
                                  HC-LEX #hclex,
                                  MC #hmc ],
                              AGR #agr,
			      CONT.HOOK #hook,
			      CONJ #conj ],
                    NONLOC #nonloc,
                    MODIFD #modif,
                    --SIND #semind,
                    --MIN #min,
                    LEX #lex,
                    PUNCT.RPUNCT #rpunct ],
    NH-DTR.SYNSEM.LOCAL [ CAT [ HEAD head & 
                                     [ MOD < expressed_synsem &
                                             [ LOCAL local & 
                                                     [ CAT [ HEAD #head,
                                                             VAL #val,
                                                             POSTHD #ph,
                                                             HC-LEX #hclex,
                                                             MC #hmc ],
                                                       AGR #agr,
                                                       CONT.HOOK #hook,
                                                       CONJ #conj ],
                                               NONLOC #nonloc,
                                               MODIFD #modif,
                                               --SIND #semind,
                                               --MIN #min,
                                               LEX #lex,
                                               PUNCT.RPUNCT #rpunct ] > ],
                                VAL.SPR *olist* ],
                          CONJ cnil ],
    C-CONT.RELS <! !> ].

head_mod_phrase_simple := basic_head_mod_phrase_simple &
  [ C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF (12-Jul-98) Changed POSTHD on mother from that of head-dtr to simply -
;; since want to prevent this rule from feeding head-adj rule.
;; DPF (25-Sept-98) Since we're no longer treating all head-complement phrases
;; as POSTHD -, we have to strengthen the constraint on the non-head-dtr's 
;; COMPS value to be truly the empty list, not just *olist*.

adj_head_phrase := basic_head_mod_phrase_simple & head_final &
		   head_nexus_rel_phrase & binary_punct_phrase &
  [ SYNSEM [ LOCAL.CAT.POSTHD #ph,
	     NONLOC [ SLASH #slash,
                      QUE *diff-list* &
                            [ LIST #qfirst,
                              LAST #qlast ] ],
	     MODIFD lmod & [ LPERIPH #periph ],
             LEX #lex,
             PUNCT.PNCTPR #ppair ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ POSTHD #ph,
                                VAL.COMPS < > ],
                    NONLOC [ SLASH #slash,
                             QUE *diff-list* &
                                   [ LIST #qmiddle,
                                     LAST #qlast ] ],
                    LEX #lex,
                    PUNCT [ LPUNCT comma_or_pair_or_no_punct,
                            PNCTPR #ppair ] ],
    NH-DTR.SYNSEM [ NONLOC [ SLASH 0-dlist & [ LIST < > ],
                             REL 0-dlist & [ LIST < > ],
                             QUE *diff-list* &
                                   [ LIST #qfirst,
                                     LAST #qmiddle ] ],
                    MODIFD.LPERIPH #periph,
                    PUNCT 
                     [ LPUNCT lital_or_pair_or_comma_or_no_punct,
                       RPUNCT comma_or_rbc_or_hyphen_or_pair_or_no_punct ] ] ].

; ERB (07-11-96) Non-head dtr is QUE 0-dlist to rule out "*Leaving when do you
; think would bother Sandy?" or "*Your house where did the government foreclose
; on?"  Not on higher type because "How long a book did you write?"
; DPF 09-dec-03 Removed QUE 0-dlist since we now want in-situ WH-phrases like
; "you are leaving when".  The above examples with in-situ WH with inversion
; are being blocked now as desired - details on how?
; DPF 04-may-04 Changed COMPS < > to COMPS #comps from head-dtr, since we want 
; to allow modification of lexical heads (e.g. for "would + rather (not)")
; DPF 12-mar-05 Removed SYNSEM..POSTHD + since no longer used to constrain
; interaction of pre- and post-head modifiers, and since it gets in the way of
; treatment of fragments such as "well, actually, Abrams" where want to build
; "well, actually" as phrase.
; DPF 21-dec-07 Changed NH-DTR..COMPS from <> to *olist* to allow e.g.
; "Kim arrived most quickly."
; DPF 2011-05-01 Changed append order of SLASH on the two daughters, to get
; the desired behavior for e.g. "In Paris, we hire him with Abrams or Browne"
; where the PP contains a coordinated NP, hence its SLASH value is a subtype
; of *arglist*, yet we don't want the SLASH value of the whole VP to be of
; type *arglist* since the VP's SLASH must have an extracted adjunct.
;; DPF 2012-02-20 Re: 2011-05-01 - Alas, but this reordering introduced the
;; problem of appending non-empty SLASH lists in both a head and its modifier,
;; as in |be used to admire| with an extracted adjunct in the VP |be used| and
;; an extracted complement in |to admire|.  The append wrongly succeeds, with
;; distinct non-empty values in each of LIST and LAST, even though the type
;; of SLASH on the mother is 0-1-dlist, because the LIST is still waiting to
;; append the value of the not-yet-found SUBJ's SLASH.  This edge will not
;; be part of any full tree, but causes trouble just being in the chart.
;; So go back to appending order with adjunct's slash first, then head's,
;; leaving the as-yet-unfound SUBJ's SLASH at the end of the list, where the
;; open end of the list needs to be.
;; DPF 2012-09-18 - Moved HD-DTR.MODIFD notmod_or_rmod down to subtypes, in 
;; order to allow post-head scopal modifiers to attach high, as in 
;; |big cats, however|
;; DPF 2016-09-28 - We were appending the QUE of head and adj, but this meant
;; that for n-pp, the QUE value could be constrained to be a paramlist, which
;; then blocks free-rel |whichever cats in Paris we admire| because |whichever|
;; makes the QUE contain an index, not a param.  So push this appending down to
;; subtype head_adj_phrase, and just for nominal head-adj, identify QUE on
;; mother and head-dtr, since we don't want WH-pied-piping (unlike for REL).
;; Further, restrict non-hd to have empty QUE, to avoid pied-piping as in
;; |difficult in corpora in which|
;; DPF 2016-10-17 - Re 2016-09-28: But we do need WH in adjuncts for in-situ WH
;; as in |Kim lives in which town?|  So remove empty QUE here, and on non-noun
;; subtype, identify non-head and mother's Que.
;; DPF 2016-12-08 - Pushed mother's MODIFD rmod down to subtypes, since we now
;; want post-title compounds like |Bygdin fjord| to not be rmod, in order to
;; accept |fingerlike Bygdin fjord| with the desired bracketing.
;; DPF 2018-05-21 - Instead of appending SLASH values of the two dtrs here, we
;; have each subtype determine the SLASH of the mother, typically identifying
;; with the head-dtr's SLASH, except for the head-adj-int variant where the
;; adjunct has a non-empty SLASH.  That rule would have to be altered in order
;; to allow for parasitic gaps.
;;
basic_head_adj_phrase := basic_head_mod_phrase_simple & head_initial & phrasal &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS #comps,
                     CONJ cnil ],
             MODIFD.LPERIPH #periph ],
    HD-DTR.SYNSEM [ LOCAL [ CAT.VAL.COMPS #comps,
                            CONT.HOOK.INDEX.--TPC #tpc ],
                    MODIFD.LPERIPH #periph,
                    PUNCT.RPUNCT comma_or_rbc_or_hyphen_or_pair_or_no_punct ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ POSTHD +,
                                  VAL.COMPS *olist* ],
                            CONT.HOOK.INDEX.--TPC #tpc ] ] ].

;; DPF 2017-12-23 - Mysteriously, we were not constraining the WH value of the
;; head-dtr, so a WH-marked head-dtr would have the WH value just disappear.
;; Instead, append the two, since can expect WH from either dtr.
;;
head_adj_phrase := basic_head_adj_phrase & binary_punct_phrase &
  [ SYNSEM [ MODIFD rmod,
	     NONLOC.QUE [ LIST #first,
			  LAST #last ] ],
    HD-DTR.SYNSEM.NONLOC.QUE [ LIST #first,
			       LAST #middle ],
    NH-DTR.SYNSEM.NONLOC.QUE [ LIST #middle,
			       LAST #last ] ].

; DPF (07-17-98) Split head_adj_phrase and adj_head_phrase into two each,
; one for intersective modifiers and one for scopal modifiers, in order to
; get desired results for recursive modification as in "apparently difficult
; problem" (cf. Kasper '98).  This split is also used in generation, where
; we delay construction of intersective modification, but not scopal.
; DPF 13-may-09 - Relaxed NH-DTR.COMPS < > to *olist* and pushed < > down to
; subtype, since this prevented 'most probably arrived' due to the optional 
; of-PP complement from 'most'.  But need *olist* to force e.g. 'as' to pick
; up complement first: "as reported, ..."
;; DPF 12-02-20 - Let's return to blocking extraction from scopal modifiers,
;; since allowing it produces great numbers of unwanted and unused edges in the
;; chart.  Maybe we'll recall when we wanted such extraction.

scopal_mod_phrase := head_mod_phrase_simple & nonhead_compositional &
		     head_nexus_rel_phrase &
  [ SYNSEM [ LOCAL.CAT.MC #mc,
	     NONLOC.SLASH #slash ],
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK [ INDEX #index,
				      XARG #xarg ],
		    NONLOC.SLASH #slash ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL scopal_mod &
						 [ CONT.HOOK.XARG #xarg ] ] >,
				  VAL.COMPS *olist*,
				  MC #mc ],
			    CONT.HOOK.LTOP #ltop ],
		    NONLOC.SLASH 0-dlist ],
    C-CONT.HOOK [ LTOP #ltop,
		  INDEX #index,
		  XARG #xarg ] ].

;; DPF 2018-03-25 - Assume that intersective modifiers do not change the
;; MC value of the phrase they modify, so pass it up here, in case we neglect
;; to account for MC on some modifiers.
;;
isect_mod_phrase := head_mod_phrase_simple & head_compositional &
  [ SYNSEM [ LOCAL.CAT.MC #mc,
	     NONLOC.REL [ LIST #first,
			  LAST #last ] ],
    HD-DTR.SYNSEM [ LOCAL [ CAT.MC #mc,
			    CONT.HOOK.LTOP #hand ],
		    NONLOC.REL [ LIST #first,
				 LAST #middle ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
			    CONT.HOOK.LTOP #hand ],
		    NONLOC.REL [ LIST #middle,
				 LAST #last ] ] ].

basic_adj_head_scop_phrase := adj_head_phrase & scopal_mod_phrase & 
                              head_final_infl &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS < >,
		       NEGPOL #negpol ],
    NH-DTR.SYNSEM.LOCAL.CAT [ POSTHD -,
			      NEGPOL #negpol ] ].
    
; DPF 19-may-09 - Changed NH-DTR..COMPS from < > to *olist* to allow e.g.
; "most obviously, Kim won"
;; DPF 11-mar-13 - Why is RPUNCT clause_punct desirable here?  It leads to
;; spurious robust analysis of |if we arrive, he arises|.  Try doing without.
;; DPF 2020-02-11 - For some reason, in MO, added SYNSEM phr_synsem, which
;; unhappily blocks |cats are probably not dogs|.  So remove, and see what
;; that new MO-specific constraint was doing.
;;
adj_head_scop_phrase := basic_adj_head_scop_phrase &
  [ SYNSEM.MODIFD.LPERIPH +,
    HD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    NH-DTR.SYNSEM [ LOCAL.CAT.VAL.COMPS *olist*,
		    PUNCT.RPUNCT comma_or_pair_or_no_punct ] ].

; For non_sentential heads - to avoid '*Kim before Abrams arrived arose'
;; DPF 2014-11-26 - But we do get phrasal scopal modifiers VP-initially, as in
;; |the cat, to annoy the dog, chased it|.  So removing LEX + on NH-DTR.
;; DPF 2016-11-08 - Constrained SPR to not only be *cons*, but *ocons*, so we
;; make sure to constrain SPCMPS in case no spr has been picked up.
;; DPF 2018-05-25 - Re 2014-11-26: For efficiency, restore LEX +.
;;
adj_head_scop_xp_phrase := basic_adj_head_scop_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR *ocons*,
    NH-DTR.SYNSEM [ LEX +,
		    PUNCT.RPUNCT rbc_or_pair_or_no_punct ] ].

; The paired variant - see comment 7-may-05 for n_adj_relcl_phrase.
adj_head_scop_prpnct_phrase := adj_head_scop_xp_phrase &
  [ SYNSEM.PUNCT.PAIRED #paired,
    NH-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired,
                          RPUNCT comma_or_pair_punct ],
    HD-DTR.SYNSEM.PUNCT [ PAIRED #pnctpr,
                          PNCTPR #paired ] ].

; Non-paired variant - propagate comma or clause-punct onward
; DPF 30-sept-06 - Also allow robust comma on head-dtr.
;; DPF 2019-11-20 (MO) - dropped RPUNCT constraint, which was mysterious, and
;; blocked |non-technically| as in |non-technically inclined people|
;; NH-DTR.SYNSEM.PUNCT.RPUNCT rbc_or_no_punct,
;;
adj_head_scop_nopair_phrase := adj_head_scop_xp_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM.PUNCT [ RPUNCT comma_or_rbc_or_clause_or_no_punct,
                          PNCTPR #ppair ] ].

;; DPF 2015-04-20 - We identify the right dtr's PSF with the mother's INDEX.SF
;; in order  to keep the punctuation constraint in e.g. |we stay if he sings.|
;; This constraint has the side effect of specializing the INDEX to event,
;; which might not be desirable; if not, will have to divide this into two
;; subrules, one for clausal heads and one for the rest.
;; DPF 2015-09-09 - Re 2015-04-20: But this is wrong for embedded WH-clauses,
;; as in |We explain how Kim arrives laughing.| with low attachment, since
;; |how ...| has to be a question, but the PSF value imposed too low will 
;; exclude questions.
;; So to preserve the PSF value for |[we stay][if he sings.]| we would need to
;; either split this phrase into MC + and MC - variants, parallel to the
;; subj-hd and filler-hd types, or move to a unary `root' phrase which would
;; do the identity of PSF and INDEX.SF.  Note that we want to be sure to get
;; |we explain how [[he arises][if we arise.]]|
;; FIX.
;;
head_adj_scop_phrase := head_adj_phrase & scopal_mod_phrase & 
			head_initial_infl &
  [ NH-DTR.SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
		    NONLOC.REL 0-dlist ],
    HD-DTR.SYNSEM.PUNCT.RPUNCT comma_or_hyphen_or_pair_or_no_punct ].

; The paired variant - see comment 7-may-05 for n_adj_relcl_phrase.
;; DPF 2015-09-09 - Following up from note above, splitting this paired type
;; into subtypes for MC+/- because of the interaction with PSF/SF.
;;
head_adj_scop_prpnct := head_adj_scop_phrase &
  [ SYNSEM.PUNCT.PAIRED #paired,
    HD-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired,
                          RPUNCT comma_or_hyphen_or_pair_punct ],
    NH-DTR.SYNSEM.PUNCT [ PAIRED #pnctpr,
                          PNCTPR #paired ] ].

head_adj_scop_prpnct_mc := head_adj_scop_prpnct &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX.SF #psf,
	     PUNCT.RPUNCT.PSF #psf ],
    HD-DTR.SYNSEM.LOCAL.CAT.MC + ].

head_adj_scop_prpnct_nmc := head_adj_scop_prpnct &
  [ HD-DTR.SYNSEM.LOCAL.CAT.MC na_or_- ].

; Non-paired variant - propagate comma or clause-punct onward
; DPF 10-sept-07 - Added RPERIPH + to mother to enable blocking of stacked
; depictives as in "Kim arrived happy sad."
;; DPF 2016-11-01 - Re 10-sept-07: But stacked depictives are possible, as in
;; |I lay awake worrying|, and even |I lay awake, unhappy.|  So generalize
;; to na_or_+.
;
head_adj_scop_nopair := head_adj_scop_phrase &
  [ SYNSEM [ PUNCT.PNCTPR #ppair,
             MODIFD.RPERIPH na_or_+ ],
    HD-DTR.SYNSEM.PUNCT.RPUNCT pair_or_no_punct,
    NH-DTR.SYNSEM.PUNCT [ RPUNCT comma_or_clause_or_pair_or_no_punct,
                          PNCTPR #ppair ] ].

;; DPF 2019-09-25 - Special case where head is comma-marked, but final adjunct
;; has no clause punct, so paired punctuation fails.
;;
head_adj_scop_no_clpunct := head_adj_scop_phrase &
  [ SYNSEM.MODIFD.RPERIPH na_or_+,
    HD-DTR.SYNSEM.PUNCT.RPUNCT comma_punct,
    NH-DTR.SYNSEM.PUNCT.RPUNCT no_punct ].

; DPF 29-Nov-02 - Removed NH-DTR..TENSE no_tense, since the adjunct
; now provides the HOOK for the mother, including E-INDEX, which must be
; unified with the head-dtr's E-INDEX.
; DPF 26-May-03 - But that spurious re-entrancy with the head-dtr's index has
; now been removed, so we can re-introduce this constraint on TENSE, crucial
; for the generator, since the heuristics will introduce lots of spurious
; auxiliaries if there is an event variable unconstrained for TENSE.

adj_head_int_phrase := adj_head_phrase & isect_mod_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps & *obllist*,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.PRD -,
			      VAL.COMPS #comps,
			      POSTHD - ] ].


; DPF 19-Oct-02 - Try making the non-head dtr PRD +, to make VP-modifying
; PPs PRD + in order to avoid spurious ambiguity for 'a foot in front of ...'
; DPF 29-Nov-02 - Removed NH-DTR..HEAD..TENSE no_tense, since the adjunct
; now provides the HOOK for the mother, including E-INDEX, which must be
; unified with the head-dtr's E-INDEX.
; DPF 26-May-03 - But that spurious re-entrancy with the head-dtr's index has
; now been removed, so we can re-introduce this constraint on TENSE, crucial
; for the generator, since the heuristics will introduce lots of spurious
; auxiliaries if there is an event variable unconstrained for TENSE.
; DPF 24-aug-04 - Try making the hd-dtr [REL 0-dlist] to avoid spurious
; parse for e.g. 'abrams has an office [[browne showed] to chiang]'
; DPF 26-aug-04 - Tempted to generalize HD-DTR..MIN from event_rel to 
; event_or_degree_or_no_rel (ignoring degree_rel here), to allow no_cop VPs
; to be post-modified, as in "down again and to the lodge.", but this will
; surely lead to lots of additional edges with little coverage benefit.
; DPF 25-aug-07 - Try restricting HD-DTR to SPR *cons* to force modifier to
; attach before specifier, to avoid spurious ambiguity for e.g. "He was 
; pretty scared himself"
; DPF 26-aug-07 - Try restricting HD-DTR to POSTHD + to avoid spurious
; attachment to attributive adjs, especially derived from participial verbs.
; as in "going on a holiday"
; DPF 16-nov-09 - Generalize HD-DTR..HEAD from adverbee to adverbee_or_modnp
; to allow `next week in Paris we dance'.  Unfortunately, we also get spurious
; ambiguity for 'here in Paris' - FIX?
; DPF 4-apr-10 - Note that HD-DTR..RPUNCT excludes ordinary commas,
; apparently to avoid (usually) spurious ambiguity as in 
; "kim hired several people, such as consultants and managers."
; We might someday regret this.  FIX?
;; DPF 2011-10-01 - Re 4-apr-10: yes, this prevents e.g. 
;; |afterwards, in Paris, we relaxed.|  So remove this, and live with the
;; extra ambiguity.
;; DPF 2015-03-14 - Re 24-aug-04: But this blocks modif of relative "where"
;; as in |the place where yesterday we arose|.  So remove, and see if and
;; why this change affects the cited example (not clear why the REL feature
;; affected that example).
;; DPF 2015-03-25 - Added identity of NEGPOL on hd-dtr and mother, to enable
;; blocking of robust "not" in |they told her to not eat pie before her dinner|
;; DPF 2015-04-15 - Changed NH-DTR..MIN from independent_rel to 
;; nondir_or_adv_rel, to conform to what we already do for extractec adjuncts,
;; so we can generate either ordering from either input.
;;
head_adj_int_phrase := head_adj_phrase & isect_mod_phrase & head_initial_infl &
  [ SYNSEM [ LOCAL.CAT.NEGPOL #negpol,
	     PUNCT.PNCTPR #ppair ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ HEAD adverbee_or_modnp & 
                                     [ MINORS.MIN event_rel ],
                                VAL [ SPR *cons*,
                                      COMPS < > ],
                                POSTHD +,
				NEGPOL #negpol ],
		    MODIFD notmod_or_rmod ],
    NH-DTR.SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN nondir_or_adv_rel,
                            CONT.HOOK.INDEX.E.ASPECT [ PROGR -, PRF - ] ],
		    NONLOC.REL 0-dlist,
                    PUNCT.PNCTPR #ppair ] ].

; For "On Tuesday who won" where need S-initial PP rather than extracted PP.
; DPF 29-Nov-02 - Removed NH-DTR..HEAD..TENSE no_tense, since the adjunct
; now provides the HOOK for the mother, including E-INDEX, which must be
; unified with the head-dtr's E-INDEX.
; DPF 26-May-03 - But that spurious re-entrancy with the head-dtr's index has
; now been removed, so we can re-introduce this constraint on TENSE, crucial
; for the generator, since the heuristics will introduce lots of spurious
; auxiliaries if there is an event variable unconstrained for TENSE.
; DPF 25-sept-04 - Changed NH-DTR..HEAD from prep to prep_or_modnp to also
; allow "tomorrow, can you come?"
; DPF 31-oct-05 - Constrained this rule to main clauses, to avoid spurious
; analyses in subordinate clauses like "we arise since today he arrives."
;; DPF 2012-11-06 - Added CONJ cnil to hd-dtr; presumably intended all along.
;; Also constrained NH-DTR to have saturated SPR, to avoid admitting the
;; rare PPs that are missing an obligatory specifier
;; DPF 2018-02-24 - We need a variant of this rule that does not require INV +
;; on the head dtr, just in case it is a WH-subj question as in |on Tuesday,
;; who arrived?|, where the head-filler phrase is necessarily INV -.
;;
basic_adj_head_inv_phrase := head_mod_phrase_simple & binary_headed_phrase &
  [ SYNSEM [ LOCAL.CAT [ VAL.COMPS < >,
			 NEGPOL #negpol ],
             NONLOC #nonloc & non-local_none_phr,
	     MODIFD lmod & [ LPERIPH #periph ],
             PUNCT.PNCTPR #ppair ],
    HD-DTR #hdtr &
         [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM fin ],
                                  VAL [ SUBJ *anti_list*,
                                        COMPS < > ],
				  MC + ],
			    CONT.HOOK [ LTOP #ltop,
					INDEX #ind & [ SF ques & #sf ] ],
			    CONJ cnil ],
                    NONLOC #nonloc,
                    MODIFD notmod_or_rmod,
                    PUNCT [ LPUNCT comma_or_pair_or_no_punct,
			    RPUNCT.PSF #sf,
                            PNCTPR #ppair ] ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD prep_or_modnp &
                                       [ MOD < synsem &
					       [ LOCAL intersective_mod,
						 --SIND #ind & event ] >,
					 TAM [ TENSE no_tense,
                                               ASPECT no_aspect ] ],
				    POSTHD +,
				    VAL [ SPR *olist*,
					  COMPS < > ],
				    NEGPOL #negpol ],
                              CONJ cnil,
			      CONT.HOOK.LTOP #ltop,
                              CTXT.ACTIVATED + ],
                      NONLOC #nonloc,
                      MODIFD.LPERIPH #periph,
                      PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
                              RPUNCT comma_or_pair_or_no_punct ] ] ],
           #hdtr >,
    C-CONT.HOOK [ LTOP #ltop,
		  INDEX #ind ] ].

adj_head_inv_phrase := basic_adj_head_inv_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV + ].

;; DPF 2018-02-24 - The surprising CASE nom constraint is to block non-WH
;; subj-head constructions even when the INDEX.SF is underspecified, as happens
;; for speech corpus where period punct is allowed with questions.
;;
adj_head_whsbj_phrase := basic_adj_head_inv_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -,
				   CASE no_case ],
    C-CONT.HOOK.INDEX.SF ques ].

; For "the team which in 1924 won the title"
; DPF 30-sept-06 - Restrict to exclude npadvs like 'there'
adj_head_rel_phrase := adj_head_phrase & head_mod_phrase_simple & 
                       head_compositional & head_final_infl &
  [ SYNSEM.LOCAL [ CAT #cat,
                   CONT.HOOK #hook ],
    HD-DTR.SYNSEM.LOCAL [ CAT #cat & [ HEAD verb & [ VFORM fin ],
                                       VAL [ SUBJ < >,
					     SPR *olist*,
                                             COMPS < > ] ],
                          CONT.HOOK #hook & [ LTOP #ltop,
                                              INDEX #index ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD prep &
                                       [ TAM [ TENSE no_tense,
                                               ASPECT no_aspect ],
                                         MOD < [ LOCAL intersective_mod ] > ],
                                  VAL.COMPS < > ],
                            CONT.HOOK [ LTOP #ltop,
                                        INDEX.E.TENSE no_tense,
                                        XARG #index ] ],
                    PUNCT.RPUNCT hyphen_or_pair_or_no_punct ] ].

; Further split the head_adj_int_phrase in order to enforce one aspect of the 
; Complex-NP constraint prohibiting extraction from nominal adjuncts.
;
; DPF (27-May-99) Moreover, the nom_adj rule constrains the NH-DTR to be 
; PRD +, in order to prevent finite VPs from serving as modifiers.  This was 
; being blocked earlier by pretending that all post-head modifiers had to have
; SUBJ *olist*, but this meant making predicative participles not specify an
; OPT value on their SUBJ - dubious generalization, and besides, it made it
; difficult to get the parse-node labels right, since passive verbs looked
; like S's.
;
; DPF 3-June-99 -- Further constrained nom_adj rule to make the modifier be
; phrasal, to block "Kim met the consultant hired." It's too strong a
; constraint, but we'll revisit the question if we move to making post-nominal
; modifiers attach at NP rather than N.  Among the disadvantages is the fact
; that we can't do "Get him something nice". (But see opt comp for generic-pro)
; DPF 9-Sept-99 - Added [PRD -] to head-dtr to avoid modifiers of e.g. 
; minute-word. 
; - 20-Nov-99: But this also blocked "the eleventh any time after three"
; DPF 15-Apr-00 - Removed [NH-DTR..SLASH 0-dlist] since now have
; relative clauses have non-empty REL value.  This means we have to split the 
; nn_adj rule into two, one for relative clauses which are REL 1-dlist and the
; other for reduced relatives which are REL 0-dlist - otherwise we would get 
; "*Kim bought a book by whom?".
; DPF 26-Mar-01 - Added [HD-DTR..RPERIPH na_or_-] to block e.g. attachment of
; post-nom modifiers to bare proper names and numerals.
; DPF 2-Jun-02 - Added NH-DTR.LEX - to exclude "the children angry"
; DPF 2-Jul-02 - (from 26-Mar-01) But attachment of post-nom modifiers to 
; proper names is possible, as in "Abrams from New York just called".  So
; removed this constraint, and leave for later how to block "Abrams by Browne
; arrived"
; DPF 3-Jul-02 - Try adding HD-DTR..NORM no_rel to exclude modification
; of np-adverbs like "here".
; DPF 13-Oct-02 - But why block this?  We want "here in Paris is nice" and
; "I'll arrive later that morning".  So remove it, and wait for motivation.
; DPF 23-aug-04 - Moved NH-DTR..LEX - from n_adj_int_phrase to n_adj_redrel_cl
; in order to allow postnominal participles like "the people hired were good"
; while still blocking e.g. "*the people happy were good"
; DPF 25-aug-04 - Change HD-DTR.LPUNCT from pair_or_no_punct to 
; comma_or_pair_or_no_punct to allow non-restrictive relatives and reduced
; relatives for now.
; DPF 06-apr-05 - Try constraining HD-DTR..RPUNCT to pair_or_no_punct, to
; exclude spurious reading for "Kim sent [a letter, then] a card."
; DPF 04-may-05 - Constrain NH-DTR to QUE 0-dlist to block NP analysis of
; "the time when".
; DPF 13-nov-05 - Changed HD-DTR..RPUNCT from rbc_or_pair_or_no_punct to
; comma_or_rbc_or_pair_or_no_punct
;; DPF 2016-07-03 - Preserved NEGPOL from hd-dtr to mother since this type
;; does not inherit from head_adj_int_phrase as one might expect.
;; DPF 2016-08-26 - Not clear why HD-DTR is INFLECTD na_or_+ while the mother
;; is stamped +, but this leads to spurious ambiguity for e.g. |we arose at
;; ten o'clock in the morning|.  So change HD-DTR to be just INFLECTD +, and
;; let's see what gets lost.  FIX?
;; DPF 2016-09-28 - For some time the hd-dtr has been stamped SLASH 0-dlist,
;; but this prevents free relatives such as |whatever cats in Paris we admire|
;; because the freerel-det has a non-empty slash, and slash-amalgamation then
;; fails to unify |whatever| with |cats in Paris|.  So remove, and let's see
;; if something goes amiss (FIX?).
;; DPF 2016-11-20 - Re 2016-08-26: What gets lost is modication of the rel
;; pronoun |that|, which is marked INFLECTD na, so we lose |the cat that on 
;; Tuesday disappeared|. So instead, we identify the INFLECTD value on hd-dtr
;; and mother.
;; DPF 2017-11-04 - In order to allow interposed relative clause between a noun
;; and its complement, as in |the claim we rejected that he arrived|, we push 
;; the COMPS < > constraint on head-dtr down to the reduced-relative subtype 
;; (since there is already a hd-aj_vmod_c rule that admits non-clausal 
;; noun modifiers before complements, as in |the claim yesterday that he 
;; arrived|.  But constrain COMPS here to be *obllist*, to avoid spurious 
;; ambig when attaching rel clause to a noun with an optional complement,
;; discharging the opt comp either before or after attaching the rel clause.
;
n_adj_int_phrase := basic_head_adj_phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL.CAT.NEGPOL #negpol,
	     NONLOC [ SLASH #slash,
		      QUE #que ] ],
    HD-DTR [ INFLECTD na_or_+ & #infl,
	     SYNSEM [ LOCAL.CAT [ HEAD supnoun,
				  VAL [ SPR.FIRST synsem_min,
					COMPS *obllist* ],
				  NEGPOL #negpol ],
		      NONLOC [ SLASH #slash,
			       QUE #que ],
		      PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
			      RPUNCT comma_or_rbc_or_pair_or_no_punct ],
		      MODIFD [ RPERIPH na_or_- ] ] ],
    NH-DTR [ INFLECTD +,
	     SYNSEM [ LOCAL.CAT [ MC na,
				  VAL.COMPS < > ],
		      NONLOC [ SLASH 0-dlist,
			       QUE 0-dlist ],
		      PUNCT.LPUNCT lital_or_pair_or_comma_or_no_punct ] ] ].

; DPF 26-Mar-01 - Added [SPR..MIN impl_or_expl_q_rel] to provide basis
; for blocking application of hdn_bnp-pn_c (non-branching) rule, to avoid e.g.
; "*I saw Abrams I had hired" - cf. "I saw the Abrams I had hired"
; Also added SYNSEM..RPERIPH + to provide basis for blocking addition of a
; thatless-rel to the right of a full relative clause.
; DPF 19-Oct-02 - Added HD-DTR..NORM no_rel to block full relatives 
; modifying np_adverbs like "here, there", and singular deictics as in 
; "*that he bought yesterday arrived" (cf "those he bought yesterday arrived")
; DPF 10-jul-04 - Can't make NH-DTR be LPUNCT no_punct as one might think for
; restrictive relatives (in contrast to non-restrictives which must be
; comma-delimited), because of pied-piping examples like "I bought five
; books, all of which were new" where the comma is optionally present even
; on the restrictive reading.
; DPF 4-mar-05 - Re 19-Oct-02: This NORM hack interacts badly with the
; appositive rule, where we want to prevent deictic pronouns from appearing,
; and use NORM to block.  Anyway, cf. "That which one writes is admired."
; So try non_number_rel as value instead, including deictics but still
; excluding "here, there".
; DPF 7-may-05 - With the current treatment of punctuation pairing, we need
; two versions of this rule (and similarly for appositives): one which 
; requires the PNCTPR value to match on both daughters, thus satisfying the
; pairing requirements and freeing the PNCTPR value on the mother; and one
; where the left daughter has no punct, so the PNCTPR value propagates.  Same
; for head_adj_scop_phrase.
; DPF 03-Feb-06 - Note that SPR..MIN impl_or_expl_q_rel now generalized to
; i_or_e_quant_or_deg_rel, still blocking construction of bare proper names
; with relative clauses.  FIX - This constraint should only hold for
; restrictive relatives, so when we add non-restrictives, should allow them
; for proper names as well.
; DPF 22-may-06 - Try moving this SPR constraint down to the non-comma variant,
; so we can get non-restrictives like "Abrams, who sings, dances" while still
; blocking the restrictive variant.
; DPF 19-jun-09 - Re 26-Mar-01: This constraint also unfortunately blocks
; "However, XHTML parsed in this way is not ...".  But given the large
; increase in ambiguity for all proper names followed by -ed verbs, and
; the markedness of this construction, leave as is.
; DPF 28-jun-09 - Re 26-Mar-01(b): This RPERIPH constraint should not be on
; this rule, because it blocks all iteration of relative clauses.  Since the
; thatless-rel rule already constrains its MOD..RPERIPH to na_or_-, remove
; it here, and still expect the desired asymmetry where thatless relatives
; must attach to the noun before that-relatives.  But since this constraint
; was also blocking attachment of rel-clauses to bare plural NPs (which are
; RPERIPH +), change n_adj_int_phrase to require MOD..RPERIPH na_or_-, make
; thatless-rels require MOD..RPERIPH -, and full relatives (here) have
; RPERIPH na_or_+.
;; DPF 2012-02-18 - It seems we want to allow relative pronouns to themselves
;; be modified by at least passive VPs, as in |the machine which, properly
;; configured, should last forever|.  So we should append the REL values from 
;; dtr to mother.  But we probably only want this modification on relative
;; pronouns when comma-separated, and this will require further work on the
;; comma machinery.  So keep stamp of [REL 0-dlist] on mother for now, and
;; FIX someday.
;; DPF 2012-08-30 - In syntax.tdl, added HD-DTR.INFLECTD + to avoid spurious 
;; |bill we admired|
;; DPF 2014-10-20 - Re 2012-02-18: Removed the 0-dlist constraint, so we can
;; get |the house which, viewed from above, ...| where the reduced relative is
;; comma-separated.
;; DPF 2015-01-06 - As long as this single type is used both for finite and
;; nonfinite relative clauses, we're stuck with overgenerating as in
;; |*flowers which, which are small, are blue, disappear|, because we want to
;; admire |flowers which, properly admired, grow well, disappear|.  Could
;; split this type for finite/nonfinite, and add [REL 0-dlist] to the head dtr
;; of the finite one, if that's the right generalization   FIX someday?
;; DPF 2020-03-31 - Fixed what appears to be a bug, where NH-DTR had
;; NORM independent_rel, but this seems incoherent - try MIN, not NORM. CHECK.
;; DPF 2020-04-17 - Re 19-Oct-02: This long-standing constraint prevents the
;; most natural analysis of wsj11a:21102002 |until tomorrow, when the report is
;; released|.  Maybe FIX?
;;
n_adj_relcl_phrase := n_adj_int_phrase & isect_mod_phrase & 
		      binary_punct_phrase &
  [ SYNSEM [ MODIFD #modif & rmod & [ RPERIPH na_or_+ ],
             NONLOC.REL [ LIST #first, LAST #last ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal & 
                                     [ TAM indic_tam &
                                           [ TENSE real_tense ],
                                       INV -,
				       MINORS.MIN independent_rel ],
                                  VAL.SUBJ *olist_or_prolist* ],
                            CONT.HOOK.INDEX.SF prop-comm ],
		    NONLOC.REL [ LIST #middle, LAST #last ],
                    MODIFD #modif ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL.CAT [ VAL.SPR.FIRST [ --MIN quant_or_deg_rel ],
				  HEAD.MINORS.NORM non_number_rel ],
		      NONLOC.REL [ LIST #first, LAST #middle ] ] ] ].

; The paired variant, where both daughters match in right punctuation
;; DPF 2012-10-10 - Removed HD-DTR..RPAREN - since this blocks e.g.
;; |the mayor (Kim) who resigned|.  We'll remind ourselves of why it was here.
;;
n_adj_relcl_prpnct := n_adj_relcl_phrase &
  [ SYNSEM.PUNCT.PAIRED #paired,
    HD-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired,
                          RPUNCT comma_or_pair_punct ],
    NH-DTR.SYNSEM.PUNCT [ PAIRED #pnctpr,
                          PNCTPR #paired ] ].

; The non-paired variant with comma
;; DPF 2011-10-01 - Try restricting HD-DTR.RPUNCT from rbc_or_pair_or_no_punct
;; to avoid some spurious ambiguity
;;
n_adj_relcl_nopair := n_adj_relcl_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN basic_nonpro_rel,
				VAL.SPR.FIRST.--MIN i_or_e_quant_or_deg_rel ],
                    PUNCT.RPUNCT pair_or_no_punct ],
    NH-DTR.SYNSEM.PUNCT [ RPUNCT comma_or_rbc_or_clause_or_no_punct,
                          PNCTPR #ppair ] ].

;; DPF 2020-06-02 - Added for asymmetric punctuation, with comma on head, 
;; missing comma on rel clause
;;
n_adj_relcl_asympr := n_adj_relcl_phrase &
  [ HD-DTR.SYNSEM.PUNCT [ PNCTPR no_ppair,
                          PAIRED no_ppair,
                          RPUNCT comma_or_pair_punct ],
    NH-DTR.SYNSEM.PUNCT [ PNCTPR ppair,
			  RPUNCT no_punct ] ].

;; DPF 2014-10-20 - Added a third variant just for parenthesized reduced
;; relatives modifying proper names, as in |Kim (called Browne) arose|,
;; where it can't be the paired variant (since there is no marking on |Kim|)
;; and can't be the non-paired one, which deliberately excludes proper names
;; to avoid spurious ambiguity.  Sigh.
;;
n_adj_relcl_proper_phr := n_adj_relcl_phrase &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    HD-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN named_rel,
                    PUNCT.RPUNCT pair_or_no_punct ],
    NH-DTR.SYNSEM.PUNCT [ LPUNCT lparen_punct,
			  RPUNCT rparen_punct,
                          PNCTPR #ppair ] ].

; DPF 27-Nov-02 - Added MOD..MIN basic_nom_rel to exclude measure-NPs from
; being modified by rel clauses.
; DPF 31-oct-03 - Tried adding ALTMIN norm_non_conj_rel to prevent modification
; of internval NPs like spurious (?) reading of  "berlin to Paris in June".
; DPF 25-aug-04 - Constrained NH-DTR..LPUNCT to pair_or_no_punct, to avoid
; spurious ambiguity for "the chair, in Berlin, arrives."
; DPF 28-sept-04 - Changed HEAD value of NH-DTR from a_or_p to a_or_p_or_adv
; since verbal gerunds still need to take post-head modifiers, as in
; 'eating quickly is not recommended'
; DPF 12-mar-05 - Re 25-aug-04: This blocks eg "Here, above Berlin, we arrive"
; so accept ambig and relax to comma_or_pair_or_no_punct.
; DPF 19-aug-06 - Since some already quantified NPs like pronouns also take 
; post-head modifiers, and since they currently carry their non-quant rel's
; handle in XARG, also unify with XARG.
; DPF 31-mar-08 - Re: 19-aug-06: Undesirable, and unnecessary since pronouns 
; present the pron_rel's LBL as their LTOP, just as expected.
;; DPF 30-jun-09 - Removed NHD-DTR..REL 0-dlist since this blocks pied piping
;; as in "consultants, the cars of whom are old, arrived."
;; DPF 2015-04-02 - Added ASPECT [PROGR -, PRF -] to NH-DTR, so we can generate
;; from paraphrased MRS that assigns these values via the SEM-I.  The trouble
;; is, we were also using this rule for title nouns as in |Ellis island|.  So
;; to keep this specificity while not pretending that title nouns introduce
;; events, added a separate rule for title nouns.
;;
basic_n_adj_redrel_phrase := n_adj_int_phrase & head_compositional &
  [ SYNSEM.NONLOC.REL [ LIST #first, LAST #last ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN norm_non_conj_rel,
				  VAL.COMPS < > ],
			    CONT.HOOK.LTOP #hand ],
		    NONLOC.REL [ LIST #first, LAST #middle ] ],
    NH-DTR.SYNSEM 
       [ LOCAL [ CAT [ HEAD n_or_a_or_p_or_adv &
                            [ MOD < [ LOCAL intersective_mod ] > ],
                       VAL.SUBJ *olist* ],
                 CONT.HOOK.LTOP #hand ],
	 NONLOC.REL [ LIST #middle, LAST #last ],
         PUNCT.LPUNCT comma_or_hyphen_or_pair_or_no_punct,
         LEX - ],
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2017-05-29 - For some reason, the [PRD +] constraint on the non-hd dtr
;; disappeared along the way, but its absence means we wrongly allow
;; |*people twenty year old| along with |people twenty years old|, since the
;; PRD value of the PA and the INFLECTD value on the measure noun are unfiied.
;; Let's restore [PRD +] and see why it may have been removed.
;; DPF 2017-10-03 - Added NH-DTR..INDEX..TENSE untensed, to be able to
;; distinguish modifiers that require tensed phrases.
;;
n_adj_redrel_phrase := basic_n_adj_redrel_phrase &
  [ SYNSEM.MODIFD rmod,
    NH-DTR.SYNSEM.LOCAL [ CAT.HEAD.PRD +,
			  CONT.HOOK.INDEX.E [ TENSE untensed,
					      ASPECT [ PROGR -, PRF - ] ] ] ].

; The paired variant, where both daughters match in right punctuation
;; DPF 2016-09-27 - Removed RPAREN + on hd-dtr, since it blocks e.g.
;; |algorithms (called schemes), such as these.|
;; DPF 2017-12-04 - Made the mother's RPUNCT allow for no_punct, since we want 
;; to analyze a sequence of two (or more) post-head modifiers such as in 
;; |transfers, conditional or otherwise, of property were made|, where the 
;; first is marked with a paired comma, but the second is not.  Still keep
;; PSF value from right dtr, in case this phrase is clause-final.
;; DPF 2020-03-30 - Removed mother's PAIRED #paired, since it is already
;; given in norm_binary_punct_phrase, though it sadly blocks
;; |Kim and cats, beside Browne, arrived|.  FIX someday.
;;
n_adj_redrel_prpnct := n_adj_redrel_phrase &
  [ SYNSEM.PUNCT.RPUNCT comma_or_clause_or_pair_or_no_punct & [ PSF #psf ],
    HD-DTR.SYNSEM.PUNCT [ PNCTPR #pnctpr,
                          PAIRED #paired,
                          RPUNCT comma_or_pair_punct ],
    NH-DTR.SYNSEM.PUNCT [ PAIRED #pnctpr,
                          PNCTPR #paired,
			  RPUNCT.PSF #psf ] ].

; The non-paired variant with comma
;;
n_adj_redrel_nopair := n_adj_redrel_phrase &
  [ SYNSEM.PUNCT [ PNCTPR #ppair,
		   RPUNCT #rpunct ],
    HD-DTR.SYNSEM.PUNCT.RPUNCT pair_or_no_punct,
    NH-DTR.SYNSEM.PUNCT [ PNCTPR #ppair,
			  RPUNCT #rpunct ] ].

;; DPF 2020-06-02 - Asymmetric punctuation
;;
n_adj_redrel_asympr := n_adj_redrel_phrase &
  [ HD-DTR.SYNSEM.PUNCT [ PNCTPR no_ppair,
                          PAIRED no_ppair,
                          RPUNCT comma_or_pair_punct ],
    NH-DTR.SYNSEM.PUNCT [ PNCTPR ppair,
			  RPUNCT no_punct ] ].

;; |Ellis island|
;; DPF 2017-02-27 - Generalized hd-dtr's RPUNCT to comma_or_pair_or_no_punct
;; in order to admit |Netscape Communications, Inc. succeeded|

n_adj_title_phrase := basic_n_adj_redrel_phrase &
  [ SYNSEM.PUNCT [ PNCTPR #ppair,
		   RPUNCT #rpunct ],
    HD-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct,
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD ttl,
		    PUNCT [ PNCTPR #ppair,
			    RPUNCT #rpunct ] ] ].

; For generator, distinguish constructions where adjunct contains a gap from
; those where it does not.
;; DPF 2018-06-05 - Have the unslashed variant propagate RPERIPH from the
;; head-dtr, while the slashed variant stamps RPERIPH bool on the mother, in
;; order to prevent spurious right-node-raising analysis of
;; |[[arrives and arises] beside] Kim|, while still allowing RNR when an
;; unextracted adjunct is attached, as in |was [[hired and fired] yesterday] by
;; Browne|

h_adj_unsl_phrase := head_adj_int_phrase &
  [ SYNSEM [ NONLOC.SLASH #slash,
	     MODIFD.RPERIPH #rperiph ],
    ARGS < [ SYNSEM [ NONLOC.SLASH #slash,
	              MODIFD.RPERIPH #rperiph ] ],
	   [ SYNSEM.NONLOC.SLASH 0-dlist & [ LIST < > ] ] > ].

; DPF 10-dec-03 - Restrict this rule to exclude elided auxiliary heads, to
; avoid "Berlin, the road is, to"
; DPF 20-oct-09 - Restrict hd-dtr to INV -, to avoid spurious ambiguity
;
h_adj_sl_phrase := head_adj_int_phrase &
  [ SYNSEM [ NONLOC.SLASH 1-dlist & #slash,
	     MODIFD.RPERIPH bool ],
    HD-DTR.SYNSEM [ LOCAL.CAT.HEAD verbal &
				   [ MINORS.ALTMIN non_ellipt_rel,
				     INV - ],
		    NONLOC.SLASH 0-dlist & [ LIST < > ] ],
    ARGS.REST.FIRST.SYNSEM.NONLOC.SLASH #slash ].

; DPF 11-May-01 - Split adj_head_int_phrase into two: one for nominal head-dtrs
; and one for non-nominals, parallel to head_adj_phrase split.  Needed at least
; to prevent pre-head adjectives from modifying partitives, to get contrast in
; "any angry at Sally left"  vs "*angry any left" 
; DPF 13-May-01 - Changed SPR..MIN from impl_or_expl_q_rel to quant_rel in
; order to get "Mr Smith" as adj_n construction which then undergoes hdn_bnp-pn_c
; rule.
; DPF 13-Mar-02 - HD-DTR..LPERIPH na_or_- prevents adjectives from modifying
; numerically-modified nouns, as in "*the tall five consultants".
; DPF 28-Apr-03 - But this constraint prevents "the next five consultants",so
; remove constraint here, and expect (statistical?) adjective-ordering
; constraints to get the order of "five" and "tall" right.  Someday.
; DPF 16-dec-03 - Made NHD be [LEX +] to prevent eg "the older than Kim chair"
; since "older" is [LEX +] but "older than Kim" is [LEX -].
; DPF 24-apr-04 - Made COMPS of mother be *obllist* to avoid spurious ambiguity
; for e.g. "easy problem" since we could otherwise discharge the optional
; complement of "easy" first with head_opt_comp, or after this rule applies,
; using n_opt_comp.
; For now, rule out comma-separated prenominal adjectives, since out for
; one adjective, pretty bad for two, and not clear how to allow for three 
; or more (if that's the right generalization).
; But this is clearly wrong, for e.g. "we expect warm, sunny days', so remove,
; and someday work out how to block comma on rightmost adjective.
; DPF 28-jun-09 - Pulled RPUNCT constraint up from two subtypes, since we
; want to allow informal comma in both constructions, to admit e.g.
; "The angry, or unhappy, cat arrives."
;; DPF 2015-03-27 - Constrain the NH-DTR to be PRF - so that we can still
;; allow the SEM-I to default the value of PERF to -, and succeed in generating
;; e.g. |the grumpy cat arose| once the resulting MRS from the parser has
;; gone through the SEM-I, assuming `grumpy' is underspecified for PRF (as it
;; has to be in order to admit |the cat has been grumpy|.
;; DPF 2020-04-26 - Temporarily propagating ORTH.CLASS from nh-dtr to mother
;; so we can restrict new mnp_vp_phr to apply only to measure NPs with `%',
;; and not, for example, |10 square meters owned by Kim|
;;
adj_n_int_phrase := adj_head_int_phrase &
  [ HD-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD basic_nom_or_ttl,
				    VAL [ SPR.FIRST 
					   [ LOCAL.CAT.HEAD.MINORS.MIN #min,
					     --MIN #min & quant_rel ],
					  COMPS < > ] ] ],
		      MODIFD notmod_or_lmod,
		      PHON.ONSET #onset ],
	     INFLECTD #infl ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ PHON.ONSET #onset ] >,
				    VAL.SUBJ *synlist* ],
			      CONT.HOOK.INDEX event & 
                                              [ E [ TENSE no_tense,
			                            ASPECT [ PROGR bool,
							     PRF - ] ] ] ],
                      LEX + ],
	     ORTH.CLASS #class,
             INFLECTD + ],
    ORTH.CLASS #class,
    INFLECTD #infl ].

; DPF 29-aug-04 - Also allow "tenth-century" with optional hyphen when the
; head noun is [INFLECTD -]
; DPF 11-mar-05 - More interested in avoiding "*The tall, chair arrived", so
; instead splitting this rule for latter purpose.  And anyway, the hyphen
; constraint was wrong, since we also want "the tenth-century church arose",
; so allow hyphen for adj-n case.
;; DPF 2012-08-29 - Added INFLECTD bool on HD-DTR to block |true that| with
;; relative pron `that'.
;; DPF 2017-12-16 - Removed rbc from NH-DTR.s RPUNCT, to block |the tall, cat|
;; now that we treat N-N compounds as left-modified, so we can use the
;; adj_adjn rule for those, allowing a comma as in |the tall, ten-foot wall|.
;;
adj_n_phrase := adj_n_int_phrase &
  [ HD-DTR [ SYNSEM.MODIFD notmod & [ LPERIPH na_or_- ],
	     INFLECTD bool ],
    NH-DTR.SYNSEM.PUNCT.RPUNCT hyphen_or_pair_or_no_punct ].

;; DPF 2017-12-20 - Add special case for |tall, and happy, cat| with a conjoined
;; AP which is comma-marked.  Eventually should do something better with paired
;; commas of this kind, so the |tall, if happy,| phrase can also be treated as
;; optionally not comma-marked (where the pairing has `discharged' the comma).
;; FIX someday.
;;
adj_n_crd_comma_phrase := adj_n_int_phrase &
  [ HD-DTR [ SYNSEM.MODIFD notmod_or_rmod,
	     INFLECTD bool ],
    NH-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX conj_event,
		    PUNCT.RPUNCT comma_punct ] ].

; DPF 17-aug-06 - Added NORM to block n-ed phrases like "wide-eyed" from 
; being recursively modified.  But this wrongly also blocks recursive
; modification of these nouns when used ordinarily.  So instead constrain
; HEAD type to exclude n-ed nouns.
; DPF 07-nov-07 - Removed [HD.DTR..LPERIPH bool] since this prevents e.g.
; "the first five cats" and "the same five cats"
; DPF 25-may-09 - Re 07-nov-07 - This was also blocking "*the tall many cats"
; but now doing this with the lexical type for normal adjectives
; DPF 2010-09-01 - Re 25-may-09: But still want to block "*the tall very cat"
; so add LPERIPH na_or_-.
;; DPF 2014-11-24 - In order to allow nouns like (non-count) "school" that
;; bar adjectival modifiers but can be heads of noun-noun compounds, add
;; RPERIPH constraint here to exclude spurious analysis for |*tall school|
;
adj_adjn_phrase := adj_n_int_phrase &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD nom_or_ttl,
                    MODIFD lmod & [ LPERIPH na_or_-,
				    RPERIPH na_or_- ] ],
    NH-DTR.SYNSEM.PUNCT.RPUNCT rbc_or_hyphen_or_pair_or_no_punct ].


; DPF 29-Nov-02 - Removed NH-DTR..HEAD..TENSE no_tense, since the adjunct
; now provides the HOOK for the mother, including E-INDEX, which must be
; unified with the head-dtr's E-INDEX.
; DPF 26-May-03 - But that spurious re-entrancy with the head-dtr's index has
; now been removed, so we can re-introduce this constraint on TENSE, crucial
; for the generator, since the heuristics will introduce lots of spurious
; auxiliaries if there is an event variable unconstrained for TENSE.
; DPF 21-may-05 - Add similar split to get comma distribution right for
; 'Kim quietly left' '*Kim quietly, left' 'Kim quietly, carefully left' 
; DPF 21-dec-07 Changed NH-DTR..COMPS from <> to *olist* to allow e.g.
; "The most quickly hired cat arrives."
; DPF 31-mar-08 - Why the re-entrancy of XARG on the two dtrs?  FIX
;; DPF 2017-10-03 - Tried constraining HD-DTR to be non-inverted, so we can 
;; avoid |*quickly did he arise.| since this construction requires the modifier
;; to be scopal (and downward-entailing: |rarely did we ..| but 
;; |*often did we...|) and |*last did we ...|
;; Cf. |not often have we seen| : it would seem that negation reverses the
;; upward vs downward entailment, but then again |*infrequently have we seen...|
;; even though one might expect this to be good if `frequently' is scopal and
;; upward-entailing.  Or maybe this shows that `frequently' is non-scopal. 
;; But alas, |in no case would we ...| shows that the modifier itself 
;; doesn't have to be scopal, but maybe has to introduce a scopal (negative?)
;; operator.  So the INV - constraint for this rule is too strong, and instead
;; we'll try making it a constraint on intersective adverbs, leaving PPs for
;; later.  FIX someday.
;; DPF 2020-04-21 - Re 31-mar-08: We should remove this strange XARG identity
;; on the two dtrs, since we may well  want to expose the XARG of adverbs, and
;; it can't be the same as the XARG of what it modifies.  FIX sooner, and
;; then add identity in basic_int_adverb_synsem of XARG and KEYREL.ARG1, as
;; expected.  FIX for algebra.
;;
basic_adj_h_int_phrase := adj_head_int_phrase & head_final_infl &
  [ HD-DTR.SYNSEM.LOCAL [ CAT.HEAD adverbee,
			  CONT.HOOK.XARG #xarg ],
    NH-DTR.SYNSEM [ LOCAL [ CAT.HEAD.TAM [ TENSE no_tense,
					   ASPECT no_aspect ],
			    CONT.HOOK.XARG #xarg ],
                    NONLOC.REL 0-dlist,
                    PUNCT.RPUNCT comma_or_rbc_or_hyphen_or_pair_or_no_punct ] ].

;; DPF 2011-09-24 - Removed this split, since it's too hard to ensure that
;; the two rules don't overlap, e.g. for |quickly worst| where |worst|
;; needs to unify with MODIFD hasmod in order to undergo the partitive rule,
;; but needs to unify with notmod in order to undergo the v_mod rule.
;;
adj_h_int_phrase := basic_adj_h_int_phrase.

; DPF 18-aug-07 - Added constructions for modifier PPs and adverbs which 
; immediately follow a verb, preceding its complements, in a generalization 
; of "heavy-NP shift".  
; DPF 26-aug-07 - Restrict NH-DTR's ALTMIN to block lexical PPs like "on"
; Also restrict to single complement for now, to avoid unlikely insertion
; before double NP or obj-control.
; DPF 28-aug-07 - Note that currently we get an unwanted ambiguity for
; "kim might quietly hire Abrams." FIX? maybe by splitting into two rules,
; one for PPs and one for adverbs, where the latter exclude verbal comps.
; DPF 17-sept-07 - Restrict hd-dtr's complement to exclude robust-np-sg,
; to cut down on spurious ambiguity.
; DPF 08-apr-08 - Removed NH-DTR..MODIFD notmod to allow 
; "we enter now the citadel"
; DPF 08-apr-08 - Re: 26-aug-07 - But this prevents application to
; passives like "associated with".  So relax constraint, and also remove
; HD-DTR.SYNSEM abstr_lex_synsem.
; DPF 31-dec-08 - Made NORM no_rel to block measure-NPs, as in spurious
; parse for "Kim [hires 48] consultants"
; DPF 2010-10-31 - Let's try expanding this to include adjective heads, so
; we can get "higher on the hill than kim"
;; DPF 2014-04-14 - The COMPS..OPT - constraint prevents the desired analysis
;; for |was studied carefully by Kim|.  It is also unnecessary, since the
;; `canonical_synsem' constraint already ensures that it will appear if an 
;; intervening modifier is picked up.
;; DPF 2015-03-13 - Pushed NH-DTR--MOD..RPERIPH na_or_+ down to non-conj
;; subtype, so we can get subord-prdp with conjunctions, as in
;; |Kim arrived, and, seeing Abrams, arose|
;; DPF 2016-09-26 - Re 31-dec-08: Pushed this down to subtypes, in order to
;; be able to say NORM norm_rel for cmod_s, so we can block subord-prdp phrases
;; to avoid spurious analysis of |we were separate from [and related] to Kim|.
;; DPF 2016-12-03 - Removed hd-dtr's MODiFD notmod since we want to use this
;; rule for |[taller tree on the street] than that one|
;; DPF 2018-02-13 - Made NH-DTR..MOD.FIRST be expressed_synsem, to exclude
;; newer PP-PP copred analysis here.
;; DPF 2018-05-31 - Added NH-DTR..NORM norm_or_no_rel to exclude measure-npadv.
;;
v_mod_phrase := head_initial & binary_punct_phrase &
                head_valence_phrase &
  [ SYNSEM [ LOCAL [ CAT.VAL #val,
                     CONJ cnil_or_lexconj ],
             LEX - ],
    HD-DTR [ INFLECTD +,
             SYNSEM 
             [ LOCAL [ CAT 
                       [ VAL #val &
                           [ COMPS.FIRST canonical_synsem &
			                 [ --MIN nonpro_or_event_rel,
					   LOCAL.CAT.VAL.COMPS *olist* ] ] ],
		       CONT.HOOK [ INDEX #index,
				   XARG #xarg ] ],
	       PUNCT.RPUNCT #rpunct ] ],
    NH-DTR 
       [ SYNSEM [ LOCAL [ CAT [ HEAD p_or_basic_adv &
                                   [ MINORS [ MIN independent_rel,
					      ALTMIN norm_rel,
					      NORM norm_or_no_rel ],
				     MOD < expressed_synsem &
					   [ LOCAL [ CAT [ HEAD verb,
							   VAL.SUBJ <[OPT -]>],
						     CONT.HOOK.INDEX #ind ],
					     PUNCT.RPUNCT #rpunct,
					     --SIND #ind ] > ],
				VAL [ SPR *olist*,
                                      COMPS < > ] ] ],
                  NONLOC non-local_none_phr & [ SLASH.LIST < > ] ] ],
    C-CONT [ HOOK [ INDEX #index,
		    XARG #xarg ],
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2012-08-01 - Generalized this to allow nominal heads as well, so we
;; get the intended analysis for e.g. |the attempt on Tuesday to arise|
;; DPF 2012-10-23 - Had MODIFD rmod on mother to block recursive application
;; of this rule (as in |you are deep within Berlin|), but this blocks
;; |In Paris, Kim is sometimes Abrams| (adjunct extraction after applic of 
;; this rule), so instead, make mother [MODIFD notmod & [ RPERIPH + ] and
;; restrict the dtr to [RPERIPH na_or_-].
;; DPF 2015-03-13 - Re 2012-10-23: Since the RPERIPH gets passed up from hd-dtr
;; to mother in hcomp (because MODIFD is reentrant there), we can't have the
;; RPERIPH value be +, since that blocks attachment of e.g. absolutives, which
;; require the mod target to be RPERIPH -, as in 
;; |Kim is indeed Abrams, her skills admired|
;; So change to mother having RPERIPH bool and dtr RPERIPH na.
;; DPF 2016-11-08 - Generalize NH-DTR..NORM from no_rel to quantity_or_no_rel
;; so we can get |she gave the answers two weeks before the test to the kids|
;;
v_mod_vg_phrase := v_mod_phrase &
  [ SYNSEM.MODIFD notmod & [ RPERIPH bool ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD v_or_g_or_a_or_n,
				  VAL.SUBJ *synlist* ],
			    CONT.HOOK #hook,
			    CONJ cnil ],
		    MODIFD.RPERIPH na ],
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MOD.FIRST [ LOCAL.CONT.HOOK #hook,
					       MODIFD.RPERIPH na_or_+ ],
			      POSTHD + ],
    GENRE nonformal ].

v_mod_int_phrase := v_mod_vg_phrase & head_compositional & 
  [ NH-DTR.SYNSEM.LOCAL [ CAT.HEAD [ MOD < [ LOCAL intersective_mod ] >,
				     MINORS.NORM quantity_or_no_rel ],
			  CONT.HOOK.LTOP #ltop ],
    C-CONT.HOOK.LTOP #ltop ].

;; DPF 29-mar-10 - Don't recall why HD-DTR..RPUNCT comma_or_pair_punct,
;; but it blocks |recommend only that he be hired|, so remove, and see
;; what happens.
;; DPF 2017-01-31 - Let's try constraining the nh-dtr to be NORM norm_rel, to
;; exclude depictives, as in [[be considerate] of cats].
;; DPF 2018-06-24 - Want to exclude nouns as heads for the scopal variant,
;; to avoid e.g. |high interest [meant a rise] in prices| and |the pictures, 
;; we thought, of Rome| where the semantics would be problematic. In order to
;; still get lexical scopal adverbs as in |pictures, apparently, of cats were 
;; seen|, as in sc02:6005190; and similarly |pictures, however, of cats|, we
;; split this rule into one for verbs/adjectives and one for noun heads where
;; the nonhead is lexical.
;;
basic_v_mod_scop_phrase := v_mod_vg_phrase &
  [ NH-DTR.SYNSEM.LOCAL [ CAT.HEAD [ MOD < [ LOCAL scopal_mod ] >,
				     MINORS.NORM norm_rel ],
			  CONT.HOOK.LTOP #ltop ],
    C-CONT.HOOK.LTOP #ltop ].

v_mod_scop_phrase := basic_v_mod_scop_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD v_or_a ].

v_mod_noun_scop_phrase := basic_v_mod_scop_phrase &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD basic_noun,
    NH-DTR.SYNSEM.LEX + ].

;; DPF 29-jan-12 - Cannot remember why HD-DTR..HEAD was constrained to
;; n_or_a_or_det, but this blocks "arrived and on Tuesday arose", so remove
;; it and maybe see what it was doing for us.
;;
conj_mod_phrase := v_mod_phrase &
  [ SYNSEM nonlex_synsem,
    HD-DTR.SYNSEM basic_lex_synsem &
		  [ LOCAL [ CAT [ HEAD subst,
				  VAL.SPR *olist* ],
			    CONJ lex-conj ],
		    PUNCT.RPUNCT comma_or_pair_or_no_punct ] ].


;; For "and on Tuesday arose" or "and later Kim"
;; DPF 2014-08-21 - Because some modifiers are adverbs even when the conjoined
;; phrase is nominal, we can't bind the modifier's MOD..INDEX since that must
;; be an event for adverbs, but there is no available event.
;;
conj_mod_int_phrase := conj_mod_phrase & head_compositional & 
  [ NH-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
			  CONT.HOOK.LTOP #ltop ],
    HD-DTR.SYNSEM.LOCAL.CONJ.CREL.LBL #ltop,
    C-CONT.HOOK.LTOP #ltop ].

;; DPF 2016-09-26 - Add NORM norm_rel to nh-dtr, to avoid spurious analysis of
;; e.g. |we were separate from [and related] to Kim|.
;; DPF 2016-10-21 - Re 2016-09-26: But this prevents 
;; |we arose and, laughing, departed|.  Cf. 
;; | we ran from and, exhausted, to Paris|.  So accept the ambiguity.
;; DPF 2018-03-26 - Re 2016-10-21: Instead, propagate NORM value from nh-dtr 
;; to mother, so head_marker_nom rule can restrict first dtr's NORM.
;; DPF 2018-06-05 - Tempting to add NH-DTR..POSTHD + to exclude spurious ambig
;; for |Kim arose and, awoken by Browne, smiled| where |awoken by Browne| is
;; vp_sbrd_pre_c, when what we want is just the vp_sbrd_prd_pas_c analysis.
;; But we need to allow pre-VP scopal adverbs such as "probably" to get
;; Collins conjunction constructions as in |we'll read books [and maybe] papers|
;; So live with the ambiguity now, and maybe FIX someday.
;; 
conj_mod_scop_phrase := conj_mod_phrase &
  [ NH-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ MOD < [ LOCAL scopal_mod &
					       [ CAT.HEAD.MINORS.ALTMIN
	                                                       non_ellipt_rel,
						 CONT.HOOK.LTOP #ltop ] ] >,
				       MINORS.NORM #norm ] ],
			  CONT.HOOK.LTOP #mltop ],
    HD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MINORS.NORM #norm,
			  CONT.HOOK [ LTOP #ltop,
				      INDEX #index,
				      XARG #xarg ] ],
    C-CONT.HOOK [ LTOP #mltop,
		  INDEX #index,
		  XARG #xarg ] ].

;; DPF 2018-02-12 - It is now clear that we want one semantics of PP+PP to be
;; different from ordinary modification, since for |on the mountain near the 
;; top stood a tall tree|, we want both PPs to take the same external argument,
;; instead of having the second PP take the index of the first as its argument.
;; But we still have to have the ordinary modification analysis of PP+PP
;; because in |we were in Paris on Tuesday| the |on Tuesday| does not take
;; |we| as external argument, but rather the state of being in Paris.  So we 
;; end up with a systematic ambiguity for |NP was PP PP|, with one reading 
;; where the semantic index of the subject NP is the external argument of each 
;; of the PPs (|we were in Paris near the Louvre|), and one where the semantic 
;; index of the first PP is the external argument of the second (|we were in 
;; Paris on Tuesday|). 
;; Note that for extraction as in |On Tuesday we were in Paris|, we want the 
;; extracted modification analysis which gives the right semantics, and which 
;; we would not get via this new rule.  Note further that for locative inversion
;; alongside |on the mountain near the top stood a tall tree|, we also want the
;; ordinary modification reading (where the second PP takes the index of the
;; first PP as argument), for e.g. |In Paris on Tuesday were two ambadassors 
;; from Asia|, where we still don't want the ambassadors to be on Tuesday.
;; Thus we're forced to have both analyses for PP+PP, unless we can find
;; sortal restrictions (e.g. time vs place?) that would exclude one or the other
;; of the two analyses.  The extra ambiguity will be unwelcome for examples such
;; as |The race will be in Paris on Tuesday| where we now have to choose
;; between the race being on Tuesday vs the locative state being on Tuesday.
;; We at least constrain this PP+PP phrase so that it won't appear as a modifier
;; but only in argument positions including complement of copula and subject in
;; locative inverson.
;; DPF 2020-02-22 - Constrain mod-PP's SPR to be *olist*, to avoid PP-PP for
;; |two years ago, he appeared|.
;; DPF 2020-05-16 - Restrict to verb-modifying dtrs, to exclude PP-PP-mod for
;; |two years ago|
;; 
prep_mod_prep_phrase := head_mod_phrase & binary_headed_phrase & head_initial &
			head_nexus_phrase &
  [ SYNSEM [ LOCAL.CAT [ VAL #val ],
	     LEX #lex,
	     NONLOC #nonloc & [ SLASH 0-dlist ] ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD prep_or_modnp & 
				       [ MOD *unexpcons* &
					     [ FIRST.LOCAL int_mod_local &
							   [ CAT.HEAD #hd &
								      verb ]] ],
				  VAL #val & [ COMPS < > ] ],
			    CONT.HOOK #hook & [ LTOP #ltop,
						XARG #xarg ] ],
		    LEX #lex,
		    NONLOC #nonloc ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD prep_or_modnp & 
				       [ MOD *cons* &
					     [ FIRST.LOCAL int_mod_local &
							   [ CAT.HEAD #hd ] ] ],
				  VAL [ COMPS < >,
					SPR *olist* ],
				  POSTHD + ],
			    CONT.HOOK [ LTOP #ltop,
					INDEX.E.TENSE tense,
					XARG #xarg ] ],
		    NONLOC non-local_none_phr ],
    C-CONT [ HOOK #hook,
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; For now, restrict adjunct extraction to posthead modifiers of VPs (and the
; special case of inverted auxiliary-headed Ss, which still have a non-empty 
; but never realized SUBJ - see discussion of sai_synsem in lextypes.tdl). 
; This will still produce two parses for "Tuesday Kim might dance", but the 
; alternatives (e.g., blocking modification of all auxiliaries except the 
; copula) seem even less attractive.  Also block extraction of adjuncts out of
; subjunctive-verb-headed phrases.

; ERB (12-11-96) This is the exception; the reason I couldn't put the MSG
; stuff on head_mod_phrase.

; DPF (23-Aug-98) Given our splitting up of the head-modifier type into 
; separate subtypes for intersective and scopal modification, we have to do
; the same for extracted adjuncts as well.
; DPF (09-Jan-99) But it is not clear that we ever need to extract scopal
; modifiers, since the ones that are post-head (maybe always adverbs) also seem
; to be available as modifiers of S, and not restricted to POSTHD +.  So 
; we'll try doing without the scopal variant.
;
; DPF 19-Oct-99 - We used to make the value of SLASH's MOD feature be the
; whole SYNSEM of the HEAD, but this interacted badly with coordination
; of two extracted_adj phrases: it resulted in the CONT features of the
; two conjoined phrases being identified, since coordination enforces
; across-the-board identity of SLASH.  This resulted in circular RELS
; values, which are undesirable.  So now we identify the values of the
; relevant LOCAL features in SLASH..MOD and in HD-DTR, avoiding false
; identity of the RELS values.  Test case: "Kim arises and arises".
; DPF 2-Feb-01 - Eliminated HD-DTR..MOOD strict_sort since it blocked
; "On tuesday Kim arrived and would stay"
; DPF 30-May-01 - Identify MC of head-dtr and extracted adjunct, to avoid
; spurious ambiguity for "For whom does she work"
; DPF 15-Oct-01 - Replaced HD-DTR..HEAD..TENSE real_tense with MIN relation,
; since former blocked extraction of adjuncts from complements of e.g. modals,
; and the latter works as intended to block extraction from no_copula VPs.
; DPF 12-Apr-02 - Added HD-DTR..SUBJ..INDEX non_expl-ind to prevent adjunct
; extraction from there-copula sentences - spurious chart ambiguity.
; DPF 28-Nov-02 - HOOK comes only from C-CONT (linked here to SLASH values)
; DPF 14-Oct-03 - But can't prevent adjunct extraction from there-copula
; sentences: "In winter there is snow". So removed non_expl constraint.

basic_extracted_adj_phrase := head_mod_phrase & head_only & phrasal &
  [ SYNSEM [ LOCAL [ CAT.VAL [ COMPS < >,
			       SPCMPS #spcmps ],
                     CONT.HOOK.INDEX.--TPC +,
                     CONJ cnil ],
             NONLOC [ QUE #que,
                      REL 0-dlist ],
             MODIFD rmod,
	     PUNCT #punct ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN norm_rel,
                                VAL [ COMPS < >,
				      SPCMPS #spcmps ] ],
                    NONLOC [ QUE #que,
                             REL 0-dlist ],
		    PUNCT #punct ] ].

;; DPF 2018-09-10 - Identified SLASH..MOD..HOOK with hd-dtr's HOOK, as per
;; the algebra for intersective modification.
;;
extracted_adj_int_phrase := basic_extracted_adj_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN #modmin,
                           POSTHD #ph,
			   MC #mc ] ],
	     NONLOC.SLASH 1-dlist &
		   [ LIST < mod-local &
			    [ CAT [ POSTHD +,
				    HEAD mobile &
                                     [ MOD < synsem &
                                             [ --MIN #modmin,
                                               LOCAL intersective_mod &
                                               [ CAT [ HEAD #head,
                                                       VAL [ SUBJ #subj,
							     COMPS #comps,
							     SPEC #spec,
							     SPCMPS #spcmps ],
                                                       POSTHD #ph,
                                                       HC-LEX #hclex,
                                                       MC #mc ],
                                                 CONT.HOOK #hook,
                                                 CONJ #conj,
                                                 CTXT #ctxt ],
					       NONLOC.SLASH 0-dlist,	 
					       --SIND #hind ] >,
                                       TAM [ TENSE no_tense,
                                             ASPECT no_aspect ],
                                       MINORS.MIN independent_rel ],
				    VAL [ COMPS *olist*,
					  SPR *olist* ] ],
			      CONT [ HOOK [ LTOP #hand,
                                            XARG #hind ] ],
			      CONJ cnil ] > ] ],
    HD-DTR.SYNSEM canonical_synsem &
	   [ LOCAL local_basic &
		   [ CAT [ HEAD #head & v_or_a_or_p &
				[ TAM.MOOD ind_or_modal_subj,
                                  MOD < anti_synsem > ],
                           VAL [ SUBJ #subj,
				 COMPS #comps,
				 SPEC #spec,
				 SPCMPS #spcmps ],
			   POSTHD #ph & +,
                           HC-LEX #hclex,
                           MC #mc ],
                     CONT.HOOK #hook & 
			       [ LTOP #hand,
                                 INDEX #hind & individual,
				 XARG #xarg ],
                     CONJ #conj,
                     CTXT #ctxt ],
             NONLOC.SLASH 0-dlist & [ LIST < > ],
	     MODIFD notmod ],
    C-CONT [ HOOK [ LTOP #hand,
		    INDEX #hind,
		    XARG #xarg ],
             RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; DPF (1-May-99) Removed identity of SLASH..KEYREL.LBL and HD-DTR..KEYREL.LBL 
; since 
; this should be redundant for most cases, and is wrong for free relatives
; like "where Kim slept" since in this construction the MIN of the free-rel and
; the MIN of its sister's SLASH must be identified in order to allow "where Kim
; put the book" while blocking "where kim relied".  But this identity means we
; can't have the LBL of that SLASH..MIN be the same as the LBL of the
; head of this extracted-adj phrase, because that would mean that the LBL of
; the ex-adj head's MIN ("slept" in "where she slept" would be wrongly 
; identified with the LBL of the MIN for "where" (which is 'place_rel').
; DPF 2-Oct-01 - Added to mother [SLASH..INDEX.SORT entity] to make this rule
; be complementary to the hd_xaj-tmp_c rule, which is restricted to SORT time.
; DPF 28-Apr-03 - The drawback of this (2-Oct-01) is that it blocks a
; combination of temporal and nontemporal modifiers, as in "why don't we hire
; kim now".
; DPF 13-mar-05 - Tried adding SPR *anti_list* to avoid spurious ambiguity for
; extracted adjuncts of adjective phrases.  Also added POSTHD + to avoid
; spurious extraction from attributive adjectives.
; DPF 28-mar-05 - Added SUBJ *synlist* to distinguish extr_vp from extr_s
; (since MSG no_msg doesn't work for "where is Kim the king", since msg is 
; added (too late) by hd_yesno_c rule).
; DPF 29-apr-07 - Added MOD *anti_list* to prevent [VP [VP [PP/X PP]]] where
; the PP undergoes this rule - while still allowing use of this rule for e.g.
; "Why is Kim in Berlin?". 
; DPF 02-jul-09 - Added HD-DTR..MC na to VP variant, to exclude spurious 
; extraction from filler-head dtr, such as "which arrive".
; DPF 2010-sept-08 - Added SLASH..MIN nondir_or_adv_rel to
; ensure that when the adjunct is extracted, it is not interpreted as
; directional.

extracted_adj_int_vp_phrase := extracted_adj_int_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ AUX -,
				  MOD *anti_list* ],
			   VAL.SUBJ *synlist*,
			   POSTHD + ],
		     CONT [ HOOK.XARG individual ] ],
	     NONLOC.SLASH.LIST.FIRST.CAT.HEAD 
		   [ MINORS.MIN nondir_or_adv_rel,
		     MOD < [ LOCAL.CAT.VAL.SPR #spr ] > ] ],
    HD-DTR.SYNSEM.LOCAL.CAT [ MC na,
			      VAL.SPR #spr ] ].

;; DPF 20-oct-09 - Cannot recall why this rule is needed, so try excluding it
;; DPF 20-mar-10 - Well, grasshopper, it's what we use for "when is he Kim?"
;; where "is he Kim" blocks ordinary adjunction extraction.  But let's try
;; to tame it by restricting hd-dtr to MC na, and to --MIN be_v_id_rel, then
;; generalize if we see need.
;; DPF 2011-05-01- Another needed variant of this rule is for extraction from
;; a conjoined S, where we can't do across-the-board extraction (since
;; semantics would force unification of the two S's events into the ARG1 or
;; the modifier).
;; DPF 2017-11-06 - Re 20-mar-10: we also need this rule for "where are there 
;; cats?", so generalize --MIN to be_v_there-or-id_rel.
;; DPF 2020-04-30 - And include be_v_nv_rel as another subtype of 
;; be_v_there-or-id_rel, so we get |how is it that it hasn't rained yet?|
;;
extracted_adj_int_s_phrase := extracted_adj_int_phrase &
  [ SYNSEM.NONLOC.SLASH.LIST.FIRST.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR #spr ] >,
    HD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & 
				   [ INV +,
				     PRD -,
				     MOD *anti_list*,
				     MINORS [ MIN be_v_there-or-id_rel,
					      ALTMIN nonpass_or_aux_rel ] ],
			      MC na,
                              VAL [ SUBJ < anti_synsem_min >,
				    SPR #spr ] ] ].

;; DPF 2014-04-26 - To avoid applying this rule to a nonconjoined S with a 
;; conjoined VP, take advantage of XARG being unbound for conjoined Ss.
;; 
extracted_adj_coord_s_phrase := extracted_adj_int_phrase &
  [ SYNSEM.NONLOC.SLASH.LIST.FIRST.CAT.HEAD.MOD 
					< [ LOCAL.CAT.VAL.SPR *anti_cons* ] >,
    HD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb & [ MOD *anti_list*,
					      VFORM fin,
					      MINORS.NORM no_rel ],
				VAL [ SUBJ < anti_synsem_min >,
				      SPR < > ] ],
			  CONT.HOOK [ INDEX conj_event,
				      XARG unbound-ind ] ] ].

;;
;; Bare plural and mass NPs, distinguished by the INDEX feature [ DIV + ]
;;
; DPF 9-Sept-99 - Changed head-dtr's SPR to be canonical_synsem rather than
; non_canonical.  Don't know why it was that way, but it was allowing e.g. the
; proper noun 'Tuesday' to undergo this rule.
; DPF 17-Mar-01 - Since the choice of bare-np rule is determined by the value
; of DIV on the dtr, this needs to be a strict sort; but a bare-np must
; be able to conjoin with another NP of a different DIV value, so we
; make these not be headed phrases (which identify AGR on mother and head-dtr).
; DPF 6-Apr-01 - Given that we now pump all optional nominal complements, this
; rule now requires the n-bar dtr to also be COMPS < >.
; DPF 22-May-01 - Instead of making mother nonpronominal_synsem (which 
; incorrectly claims all bare NPs are [LEX +]), make mother's MIN nonpro_rel.
; Then make LEX value propagate from dtr to mother.
; DPF 25-Sep-01 - From 17-Mar: Having broken link for AGR of dtr and mother,
; DPF 20-Nov-01 - Moved identification of MODIFD down to the non-proper-name
; subtypes, in order to allow "My friend Mister Abrams" as an appositive.
; DPF 25-Nov-01 - Changed dtr's HEAD from noun to noun_or_nomger to allow e.g.
; "Processing of requests is important"
; DPF 19-Oct-02 - Moved ALTMIN to subtypes, to allow num-nps to differ.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 23-oct-03 - Added LPERIPH na_or_+ to dtr to enable blocking of bare-np
; for e.g. "miles an hour" as in "*Kim ran miles an hour".
; DPF 03-dec-03 - But this also blocks "I have time" - not true that the
; candidates for bare-np are same as those for np_adv_c rule.  So undo this
; constraint.  Anyway, above bad example is probably duu to measure-NP that
; should (somehow) be blocked for same reason as "*this string is foot long".
; DPF 14-dec-03 - Removed [ SLASH 0-dlist ] from dtr, since it prevented
; "who did you have pictures of"
; DPF 04-mar-06 - Removed reentrancy of LEX on dtr and mother - need to stamp
; LEX - on mother for hdn_bnp-num_c.  So move down to norm_bare_np.
; DPF 31-mar-08 - Maybe don't want XARG constrained on daughter.  FIX.
; DPF 21-may-09 - Changed mother's SYNSEM from synsem to 
; nonlex_or_lex_phr_synsem so we can distinguish these constructions from
; lexical items.
; DPF 25-may-09 - Added propagation of INFLECTD from dtr to mother, in part
; to block "[Kim and many] gems"
; DPF 26-jun-09 - Re 04-mar-06: Try again to identify LEX on dtr and mother,
; to avoid |US$ 10 billion in revenues| as cmpnd.
;; DPF 2017-05-20 - Detless PP nominals cannot simply identify the HEAD value
;; of mother and dtr, since we want e.g. |at last count| where |last| requires
;; its MOD value to have an explicit quantifier, but we want the mother to be
;; ALTMIN implicit_q_rel.  So remove the identity here, and push down to the
;; other subtypes.
;; DPF 2017-09-05 - Moved identity of PNG on mother and dtr down to subtypes,
;; so the rule for bare predicatives (|Kim is president|) can override the
;; idiosyncratic AGR.PNG 3p constraint on its dtr.
;; DPF 2017-09-12 - Removed identity of C-CONT..XARG and dtr's LTOP, since we
;; now have a bare-NP pumping rule for e.g. |someone who arose| allowing us to
;; attach the post-modifier while the hd-dtr's LTOP is still tied to the main
;; predication's LBL.  This XARG constraint was clashing with use of XARG as
;; index-valued for mal-rule for |?Kim arrives last year|, since having
;; |Saturday| be handle-valued now blocked |Kim arrived Saturday|.  Keep an
;; eye out for other constructions where this [XARG handle] might be used. FIX?
;; DPF 2020-05-09 - Move SPCMPS < > down to subtype, so we can use a non-empty
;; value to prevent detlesspp-NPs from appearing in NP coord structures. Hack,
;; but not clear how else to block.  FIX someday.
;;
basic_generic_bare_np_phrase := basic_unary_phrase &
  [ INFLECTD #infl,
    SYNSEM nonlex_or_lex_phr_synsem &
           [ LOCAL [ CAT [ HC-LEX #hclex,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < synsem_min &
				       [ --MIN just_only_deg_rel,
                                         LOCAL [ CAT [ HEAD adv,
						       VAL.SPR *unexplist* ],
                                                 CONT.HOOK.LTOP #splbl ],
                                         OPT + ] > ],
                           MC na,
			   NEGPOL - ],
                     AGR ref-ind,
                     CONJ #conj,
		     CTXT #ctxt ],
             NONLOC #nonloc,
	     LEX #lex,
             MODIFD.RPERIPH +,
	     PUNCT #punct ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM 
             [ LOCAL [ CAT [ HEAD noun_or_nomger,
                             HC-LEX #hclex,
                             VAL [ SUBJ *olist*,
                                   COMPS < >,
                                   SPR.FIRST [ LOCAL [ CAT.HEAD det,
						       CONT.HOOK.LTOP #splbl ],
					       NONLOC [ SLASH 0-dlist,
							REL 0-dlist,
							QUE 0-dlist ] ] ] ],
                       CONJ #conj & cnil,
                       CONT [ HOOK [ LTOP #nhand,
                                     INDEX #index ] ],
		       CTXT #ctxt ],
               LEX #lex,				     
               NONLOC #nonloc,
               PUNCT #punct & 
		     [ LPUNCT lital_or_pair_or_comma_or_no_punct ] ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ INDEX #index ],
             RELS <! [ LBL #splbl,
                       PRED quant_rel,
                       ARG0 #index,
                       RSTR #rhand,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq &
		     [ HARG #rhand,
		       LARG #nhand ] !>,
	     ICONS <! !> ] ].

; CSY 29-12-2020 try removing [ SYNSEM.LOCAL.CAT.VAL.SPCMPS < > ] so that singular nouns can also 
; become bare NPs
generic_bare_np_phrase := basic_generic_bare_np_phrase.
;  [ SYNSEM.LOCAL.CAT.VAL.SPCMPS < > ].

; DPF 21-sept-04 - Changed ARGS..SPR canonical_synsem to unexpressed_reg
; in order to prevent bare-nps where the determiner is obligatory, as in
; 'those five chairs' to avoid spurious ambiguity with the determiner 'five'

norm_bare_np_phrase := generic_bare_np_phrase &
  [ SYNSEM nonlex_synsem &
	   [ LOCAL.CAT [ HEAD #head & [ MINORS.MIN nonpro_rel ],
			 VAL.SPEC < anti_synsem_min > ],
	     LEX #lex ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD #head,
				  VAL.SPR.FIRST unexpressed_reg ],
		      LEX #lex ] ] > ].

; DPF 19-Oct-02 - Changed SPR..MIN from udef_q_rel to abstr_def_or_udef_q_rel
; to also allow "afternoons" using (necessarily) the 'afternoon' with an
; optional PP-of and a usually obligatory definite determiner (to get the
; contrast between "on the afternoon of the fifth" but "in the afternoon"

reg_bare_np_phrase := norm_bare_np_phrase &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.ALTMIN implicit_q_rel,
			   VAL.SPR < synsem > ],
		     AGR.DIV #div ],
             MODIFD #modif ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ AGR.DIV #div,
                              CAT.VAL.SPR.FIRST synsem &
					    [ --MIN abstr_def_or_udef_q_rel ]],
		      MODIFD #modif ] ] >,
    C-CONT.RELS <! [ PRED udef_q_rel, ARG0 ref-ind ] !> ].

; DPF 19-mar-06 - Divided bare_np_phrase into two, one for nouns and
; another for nominal gerunds, so we can restrict the gerunds to phrasal
; ones, to reduce the unwanted ambiguity for eg 'Singing is fun'.
; DPF 23-may-07 - But this restriction is unfortunate in two ways: (1) it
; prevents e.g. "Hiring is fun" since the verbal gerund LR preserves the
; non-optionality of the verb's NP complement; (2) it prevents N-N compounds
; like "bell ringing is fun" where the N-N compound rule carefully excludes
; verbal gerunds as heads.  So we remove this constraint and merge these 
; two rules again.

;bare_np_phrase := reg_bare_np_phrase &
;  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD basic_noun ] > ].
;
;bare_nomger_phrase := reg_bare_np_phrase &
;  [ ARGS < [ SYNSEM nonlex_synsem & [ LOCAL.CAT.HEAD nomger ] ] > ].
;;
;; DPF 2017-10-07 - If this rule only constrains AGR.DIV, we can't block
;; group or classifier nouns such as |pair of shoes|, which have a mismatch of
;; AGR and INDEX features.  So it's tempting to also require INDEX.DIV + on dtr,
;; but we want to use this rule for measure NPs such as |a dollar| as well, and
;; this phrase is INDEX.DIV - because of the lexical semantics of singular 
;; `dollar'.  So instead require SPR..DIV +, compatible with measure NPs and 
;; |pairs of shoes| but not |pair of shoes|.
;;
bare_np_phrase := reg_bare_np_phrase &
  [ SYNSEM.LOCAL.AGR #agr & [ DIV + ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD noun_or_nomger,
				    VAL.SPR [ FIRST [ OPT -,
						      LOCAL.AGR.DIV + ],
					      REST *olist* ] ],
			      AGR #agr ] ] ] > ].

;; DPF 2012-11-14 - Added INDEX.DIV - to mother to prevent `group' nouns
;; (which are underspecified for AGR) from spuriously using this rule.
;; DPF 2020-04-14 - Restrict ARGS..MIN to norm_nom_rel to exclude foreign-word
;; tokens
;; 
bare_np_prd_phrase := reg_bare_np_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRD +,
		   CONT.HOOK.INDEX.DIV -,
		   AGR [ PNG.PN 3s,
			 DIV - ] ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun & [ CASE nom,
						MINORS.MIN norm_nom_rel ],
				  VAL.SPR.FIRST unexpressed_reg ],
			    CONT.HOOK.INDEX nonconj_ref-ind & [ PNG #png ],
			    AGR.PNG #png & [ PN 3p ] ] ] > ].


; DPF 23-Nov-01 - Added SPR..MIN udef_q_rel to block hdn_np-num_c as input.
; DPF 2-Jun-02 - Added ARGS..MIN non_temp_nom_rel to exclude temporal nouns.
; DPF 31-aug-07 - Tried excluding prenominal adjectives.  But this loses too
; much coverage (e.g. "replace original fuse"), so live with extra ambiguity.
; DPF 19-sept-07 - Removed constraint that dtr's INDEX be nonconj_ref-ind,
; since this blocked e.g. "chase cat and dog.
; DPF 19-sept-07 - Replaced dtr's MIN non_temp_nbar_rel with MIN nom_nbar_rel
; so we get measure nouns like "meter" to go through this rule.  To avoid
; partitives (at least), the SPR..--MIN constraint should suffice.
;; DPF 2017-10-06 - Removed ALTMIN udef_q_rel since this prevents robust 
;; treatment where nominal dtr wants missing explicit quant.
;; DPF 2018-02-16 - The feature --BARE constrains whether a head can undergo
;; this rule, and --BARED records on the mother that the rule applied.  Needed
;; for example in NP coordination, where we don't want a spurious ambiguity for
;; |the dogs and cats|, so make right conjunct --BARED -.
;; DPF 2018-10-01 - Re 2-Jun-02: But this prevents robust analysis of e.g.
;; |we stayed for many month|.  So undo and monitor.
;; DPF 2019-05-19 - Removed ALTMIN implicit_q_rel since we want this rule for
;; e.g. |we arrive on 5th of February| where dofm "5th" requires explicit SPR.
;; Check for unwanted effects.
;; DPF 2019-08-26 - Remove PN 3s, DIV - from mother, so we can also get 
;; |cat arrive| where the verb's morphology is already correct.
;;
basic_bare_np_sg_phrase_robust := generic_bare_np_phrase &
  [ SYNSEM [ LOCAL.CAT.HEAD #head & [ MINORS.MIN non_proper_rel,
				      --BARE +,
				      --BARED + ],
             MODIFD #modif ],
    ARGS < [ SYNSEM 
	     [ LOCAL [ AGR [ DIV -,
			     PNG.PN 3s ],
		       CAT [ VAL.SPR < synsem &
				       [ OPT -,
		                         LOCAL.CAT.HEAD.POSS - ] >,
			     HEAD #head ] ],
	       MODIFD #modif & [ LPERIPH na_or_- ] ],
	     INFLECTD + ] >,
    C-CONT.RELS <! [ PRED def_udef_a_q_rel, ARG0 ref-ind ] !>,
    GENRE robust ].

bare_np_sg_phrase_robust := basic_bare_np_sg_phrase_robust &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN udef_q_rel ].

; DPF 8-Mar-01 - Removed [MODIFD notmod_or_lmod] from head-dtr, since it
; prevented "Tuesday at five" as an NP.
; DPF 17-Mar-01 - But then put it back, since we have to block e.g.
; "*I met Abrams you hired".  So will look for another analysis of above.
; DPF 25-Mar-01 - Removed it again, in favor of constraint on SPR in full relcl
; rule which blocks it from feeding this rule.
; DPF 24-Jun-01 - Removed ARGS..DIV - since need to identify AGR of
; dtr and mother to get semantics right, and need mother to be DIV -*,
; and don't know what that constraint was blocking anyway.
; DPF 10-Apr-02 - Changed ALTMIN from basic_nom_rel to implicit_q_rel so
; these can appear in np-n compounds like "Kim Browne"
; DPF 27-Oct-02 - Re: 24-Jun-01 - Well, it blocked the spurious analysis of 
; plural proper names like in "on Fridays", where the bare-plural rule already
; supplies the desired analysis.  This is another case where our use of
; overspecification for coordination goes wrong, since we want the daughter to
; be really [DIV -] (alternatively, really [PN 3s]) but we want the
; mother to be able to coordinate with unlikes, and yet we need the AGR
; reentrancy (really the INDEX reentrancy) for the semantics.
; DPF 8-May-03 - Added identity of MODIFD on mother and daughter (like most
; of the other bare_np_phrase types, here to avoid "afternoon Monday" as a
; temporal modifier.
; DPF 5-Sep-03 - Added ARGS..INDEX nonconj_ref-ind to prevent conjoined n-bars 
; like 'Kim and Sandy' to avoid spurious ambiguity.
; DPF 06-mar-06 - Propagate LEX from dtr to mother - needed to block '*the
; Paris to a city in Italy tour'
; DPF 31-jul-06 - Split into two, one for non-conjoined proper names, which
; may or may not be modified, and one for conjoined names, which must be
; modified (in order to avoid spurious ambiguity for e.g. "Kim and Pat arose.")
; DPF 02-nov-08 - Re 31-jul-06: Can't see when this rule would be needed, 
; since should always be possible to pump the proper name conjuncts before
; coordinating.  So comment out for now.
; DPF 30-nov-09 - Also constrain dtr's INDEX to be nonconj, to block e.g.
; "Kim and tree disappeared."

proper_np_phrase := norm_bare_np_phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT.HEAD.PRD #infl,
                     AGR #agr & [ DIV -,
				  PNG.PN 3s ] ],
             MODIFD #modif ],
    ARGS < [ INFLECTD #infl,
             SYNSEM 
             [ LOCAL [ CAT [ HEAD.MINORS.MIN abstr_named_np_rel,
                             VAL.SPR < [ --MIN proper_q_rel,
					 OPT - ] > ],
		       CONT.HOOK.INDEX nonconj_ref-ind,
                       AGR #agr ],
               MODIFD #modif ] ] >,
    C-CONT.RELS <! [ PRED proper_q_rel ] !> ].
                      
; DPF 22-May-02 - Split proper_np_phrase into two, one for non-numbers and
; one for numbers, so we can constrain the latter to be unmodified, in order
; to block "*Toshiba 2000 is here" but allow "I visited sunny Pittsburgh"
; DPF 30-May-02 - But this also blocked "order (number) fifty".  So instead
; only require [MODIFD.LPERIPH -], since titles don't affect LPERIPH, but
; adjectives and n-n-compounds do.
; DPF 19-Oct-02 - Added ALTMIN never_unify_rel to prevent these guys from
; appearing in np_n_cmpnds.
; DPF 4-Feb-02 - Changed this never_unify_rel to number_q_rel to still keep
; them out of np_n_cmpnds, but allow them in measure phrases.
; DPF 25-May-03 - Since num-nouns now LPERIPH + again, remove constraint from
; ARGS, and see what has to be done to avoid overgeneration of "Toshiba 2000"
; DPF 31-jul-06 - Split into two, like for proper names: either non-conjoined
; or modified when conjoined.
; DPF 12-may-08 - Made mother be INFLECTD + rather than bool, to prevent 
; these in NP-N compound "2 cats" (no record of why the strange 'bool' value).
; Note that cannot stamp these as LEX + to block that spurious compound,
; since these num-nps would not then be able to construct num-sequence phrases
; DPF 04-aug-08 - Re 12-may-08: This phrase is INFLECTD bool in order to
; get these phrases in NP-N compounds like "class 2 drugs".  So identify the
; INFLECTD feature on mother and head-dtr, allowing us to still block
; compound "2 cats" because "2" is INFLECTD + while "number 2" is not.
; DPF 02-nov-08 - Re 31-jul-06: Can't see when this rule would be needed, 
; since should always be possible to pump the number conjuncts before
; coordinating.  So comment out for now.
; DPF 25-may-09 - Re 12-may-08 ff: Moved identity of INFLECTD up to parent
; type - see if there's trouble.
; DPF 30-mar-10 - Don't recall why dtr's SPR is canonical_synsem, but this
; makes it not possible in prescriptive mode to require that it be
; unexpressed, so move this constraint to constructions.tdl for now.  But
; should understand it better - FIX.
;; DPF 2017-12-09 - Changed ARGS..LPERIPH from na_or_+ to na_or_-
;;
num_np_phrase := generic_bare_np_phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT [ HEAD #head & [ MINORS.ALTMIN number_q_rel ],
                           VAL.SPEC < anti_synsem_min > ],
                     AGR #agr & [ DIV - ] ],
             MODIFD #mod,
	     PHON #phon ],
    ARGS < [ INFLECTD #infl,
             SYNSEM [ LOCAL [ CAT [ HEAD #head &
				       [ MINORS.MIN named_num_or_fract_rel ],
				    VAL.SPR < [ --MIN number_q_rel,
						OPT -,
						LEX - ] > ],
                              AGR #agr ],
                      MODIFD #mod & [ LPERIPH na_or_- ],
		      PHON #phon ] ] >,
    C-CONT.RELS <! [ PRED number_q_rel ] !> ].

num_np_noconj := num_np_phrase &
  [ ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX nonconj_ref-ind ] > ].

; For nominal phrases which already contain a quantifier but can still be
; modified intersectively, including partitives like "some in Paris", 
; pronouns ("we in Berlin"), and nouns like "here" and "now". Since the
; LTOP of the dtr must be the label of the implicit nominal relation to 
; allow for intersective modifiers, but the LTOP of the full NP must be 
; unbound to allow for normal quantifier scoping, this rule makes the LTOP 
; unbound and cancels the SPR list.
; DPF 25-may-09 - Added propagation of INFLECTD from dtr to mother, in part
; to block "[Kim and many] gems"
;; DPF 2016-07-03 - NEGPOL was being stamped with value - on mother, but this
;; removes the distinction between |any of the cats| and |all of the cats|.  So
;; preserve from daughter to mother, and let's if something goes amiss.
;;
bare_npq_phrase := basic_unary_phrase &
  [ INFLECTD #infl,
    SYNSEM synsem &
           [ LOCAL [ CAT [ HEAD #head,
                           HC-LEX #hclex,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < synsem_min &
				       [ --MIN just_only_deg_rel,
                                         LOCAL [ CAT [ HEAD adv,
						       VAL.SPR *unexplist* ],
                                                 CONT.HOOK.LTOP #ltop ],
                                         OPT + ] >,
				 SPCMPS < > ],
                           MC na,
			   NEGPOL #negpol ],
                     AGR ref-ind &
                         [ PNG #png,
			   DIV #div ],
                     CONJ #conj ],
             NONLOC #nonloc,
	     LEX #lex,
             MODIFD #modif & [ RPERIPH + ],
	     PUNCT #punct ],
    ARGS < [ INFLECTD #infl,
	     SYNSEM 
             [ LOCAL [ CAT [ HEAD #head & partn,
                             HC-LEX #hclex,
                             VAL [ SUBJ *olist*,
                                   COMPS < >,
                                   SPR < unexpressed &
					 [ LOCAL.CONT.HOOK.LTOP #ltop,
					   NONLOC.QUE 0-dlist,
					   OPT - ], ... > ],
			     NEGPOL #negpol ],
                       AGR [ PNG #png,
			     DIV #div ],
                       CONJ #conj & cnil,
                       CONT.HOOK [ INDEX #index,
				   XARG #xarg ] ],
               NONLOC #nonloc,
	       LEX #lex,
	       MODIFD #modif & [ RPERIPH na_or_+ ],
	       PUNCT #punct & [ LPUNCT lital_or_pair_or_comma_or_no_punct ]]] >,
    C-CONT [ HOOK [ INDEX #index,
		    XARG #xarg ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; For determinerless-PPs of three subtypes
; DPF 13-nov-05 - Try making these SPEC < >, so they won't combine with
; e.g. identity copula.
;; DPF 25-jun-10 - To avoid bare nouns as NP fragments, tried restricting them
;; to [CASE obliq] which is compatible with PPs, but not with np_frag rule.
;; But this fails for e.g. "take part" where CASE is acc.  So find another
;; way to block as NP fragments.
;; DPF 2017-05-16 - Re 13-nov-05: But this prevents analysis of 
;; |stock of record| with detless-PP |of record| since |of| requires its
;; complement to have a non-empty SPEC.  Happily, the identity copula also
;; blocks these bare NPs because the HEAD value is incompatible, so change
;; SPEC to < anti_synsem_min >.  This entails also changing np_non_trans_nb_verb
;; so its COMPS..SPEC matches.

detlesspp_np_phrase := basic_generic_bare_np_phrase &
  [ INFLECTD +,
    SYNSEM.LOCAL [ CAT [ HEAD noun_nonmob &
			    [ MINORS [ MIN #min & bare_nom_rel,
				       ALTMIN implicit_q_rel ],
			      MOD < >,
			      CASE non_nom,
			      --BARE + ],
			 VAL [ SPEC < anti_synsem_min >,
			       SPCMPS < anti_synsem_min > ] ],
		   AGR #agr ],
    ARGS < [ INFLECTD +,
             SYNSEM.LOCAL [ CAT [ HEAD noun_nonmob &
				     [ MINORS.MIN #min ],
				  VAL.SPR < [ OPT - ] > ],
			    AGR #agr ] ] >,
    C-CONT.RELS <! [ PRED idiom_q_i_rel, ARG0 ref-ind ] !> ].

; 'at eye level'
detlesspp_np_nmod_phrase := detlesspp_np_phrase &
  [ ARGS < [ SYNSEM lex_phr_synsem &
                    [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_nmod_rel,
                      MODIFD.LPERIPH na ] ] > ].
; 'at close range'
detlesspp_np_jmod_phrase := detlesspp_np_phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN bare_n_jmod_rel,
                      MODIFD lmod & [ LPERIPH bool ] ] ] > ].

; 'within range' (optional modifier not present)
; 'on top', 'of course' (no modifier allowed)
detlesspp_np_nomod_phrase := detlesspp_np_phrase &
  [ ARGS < [ SYNSEM lex_or_nonlex_synsem &
		    [ LOCAL.CAT.HEAD.MINORS.MIN bare_nom_rel,
                      MODIFD notmod & [ LPERIPH + ] ] ] > ].


; Verbal gerunds with no (possessive) specifier.
; DPF 12-May-00 Block extraction from gerund NPs.
; DPF 07-Jan-01 Allow "Me hiring Sandy impressed Kim" as well as "Hiring 
; Sandy impressed Kim" by removing constraint that head-dtr be SPR < >,
; but then block spurious analysis for "My hiring Sandy impressed Kim"
; by requiring the head-dtr to be ALTMIN no_rel (the head-spr rule makes
; the mother's ALTMIN the quant_rel).  Also, block spurious analysis for
; "me hiring Sandy impressed kim" (failing to undergo this rule and hence
; leaving an unbound variable for the gerund_rel), by making this rule's
; output be MSG no_msg, and (in lextypes.tdl and auxverbs.tdl) 
; requiring that subjects (only ever of finite verbs) be MSG no_msg.
; This means sentential subjects will have to undergo a non-branching
; rule to make nominative NPs, but this is at least defensible, since we
; need to get the nominative case from somewhere, to prevent them from
; appearing as, say, objects of prepositions.
; DPF 19-Feb-01 - We're getting spurious ambiguity for "Kim prefers sleeping"
; where both the verbal gerund and the nominal gerund produce an NP.  So let's
; try blocking the lexical verbal gerunds by making HD-DTR a phrase.
; DPF 23-Apr-01 - But while we are avoiding nominal gerunds of intransitives,
; we'll undo this block.
; DPF 30-May-01 - Removed head-dtr's non-empty SUBJ requirement, since we
; still need to supply a quantifier in the ACC subj constructions like
; "I resent you leaving early".
; DPF 22-May-02 - Made HD-DTR..COMPS < > rather than *olist*, to avoid
; spurious parse for e.g. "Abrams is interviewing" where hdn_optcmp_c applies.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 31-mar-08 - Maybe don't want XARG constrained on dtr.  FIX.
;; DPF 2015-03-17 - Removed HD-DTR..SPR < unexpressed_reg >, so this rule will
;; also apply to subjh variants as in |we approve of him admiring Kim|
;; Then in order to keep this rule from feeding itself, drop SUBJ reentrancy
;; and change from non-empty to empty list.
;; DPF 2017-11-19 - Re 2015-03-17: Constrain hd-dtr's ALTMIN to prevent this
;; rule from spuriously applying when the gerund has picked up a specifier
;; instead of a subject.
;; DPF 2017-12-16 - Added PUNCT norm_punctuation to prevent single lexical
;; participles (since we already get nominal gerund analysis), even if they
;; have undergone the optcomp rule.
;;
bare_vger_phrase := head_only & head_valence_phrase & phrasal &
  [ SYNSEM [ LOCAL.CAT [ VAL [ SUBJ < >,
			       SPR < >,
			       COMPS < >,
			       SPCMPS < > ],
			 MC na ],
	     PUNCT #punct ],
    HD-DTR 
         [ SYNSEM 
	   [ LOCAL [ CAT [ HEAD gerund & [ MINORS [ MIN gerund_rel,
						    ALTMIN no_rel ] ],
                           VAL [ SPR *cons* & 
				     [ FIRST.NONLOC non-local_none ],
				 SUBJ.FIRST [ OPT +,
					      NONLOC non-local_none ],
				 COMPS < > ],
                           MC na_or_- ],
		     CONJ cnil,
		     CONT.HOOK [ LTOP #hand,
                                 INDEX #index & [ DIV + ] ] ],
	     PUNCT #punct & norm_punctuation ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ INDEX #index & ref-ind,
                    XARG #hand ],
	     RELS <! [ PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #rhand,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! qeq &
		     [ HARG #rhand,
		       LARG #hand ] !>,
	     ICONS <! !> ] ].

; 'Whether (or not) Kim slept is not clear to Sandy"
;; DPF 11-Apr-02 -- Why is this rule needed, again?  It produces spurious
;; parses, as in "He thought about what she said."
;; DPF 28-Nov-02 - HOOK comes only from C-CONT
;; "it was [known to be true [that Abrams hired Browne]]".
;; DPF 06-May-04 - The above example would only get a free relative reading,
;; which is not the only one, as evidenced by "He thought about who she hired"
;; where there is no free-relative "who", and which we don't get without the
;; np_cp-wh rule.  We make it CASE obliq to avoid spurious parses for verbal
;; complements as in "he knew who arrived"
;; DPF 24-aug-04 - Moved ARGS..MODIFD notmod_or_rmod up to basic type
;; to prevent both WH and non-WH S's with pre-modifiers from being NPs, 
;; to exclude spurious analysis of ...
;; DPF 07-apr-08 - Re: 06-May-04 Changed to CASE nom_or_obliq so we can
;; still get these in subject position, as in "Who we hired surprised Kim."
;; DPF 08-apr-08 - Added NORM no_rel to prevent these as nonhds in appositives.
;; DPF 10-apr-08 - Added SUBJ < anti_synsem_min > to prevent as hd in 
;; hdn-np_app-pr_c.
;; DPF 20-mar-10 - Tried changing dtr's SUBJ from <> to *anti_list* to allow
;; whether-CP phrases, to admit e.g. "about whether Kim won".  But this
;; also wrongly admits non-WH topicalized clauses.  So instead make "whether"
;; have an empty SUBJ, so it projects clauses like other WH-clauses.
;; DPF 2016-10-27 - Re 07-apr-08: But this is still too restrictive, since
;; we want coordination of ordinary NP and WH-CP as in 
;; |we admire her and who she represents| (where the latter can't be a free
;; relative clause).  We might think to fiddle with CASE in a conjoined NP, but
;; we want them to agree on the dtrs, so can't just stamp result on mother.
;; Also can't use the hack of stamping OPT - on the mother's SUBJ, which could
;; work since ordinary transitive verbs require their complement to be SUBJ 
;; *olist*, and the NP-coord rule does not propagate SUBJ from each of the dtrs.
;; But prepositions also demand SUBJ *olist*, and so do predicative adjectives,
;; which would block |who won is clear| or |who won is in doubt|.
;; DPF 2016-12-10 - Re 20156-10-27: Finally added new SORT value type q-event
;; for this construction, and changed mother's SORT from basic-entity-or-event
;; to this q-event, so we can avoid the spurious ambiguity of |we know why 
;; he won| by constraining the complement of transitive verbs (but not of
;; prepositions), and we can also prevent these as NP fragments.
;; DPF 2020-08-13 - Removed ALTMIN udef_q_rel since it's not clear what it was
;; excluding, and it now blocks "half what we invested" where "half" requires
;; its NP comp to be explicit_q_rel to block "half rice" contrasted with
;; "half the rice".
;;
basic_np_cp_wh_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & 
                                [ MOD < >,
                                  MINORS [ MIN nominalize_rel,
					   NORM no_rel ],
				  CASE #case ],
                           VAL [ SUBJ < anti_synsem_min >,
                                 SPR < >,
                                 COMPS < >,
                                 SPEC < anti_synsem_min >,
				 SPCMPS < > ],
                           MC na ],
                     AGR.PNG.PN 3s,
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
	     PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verbal &
                                         [ VFORM fin_or_inf,
                                           TAM.MOOD ind_or_modal_subj,
					   CASE #case ],
                                    VAL [ COMPS < > ] ],
                              CONJ cnil,
                              CONT.HOOK [ LTOP #chand,
                                          INDEX.SF ques ] ],
                      NONLOC [ SLASH 0-dlist & [ LIST < > ],
                               QUE 0-dlist,
                               REL 0-dlist ],
                      MODIFD notmod_or_rmod,
                      LEX -,
		      PUNCT #punct ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ INDEX #index & ref-ind &
			  [ PNG.PN 3s,
			    SORT q-event ] ],
	     RELS <! [ PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #rhand,
		       CFROM #from, CTO #to ],
                      basic_diadic_nom_relation &
                    [ PRED nominalization_rel,
		      LBL #nhand,
                      ARG0 #index,
                      ARG1 #chand,
		      CFROM #from, CTO #to ] !>,
             HCONS <! qeq &
		     [ HARG #rhand,
		       LARG #nhand ] !>,
	     ICONS <! !> ] ].

np_cp_wh_phrase := basic_np_cp_wh_phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD [ INV -,
				       MINORS.NORM norm_rel ],
                                VAL.SUBJ < >,
                                MC - ] ] > ].

;; Non-WH CP subjects, which often alternate with expletive-it subject, where
;; the alternation could be analyzed as it-extraposition.  Here we assume that
;; any predicate with an expletive-it subject and a CP complement also has
;; a subcat without the CP and with an ordinary NP subject.  So we take an
;; ordinary finite VP and convert it via non-branching (syntactic) rule to a 
;; VP that wants a non-WH CP subject and adjusts its semantic linking so it 
;; takes the LTOP of that subject (rather than the INDEX) as its XARG.
;;
;; 'That Kim slept bothers sandy"
;;
;; DPF 22-apr-09 - Re-worked this analysis, so this rule now takes as its
;; dtr a VP/CP looking for an expletive-it subject, and simply discharges
;; the subject, producing an S/CP which is a suitable head for the normal
;; non-WH filler-head construction.  One benefit is that we now also get
;; "That Kim won, we think should be obvious."
;; Another benefit is that we no longer overgenerate anomalous CP subjects
;; as in "That Kim won slept"
;; DPF 2012-10-20 - Added MODIFD lmod to mother to prevent spurious ambig 
;; where a post-hd PP attaches to VP after this rule applies (as well as before)

cp_subj_phrase := head_only & phrasal & clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD #head,
			   VAL [ SUBJ < anti_synsem >,
				 SPR < >,
				 SPEC < >,
				 SPCMPS < > ] ],
		     AGR.PNG.PN 3s ],
	     MODIFD lmod,
	     NONLOC #nonloc,
	     PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & #head & 
					 [ VFORM fin,
					   TAM #tam,
					   --ADDIN [ ADDTAM #tam,
						     ADDPN #pn ] ],
                                    VAL [ SUBJ < unexpressed_reg &
                                                 [ LOCAL.CAT.HEAD noun,
						   --SIND it-ind,
						   OPT - ] >,
                                          COMPS < > ] ],
			      AGR.PNG.PN #pn,
                              CONJ cnil,
                              CONT.HOOK #hook ],
                      NONLOC #nonloc & 
 		        [ SLASH <! [ CAT [ HEAD comp &
						[ TAM.MOOD ind_or_modal_subj,
						  CASE nom,
						  MINORS.MIN non_ellipt_rel &
							verb_or_subord_rel],
					   VAL [ COMPS < > ] ],
				     CONT.HOOK.INDEX.SF prop-or-ques ] !>,
			  REL 0-dlist ],
		      PUNCT #punct ] ] >,
    C-CONT [ HOOK #hook,
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 13-may-09 - Restrict to infinitivals, as in 'To win is good.'
;; DPF 2012-10-20 - Added MODIFD lmod to prevent these VPs from undergoing
;; the extracted-adj rule and hadj_rule: spurious ambig.
;; DPF 2012-11-13 - Try constraining dtr to SLASH 0-dlist, to avoid a lot of
;; (unmotivated?) chart ambiguity.
;; DPF 2020-04-10 - Generalized AGR..PN 3s to just 3 since we also want
;; |to speak and to listen are important|.
;; DPF 2020-04-21 - Re 2020-04-10: Yes, well, we still want to block
;; |*to speak are important|, so propagate AGR from dtr to mother.  Sigh.
;; Also add LEX - to exclude just infinitival "to", as in 
;; 
;; 
;;
cp_subj_inf_phrase := head_only & phrasal &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ VAL [ SUBJ < synsem &
                           [ --MIN non_ellipt_rel,
                             LOCAL [ CAT [ HEAD comp & 
                                                [ VFORM bse_or_inf,
                                                  TAM.MOOD ind_or_modal_subj ],
                                           VAL.COMPS < > ],
                                     CONT.HOOK [ LTOP #sltop,
                                                 INDEX.SF prop-or-ques ],
				     AGR #agr ],
			     NONLOC.SLASH 0-dlist & [ LIST < > ], 
			     OPT - ] >,
                    SPR #spr,
                    COMPS < >,
                    SPEC < >,
		    SPCMPS < > ],
              POSTHD #ph ],
        AGR #agr & [ PNG.PN 3 & #pn ],
        CONJ cnil ],
      NONLOC #nonloc,
      MODIFD lmod &
	     [ LPERIPH +,
               RPERIPH + ],
      PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & 
                                         [ VFORM fin,
					   TAM #tam,
					   --ADDIN [ ADDTAM #tam,
						     ADDPN #pn ],
                                           MOD *anti_cons* ],
                                    VAL [ SUBJ < unexpressed_reg &
                                                 [ LOCAL.CAT.HEAD noun ] >,
                                          SPR #spr,
                                          COMPS < > ],
                                    POSTHD #ph ],
			      AGR.PNG.PN #pn,
                              CONJ cnil,
                              CONT.HOOK #hook & [ XARG #index ] ],
                      NONLOC #nonloc & [ REL 0-dlist,
					 SLASH 0-dlist ],
		      PUNCT #punct ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK #hook,
             RELS <! [ PRED udef_q_rel,
                       ARG0 #index & ref-ind,
                       RSTR #rhand,
		       CFROM #from, CTO #to ],
                      basic_diadic_nom_relation &
                    [ PRED nominalization_rel,
		      LBL #nhand,
                      ARG0 #index,
                      ARG1 #sltop,
		      CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !>,
	     ICONS <! !> ] ].

;; 
;; Noun-noun compounds
;;

; Make left member be [ COMPS < > ] to avoid spurious ambiguity since we have
; separate lexical entries to handle optional nominal complements.
; DPF (22-Oct-98) Can't do the above, since it's not true for most nouns, and
; also won't work for "two fifteen meeting" where the am_pm argument is not
; expressed, but can't be discharged by the optcomp rule.

; DPF (4-Mar-99) - Removed the gratuitous some_rel, which was wrong for
; proper name left members of N-N compounds, and also wrong for hour words like
; "a one o'clock meeting" since "one o'clock" already supplied a 
; def_implicit_q_rel of its own.
; Added [ ALTMIN no_rel ] to non-head-dtr to block partitives, deverbal nouns,
; and other unwanted NPs with complex lexical semantics.
; DPF 09-Jan-00 - Also added [ ALTMIN no_rel ] to head-dtr, to block adj-nouns
; from compounds, as in "*Devito five" (ignoring for now "the Jackson five").
; 23-Oct-00 - Dropped NONHD-DTR's [AGR 3sg] constraint in order to allow
; "auto and mortgage loans", as well as "systems analyst" - the constraint is
; not really AGR 3sg, but perhaps something like lexeme vs. inflected word,
; where the lexeme might be conjoined, or even lexically marked as if it were
; plural, but still not [INFLECTD +].
; DPF 18-Aug-01 - Instead of that failed [AGR 3sg] constraint, made the non-hd
; be [INDEX 3sg], since conjoined nominals do not constrain the INDEX value.
; This lets us get 'auto and mortgage loans' while still blocking 'cats hairs'
; 23-Oct-00 - Changed NONHD-DTR's constraint, removing 'pronominal_synsem'
; and instead making the MIN be nonpro_rel, in order to allow conjoined 
; lexical NPs such as "auto and mortgage loans", where the synsem of the phrase
; will not be a subtype of nonpronominal_synsem.
; 17-Nov-00 - Removed 0-dlist specification for head-dtr and mother for
; QUE and REL, since this blocked e.g. "Which state office did he seek"
; DPF 1-Mar-01 - Changed COMPS < > to < > on non-head, now that we are 
; pumping nouns with complements.
; DPF 5-Apr-01 - Moved [LPERIPH -] from here to the noun-noun subtype, to 
; continue to block "towel rusty rack" but allow "1998 annual report".
; DPF 12-mar-05 - Added MODIFD notmod to avoid spurious ambiguity of
; prenom adjective attachment.
; DPF 14-nov-05 - Added MODIFD notmod_or_lmod to nonhd-dtr as well.
;; DPF 2014-11-17 - Moved NH-DTR..MODIFD notmod_or_lmod down to subtypes, to 
;; allow the city-state rule to admit |IBM Corp., Texas|.
;; DPF 2015-03-27 - Added PT notpro to non-head dtr, to prevent unwanted
;; anaphor substitution when paraphrasing.
;; DPF 2017-08-20 - Moved binary_punct_phrase down to subtypes, since we want
;; the np_city_state rule to inherit from this type, but it can swallow the
;; rightmost comma, as in |Kim and the residents of Akron, Ohio, arrived| where
;; NP-coord doesn't want to see that final comma.
;;
basic_n_n_cmpnd_phr := head_final & head_compositional &
  [ SYNSEM [ LOCAL.CAT [ VAL #valence,
			 MC #mc ],
	     NONLOC [ SLASH #slash,
                      QUE #que,
                      REL #rel ] ],
    HD-DTR.SYNSEM synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN nonpro_or_num_rel,
			   VAL #valence,
			   MC #mc ],
		     CONJ cnil ],
	     NONLOC [ SLASH #slash,
		      QUE #que,
		      REL #rel ],
	     PUNCT.LPUNCT lparen_or_dq_or_comma_or_no_punct ],
    NH-DTR.SYNSEM 
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN nom_or_mnp_rel,
			   VAL.COMPS < > ],
		     CONT.HOOK.INDEX non_expl-ind & [ PT notpro ] ],
	     NONLOC [ SLASH 0-dlist & [ LIST < > ],
		      QUE 0-dlist,
		      REL 0-dlist ] ] ].

; DPF 13-nov-05 - Changed mother's LEX from + to bool, to allow these to
; conjoin with phrasal nbars.  Not clear what effects ...
; DPF 28-aug-07 - Changed NH-DTR..RPUNCT to exclude comma, since we don't
; want "the IBM, product code".
;; DPF 2017-12-16 - Let's try changing MODIFD from notmod to lmod on some
;; subtypes, so we can allow |the tall, ten-foot wall| with a comma, while 
;; blocking |the tall, wall| where the latter is via the adj_n_phrase which 
;; blocks comma on nh-dtr, while the former will use adj_adjn_phrase which 
;; allows a comma.
;;
n_n_cmpnd_phr := basic_n_n_cmpnd_phr & binary_punct_phrase &
  [ INFLECTD #infl,
    SYNSEM lex_phr_synsem &
	   [ LOCAL.CAT.HEAD.MOD *anti_list*,
             LEX bool,
             PUNCT.PNCTPR #ppair ],
    HD-DTR [ INFLECTD #infl,
	     SYNSEM [ LOCAL [ CAT [ HEAD  basic_nom_or_ttl &
					[ MINORS.MIN nonpro_rel ],
                                  VAL.SPR < synsem & 
                                            [ OPT -,
                                              --MIN quant_rel ] > ],
                            CONT.HOOK [ LTOP #ltop,
                                        INDEX #hind ] ],
		      PUNCT.PNCTPR #ppair,
		      MODIFD notmod_or_lmod ] ], 
    NH-DTR.SYNSEM [ LOCAL [ CAT.HEAD.--CPDNHD +,
                            CONT.HOOK.INDEX #modind ],
                    PUNCT.LPUNCT lital_or_pair_or_comma_or_no_punct,
		    MODIFD notmod_or_lmod ],
    ORTH [ FROM #from, TO #to ],
    C-CONT.RELS.LIST < prep_notense_relation &
                       [ LBL #ltop,
                         PRED compound_rel,
                         ARG1 #hind,
                         ARG2 #modind,
			 CFROM #from, CTO #to ], ... > ].

; DPF 22-Mar-01 - It seems we need LEX + on non-head-dtr to block "an exactly 
; seven appointment", since we want "a seven o'clock appointment".  But why did
; we move LEX + down from the n_n_cmpnd_phr in the first place?
; DPF 6-Apr-01 - Added LPERIPH na_or_- to head-dtr to block "Browne five 
; dollars" while still allowing "1998 annual report".
; DPF 17-Apr-01 - Added LPERIPH na to mother to block NNN-cmpnd for "a reason 
; Kim left"
; DPF 5-Sep-03 - Changed HD-DTR..ALTMIN no_rel to def_or_udef_q_rel
; since ALTMIN now inherits from head-dtr to mother, but we still want to
; block proper names, numbers, etc as head dtrs.
; DPF 5-Sep-03 - And changed NH-DTR..ALTMIN to proper_q_rel.
; DPF 25-Nov-03 - Changed NHD's LEX from + to na_or_+ to allow conjoined
; proper names while still blocking "an exactly seven appointment"
; DPF 10-dec-03 - Since numerals are now LPERIPH na (to block spurious parse
; for "two hundred three chairs" while allowing "two hundred big chairs"),
; make head-dtr be LPERIPH bool, to still block "Browne five chairs" but get
; "IBM annual report"
; Also added PRD - to NHD to prevent measure phrases here in currency "usd 10"
; DPF 10-dec-03 - Tried adding HD-DTR..ALTMIN def_or_udef_q_rel to prevent 
; proper names, to avoid spurious analysis for e.g. "Kim Abrams".  But this
; conflicts with the no_rel constraint on NHD for N-N-cmpnd rule, blocking one
; analysis for "CSLI department manager".  So try restricting H-DTR..MIN to
; nom_nbar_rel.
; DPF 19-mar-06 - Re DPF 17-Apr-01: But this also blocks "university IBM chair"
; so we remove LPERIPH bool on mother, and see if we can live with the ambig.
; DPF 09-aug-07 - Re 10-dec-03: If we exclude integers here, we can't get e.g.
; "the 101 freeway" or "a number 2 pencil".  But simply allowing any integer
; before any noun to produce a compound is too expensive in increased (usually
; spurious) ambiguity.  Note for further study on RESTRICTED AMBIGUITY.  For
; now, assume we'll add lexical proper names for e.g. highway names, and to
; block "6 cats" here, we make number_q_rel not be a subtype of
; impl_or_proper_q_rel.
; DPF 07-sep-07 - Relaxed HD-DTR..MIN from nom_nbar_rel to nbar_or_nger_rel
; to re-allow nominal gerunds as heads - we weren't getting e.g. "IBM hiring".
; DPF 12-may-08 - Re 09-aug-07: But we want "class 2 drugs" even though not
; "2 drugs" here.  So restore number_q_rel as subtype of impl_or_proper_q_rel,
; and make hdn_bnp-num_c rule stamp [LEX -] on mother, while NP-title rule does not.
; DPF 25-may-09 - Changed HD-DTR..LPERIPH from bool to - in order to block
; "Kim [other gems]"  
; Also constrain NH-DTR..SPR..HEAD to a_or_adv in order allow both
; "Chiang cat" and "hundred-mile road" but block spurious ambig for
; "Chiang cat" before "Chiang" discharges det specifier.
;; DPF 2012-08-25 - Re 25-may-09: But that constraint no longer works, and
;; sadly it blocks |the 2012 third quarter|.  So change back to [LPERIPH bool].
;; DPF 2015-05-06 - Since we want to analyze |The November 6 event| as an NP-N
;; compound, and since we want to keep INFLECTD + constraint on most rules,
;; including spr-hd (to avoid unwanted ambiguity), we have to change INFLECTD
;; (and PRD) values on non-hd dtr from - to +.  This will likely be expensive
;; in treebank updating, but I don't see a good alternative.  Also note the
;; original motive for [PRD -] from 10-dec-03 above, and check.
;; DPF 2017-12-09 - Changed HD-DTR..LPERIPH from bool to na_or_-, in order to
;; block |IBM more products|.
;; And changed NH-DTR..LPERIPH from + to bool
;;
basic_np_n_cmpnd_phr := n_n_cmpnd_phr &
  [ SYNSEM.MODIFD notmod,
    HD-DTR.SYNSEM abstr_lex_synsem &
                      [ LEX +,
                        LOCAL.CAT.HEAD.MINORS.MIN nbar_or_nger_rel,
                        MODIFD.LPERIPH na_or_- ],
    NH-DTR 
     [ INFLECTD +,
       SYNSEM [ LOCAL [ CAT [ HEAD basic_noun &
				   [ MINORS [ MIN named_or_meas_rel,
					      ALTMIN impl_or_proper_q_rel,
					      NORM norm_rel ] ],
			      VAL [ SUBJ < >,
				    SPR.FIRST [ LOCAL.CAT.HEAD a_or_adv,
						OPT + ] ] ] ],
		LEX +,
		MODIFD.LPERIPH bool ] ],
    C-CONT [ RELS <! relation !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

np_n_cmpnd_phr := basic_np_n_cmpnd_phr &
  [ NH-DTR.SYNSEM.PUNCT.RPUNCT hyphen_or_pair_or_no_punct ].

;; DPF 2012-08-25 - Admits |the Cupertino, Calif., company|
;; DPF 2020-03-29 - Removed NH-DTR..PNCTPR ppair since this blocked
;; |the November 8, 2019, cat|.  CHECK.
;;
np_n_cmpnd_pr_phr := basic_np_n_cmpnd_phr &
  [ NH-DTR.SYNSEM.PUNCT [ RPUNCT comma_punct ] ].

; For "Jim Smith"
; DPF 10-Apr-02 - Changed HD-DTR..MIN from named_np_rel to abstr_named_np_rel
; to allow number names, as in "Toshiba 3000" of "Toshiba 3000 laptop".  Also
; removed LEX + from HD-DTR for same reason.
; DPF 14-feb-04 - Removed MODIFD lmod since want these in appositive
; constructions.  
; DPF 17-oct-07 - Changed NH-DTR..MIN from reg_nom_rel to reg_or_temp_nom_rel
; in order to also allow temporal nouns, as in "day 6"
; DPF 31-mar-08 - Once we get rid of quantifiers for proper names and numbers,
; FIX XARG on hd-dtr.
; DPF 10-may-08 - Pushed identity of AGR.PNG.PN on two dtrs down to np_title,
; to allow "[Kim and John] Abrams".
; DPF 28-may-08 - But it's more complicated than this, since "Kim and John
; Browne" has to be plural: "Kim and John Browne arrive" - hard to do if the
; head is "Browne" which is inflected as singular.  Give this more thought,
; but in the meantime restore the AGR identity.
; DPF 26-jun-09 - Re 10-apr-02: But we now admit "Toshiba 3000" with a
; separate rule, and we want to block "Kim Browne who dances" as compound,
; so restore HD.DTR..LEX + on np_name_cmpnd_phr
; DPF 28-jun-09 - To avoid spurious analysis for e.g. |Abrams (2009)|,
; constrain hd-dtr's LPUNCT to dq_or_no_punct.
; DPF 23-mar-11 - Constrain NH-DTR to be unmodified, to avoid spurious
; ambiguity for |young Kim Abrams|
;; DPF 2011-aug-05 - Changed HD-DTR..MODIFD from notmod_or_rmod to notmod,
;; to avoid spurious analysis of |offer one of the ski tracks|
;; DPF 2012-mar-12 - Removed NH-DTR..SPR..HEAD det since we want to allow
;; both |Kim Browne| and |Kim and Pat Browne|, where our NP coord is already
;; constrained to have undergone the proper_np_rule.
;; DPF 2012-10-28 - Re 23-mar-11: But this must be pushed down to subtypes,
;; since we do want |federal judge Kim Abrams| with title construction.
;; DPF 2014-04-28 - Re 2011-aug-05: But this constraint needs to be pushed
;; down, since we want |parent General Electric Co.|.
;; DPF 2014-11-17 - Moved LEX + on NH-DTR down to subtypes, to allow the
;; city-state rule to admit |IBM Corp., Texas|.
;; DPF 2015-04-30 - Re 28-jun-09: But we now want to use this construction
;; for |paragraph (b)|, so let's accept the ambiguity for |Abrams (2000)|.
;; DPF 2017-09-15 - Pushed nh-dtr INFLECTD + down to subtypes, so we can get
;; |the three-month LIBOR| using the np-title compound where "month" is not 
;; inflected.
;; DPF 2020-05-15 - Pushed HD-DTR..MODIFD notmod_or_rmod down to subtypes, so
;; basic_np_title_cmpnd_phr can have hd-dtr be notmod_or_lmod.
;;		    
basic_np_name_cmpnd_phr := basic_n_n_cmpnd_phr &
  [ SYNSEM lex_phr_synsem & [ LOCAL.CAT.HEAD.MOD < > ],
    HD-DTR.SYNSEM 
           [ LOCAL [ CAT.HEAD noun,
                     CONT.HOOK.INDEX #ind ],
             NONLOC non-local_none ],
    NH-DTR [ SYNSEM.LOCAL [ CAT [ HEAD basic_noun &
				       [ MINORS.MIN reg_or_temp_nom_rel ],
				  VAL.SPR.FIRST [ NONLOC non-local ] ],
			    CONT.HOOK.INDEX #nhind ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS.LIST < prep_notense_relation & 
			 [ ARG1 #ind,
			   ARG2 #nhind,
			   CFROM #from, CTO #to ], ... > ] ].

;; DPF 2014-07-15 - Change link of cmpnd_rel's LBL to hd-dtr's LTOP, not XARG
;;
norm_np_name_cmpnd_phr := basic_np_name_cmpnd_phr &
  [ INFLECTD #infl,
    SYNSEM.MODIFD.LPERIPH #modlp,
    HD-DTR [ INFLECTD #infl,
	     SYNSEM [ LOCAL.CONT.HOOK.LTOP #nhand,
		      MODIFD notmod_or_rmod & [ LPERIPH #modlp ] ] ],
    NH-DTR [ INFLECTD +,
	     SYNSEM [ LOCAL.CAT.VAL.SPR < [ ] >,
		      MODIFD.LPERIPH + ] ],
    C-CONT.RELS.LIST.FIRST.LBL #nhand ].

;; DPF 2012-mar-12 - Removed surprising constraint on NH-DTR of AGR.PNG.PN 3s,
;; since we want to allow |[Kim and Pat] Browne|.
;; DPF 2014-01-23 - Changed NH-DTR..RPUNCT from the mysteriously permissive
;; quote_or_hyphen_or_clause_or_no_punct to quote_or_hyphen_or_no_punct, to
;; prevent e.g. |*Puebla? Mexico|.
;; DPF 2015-04-06 - Re 2014-01-23: And generalized to hyphen_or_pair_or_no_punct
;; for both LPUNCT and RPUNCT to get |(Eddie) Murphy|.
;; DPF 2020-04-29 - Try generalizing LPERIPH + to na_or_+, so we can have
;; adj-n constrain hd to be na_or_- and still get |tall Kim Browne|
;;
np_name_cmpnd_phr := norm_np_name_cmpnd_phr & binary_punct_phrase &
  [ SYNSEM [ PUNCT.PNCTPR #ppair,
             MODIFD notmod ],
    HD-DTR.SYNSEM [ MODIFD notmod & [ LPERIPH na_or_+ ],
		    LOCAL [ CAT [ HEAD.MINORS.MIN named_np_or_num_rel,
				  VAL.SPR < [ OPT - ] > ],
			    CONT.HOOK.LTOP #hdltop ],
		    PUNCT.PNCTPR #ppair,		    
		    LEX + ],
    NH-DTR.SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN named_np_rel,
					      NORM norm_rel ],
				VAL.SPR.FIRST.LOCAL.CAT.HEAD adv ],
		    MODIFD notmod,
		    LEX +,
		    PUNCT [ LPUNCT hyphen_or_pair_or_no_punct,
		            RPUNCT hyphen_or_pair_or_no_punct ] ],
    C-CONT [ RELS <! [ PRED compound_rel,
		       LBL #hdltop ]!>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 24-apr-09 - Added NORM no_rel to nh-dtr, to block eg. 'single crystal'
; DPF 24-may-09 - But this also blocks ordinary titles like |Dr.| or |Mr.|,
; and we still want to prevent these in ordinary compounds, so we'll live
; with 'single crystal', and return to NORM norm_rel, so we can still block
; 'hire Browne'
; DPF 04-sept-09 - Can't remember why HD-DTR..MIN was named_or_meas_rel
; but don't want e.g. "train next year", so change MIN back to named_rel
; DPF 2010-08-22 - Prevent title with Det-N proper NP, to block e.g.
; *|Mr. that Browne|
; DPF 2010-09-20 - Re 04-sept-09: But named_rel blocks "year 1997", so 
; generalize to abstr_named_np_rel, still excluding numbers as in "number ten"
; which are admitted by np_num_cmpnd_phr.
;; DPF 2012-06-14 - Added NH-DTR..SPR..OPT - to exclude spurious analysis for
;; e.g. |height around Paris|, even if |around Paris| were allowed as a hd dtr
;; admitted by hd-spr rule.  Also made HD-DTR..SPR be non-empty but [OPT +]
;; to block even the nbar-hd analysis of |height around Paris| when the hd-dtr
;; has a degree specifier.
;; DPF 2015-09-20 - Sometime since 1214 the mother's LPERIPH got constrained
;; to na_or_-, but no record of why, and it blocks |the Mt Olympus cat|, so
;; remove, and let's see if we can notice why the constraint was added.
;; Generalized hd-dtr's MIN from abstr_named_np_rel to also allow
;; |phone 555 12 12|
;; DPF 2017-09-15 - Re 24-may-09: Generalized nh-dtr's NORM from norm_rel to
;; norm_or_quantity_rel so we can also get |the three-month LIBOR|.  Also
;; changed SPR from single-element to potentially longer list, to allow
;; measure phrases.
;; DPF 2018-06-10 - Move identity of HD-DTR..LTOP and NH-DTR's compound_rel
;; down to the singular subtype, so the plural variant for |Mssrs. Browne and 
;; Chiang| (which has NP coord for |Browne and Chiang|) does not expose the 
;; compound's LBL on the mother, a full NP.
;; DPF 2020-05-15 - Exclude MODIFD rmod on hd-dtr.
;; DPF 2020-05-20 - Removed NH-DTR..SPR.FIRST unexpressed, to get |20-stock MMI|
;; DPF 2020-05-21 - block day-of-month as in |25 50| via NH-DTR..HEAD non_partn
;;
basic_np_title_cmpnd_phr := basic_np_name_cmpnd_phr & binary_punct_phrase &
  [ INFLECTD +,
    SYNSEM [ PUNCT.PNCTPR #ppair,
	     MODIFD hasmod ],
    HD-DTR [ INFLECTD +,
	     SYNSEM [ LOCAL.CAT.HEAD.MINORS.MIN numseq_or_named_rel,
		      PUNCT.PNCTPR #ppair,
		      MODIFD notmod_or_lmod & [ LPERIPH na_or_+ ] ] ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD non_partn &
					 [ MINORS 
					   [ MIN gen_nom_nbar_rel,
					     ALTMIN udef_or_proper_q_rel,
					     NORM quantity_or_norm_rel ] ],
				    VAL.SPR.FIRST.OPT - ],
			      CONT.HOOK [ LTOP #nhltop,
					  INDEX #nhind ] ],
		      MODIFD notmod_or_lmod,
                      LEX +,
		      PUNCT [ LPUNCT dq_or_sq_or_no_punct,
			      RPUNCT quote_or_hyphen_or_no_punct ] ],
	     ORTH [ FROM #from2, TO #to2 ] ],
    C-CONT [ RELS <! [ PRED compound_rel ],
		     [ PRED udef_q_rel,
		       ARG0 #nhind & overt_non_expl-ind,
		       RSTR #rhand,
		       CFROM #from2, CTO #to2 ] !>,
	     HCONS <! qeq & [ HARG #rhand,
                              LARG #nhltop ] !>,
	     ICONS <! !> ] ].

;; DPF 2020-05-20 - Removed identity of AGR..PN on two dtrs, since we want to
;; admit |20-stock MMI|.  Also constrain NH-DTR to LOCAL noninfl_noun_local to 
;; prevent title analysis for |next September|.  Can't make HD-DTR AGR..PN 3s 
;; because we need this rule for e.g. |twin-deficit Keynesians| with plural 
;; generic PN.
;;
np_title_cmpnd_phr := basic_np_title_cmpnd_phr &
  [ HD-DTR.SYNSEM [ LOCAL [ CAT.VAL.SPR < [ OPT - ] >,
			    CONT.HOOK.LTOP #lbl ],
		    MODIFD.LPERIPH + ],
    NH-DTR [ INFLECTD na_or_-,
	     SYNSEM.LOCAL noninfl_noun_local &
		          [ CONT.HOOK.INDEX nonconj_ref-ind ] ],
    C-CONT.RELS.LIST.FIRST.LBL #lbl ].

;; DPF 2012-10-01 - Special case for plural NPs as in |Mssrs. Abrams and Browne|
;; needed because we exclude nbar-coord of proper names (to avoid spurious
;; ambiguity), and yet we want ordinary title-noun constructions to have nbar
;; heads, in order to allow e.g. |your Mr. Browne|
;; DPF 2017-11-17 - It seems that we also need to allow the other variant, as
;; in |Mr. and Mrs. Jones|, where the nh-dtr is necessarily INFLECTD + (since
;; noun-coord insists on it to avoid spurious ambig), but the hd-dtr is
;; singular.  Hence tried leaving the hd-dtr unmarked for number, and pushed
;; down the supertype's constraint identifying PN on the two dtrs.  But alas,
;; note that all headed phrases identify AGR of mother and hd-dtr, so we would
;; have to make a more radical change here to treat titles as heads, in order
;; to predict the plural number on |Mr. and Mrs. Jones|.  FIX, so we can
;; get subj-verb agreement right here.
;; DPF 2020-03-24 - Don't want HD-DTR..PN 3p as was in trunk, since this blocks
;; |Mr. and Mrs. Browne| where |Browne| is singular.
;; Removed recently added NH-DTR..DIV + since |Mr. and Mrs.| is DIV -
;;
np_title_cmpnd_pl_phr := basic_np_title_cmpnd_phr &
  [ HD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR *olist*,
			  CONT.HOOK.XARG #lbl ],
    NH-DTR [ INFLECTD +,
	     SYNSEM.LOCAL.AGR.PNG.PN 3p ],
    C-CONT.RELS.LIST.FIRST.LBL #lbl ].

; DPF 04-nov-07 - This rule is distinct from the above so we can still avoid
; spurious parse for "Browne five chairs".  
; DPF 04-aug-08 - Also, this rule does not identify INFLECTD on mother and
; head dtr, so we can admit "the class 2 drugs" (where non-hd of compound
; headed by "drugs" unifies with INFLECTD - given this rule), but block
; n-n-compound for "2 drugs" in "the 2 drugs" because the num-noun "2" is
; INFLECTD +.
; DPF 02-jul-09 - Restrict NH-DTR..MIN to non_temp_nom_rel, to avoid spurious
; analysis for e.g. June 2000.
; DPF 2010-sep-26 - Changed HD-DTR..SPR *olist* to [OPT -] in order to 
; admit "My Nokia 500" while still avoiding spurious ambiguity.
;; DPF 2012-04-09 - Re 02-jul-09: But this is too strict, since it also blocks
;; |day one| or |week ten|.  And in principle, we should be able to get both
;; |Indy 500| and |June 500|, where the latter is the 500 race run in June.
;; So relax this constraint to MIN gen_nom_nbar_rel, and live with the
;; ambiguity.
;; DPF 2012-11-14 - Re 2012-04-09: But gen_nom_nbar_rel excludes proper names,
;; so that can't be right.  Let's try reg_or_temp_nom_rel.
;; DPF 2013-02-12 - Constrained HD-DTR's SPR to be HEAD det, to exclude
;; spurious analysis for |text to speech| where `to' wants a noun specifier.
;; DPF 2013-06-13 - Added [LPERIPH na_or_-] to hd-dtr, to block spurious
;; "NP to NP" interval phrase as right member, as in |October twenty to thirty|.
;; DPF 2014-04-03 - But this prevents "chapter 1", and anyway, we're not getting
;; that spurious reading at present, so removed constraint.
;; DPF 2017-12-17 - Changed NH-DTR..MODIFD from notmod to notmod_or_lmod, since
;; N-N compounds are now lmod, and we want this rule used for |[order #] 5|
;;
np_num_cmpnd_phr := basic_np_name_cmpnd_phr & binary_punct_phrase &
  [ SYNSEM [ PUNCT.PNCTPR #ppair,
             MODIFD notmod ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN named_num_or_seq_rel,
				  VAL [ SPR.FIRST [ OPT -,
				                    LOCAL.CAT.HEAD det ],
					COMPS < > ] ],
			    CONT.HOOK.LTOP #hdhand,
			    AGR.PNG.PN #pn ],
		    MODIFD notmod,
		    PUNCT.PNCTPR #ppair ],
    NH-DTR [ INFLECTD +,
	     SYNSEM [ LOCAL [ AGR.PNG.PN #pn,
			      CAT [ HEAD.MINORS [ MIN reg_or_temp_nom_rel,
						  NORM norm_rel ],
				    VAL.SPR < [ LOCAL.CAT.HEAD det ] > ],
			      CONT.HOOK [ LTOP #nhltop,
					  INDEX #nhind & [ IND + ] ] ],
		      MODIFD notmod_or_lmod & [ LPERIPH + ],
                      LEX +,
		      PUNCT [ LPUNCT dq_or_sq_or_no_punct,
			      RPUNCT quote_or_hyphen_or_no_punct ] ],
	     ORTH [ FROM #from2, TO #to2 ] ],
    C-CONT [ RELS <! [ PRED compound_rel,
			LBL #hdhand ],
		     [ PRED udef_q_rel,
		       ARG0 #nhind & overt_non_expl-ind,
                       RSTR #rhand,
		       CFROM #from2, CTO #to2 ]!>,
	     HCONS <! qeq & [ HARG #rhand,
                              LARG #nhltop ] !>,
	     ICONS <! !> ] ].

;; DPF 2014-05-13 - Generalize NH-DTR..MIN from named_city_rel to
;; named_np_or_num_rel, to admit e.g. |Bank One, Dover|
;; DPF 2015-05-04 - Added SORT basic_entity to exclude time expressions such
;; as yofc |2002| as nh-dtr.
;; DPF 2016-09-17 - Removed PNG.PN 3s on nh-dtr, since we want to also allow
;; |Sacramento and Modesto, California|
;; DPF 2017-08-20 - Pulled the PUNCT constraints down from basic_punct_synsem,
;; but not identifying PAIRED on mother and right dtr, since we want to also
;; admit |Kim and the people in Akron, Ohio, arose| where NP-coord does not
;; want to see the comma on Ohio.
;; DPF 2017-09-30 - Re 2015-05-04: But `time' sort is already distinct from
;; `entity', so changed basic_entity to entity.
;; DPF 2020-04-29 - Generalized HD-DTR.LPERIPH from + to na_or_+ to get
;; |rural Cupertino, California,|
;;
np_city_state_phr := norm_np_name_cmpnd_phr &
  [ SYNSEM [ MODIFD notmod,
	     PUNCT [ LPUNCT #lpunct,
		     RPUNCT #rpunct,
		     RCLSTR #rclstr ] ],
    HD-DTR.SYNSEM [ MODIFD notmod & [ LPERIPH na_or_+ ],
		    LOCAL [ CAT [ HEAD.MINORS.MIN named_np_or_num_rel,
				  VAL.SPR < [ OPT - ] > ],
			    CONT.HOOK.LTOP #hdltop ] ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS [ MIN named_np_or_num_rel,
						NORM norm_rel ],
				  VAL.SPR.FIRST.LOCAL.CAT.HEAD adv ],
			    CONT.HOOK.INDEX.SORT entity ],
		    MODIFD notmod_or_rmod,
                    PUNCT [ LPUNCT lparen_or_dq_or_comma_or_no_punct,
			    RPUNCT comma_punct ] ],
    C-CONT [ RELS <! [ PRED compound_rel,
		       LBL #hdltop ] !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpunct ],
           [ SYNSEM.PUNCT [ RPUNCT #rpunct,
                            RCLSTR #rclstr ] ] > ].

; DPF 24-Sept-01 - Made LPERIPH of mother be same as LPERIPH of non-hd, to 
; block e.g. "*The table important consultant chair arrives".
; DPF 2-Jul-02 - Go back to making NH-DTR..ALTMIN be no_rel to block
; spurious compound analysis for v-gerund for "hiring Sandy", and let's see
; why we wanted to remove it in the first place.
; DPF 9-Oct-02 - Removed [OPT -] from NH-DTR..VAL.SPR, since it prevented
; compounds like "three pm meeting", and it's not clear what it was needed for.
; DPF 08-May-03 - Identified MODIFD of mother and non-hd-dtr (see 24-Sept-01)
; to preserve notmod or lmod status of the left member (not just the PERIPH
; value).
; DPF 05-Sep-03 - Replaced NH-DTR..ALTMIN no_rel with 
; def_or_udef_q_rel, since no_rel not needed to block verbal gerunds
; anymore, but still want to prevent proper names, while also getting second
; parse for "CSLI department manager".
; DPF 10-dec-03 - But this doesn't block proper names, since their ALTMIN
; only gets specialized to proper_q_rel when made an NP.  So go back to no_rel.
; DPF 10-dec-03 - Made LPERIPH of NHD be bool to exclude possibly spurious 
; analysis for "the ten foot chair".  But this would make the rule not 
; right-recursive, preventing the less likely analysis of "the tobacco garden 
; dog".  So drop constraint on NHD..LPERIPH, and live with the ambiguity.
; DPF 14-dec-03 - Wonder about motivation for 08-May-03 change, since this
; now prevents Adj-N-N from being modified by a PP, as in "big league baseball
; in Pittsburgh".  FIX.
; DPF 29-aug-04 - Re: 08-May-03, but this blocks PP-modification of compounds
; where the non-head happens to be modified, as in "tenth century church in
; Paris".  So return to only identifying the LPERIPH values (see 24-Sept-01),
; and insist that compounds are still notmod
; DPF 22-sept-04 - Changed NH-DTR..SPR *unexpcons* to just *cons* since we
; want e.g. 'nineteenth century farmhouse' where numadj+noun now requires
; the SPR to be expressed to avoid spurious ambiguity for 'five chairs'.
; DPF 09-may-05 - Since we want to constrain appositives to treat indefinites
; separately, we need ALTMIN for nouns to be contentful, reflecting their
; specifier's MIN.  But we still want to exclude proper names (and verbal
; gerunds?), so drop ALTMIN no_rel and instead use MIN nom_nbar_rel.
; DPF 05-oct-05 - Tried adding NORM no_rel to HD-DTR as well, to
; prevent non-compounding nouns from being heads as well as non-heads, as in
; "*the book next" analogous to blocking the unwanted reading for "next book".
; But this alas also blocks det-less noun compounds like 'sea level, where
; we don't want 'level' as left member, but do as head.  So instead make
; type for nouns like 'next' which can't be heads or non-heads.
; DPF 21-jun-07 - Try restricting HD-DTR..MIN to nbar_or_nger_rel, to
; prevent verbal gerunds as heads in compounds, e.g. to avoid spurious parse
; for "[story involving] cats"
; DPF 16-sept-08 - Added HD.DTR..HEAD noun_or_nomger to block spurious 
; analysis for |rule-based|.
; DPF 05-apr-09 - But this also blocks |pea-sized| which we want.  So have to
; live with extra analysis for |rule-based|
; DPF 02-jun-10 - Make NORM quantity_or_no_rel instead of no_rel, to allow 
; for measure nouns.  This no longer gives rise to ambiguity for e.g. 
; |fifty meter ropes| which also had MNP combining with
; head noun via np-hdn_cpd_c rule, because now MNP would have to undergo
; bare-np rule to make NP for compound, but INFLECTD blocks this for bare-nps.
;; DPF 2014-10-20 - Can't make NH-DTR's SPR be *unexplist* as hoped, since it
;; blocks |the ten car garage|.  Let's remind ourselves of why this constraint
;; got added recently...
;;
basic_basic_noun_n_cmpnd_phr := n_n_cmpnd_phr &
  [ SYNSEM.MODIFD lmod &
		  [ RPERIPH #rperiph ],
    HD-DTR.SYNSEM [ LOCAL.CAT.HEAD noun_or_nomger_or_nadj & 
				   [ MINORS.MIN nbar_or_nger_rel ],
		    MODIFD.RPERIPH #rperiph,
		    LEX + ],
    NH-DTR 
       [ SYNSEM [ LOCAL [ CAT [ HEAD noun_or_nomger &
				     [ PRD -,
				       MINORS [ MIN nbar_or_nger_rel,
						NORM quantity_or_no_rel ] ],
				VAL.SPR [ FIRST.NONLOC non-local_none ] ],
			  CONT.HOOK [ LTOP #nltop,
				      INDEX #nind ] ],
		  LEX + ],
	 ORTH [ FROM #from, TO #to ] ],
    C-CONT [ RELS <! prep_notense_relation &
                     [ PRED compound_rel ], 
                     [ PRED udef_q_rel,
                       ARG0 #nind & overt_non_expl-ind,
                       RSTR #rhand,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! qeq & [ HARG #rhand,
                              LARG #nltop ] !>,
	     ICONS <! !> ] ].

basic_noun_n_cmpnd_phr := basic_basic_noun_n_cmpnd_phr &
  [ SYNSEM.MODIFD.LPERIPH #lperiph,
    NH-DTR.SYNSEM.MODIFD.LPERIPH #lperiph ].

;; Ordinary compound nouns do not allow interleaved adjectives
;; DPF 20-apr-09 - Block left paren on head dtr
;; DPF 2017-04-26 - Constrain NH-DTR to be nonconj_ref-ind, to avoid spurious
;; ambiguity for e.g. |dog and cat collars| since the plural-compound rule
;; necessarily provides one analysis for these.
;; DPF 2017-09-15 - Re 2017-04-26: But we also want 
;; |two-year and three-year notes| where the two conjuncts are not inflected,
;; while still excluding |*two year and three-years notes|. So let's try
;; removing the nonconj constraint here, and constraining the plural cmpd rule
;; to require its nonhd dtr to be DIV +, since |dog and cat| is DIV -.
;; DPF 2017-12-16 - Re 2017-09-15 - Too much spurious ambiguity as for
;; |sand and gravel trucks| with this rule (and the desired plural variant),
;; so let's try again.  Restore nonconj_ref-ind on NH-DTR, and add separate
;; plural-compound rule for measure NP non-hds.
;; DPF 2020-04-22 - Now that lexical plurals such as "earnings" are INFLECTD
;; na_or_+ (so we can get |earnings-related| as N-V compound and also
;; |earnings report| as plN-N compound), considered adding NH-DTR..AGR..PN 3s 
;; to block spurious N-N analysis with this rule for |earnings report|, but 
;; this would block |three dog night|.
;; DPF 2020-04-26 - Temporarily propagating ORTH.CLASS from nh-dtr to mother
;; so we can restrict new mnp_vp_phr to apply only to measure NPs with `%',
;; and not, for example, |10 square meters owned by Kim|
;;
noun_n_cmpnd_phr := basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM abstr_lex_synsem & 
		  [ MODIFD notmod_or_lmod & [ LPERIPH na ],
		    PUNCT.LPUNCT dq_or_no_punct ],
    NH-DTR [ INFLECTD na_or_-,
	     SYNSEM [ LOCAL noninfl_noun_local &
			    [ CONT.HOOK.INDEX nonconj_ref-ind ],
		      PUNCT.RPUNCT hyphen_or_pair_or_no_punct ],
	     ORTH.CLASS #class ],
    ORTH.CLASS #class ].

; But for more robust parsing, we'll let them in
;; DPF 2017-02-22 - Changed nh-dtr's RPUNCT from no_punct to comma_or_no_punct,
;; in order to get |the open access, integrated ontology|
;; DPF 2018-03-10 - Generalize hd-dtr from nonlex_synsem to 
;; nonlex_or_lex_phr_synsem so we can also get |five-year direct marketing plan|
;; and |thirty-day full refund guarantee|.
;;
noun_adjn_cmpnd_phr := basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM nonlex_or_lex_phr_synsem &
		  [ MODIFD lmod & [ LPERIPH - ] ],
    NH-DTR [ INFLECTD na_or_-,
	     SYNSEM abstr_lex_synsem &
		      [ PUNCT.RPUNCT comma_or_no_punct ] ],
    GENRE nonformal ].

;; DPF 2016-02-16 - Exclude conjoined non-head to avoid ambig.
;; DPF 2016-11-07 - Removed [LPERIPH na] so we can also get
;; |securities mutual fund|.  Monitor for over-generation and FIX?
;; DPF 2017-04-26 - Re 2016-02-16: But we need to use this rule for
;; |sales and marketing arm| since the coord-nbar has to be INFLECTD + because
;; of |sales| being inflected for plural.  So relocate the nonconj_ref-ind
;; constraint to the normal n-n-compound rule, since this rule will give us
;; an analysis for |dog and cat collars|
;; DPF 2017-10-23 - Constrain nh-dtr to CASE non-nom, to avoid spurious ambig
;; for e.g. |the sand and gravel truck| where we could admit |sand and gravel|
;; either via div-coord rule or mass-coord-singular rule.
;; DPF 2017-12-08 - Split this rule into two, as done for adj-N and adj-adj-N, 
;; so we can block |systems, analyst| while allowing 
;; |$10 million, three-year contract|.
;; DPF 2017-12-16 - Add CASE no_case to NH-DTR, to block spurious analysis with
;; mass N-N coord rule for |sand and gravel truck|.
;; DPF 2018-05-21 - Change NH-DTR.INFLECTD from + to na_or_+ so we can also get
;; |text-to-speech and grapheme-to-speech systems|, where |text- to- speech| is
;; INFLECTD na.  One consequence is that we now get a spurious parse for
;; |department manager| since `department' is such that we can get
;; |the department of linguistics director|.  FIX someday.
;; DPF 2020-04-01 - Removed NH-DTR..SPR..--MIN quant_rel, since this blocked
;; |[text-to-speech and grapheme-to-speech] systems|.  CHECK.
;; DPF 2020-04-22 - Can't have NH-DTR..CASE no_case, since conjoined nouns are
;; real_case.  
;;
noun_n_cmpnd_pl_phr := basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM abstr_lex_synsem & 
		  [ MODIFD notmod_or_lmod,
		    PUNCT.LPUNCT dq_or_no_punct ],
    NH-DTR [ INFLECTD na_or_+,
	     SYNSEM [ LOCAL [ AGR.PNG.PN 3p,
			      CAT [ HEAD.--BARE -,
				    VAL.SPR.FIRST [ LOCAL.CAT.HEAD det ] ],
			      CONT.HOOK.INDEX ref-ind &
					      [ PNG.PN 3p ] ],
		      MODIFD notmod_or_lmod,
		      PUNCT.RPUNCT rbc_or_hyphen_or_pair_or_no_punct ] ] ].

;; DPF 2917-12-16 - Added yet another variant just for coordinated measure NPs,
;; which are not inflected.
;;
noun_n_cmpnd_pl_mnp_phr := basic_noun_n_cmpnd_phr &
  [ HD-DTR.SYNSEM abstr_lex_synsem & 
		  [ MODIFD notmod_or_lmod,
		    PUNCT.LPUNCT dq_or_no_punct ],
    NH-DTR [ INFLECTD -,
	     SYNSEM [ LOCAL [ CAT.HEAD.MINORS.MIN meas_nom_rel,
			      CONT.HOOK.INDEX conj_ref-ind ],
		      MODIFD notmod_or_lmod,
		      PUNCT.RPUNCT rbc_or_hyphen_or_pair_or_no_punct ] ] ].

; n-adj phrases: "wide-eyed" "pea-sized", "sky blue"
; DPF 30-oct-06 - Stopped passing up of ALTMIN from dtr to mother, since
; we want to coordinate "large and medium-sized" where "large" says ALTMIN
; is norm_rel.  Instead, stamp norm_rel on mother's ALTMIN.
; DPF 05-apr-09 - FIX: We currently can't parse "inch-sized" since we don't
; want measure nouns as nonheads in noun-noun compounds ("*inch string" vs.
; "three-inch string"), yet we normally build "pea-sized" first as an N-N
; compound which then undergoes this rule.
;; DPF 2012-05-22 - Added DTR..PRD - to prevent directional nouns like west_n1
;; from undergoing this rule.
;; DPF 2012-09-10 - Constrained dtr's SPR to be synsem, to avoid spurious
;; analysis of |only one| as in |they arose on only one exchange|.
;; DPF 2012-10-01 - Changed MODIFD lmod to notmod, in order to allow post-modif
;; as in |Kim was tight-lipped about the plan|, and to allow extraction in
;; copula constructions, as in |yesterday, Kim was tight-lipped|.
;; DPF 2017-09-21 - Removed MOD..--MIN nonpro_rel, since we were blocking 
;; pronoun subjects as in |they are warm-blooded|, now that the copula is 
;; propagating this MIN constraint to its subject, as it should.
;;
n-adj_phrase := basic_unary_phrase &
  [ SYNSEM 
    [ LOCAL 
      [ CAT [ HEAD adj &
              [ MOD < synsem_min &
                      [ LOCAL intersective_mod &
                              [ CAT [ HEAD.POSS -,
                                      VAL [ SUBJ < >,
                                            SPR < synsem & 
                                                  [ --MIN quant_or_deg_rel ] >,
                                            COMPS < > ],
                                      MC na ],
                                CONJ cnil ],
                        --SIND #modind & non_expl-ind ] >,
                MINORS [ MIN norm_adj_rel,
                         ALTMIN norm_rel,
                         NORM #norm ] ],
              VAL [ SUBJ < >,
                    SPR < synsem_min &
                          [ --MIN more_or_very_deg_rel,
                            LOCAL 
                            [ CAT [ VAL [ SPR *olist*,
                                          SPEC < [ LOCAL.CAT.HS-LEX #hslex ]>],
                                    MC na ],
                              CONT.HOOK [ LTOP #lbl,
                                          XARG #arg0 ] ],
                            NONLOC.SLASH 0-dlist,
                            OPT + ] >,
                    COMPS < >,
		    SPEC < >,
		    SPCMPS < > ],
              HS-LEX #hslex ],
        CONJ cnil,
        CTXT #ctxt ],
      NONLOC #nonloc,
      PUNCT #punct,
      LEX +,
      MODIFD notmod & [ LPERIPH bool ] ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD noun_adj & 
                                       [ MOD < >,
                                         MINORS.NORM #norm,
					 PRD - ],
                                    VAL [ SPR < synsem &
                                                [ LOCAL.CAT.HEAD det,
                                                  NONLOC non-local_none ] >,
                                          COMPS < > ] ],
                              CONT.HOOK [ LTOP #nltop,
                                          INDEX #nind ],
			      CONJ cnil,
                              CTXT #ctxt ],
                      NONLOC #nonloc,
                      MODIFD notmod_or_lmod & [ LPERIPH na_or_+ ],
                      LEX +,
                      PUNCT #punct ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #lbl,
                    INDEX #arg0,
                    XARG #modind ],
             RELS <! [ LBL #lbl,
                       PRED compound_rel,
                       ARG0 #arg0 & event,
                       ARG1 #modind,
                       ARG2 #nind,
		       CFROM #from, CTO #to ],
                     [ PRED udef_q_rel,
                       ARG0 #nind & ref-ind,
                       RSTR #rstr,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rstr,
                              LARG #nltop ] !>,
	     ICONS <! !> ],
    INFLECTD + ].

; N-Particple-N phrases: "snow covered mountain, life threatening illness"
; "risk-averse, age-appropriate, PC-compatible"
; DPF 7-feb-08 - Preserve CONJ value from right dtr to mother
; Also, removed POSTHD - to allow e.g.'The mountains are snow-covered'
; So in order to still block "Abrams-put"
; DPF 05-apr-09 - Considered removing first dtr's NORM no_rel since we want 
; to allow e.g. 'inch-wide', but this would also allow "being interviewed"
; as compound, so let's not, and FIX some other way.
; DPF 25-may-09 - Added LPERIPH - to second dtr, to block "[Kim other] cats"
; DPF 18-jun-09 - Re 25-may-09: But this also blocks "cat-only garden", so
; push down to trans-adj variant.
; And Re 05-apr-09: Now treating "being/beings" as already inflected, so
; they cannot participate as non-hds in compounds.  So now remove first dtr's
; NORM no_rel, so we get "inch-wide", and also "human-readable".
; Also made first dtr MIN reg_nom_rel rather than nom_rel to block detless NPs
; like "being happy"
; DPF 25-jun-09 - Re 18-jun-09 (last): But want |head-driven| so change MIN
; from reg-nom-rel to parent type reg_or_temp_nom_rel.
; DPF 18-jan-10 - Block verb-particle verbs as right dtr, to avoid spurious
; ambiguity in e.g. "stock-picking tips"
; DPF 15-mar-10 - Re 18-jan-10: But this unfortunately also blocks adjectives
; which select for empty-prep PP, as in "context-sensitive"
; DPF 2011-02-03 - Changed first dtr from basic_lex_synsem to abstr_lex_synsem
; to also admit e.g. |T-cell-specific| where first dtr is NP-N cmpnd
;; DPF 2011-09-24 - Constrained right dtr's SPR.--MIN value to exclude
;; comparative adjectives: |*land-richer people prospered|
;; DPF 2012-09-26 - Removed AGR..PN 3s from first dtr, so we can get 
;; (uninflected) plurals as in |earnings-related increase|.
;; DPF 2014-07-10 - Changed first dtr's MODIFD from notmod to notmod_or_lmod
;; in order to admit |the [[open source] dominated] world|
;; DPF 2016-02-15 - To block |above happy| with noun |above|, make
;; first daughter's SPR be unexpressed_synsem.
;; 2020-04-22 - Re 2012-09-26: Now that we treat lexical plurals as inflected,
;; let's make them INFLECTD na_or_+, and constrain first dtr here to be na_or_-
;; so we can still get |earnings-related| and |futures-related|.
;;
basic_basic_n_v-or-adj_cmpnd_phr := binary_punct_phrase &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ VAL.COMPS < > ],
		     CONT.HOOK #hook,
		     CONJ #conj  ],
	     NONLOC #nonloc,
	     MODIFD notmod,
	     PHON.ONSET #onset,
	     PUNCT.PNCTPR #ppair ],
    ARGS < 
     [ SYNSEM abstr_lex_synsem &
	   [ LOCAL [ CAT [ HEAD basic_noun,
			   VAL [ SPR.FIRST unexpressed & 
					   [ OPT -,
					     LOCAL.CAT.HEAD.POSS - ],
				 COMPS < > ] ],
		     CONT.HOOK [ LTOP #nltop,
				 INDEX non_expl-ind & #nind ],
		     CONJ cnil ],
	     NONLOC [ SLASH 0-dlist & [ LIST < > ],
                      QUE 0-dlist,
                      REL 0-dlist ],
	     MODIFD notmod_or_lmod & [ RPERIPH - ],
	     PHON.ONSET #onset,
	     PUNCT.RPUNCT hyphen_or_pair_or_no_punct ],
       ORTH [ FROM #from2, TO #to2 ] ],
     [ INFLECTD +,
       SYNSEM 
	   [ LOCAL [ CAT [ HEAD v_or_a & [ PRD +,
					   MINORS.NORM no_rel ],
			   VAL [ SPR *olist* &
				     [ FIRST.--MIN more_deg_rel ] ] ],
		     CONT.HOOK #hook &
			       [ LTOP #ltop,
				 INDEX #ind ],
                     CONJ cnil & #conj ],
	     NONLOC #nonloc & non-local_none,
	     MODIFD notmod,
             PUNCT [ LPUNCT dq_or_no_punct,
                     PNCTPR #ppair ] ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS <! [ LBL #ltop,
                       ARG1 #ind,
                       ARG2 #nind,
		       CFROM #from, CTO #to ], 
                     [ PRED udef_q_rel,
                       ARG0 #nind & overt_non_expl-ind,
                       RSTR #rhand,
		       CFROM #from2, CTO #to2 ] !>,
	     HCONS <! qeq & [ HARG #rhand,
                              LARG #nltop ] !>,
	     ICONS <! !> ] ].

basic_n_v-or-adj_cmpnd_phr := basic_basic_n_v-or-adj_cmpnd_phr &
  [ SYNSEM adj_synsem_constr & [ LEX + ],
    ARGS < [ INFLECTD na_or_-,
	     SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN reg_or_temp_nom_rel,
	                        VAL.SPR < [ ] > ] ],
	   [ SYNSEM basic_lex_synsem &
		    [ LEX + ] ] >,
    C-CONT.RELS.LIST.FIRST prep_notense_relation ].

; DPF 24-may-09 - Note that this formulation excludes passivized 
; verb-particle verbs only because the by-PP is currently wrongly ordered
; in the COMPS list before the particle. FIX
;
n_v-or-adj_cmpnd_phr := basic_n_v-or-adj_cmpnd_phr &
  [ ARGS < [ ],
           [ SYNSEM 
	     [ LOCAL.CAT.VAL.COMPS [ FIRST.LOCAL.CAT [ HEAD n_or_p,
						       VAL [ COMPS < >,
							     SPR *olist* ] ],
				     REST *olist* ],
	       MODIFD.LPERIPH - ] ] >,
    C-CONT.RELS <! [ PRED compound_rel ], [ ] !> ].

;; DPF 2017-10-13 - It seems like we want to constrain the verb's first comp
;; to be [OPT -] in order to avoid |the cat-related mice| using v_np-pp entry.
;; Could alternatively also require --OCOMPKEY to be independent_rel.
;; Well, we can't say first comp is OPT - since we need passive verbs here,
;; where the comp is optional.  So let's try the --OCOMPKEY route.
;; DPF 2020-04-27 - Added mother's MOD..INDEX.PT notpro to block 
;; |[company reported] [a third]| with meas-NP |a third|
;;
n_v_cmpnd_phr := n_v-or-adj_cmpnd_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CONT.HOOK.INDEX.PT notpro,
    ARGS < [ ],
           [ SYNSEM [ LOCAL.CAT.HEAD verb,
		      LKEYS [ --COMPKEY independent_rel,
			      --OCOMPKEY independent_rel ] ] ] > ].

n_adj_cmpnd_phr := n_v-or-adj_cmpnd_phr &
  [ ARGS < [ ],
           [ SYNSEM.LOCAL.CAT [ HEAD adj,
				VAL.COMPS.FIRST.OPT + ] ] > ].

;; DPF 2012-08-03 - With EMB, decided to underspecify the pred name of the
;; EP introduced by both the transitive and non-transitive adjective-dtr 
;; variants of this construction, so changing the transitive one from
;; argument_rel to compound_rel, and the intransitive one below from 
;; comp_equal_rel to compound_rel
;; DPF 2012-11-08 - This should probably be restricted to HEAD adj for
;; right dtr, to avoid spurious ambig for |bell-ringing children|.
;; Let's see how it goes ...
;;

n_adj_intr_cmpnd_phr := basic_n_v-or-adj_cmpnd_phr &
  [ SYNSEM.LOCAL.CAT.MC -,
    ARGS < [ ],
           [ SYNSEM.LOCAL.CAT [ HEAD adj,
				VAL [ SPR *ocons*,
				      COMPS < > ] ] ] >,
    C-CONT.RELS <! [ PRED compound_rel ], [ ] !> ].

;; DPF 2020-04-25 - Added specialized construction for 
;; |The unit is [10% owned by IBM]|
;; with measure-NP as left dtr, and passive VP as right dtr, with left-dtr
;; for now restricted only to measure-NPs with the % character, via
;; ORTH.CLASS non_alphanumeric
;;
mnp_vp_phr := basic_basic_n_v-or-adj_cmpnd_phr &
  [ SYNSEM norm_adj_synsem &
	   [ LOCAL [ CAT [ HEAD adj & [ PRD +,
					MOD.FIRST.LOCAL intersective_mod ],
			   VAL [ SPR < anti_synsem_min >,
				 SPEC < > ] ] ] ],
    ARGS < [ INFLECTD +,
	     SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN meas_nom_rel,
				VAL.SPR < [ ], anti_synsem_min > ],
	     ORTH.CLASS non_alphanumeric ],
	   [ SYNSEM phr_synsem & 
		    [ LOCAL.CAT [ HEAD verb & [ VFORM pas ],
				  VAL.COMPS < > ] ] ] >,
    C-CONT.RELS <! [ PRED compound_rel,
		     ARG0 event ], [ ] !> ].

;; DPF 2018-02-13 - Similar to N-V adjective compounds, we also get Adj-V ones
;; such as |tough-sounding| and |angry-looking|
adj_v_cmpnd_phr := binary_punct_phrase &
  [ INFLECTD +,
    SYNSEM basic_adj_synsem_constr &
	     [ LOCAL [ CAT [ HEAD.MOD.FIRST.LOCAL.CONT.HOOK.LTOP #ltop,
			     VAL.COMPS < > ],
		       CONT.HOOK #hook,
		       CONJ #conj  ],
	       NONLOC #nonloc,
	       LEX +,
	       MODIFD notmod,
	       PHON.ONSET #onset,
	       PUNCT.PNCTPR #ppair ],
    ARGS < 
     [ INFLECTD +,
       SYNSEM abstr_lex_synsem &
	   [ LOCAL [ CAT [ HEAD adj & #adjhead,
			   VAL.COMPS *olist* ],
		     CONT.HOOK #adjhook,
		     CONJ cnil ],
	     NONLOC [ SLASH 0-dlist & [ LIST < > ],
                      QUE 0-dlist,
                      REL 0-dlist ],
	     PHON.ONSET #onset,
	     PUNCT.RPUNCT hyphen_or_pair_or_no_punct ] ],
     [ INFLECTD +,
       SYNSEM basic_lex_synsem & 
	   [ LOCAL [ CAT [ HEAD verb & [ PRD +,
					 MINORS.NORM no_rel ],
			   VAL [ SPR *olist* &
				     [ FIRST.--MIN more_deg_rel ],
				 COMPS.FIRST.LOCAL [ CAT.HEAD #adjhead,
						     CONT.HOOK #adjhook ] ] ],
		     CONT.HOOK #hook & [ LTOP #ltop ],
                     CONJ cnil & #conj ],
	     NONLOC #nonloc & non-local_none_phr,
	     LEX +,
	     MODIFD notmod,
             PUNCT [ LPUNCT dq_or_no_punct,
                     PNCTPR #ppair ] ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

;; Appositives
;; For now, restrict this to temporal nouns and proper names, since it's an 
;; overly enthusiastic rule.  So only get "Tuesday the tenth" and "Jim Smith"
;; (well, and also "Jim the tenth", but then it's only a hack anyway).
;; Use CASE feature hack on non-head to avoid unwanted "minor" NPs like 
;; minute_word as appositives: "seven thirty"
;; DPF 10-May-00 - In fact, restrict to only proper names, since the date
;; guys already come in via the npadv_mod rule.
;; DPF 11-Sept-01 - Restrict head-dtr to be reg_nom_rel (not basic_nom_rel)
;; to exclude deictic pronouns as in "that Kim", and further restrict to
;; explicit_q_rel so we can allow nonhead-dtr to include numbers as in
;; "the number five" but not "Abrams five".  This means we'll get as an
;; appositive "my friend Kim" but not "Kim my friend".  It means we also
;; block this analysis for "Lee Browne" - probably right.
;; DPF 12-Sept-01 - Restrict head-dtr to be PRD + to rule out free-relatives
;; DPF 18-Oct-01 - Removed [MODIFD notmod] from HD-DTR, since it blocks
;; 'my old friend kim'
;; DPF 4-Dec-02 - Made AGR..PN be strict_sort on the two dtrs, to exclude
;; as appositives e.g. "Kim and Sandy the book", even though this also rightly
;; will force another analysis to be constructed someday for 
;; "the brothers Grimm".
;; DPF 5-Sep-03 - Changed HD-DTR..ALTMIN from explicit_q_rel to quant_rel
;; to allow proper names which now have ALTMIN proper_q_rel.  Use SORT 
;; unification now to block "Abrams five" while allowing "the number five".
;; DPF 13-Nov-03 - Generalized to allow definite NPs as right dtrs, and
;; prevented recursion by use of LPERIPH.  [NORM no_rel] prevents np_adv's
;; like in "the chair here" or "here the chair"
;; DPF 27-jan-04 - Made MODIFD on non-hd dtr be notmod_or_rmod to prevent 
;; appositive analysis for "Kim interviewed Sandy".
;; But this blocks "my order # 12345", so undo, and instead make the
;; attr_adj_verb lexical rule restrict its MOD.MINORS.MIN value to block the
;; construction of "interviewed Sandy" in the first place, though this may
;; be too strong.
;; DPF 03-may-04 - Changed NHD..MIN from nonpro_rel to nonpro_or_num_rel,
;; to allow "Abrams, number five, arrived".  Still blocking "*Abrams five"
;; because the simple num-noun "five" is LPERIPH na.
;; DPF 16-jun-04 - Removed HD-DTR..LPERIPH bool since it blocks
;; "two people (Kim and Sandy)" since "two people" must be [LPERIPH na].
;; Not sure what overgeneration will result, but we'll see.
;; DPF 16-jul-04 - Added RPERIPH constraints on HD-DTR and mother to block
;; left recursion.
;; DPF 18-jul-04 - Made two subtypes of hdn-np_app-pr_c, one as before for proper
;; names and definite NPs ('Kim the doctor", "my brother Sandy") which allows
;; but does not require separating commas, and the other for indefinites
;; ("Kim, a manager, arrives') where commas are obligatory (to avoid a lot
;; of unwanted ambiguity as in 'We sent Kim a book').
;; DPF 20-aug-04 - Try changing HD-DTR..MIN from reg_nom_rel to
;; nonpro_or_num_rel, to admit "highway 55, the new road"
;; DPF 25-aug-04 - Restrict both dtrs to MSG no_msg, to exclude NPs derived
;; from S's or inf-VPs. 
;; DPF 26-sept-04 - Let's try requiring number agreement for the two dtrs,
;; to rule out spurious analysis for "another two of the chairs".
;; DPF 18-Nov-04 - Removed HD-DTR..PRD -, since this now excludes proper NPs
;; DPF 22-apr-05 - Try ruling out bare plurals as heads, to avoid spurious
;; ambiguity for "we sent two [consultants, Abrams and Browne]"
;; DPF 16-mar-06 - Re 13-Nov-03: Conflict with desire to constrain rel clause
;; rule via NORM.  So removed from NH-DTR, since 'the chair here' is now
;; ruled out by SORT mismatch.
;; DPF 24-may-07 - Tried requiring PNG to match on both dtrs, but this blocked
;; hdn-np_app-pr_c analysis of 'we have two cats, one from each litter'.  
;; Also prevents
;; 'Our team, six men and six women, is going to win', and "Our friends, a
;; couple from Kansas, are visiting."  So remove constraint.
;; DPF 31-may-07 - Changed HD-DTR..MIN from nonpro_or_num_rel to nom_rel,
;; to allow "I myself arrived early" and "we the people"
;; DPF 24-jul-07 - Re 16-mar-06: But we still allow "his home" as 
;; hdn-np_app-pr_c, since
;; pronoun is necessarily unrestricted for SORT.  So instead make the NORM
;; be norm_rel, which will block "home", but allow NPs with rel clauses.
;; DPF 24-apr-09 - Re 13-Nov-03: Changed hd-dtr's NORM from no_rel 
;; to quantity_or_no_rel to allow measure-NPs: |10 mm, the highest measure|, 
;; (note that SPR *olist* (surprisingly) blocks adverbial NPs as heads).
;; DPF 02-jul-09 - Push NH-DTR..NORM norm_rel down to subtypes, to allow
;; parenthetical hdn-np_app-pr_c to admit more variety, as in "the story (what he said)"
;; DPF 11-jan-10 - Removed identification of CASE on two dtrs, since it blocks
;; "John himself arose."  Can't remember what it was added to avoid ...
;; DPF 18-jul-2010 - Re 24-jul-07: Changed HD-DTR..NORM quantity_or_no_rel
;; to quantity_or_norm_or_no_rel, since this was blocking as heads any NPs 
;; which don't appear as left members of noun-noun compounds (these are NORM 
;; norm_rel), and because we now block appos of e.g. |his home| with distinct 
;; NORM values. New value still blocks demonstratives, as in |that Browne|.
;; DPF 2012-12-20 - Changed HD-DTR..LPUNCT from no_punct to dq_or_no_punct
;; since we want |we admire "Scores Plus," the film.|
;; DPF 2013-01-09 - Removed RPERIPH na on mother and RPERIPH bool on NH-DTR,
;; to allow appos in coord, such as [[Kim, the cat,] and Abrams].
;; DPF 2014-08-21 - Further extended HD-DTR..LPUNCT to allow left parens,
;; since we want |my uncle (Kim Browne, the author)|
;; DPF 2015-03-27 - Added PT notpro_or_refl to non-head dtr, to prevent unwanted
;; anaphor substitution when paraphrasing, while still allowing |Kim herself|
;; DPF 2016-01-27 - Added MINORS.NORM norm_rel to prevent appositives from
;; being vocatives, to avoid mostly spurious ambiguity, as in 
;; |the pronoun "you" sleep|. FIX better someday?
;; DPF 2016-08-06 - Re DPF 13-Nov-03: Let's keep LPERIPH na since this
;; prevents appositive |Monday the first| from undergoing npadv rule as in
;; |we arrrived Monday the first|, so we only get the preferred n-mod analysis.
;; DPF 2018-03-29 - Removed --BARE from HD-DTR: push into educ subtypes.
;; DPF 2019-09-12 - Re 2016-01-27: Generalize norm_rel to quantity_or_norm_rel,
;; so we can also allow measure phrases as heads, as in |$200, my total, rises.|
;; DPF 2019-10-31 - Re 2018-03-29: But we want to avoid detless-NPs as heads of
;; appositions as in "in case of [emergency, call ...]", so restore it here.
;; DPF 2020-03-24 - Changed NORM norm_rel to quantity_or_norm_rel as per trunk.
;; Also added HD-DTR..--BARE - as per trunk.
;; DPF 2020-04-17 - Push non-hd's HEAD basic_noun down to norm_appos_phr, so we
;; can get nominal gerunds in indefinites, as in |recent data, a widening of the
;; gap| (wsj11a:21102015).  CHECK for extra ambiguity.
;;
basic_appos_phr := head_compositional & basic_binary_headed_phrase &
  [ INFLECTD +,
    SYNSEM phr_synsem &
	   [ LOCAL.CAT [ HEAD.MINORS.NORM quantity_or_norm_rel,
			 VAL #valence ],
	     MODIFD.LPERIPH na,
	     NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL #rel ] ],
    HD-DTR [ INFLECTD +,
	     SYNSEM canonical_synsem &
	     [ LOCAL [ CAT [ HEAD noun_or_nomger &
                                [ MINORS [ MIN nom_rel,
					   NORM quantity_or_norm_or_no_rel ] ],
			     VAL #valence &
                                  [ SPR *olist*,
                                    SUBJ *olist*,
                                    COMPS < > ] ],
                       CONT.HOOK.INDEX ref-ind & #hind,
		       CONJ cnil ],
               NONLOC [ SLASH 0-dlist,
                        QUE 0-dlist,
			REL #rel ] ] ],
    NH-DTR [ INFLECTD +,
	     SYNSEM canonical_synsem &
  	     [ LOCAL [ CAT [ HEAD noun_or_nomger &
                                [ MINORS [ MIN nonpro_or_refl_or_num_rel,
                                           ALTMIN appos-able_rel ],
                                  --BARE -,
				  CASE real_case ],
                             VAL.COMPS < > ],
		       CONT.HOOK.INDEX #modind & [ PT notpro_or_refl ] ],
               NONLOC [ SLASH 0-dlist & [ LIST < > ],
                        QUE 0-dlist,
                        REL 0-dlist ] ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #ltop ],
	     RELS.LIST.FIRST prep_notense_relation &
                             [ LBL #ltop,
                               PRED appos_rel,
                               ARG1 #hind,
                               ARG2 #modind,
			       CFROM #from, CTO #to ] ] ].

reg_appos_phr := basic_appos_phr & head_initial &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct & lparen_or_dq_or_comma_or_no_punct,
		   RPUNCT #rpunct,
		   RCLSTR #rclstr ],
    HD-DTR.SYNSEM.PUNCT.LPUNCT #lpunct,
    NH-DTR.SYNSEM.PUNCT [ RPUNCT #rpunct,
			  RCLSTR #rclstr ] ].

;; DPF 2014-05-12 - Constraining the HD-DTR..HEAD to basic_noun precludes
;; punctuated appositives such as |program trading - the popular practice . ...|
;; so instead move this constraint down to the non-paired variants.
;;
norm_appos_phr := reg_appos_phr &
  [ HD-DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < >,
			  CONT.HOOK.INDEX.SORT #sort ],
    NH-DTR.SYNSEM.LOCAL [ CAT.HEAD basic_noun,
			  CONT.HOOK.INDEX.SORT #sort ] ].

basic_appos_np_phr := norm_appos_phr &
  [ HD-DTR.SYNSEM.MODIFD.RPERIPH bool,
    NH-DTR.SYNSEM.LOCAL.CAT.VAL.SPR *olist*,
    C-CONT [ RELS <! relation !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2016-11-02 - Generalized NH-DTR..NORM from norm_rel to norm_non_num_rel
;; to also allow deictics, as in |my book, that which we admired|
;; DPF 2017-01-30 - Replaced NH-DTR..NORM norm_non_num_rel with quantity_rel
;; to exclude deictic pronouns, to avoid |Kim that| as appositive.
;; DPF 2017-02-25 - Re 2017-01-30: But we do want |the suggestion, that of the
;; advisor|, so we'll return to norm_non_nom_rel, and live with |Kim that| for
;; now.  FIX someday?
;;
appos_np_phr := basic_appos_np_phr &
  [ NH-DTR.SYNSEM [ LOCAL.CAT [ HEAD.MINORS.NORM norm_non_num_rel,
				VAL.SUBJ < > ],
		    PUNCT.LPUNCT dq_or_no_punct ] ].

; For these two subtypes, see comment 7-may-05 for n_adj_relcl_phrase
; DPF 07-sept-07 - Restrict this nopair variant to exclude bare_sg NP as head.
; DPF 23-apr-09 - Block left paren on NH-DTR -- when both left and right par
; are present, uses appos_np_phr rule.
; DPF 13-may-09 - Block bare partitives as heads, to avoid spurious parse for
; 'both the cats'
; DPF 13-may-09 - Re 23-apr-09: Remove paren constraint, since get 
; PNCTPR no_pair on parenthesized coord NP.
;; DPF 2019-09-12 - Removed HD-DTR..NORM norm_or_no_rel, since this NORM value
;; is constrained by the mother's value, set in basic_appos_phr.
;; DPF 2020-04-27 - Let's pursue a long-standing mystery (at least back to 1214)
;; of why NH-DTR..RPUNCT was comma_or_clause, excluding no_punct, and thus
;; having incoherent ...or_no_punct on the paired variant of this rule, which
;; should require overt paired punctuation.
;;
#|
appos_phr_nopair := appos_np_phr &
  [ SYNSEM.PUNCT [ PNCTPR #ppair,
		   PAIRED #paired ],
    HD-DTR.SYNSEM [ LOCAL.CAT.HEAD basic_noun &
				   [ MINORS.ALTMIN impl_or_expl_or_prop_q_rel ],
                    PUNCT.RPUNCT no_punct ],
    NH-DTR.SYNSEM [ PUNCT [ RPUNCT comma_or_clause,
                            PNCTPR #ppair,
			    PAIRED #paired ] ] ].
|#
appos_phr_nopair := appos_np_phr &
  [ SYNSEM.PUNCT [ PNCTPR #ppair,
		   PAIRED #paired ],
    HD-DTR.SYNSEM [ LOCAL.CAT.HEAD basic_noun &
				   [ MINORS.ALTMIN impl_or_expl_or_prop_q_rel ],
                    PUNCT.RPUNCT no_punct ],
    NH-DTR.SYNSEM [ PUNCT [ PNCTPR #ppair,
			    PAIRED #paired ] ] ].

;; DPF 18-jul-2010 - Added HD-DTR..ALTMIN non_pronoun_q_rel to block
;; relative pronouns as heads, as in |who Browne ...|
;; DPF 2012-10-10 - Also allow indefinite on HD-DTR, to admit 
;; |a friend, Kim, arrived|
;; DPF 2020-04-27 - Removed _or_no_punct from HD-DTR..RPUNCT, to avoid use for
;; |[The New] York|
;;
#|
appos_phr_prpnct := appos_np_phr &
  [ HD-DTR.SYNSEM [ PUNCT [ PNCTPR #pnctpr,
			    PAIRED #paired,
			    RPUNCT comma_or_pair_or_no_punct ] ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN def_or_meas_rel,
                    PUNCT [ PAIRED #pnctpr,
                            PNCTPR #paired ] ] ].
|#
appos_phr_prpnct := appos_np_phr &
  [ HD-DTR.SYNSEM [ PUNCT [ PNCTPR #pnctpr,
			    PAIRED #paired,
			    RPUNCT comma_or_pair_punct ] ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN def_or_meas_rel,
                    PUNCT [ PAIRED #pnctpr,
                            PNCTPR #paired ] ] ].

;; DPF 2011-08-24 - For each of the paired and non-paired phrase types, 
;; exclude proper name from right dtr in first rule, to avoid spurious appos 
;; analysis of "John Browne".  Then exclude proper name from the left dtr of 
;; the second variant, and require proper name for the right dtr.

appos_phr_nonprop_nopair := appos_phr_nopair &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD basic_noun &
				 [ MINORS.ALTMIN explicit_or_proper_q_rel ],
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN def_or_meas_noproper_rel ].

appos_phr_prop_nopair := appos_phr_nopair &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD basic_noun & 
				 [ MINORS.ALTMIN def_or_meas_or_num_rel ],
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN num_or_proper_q_rel ].

;; Tried replaciing NH-DTR..ALTMIN def_or_meas_noproper_rel with
;; udef_or_def_or_meas_rel to get |Bygdin 1:50000| (also adding PRD - to exclude
;; detless NPs), but it's too expensive to allow all udef NPs, especially 
;; single word NPs as in |the Bergen area|. So instead, add yet another
;; separate rule just for meas-NP right dtrs.
;;
appos_phr_nonprop_prpnct := appos_phr_prpnct &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN non_pronoun_q_rel,
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.ALTMIN def_or_meas_noproper_rel,
			      VAL.SPEC *cons* ] ].

;; DPF 2017-10-08 - Since we stopped treating deictics with appos_phr_nonprop_prpnct
;; (to avoid spurious analyses as for |[the cat that] arrived.|), we add a separate
;; type just for deictic phrases: |one door, that for pets, stayed open|
;;
appos_phr_deictic_prpnct := appos_phr_prpnct &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN non_pronoun_q_rel,
    NH-DTR.SYNSEM phr_synsem &
   	          [ LOCAL.CAT [ HEAD.MINORS.ALTMIN demonstrative_q_rel,
				VAL.SPEC *cons* ],
		    PUNCT.RPUNCT comma_or_clause ] ].

;; DPF 2017-07-10 - Further constrained this new rule to exclude number NPs
;; as heads, to avoid spurious analysis for |3.2 shares|
;;
appos_phr_meas_prpnct := appos_phr_prpnct &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS [ MIN basic_basic_non_temp_nonpro_rel,
					  ALTMIN non_pronoun_q_rel ],
    NH-DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS [ MIN meas_nom_rel,
					    ALTMIN udef_q_rel,
					    NORM quantity_rel ],
			      VAL.SPEC *cons* ] ].

;; DPF 2012-07-22 - Added for |Kim, 22, arose| but still blocking appos for 
;; |Kim 22 arose|
;appos_phr_num_prpnct := appos_phr_prpnct &
;  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN non_pronoun_q_rel,
;    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN number_q_rel ] ].

;; DPF 2016-11-20 - Since we removed the RPUNCT comma_punct from the nh-dtr,
;; perhaps we can now constrain the next rule to exclude numbers, to avoid the
;; spurious ambig for |the number five|
;;
appos_phr_num_prpnct := appos_np_phr &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN non_pronoun_q_rel,
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN number_q_rel ] ].

appos_phr_prop_prpnct := appos_phr_prpnct &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN indef_or_def_or_meas_rel,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN proper_q_rel ].

; DPF 18-jun-07 - This is a patch to enable us to get comma-marked appositives
; as right conjuncts, while our comma constraints on conjuncts currently block
; them with normal commas.
; DPF 13-may-09 - Re 18-jun-07: Leads to a lot of spurious ambiguity.  Let's
; instead try not propagating the PAIRED value from hd-dtr to mother in 
; the appos_phr_prpnct rule.
;; DPF 2016-11-12 - Let's try two more specific rules for missing comma for
;; |Kim, my doctor arrived| and |my doctor, Kim arrived|
;;
appos_phr_rbc := appos_np_phr &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN non_pronoun_q_rel,
		    PUNCT.RPUNCT rbcomma_punct ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN def_or_meas_noproper_rel,
		    PUNCT.RPUNCT no_punct ],
    GENRE nonformal ].

appos_phr_prop_rbc := appos_np_phr &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN indef_or_def_or_meas_rel,
		    PUNCT.RPUNCT rbcomma_punct ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN num_or_proper_q_rel,
		    PUNCT.RPUNCT no_punct ],
    GENRE nonformal ].


;; DPF 2016-10-11 - Constraining HD-DTR..HEAD to basic_noun excludes analysis
;; of e.g. |machine learning, a branch of science, ...|.  So let's try leaving
;; as generalized noun_or_nomger, and see if the increased ambiguity is still
;; tolerable (FIX?).
;;
norm_appos_indef_phr := reg_appos_phr &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD [ CASE #case,
				     MINORS.NORM norm_rel ],
		    MODIFD.RPERIPH bool ],
    NH-DTR.SYNSEM [ LOCAL.CAT [ HEAD [ MINORS [ ALTMIN indef_or_udef_rel,
						NORM norm_rel ],
				       CASE #case ],
				VAL.SPR *olist* ] ],
    C-CONT [ RELS <! relation !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2020-03-24 - Removed SYNSEM..PNCTPR ppair, since it blocks paired
;; relative clause containing one of these appositives, as in jh1 3013753:
;; |...the blue Bessvatn, which curves toward the foot of Bessh, a peak that 
;; makes ...|
;;
appos_indef_phr := norm_appos_indef_phr &
  [ HD-DTR.SYNSEM.PUNCT [ RPUNCT comma_or_pair_punct,
			  PNCTPR #ppair,
			  PAIRED #paired ],
    NH-DTR.SYNSEM.PUNCT [ RPUNCT comma_or_clause_or_pair_punct,
			  PNCTPR #ppair,
			  PAIRED #paired ] ].

;; DPF 2017-07-10 - Let's try restricting the NH-DTR to phrases, to avoid
;; some spurious ambiguity, as in |... 23, cats ...|
appos_indef_rbc_phr := norm_appos_indef_phr &
  [ HD-DTR.SYNSEM.PUNCT.RPUNCT rbcomma_punct,
    NH-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
		    LEX na_or_- ] ].

;; DPF 2014-05-16 - Let's use the RPAREN attribute, and generalize this to
;; all parenthesized NPs for right dtr.
;; DPF 2016-10-04 - Changed NH-DTR..RPUNCT from rparen_or_clause_punct to
;; comma_or_clause_or_pair_punct, since we also want |Kim (a cat), ...|
;; and we also have the RPAREN na_or_+ feature to keep application constrained.
;; DPF 2020-03-24 - Changed NH-DTR..RPAREN na_or_+ from +, as per trunk.
;;
appos_indef_paren_phr := basic_appos_np_phr &
  [ SYNSEM.PUNCT [ PNCTPR #ppair,
		   PAIRED #paired ],
    HD-DTR.SYNSEM [ LOCAL.CAT.HEAD.CASE #case,
		    PUNCT.RPUNCT no_punct ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.CASE #case,
                    PUNCT [ LPUNCT lparen_punct,
			    RPUNCT comma_or_clause_or_pair_punct,
                            PNCTPR #ppair,
			    PAIRED #paired,
			    RCLSTR.RPAREN na_or_+ ] ] ].

; 'Paris, home of the Eifel Tower'
; DPF 07-apr-08 - Replaced phr_synsem constraint on NH-DTR with 
; nonlex_or_lex_phr_synsem to allow compounds, such as in 
; "Kim Smith, airport director, resigned."
; DPF 02-jul-09 - Restricted NH-DTR..MIN to non_temp_nbar_rel instead of
; nom_nbar_rel, to exclude e.g. numbers as in "June, 2000"
; Also relaxed NH-DTR..RPUNCT to allow "Kim, creator of X" with no closing
; comma.
; Also restricted NH-DTR to singular count nouns, to avoid spurious ambiguity
; with ordinary NP apposition
;; DPF 2017-08-14 - Dropped the PAIRED identity of mother and hd-dtr, since no
;; longer requiring the phrase to be comma paired (though it can be), and we 
;; want to allow |Kim Browne and Sandy, head of the class, arose|
;; DPF 2020-03-31 - Generalized HD-DTR..RPUNCT to include rparen and hyphen
;; DPF 2020-04-27 - Restricted HD-DTR to exclude measure-NPs:
;; |[a third-] [quarter net loss]|
;;
appos_nbar_phr := norm_appos_phr &
  [ HD-DTR.SYNSEM [ LOCAL.CAT.HEAD basic_noun &
				   [ MINORS [ MIN nonpro_or_num_rel,
					      NORM norm_or_no_rel ] ],
                    PUNCT [ RPUNCT hyphen_or_comma_or_rparen_or_clause ] ],
    NH-DTR [ SYNSEM nonlex_or_lex_phr_synsem & 
                  [ LOCAL [ CAT [ HEAD.MINORS [ MIN non_temp_nbar_rel,
						NORM norm_rel ],
                                  VAL.SPR < synsem & 
                                            [ LOCAL.CAT.HEAD det,
                                              OPT - ] > ],
			    AGR [ PNG.PN 3s,
				  DIV - ],
                            CONT.HOOK [ LTOP #nhand,
                                        INDEX #index ] ],
                    PUNCT [ LPUNCT dq_or_no_punct,
			    RPUNCT comma_or_clause_or_pair_or_no_punct ] ],
	     ORTH [ FROM #from, TO #to ] ],
    C-CONT [ RELS <! relation, [ PRED udef_q_rel,
                                 ARG0 #index & ref-ind,
                                 RSTR #rhand,
				 CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !>,
	     ICONS <! !> ] ].

;; Reverse appos phrase, to enable paraphrase generation of |the teacher Kim|
;; with the same MRS as |Kim the teacher|.  Not used in normal parsing to
;; avoid spurious ambiguity.
;;
appos_np_reverse_phr := basic_appos_phr & head_final &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct & lparen_or_dq_or_comma_or_no_punct,
		   RPUNCT #rpunct,
		   RCLSTR #rclstr ],
    HD-DTR.SYNSEM [ LOCAL.CAT [ HEAD.MINORS.NORM norm_rel,
				VAL.SUBJ < > ],
		    NONLOC non-local_none_phr,
                    PUNCT [ PNCTPR #pnctpr,
			    PAIRED #paired,
			    RPUNCT #rpunct & 
				   comma_or_rbc_or_clause_or_pair_or_no_punct,
			    RCLSTR #rclstr ] ],
    NH-DTR.SYNSEM [ LOCAL.CAT [ HEAD.MINORS.NORM norm_rel,
				VAL.SUBJ < > ],
		    NONLOC non-local_none_phr,
		    PUNCT [ PNCTPR #pnctpr,
			    PAIRED #paired,
			    LPUNCT #lpunct,
			    RPUNCT comma_or_pair_or_no_punct ] ],
    C-CONT [ RELS <! relation !>,
             HCONS <! !>,
	     ICONS <! !> ],
    GENRE paraphrase ].

;;
;; Adverbial-NP modifiers
;;

; DPF 11-Jun-99 - Added SUBJ..OPT - to prevent these temporal NPs from filling
; ordinary NP argument positions.
;
; DPF 26-Jul-99 - Changed [HEAD noun] to [HEAD prep] to avoid double parse
; for "Thursday the fourth" where "the fourth" attaches after "Thursday"
; is itself an npadv_mod phrase.
; DPF 9-Sept-99 - Added PRD - to mother, to block temp-mods as complements of
; copula.
; DPF 30-Sept-99 - But this blocks all post-nominal modification with temporal
; NPs, sigh.  Besides, the most natural reading of "The meeting is Tuesday" is
; with the temp-mod reading rather than the identity one.
; DPF 2-Sept-00 - Removed SPR, to avoid spurious analysis for "my mornings 
; look pretty booked tuesdays".  Don't recall why we wanted a SPR on these
; phrases.
; DPF 4-Apr-01 - Added PRD from dtr to prevent e.g. relpro "that" from being 
; the complement of copula, as in "the book that Kim is", while allowing "here
; are the books", which requires npadv_mod extraction from locative inversion.
; DPF 17-Jul-01 - Replaced SPR, since we want "leave right now", where the 
; nominal "now" gets pumped to a modifier, and can (only) then take a degree 
; specifier.  It seems the ambiguity of 2-Sept-00 is not spurious, just
; unlikely.
; DPF 25-Sep-01 - Added reentrancy of AGR and SUBJ's INDEX, to get no-copula
; constructions like "Kim in Berlin becoming impatient"
; DPF 2-Apr-02 - Made SUBJ be expressed_synsem rather than synsem, to prevent
; these phrases from appearing as complements of when_subord_prd.
; DPF 30-May-02 - But this also blocks "someone there".  So remove this
; constraint, and instead restrict the when_subord_prd complement to be
; non-temporal.
; DPF 9-May-02 - Identified INDEX.SORT of dtr and of mother, to avoid letting
; temporal NPs be fillers for ordinary adjunct extraction, which was giving
; us a spurious parse for e.g. "when did kim arrive"
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 2-May-03 - Try replacing dtr's [MODIFD hasmod] with [MODIFD lmod] to
; block "*KIm fell time that I did" but allow "Kim fell two times".  This
; seems to force us to have two lexical entries for "the", one which is notmod
; (as is its head sister), and one for modified nominals, where "the" stamps
; [MODIFD lmod] whether the nominal is right-modified or left-modified, so
; we still get "Kim arrived the week Sandy left".
; DPF 13-May-02 - Added SLASH <! !> to prevent spurious ambiguity for "Kim
; arrived when(ever) Sandy left". 
; DPF 27-May-03 - Re 2-May-03: But those two "the" entries have the effect of
; preventing us from using the intersective modification efficiency improvement
; for generation, since "the consultant" uses a different "the" than "the tall
; consultant", which means the generator's second-pass adjunction algorithm
; will fail to enrich "the consultant" to "the tall consultant".  Since that
; two-pass strategy depends on the phrase without modifiers being the "same"
; as the phrase with modifiers (at least using the same lexical entries), it
; seems to drive us back to just one entry for "the" which preserves the
; MODIFD value of its SPEC.  And then this rule requires that its dtr go back
; to just [MODIFD hasmod].  Not too troubling for this particular case, since
; the above example with "time" was playing on an ambiguity between the count
; and the mass senses, which we are treating as underspecification, perhaps
; wrongly.
; DPF 06-Jun-03 - Changed the identity of SORT on dtr and mother's INDEX, since
; this excluded temporal modifiers of non-temporal nouns ("meetings Tuesday"),
; and seemed counter-intuitive.  Rather we want the SORT of the dtr to 
; constrain the ARG0 of the derived "PP" itself (its E-INDEX), not what the PP 
; modifies.
; DPF 09-Jun-03 - Made dtr be MODIFD.LPERIPH bool to exclude "Kim arrived
; times I left"
; DPF 22-Jul-03 - Might think to make SPR's MIN be much_deg_rel rather than 
; simply degree_rel to avoid spurious ambig for "right now", given two entries
; "right" for 'very' and 'much' type degree specifiers.  But this blocks "too
; late" where "too" is not much-deg subtype.  
; DPF 16-oct-03 - Changed LPERIPH from bool to na_or_+ to be consistent with
; revised treatment of number adjectives
; DPF 30-oct-03 - Mysteriously, MOD was not restricted to non-empty SPR, which
; meant spurious parses attaching to both Nbar and NP (and VP and S).  Changed,
; but how unnoticed till now?  Also, --SIND on SUBJ was not co-indexed. Fixed
; DPF 01-may-04 - Continuing the pendulum swing of 2-Sept-00 and 17-Jul-01,
; removed SPR again, since we get "right now" as an NP, and have just added
; an analysis for "too late" and "too long" where these gradable NPs take
; "too", "very", etc. before pumping to PP.
; DPF 25-sept-04 - Removed SYNSEM..MOD..MSG no_msg, since we want to allow
; e.g. 'tomorrow, can you come' using adj_i_ques rule.  Rather, make MSG
; value same as that of MOD, like ordinary prepositions.
; DPF 12-nov-05 - Added MOD..NORM norm_rel to prevent these from 
; modifying lexical NP-adverbials as in e.g. "here there"
; DPF 05-dec-05 - Re: 25-sep-01 - Not clear what that comment meant, but
; removed AGR reentrancy since this was preventing e.g. "Here lies Kim"
; where the AGR ends up not being of type 'index'
; DPF 30-sept-06 - Re: 12-nov-05: But this interferes in interaction with
; appositives, as in "the manager today, Abrams, arrives."  So instead use
; value 'non_number_rel', which also allows 'no_rel', only excluding
; 'never_unify_rel'.
; DPF 23-may-07 - Re: 01-may-04, we want "they know why Kim is here", and
; "why" wants to modify a phrase with a non-empty SPR, so modnp "here"
; needs such a SPR, but we'll make it anti_synsem_min to avoid unwanted
; side-effects.
; DPF 18-jun-07 - Re 30-sept-06: But if we block "here there", we also
; block "here today" as in "Kim is here today", and also "Kim arrives late
; this afternoon."  So remove this constraint, and live with the spurious
; analysis of "here there".
; DPF 02-jul-09 - Constrain dtr to INDEX nonconj_ref-ind to avoid spurious
; ambiguity for "Kim arrives Tuesday and Wednesday"
; DPF 04-sept-09 - Removed reentrancy of MODIFD on mother and dtr, since
; we want to allow "Yesterday, Kim was here", where the np_adv_c must undergo
; hd_xaj-int-vp_c rule, which constrains its dtr to be notmod (to avoid
; spurious ambiguity).  See what trouble this removed constraint might give...
; DPF 13-mar-10 - Re 02-jul-90: Unfortunately, this also blocks "every 
; morning and evening", so undo this change, and live with ambiguity for
; "Tuesday and Wednesday".
; DPF 20-mar-10 - Re 23-may-07: Given that degree specifiers cannot combine
; directly either with cardinal adjectives or with meas-NPs (in both cases
; to avoid spurious ambiguity elsewhere), we need to allow adverbial
; meas-NPs to take specifiers, as in "Kim slept just over twelve hours."
; So push down to subtypes.
;; DPF 2011-08-02 - Re 16-oct-03: Changed to LPERIPH +, to exclude e.g.
;; |We arrived March the third month|, where appositives are necessarily
;; [LPERIPH na].
;; DPF 2011-10-21 - Removed REL 0-dlist from mother, since it blocks e.g.
;; |companies whose ads this year were longer prospered|
;; DPF 2015-03-11 - Changed parent type from basic_unary_phrase to
;; norm_unary_phrase in order to get the delimiter properties to propagate
;; from dtr to mother, and also PUNCT, to avoid leaving RPUNCT unbound in
;; spurious analysis of |when did Kim arise?|
;; DPF 2015-08-17 - Was tempted to add no_aspect to event of mother's EP, in
;; order to facilitate generation, but this is clearly wrong for predicative
;; uses, as in |the meeting was Tuesday| with pred copula.  So undo, and
;; reconsider how to enable generation when input MRS may arrive with overt
;; no_aspect constraint on that ARG0.
;;
basic_npadv_mod_phrase := basic_unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD modnp &
				[ MOD < [ LOCAL intersective_mod &
					  [ CAT 
                                            [ HEAD subst & 
                                                   [ AUX - ],
                                              VAL.COMPS < >,
                                              MC #mc ],
					    CONT.HOOK.INDEX #ind,
                                            CONJ cnil ],
					  --SIND #ind & non_expl &
					     [ SORT basic-entity-or-event ] ] >,
                                  TAM #tam,
                                  MINORS.ALTMIN #altmin,
                                  PRD #prd ],
                           POSTHD +,
			   VAL [ SUBJ < >,
                                 COMPS #comps,
				 SPCMPS < > ],
			   MC #mc,
			   NEGPOL #negpol ],
		     CONT.HOOK [ INDEX [ SORT #sort ],
                                 XARG #ind ],
                     CONJ cnil,
                     CTXT #ctxt ],
             NONLOC #nonloc & [ REL 0-dlist,
                                SLASH 0-dlist ],
	     PUNCT #punct ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD basic_noun & 
                                         [ MINORS.MIN #altmin,
                                           PRD #prd,
					   --BARE - ],
                                    VAL [ SPR *olist*,
                                          SUBJ *anti_list*,
					  COMPS #comps & < > ],
				    NEGPOL #negpol ],
			      CONT.HOOK.INDEX #index & 
				              [ SORT #sort ],
			      CONJ cnil,
                              CTXT #ctxt ],
                      NONLOC #nonloc,
		      PUNCT #punct ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #khand,
                    INDEX #arg0 ],
	     RELS <! prep_relation &
                     [ LBL #khand,
                       PRED loc_nonsp_rel,
                       ARG0 #arg0 & non_conj_event & [ E #tam ],
                       ARG1 #ind & event_or_index,
                       ARG2 #index,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    INFLECTD + ].

;; DPF 2012-04-16 - Added MODIFD lmod to mother, to prevent these from being
;; post-modified, to avoid redundant analysis for |25% of the cats in Paris|
;; DPF 2012-09-12 - Tried adding MOD..NORM no_rel to block unwanted ambiguity 
;; of analysis of e.g. |a year earlier| where |a year| is itself already an
;; np_adv_mnp.  But this runs afoul of the constraint on the complement of the
;; predicative copula which requires NORM norm_rel of its complement, so we
;; would not get |when was Kim hired?|, where |when| demands that its MOD
;; (namely |hired| be [NORM no_rel], while |was| demands that |hired| be
;; [NORM norm_rel|.  So instead use the same MODIFD lmod feature on the
;; mother of the npadv_meas rule that we use here to block similar unwanted
;; ambiguity for |here earlier|.
;; DPF 2014-05-01 - Re DPF 2012-04-16: But this prevents npadv's from undergoing
;; adjunct extraction, blocking |Today, we are here.|  So let's try relaxing
;; the mother's MODIFD to notmod_or_lmod, and constrain its MOD..LPERIPH to
;; block npadvs from modifying other npadvs.
;; DPF 2018-03-10 - Re 2014-05-01: This hack is counterintuitive, and also
;; undesirable since it wrongly blocks modifying of partitives, which are 
;; LPERIPH na.  So remove, and maybe look for a different way to block double
;; modification, if desirable.  FIX?
;;
npadv_mod_phrase := basic_npadv_mod_phrase &
  [ SYNSEM [ LOCAL.CAT 
	       [ HEAD [ MINORS.MIN loc_nonsp_rel,
			MOD < [ LOCAL.CAT.VAL.SPR < synsem_min, ... > ] > ],
		 VAL.SPR < anti_synsem_min > ],
	     MODIFD notmod_or_lmod & [ LPERIPH na ] ],
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD [ MINORS.MIN modable_rel,
				       CASE real_case ],
		      MODIFD hasmod & [ LPERIPH + ] ] ] > ].

; For "Kim fell three meters."
; DPF 31-dec-08 - Added NORM norm_rel to prevent these from appearing in
; v_mod construction, as in "Kim has 46 cats"
; DPF 28-apr-09 - Generalized MOD..HEAD to v_or_a to allow 
; e.g. |Kim was low three liters|
; DPF 21-oct-09 - Added PRD - to prevent spurious ambiguity for "the distance
; is ten feet"
;; DPF 2012-10-14 - Tried adding MODIFD hasmod to dtr to block spurious 
;; |we arose years|, but this is wrong since ordinary binary meas-NPs are
;; also |MODIFD notmod|.
;; DPF 2012-12-17 - Added SPR..OPT + to improve parse-node labeling.
;; DPF 2014-06-11 - Let's return to constraining MOD to v_or_a, excluding
;; nouns to avoid spurious ambiguity for e.g. |ten cents a share|.  We'll
;; see where the nominal modification was desirable, but in general it seems
;; unwanted: |*the drop two feet was alarming|
;; DPF 2014-07-10 - Tempting to cnnstrain dtr to be nonconj, to avoid spurious
;; ambiguity for |prices rose 10% or 20%|. But this blocks 
;; |we arrive Nov. 2 or 3|.  So unless we add a non-head syntactic feature that
;; distinguishes between coord and non-coord structures, can't avoid this ambig.
;; DPF 2016-10-16 - Constraining the MOD to be HEAD v_or_a was too cautious,
;; since it blocks e.g. |we have been in Paris two weeks|.  So generalize.
;; DPF 2016-11-08 - Re 31-dec-08: But this blocks |she gave the questions
;; two days before the exam to the students|.  So change NORM from norm_rel
;; to quantity_rel, and generalize the vmod rule to allow quantities.
;; DPF 2017-06-24 - Re 21-oct-09: But this prevents coordination of these
;; NPadv phrases with other PPs, as in |wait two hours or until the afternoon|.
;; So removed PRD -; let's see how it goes.  FIX?
;; DPF 2017-07-17 - Changed dtr's SPR from synsem to synsem_min since we want
;; the rule to apply for |prices rose a modest 3%| where the measure-NP has an
;; *anti-list* for its SPR.
;; DPF 2017-11-17 - The [CASE no_case] on the dtr, intended to block bare
;; measure NPs as input here, as in |the fence was inches taller|, seems wrong
;; since these are probably good, and anyway it blocked the intended analysis
;; of |the price rose [$10 a share]|, so consider removing it later. 
;; FIX post-2017.
;; DPF 2018-11-30 - Re 28-apr-09 and 2016-10-16: Need to generalize further, to
;; subst, since we also want |the site 23 miles northeast of the city|.
;; DPF 2019-10-12 - Re 2018-11-30: But we don't want |The meeting two hours|,
;; so break this into two, one for non-nominal subst MOD, and one for nominal
;; MOD which also has to be post-modified.
;; DPF 2020-03-24 - Changed to MOD..HEAD subst from v_or_a_or_p as per trunk
;; DPF 2020-05-16 - Re 2016-11-08: Now we want |was two miles north| to use
;; this construction rather than the previous analysis with sp-hd_hc, so
;; generalize NORM from quantity_rel to quantity_or_norm_rel.  CHECK.
;;
npadv_measnp_phrase := basic_npadv_mod_phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS [ MIN miscprep_rel,
					 NORM quantity_or_norm_rel ],
				MOD < [ LOCAL.CAT
					  [ HEAD subst,
					    VAL.SPR < synsem_min, ... > ] ] >],
			 VAL.SPR < synsem &
				   [ --MIN just_only_degree_rel,
				     LOCAL [ CAT [ HEAD adv,
						   VAL.SPR *unexplist* ],
					     CONT.HOOK.LTOP #ltop ],
				     NONLOC non-local_none,
				     OPT + ] > ],
	     MODIFD lmod ],
    C-CONT.HOOK.LTOP #ltop,
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS.MIN num_or_meas_rel,
					 CASE no_case ],
				  VAL.SPR < synsem_min &
					    [ LOCAL.CAT.HEAD adv ] > ],
		      NONLOC.SLASH 0-dlist ] ] > ].

; DPF 5-Feb-01 - Restrict mother's SPEC..HEAD value to adj for now, to block
; silly analysis for e.g. "There are a bookcase in the office."
; DPF 22-Apr-01 - Added MODIFD identification of mother and left daughter to
; distinguish "an inch" from "one inch" as in "I need one inch nails" but not
; "*I need a inch nails".  Corresponds here roughly to left stress.
; DPF 8-Jan-02 - Removed above constraint on SPEC, since this also blocked
; "Kim arrived two days before Sandy".  Instead, prevent most PPs from taking
; measure-NP specifiers.
; DPF 11-Feb-02 - Made INDEX.SORT of phrase be that of right dtr to enable
; blocking of meas-NP analysis of "a laptop" in "Can you get me a laptop before
; Christmas"
; DPF 2-Apr-02 - Changed SPEC..HEAD from a_or_adv to a_or_p since we don't
; want "ten times competently".  Will need to do something for comparative
; adverbs like "faster" as in "ten times faster".
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 17-Jul-03 - Changed C-CONT.RELS deg_rel to much_or_very_deg_rel, since 
; we want MNP specifiers for comparatives as well, but still exclude them for
; e.g. subordinating conjunctions.
; DPF 10-dec-03 - Made DTR1 be COMPS < > to avoid spurious measure-NP for e.g.
; "thirty foot" - possible now that we've changed analysis for currency as in
; "usd 10"
; DPF 6-jun-04 - Changed SPEC..HEAD from a_or_p to n_or_p_or_a to also allow
; e.g. "ten weeks early"
; DPF 23-aug-04 - Considered extended it further to n_or_p_or_a_or_adv, to 
; allow "ten miles further on" where "further" is treated as a degree-spec,
; but this creates massive spurious ambiguity with constituents for e.g. 
; "peaks approximately".  And probably there's another analysis for 
; "further into the woods", at least one where that "further" is still a noun.
; DPF 08-Feb-06 - Added NORM norm_rel to avoid spurious N-N compound
; analysis for 'ten foot rope' (in addition to intended NP-N compound).
; DPF 25-may-09 - Leave SPR on mother unconstrained here, and in subtypes,
; either stamp < anti_synsem > or in normal binary rule, pass up from left
; dtr, to enable "the hundred mile road" but block 
; "*the hundred miles long road" since the meas_np_degadv rule requires 
; the dtr's SPR to be anti_synsem.
;; DPF 2012-09-18 - Moved DTR1.SYNSEM basic_lex_synsem down to bare-mnp,
;; to allow |ten percentage point rise| where the n-n cmpnd is lex_phr_synsem.
;; DPF 2018-03-12 - Added LPERIPH na_or_+ to block spurious adj-adjn analysis
;; for e.g. |benchmark ten-dollar stock|.
;; DPF 2020-04-18 - Change mother's SPEC from < > to < anti_synsem_min > so
;; we can get |the five cent a gallon tax| where |five cent| is a spr of
;; |a gallon| without being pumped to a bare NP as we were doing for
;; |$2 a gallon|, so it needs a non-empty SPEC value.
;; DPF 2020-04-21 - The 2020-04-18 change required corresponding change for
;; meas_np_degadv_phrase, allowing dtr to have non-empty SPEC. 
;;
basic_measure_np_phrase := phrase &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MINORS [ MIN meas_nom_rel,
                                                  NORM quantity_rel ],
                                         MOD < > ],
                           VAL [ SPEC < anti_synsem_min >,
				 SPCMPS < > ] ],
		     AGR.DIV +,
                     CONJ cnil ],
	     MODIFD.LPERIPH na_or_+ ],
    DTR1 [ INFLECTD #infl,
           SYNSEM abstr_lex_synsem &
                  [ LOCAL [ CAT [ HEAD noun &
                                       [ MINORS [ MIN abstr_meas_nom_rel,
                                                  ALTMIN udef_q_rel ] ],
                                  VAL [ SUBJ < >,
                                        SPR < canonical_synsem &
                                              [ --MIN udef_q_rel,
                                                OPT -,
                                                NONLOC [ SLASH 0-dlist,
                                                         REL 0-dlist,
                                                         QUE 0-dlist ] ] > ] ],
                            CONJ cnil,
                            CONT.HOOK.INDEX #nindex ],
		    NONLOC.SLASH 0-dlist,
                    MODIFD.LPERIPH bool ] ],
    C-CONT.HOOK.INDEX #nindex ].

; For "days ago", "miles high"
; DPF 15-Nov-03 - Made bare-MNPs HEAD adv to prevent "*days arrive(s)" etc.
; DPF 26-aug-04 - Restrict dtr to be MIN abstr_meas_nom_rel to exclude
; spurious edges for ordinary plural nouns.
; DPF 21-dec-05 - Re 15-Nov-03: This prevented "We arrive in hours", so
; instead make HEAD noun, but CASE obliq.
; DPF 10-aug-09 - Re 21-dec-05: But this prevents "miles remained" and
; "we use gallons".  So remove CASE obliq.
;; DPF 12-03-01 - Somehow we have not been supplying a udef quantifier to
;; bind the INDEX.  Fixed, but have to think about degadv usage as in 
;; |he arrived days later|.  FIX
;; DPF 12-08-03 - Re: 12-03-01 - The udef quantifier should come either
;; from the meas_np_degadv rule or from the bare_np rule, so not from here.
;; We force the bare-meas phrase to under the bare_np rule by making the
;; SPR be [OPT -].  Also changed SPR from anti_synsem_min to unexpressed_rel, 
;; since we had lost |miles high| with |miles| undergoing the meas_np_degadv 
;; rule, where that dtr is [ SPR < synsem > ].  Sigh.
;; DPF 2012-10-14 - Tried constraining mother to MODIFD notmod (preserved from 
;; dtr) to avoid these undergoing npadv rule for spurious analysis of 
;; |Kim arose years|.  But this doesn't help, since for independent reasons
;; we also make binary meas-NPs be MODIFD notmod, and we need the npadv_meas
;; rule to take those as dtrs, of course. Besides, already adopted a hack
;; via CASE on |dollars| for this purpuse, so generalize to other measure-nouns
;; that we don't want as bare npadv.  Also added no_case to dtr, to block
;; these non-bare measure-nouns as input to this rule.
;; DPF 2020-04-24 - Added SPR < [ ], anti_synsem_min > to still get
;; |miles high|, with |miles| as mnp_deg-adv.
;;
bare_measure_np_phrase := basic_unary_phrase & basic_measure_np_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.ALTMIN udef_q_rel,
				  CASE no_case ],
			   VAL [ SPR < unexpressed_reg & [ OPT - ],
				       anti_synsem_min >,
				 COMPS < > ] ],
		     AGR #agr ],
             NONLOC [ SLASH 0-dlist,
                      REL 0-dlist,
		      QUE 0-dlist ],
	     LEX +,
	     PUNCT #punct ],
    DTR1 #dtr1 & [ INFLECTD +,
		   SYNSEM basic_lex_synsem &
			 [ LOCAL [ CAT [ HEAD [ MINORS [ MIN abstr_meas_nom_rel,
							 NORM quantity_rel ],
						CASE no_case ],
					  VAL.COMPS < > ],
				    CONT.HOOK [ LTOP #ltop,
						INDEX #index ],
                                    AGR #agr & [ PNG.PN 3p ] ],
                            MODIFD notmod,
                            LEX +,
			   PUNCT #punct ] ],
    ARGS < #dtr1 >,
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX #index ],
	     RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 12-Apr-03 - Added CARDINAL + to DTR2 to block e.g. 'first day' as meas-NP
; DPF 27-jul-04 - Removed DTR2..SPR *olist* to get 'the million dollar view'
; DPF 20-aug-04 - Removed MODIFD notmod, since this prevents "ten miles east"
; from being an np_adv_c, since the sp-hd_n_c rule takes its MODIFD value from 
; the non-hd dtr.  Don't know what this constraint was ruling out - we'll see.
; DPF 19-nov-04 - Considered making mother be MODIFD lmod, in order to avoid 
; seemingly spurious ; attachment of posthead modifiers to measure-NP, as in 
; "ten dollars that Kim hired".  (The current analysis of "ten miles east" has 
; "ten miles" as a specifier of "east".)  But this constraint would block e.g.
; "ten miles on artificial snow is hard work", so we live with the ambiguity.
; DPF 24-may-10 - (Re 27-jul-04) Again tried removing DTR2..SPR *olist* since 
; we want "the million dollar house".  Assume the mnp-deg-spec rule will 
; ensure that we block "*the mountain is thousand meters high" while allowing 
; "the thousand-meter high mountain".
;; DPF 2012-04-09 - Re 24-may-10, note that we keep putting this *olist* back.
;; If remove it, then need to change bare-np rule to require its dtr's SPR
;; list to have REST be *olist*.
;; DPF 2012-09-12 - Re 20-aug-04 and 19-nov-04: It is clear that we want to
;; allow rightward modification, as in |ten miles on snow is fun|, so we
;; can't stamp MODIFD lmod on mother; and also clear that we can't stamp
;; MODIFD notmod on mother, since we want |ten miles east| to be able to be
;; np_adv.  But we also want to block spurious adj_adjn for |big ten feet|
;; so let's try MODIFD.LPERIPH + on mother.
;; DPF 2012-09-28 - But LPERIPH + also blocks N-N compounds where the meas-NP
;; is in the head-dtr, as in |benchmark 10% rate|, and anyway the npadv_mnp
;; rule does not mind its dtr with MODIFD notmod, so we go back to notmod.
;; DPF 2017-07-06 - We can't propagate CASE from noun dtr to mother, since
;; we're using [CASE no_case] on some meas nouns to prevent them as bare NP
;; modifiers as in |*the market rose dollars|.  We'll see what that identity
;; was intended to do.  FIX??
;; DPF 2017-09-15 - To avoid spurious ambiguity with nbar-coord for
;; |two-year and three-year notes|, make the LEX value the same as that of DTR1
;; Also, push [PN 3s] down to the subtype for |ten foot|, leaving it underspec
;; for |$10 million|, so we can allow |$10 million were invested|.
;; DPF 2020-04-16 - Removed identity of COMPS on mother and DTR2 (normally
;; empty), since the value of COMPS is now constrained in subtypes.
;; DPF 2020-05-16 - The reason for appending the SPR of the adj dtr to the 
;; mother's SPR seems to be to block |hundred years elapsed|, but having it 
;; prevents analysis of |the past hundred years|.  Instead, since bare-NP rule
;; requires dtr to be RPERIPH +, we propagate RPERIPH from adj dtr, and have
;; |hundred| etc be RPERIPH -.  But still need to have mother's SPR.REST be
;; compatible with *unexpcons* so these can undergo mnp_deg_adv rule which
;; has additional constraints on its dtr.
;;
#|
binary_measure_np_phrase := binary_punct_phrase & basic_measure_np_phrase &
  [ SYNSEM [ LOCAL [ CAT [ VAL.SPR < synsem & 
				     [ --MIN quant_rel,
				       LOCAL.CAT [ HEAD det,
						   VAL [ SUBJ < >,
							 SPR *olist* ] ],
				       OPT - ] . #spr2 > ],
		     CONT.HOOK.INDEX.PT #prontype,
		     AGR.PNG.PN 3 ],
	     LEX #lex,
	     NONLOC.QUE #que,
	     PHON.ONSET #onset,
	     MODIFD notmod ],
    DTR2 [ INFLECTD +,
           SYNSEM 
	   [ LOCAL [ CAT [ HEAD intadj_or_comp & 
			   [ CARDINAL +,
			     MINORS.MIN const_or_meas_rel,
			     MOD < synsem &
				   [ PHON.ONSET #monset,
				     --MIN #min,
				     LOCAL [ AGR #agr,
					     CAT.HEAD.CASE #case ] ] >,
			     CASE #case ],
			   VAL [ SPR #spr2 & *unexplist*,
				 COMPS *phrlist* ] ],
		     CONT.HOOK [ LTOP #nhand,
				 INDEX [ E [ TENSE no_tense,
					     ASPECT no_aspect ],
					 PT #prontype ],
				 XARG #index ],
		     CONJ cnil ],
	     NONLOC [ SLASH 0-dlist,
		      QUE #que ],
	     PHON.ONSET #onset,
	     LEX + ] ],
    DTR1.SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN #min,
				       CASE #case ] ],
			  CONT.HOOK [ LTOP #nhand,
				      INDEX #index ],
			  AGR #agr ],
		  LEX #lex,
		  PHON.ONSET #monset ],
    C-CONT [ HOOK.LTOP #nhand,
	     RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].
|#
binary_measure_np_phrase := binary_punct_phrase & basic_measure_np_phrase &
  [ SYNSEM [ LOCAL [ CAT [ VAL.SPR < synsem & 
				     [ --MIN quant_rel,
				       LOCAL.CAT [ HEAD det,
						   VAL [ SUBJ < >,
							 SPR *olist* ] ],
				       OPT - ], unexpressed &
				                [ LOCAL.CAT.HEAD adv,
						  --MIN never_unify_rel ] > ],
		     CONT.HOOK.INDEX.PT #prontype,
		     AGR.PNG.PN 3 ],
	     LEX #lex,
	     NONLOC.QUE #que,
	     PHON.ONSET #onset,
	     MODIFD notmod & [ RPERIPH #rperiph ] ],
    DTR2 [ INFLECTD +,
           SYNSEM 
	   [ LOCAL [ CAT [ HEAD intadj_or_comp & 
			   [ CARDINAL +,
			     MINORS.MIN const_or_meas_rel,
			     MOD < synsem &
				   [ PHON.ONSET #monset,
				     --MIN #min,
				     LOCAL [ AGR #agr,
					     CAT.HEAD.CASE #case ] ] >,
			     CASE #case ],
			   VAL [ SPR *unexplist*,
				 COMPS *phrlist* ] ],
		     CONT.HOOK [ LTOP #nhand,
				 INDEX [ E [ TENSE no_tense,
					     ASPECT no_aspect ],
					 PT #prontype ],
				 XARG #index ],
		     CONJ cnil ],
	     NONLOC [ SLASH 0-dlist,
		      QUE #que ],
	     PHON.ONSET #onset,
	     MODIFD.RPERIPH #rperiph,
	     LEX + ] ],
    DTR1.SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN #min,
				       CASE #case ] ],
			  CONT.HOOK [ LTOP #nhand,
				      INDEX #index ],
			  AGR #agr ],
		  LEX #lex,
		  PHON.ONSET #monset ],
    C-CONT [ HOOK.LTOP #nhand,
	     RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].


; DPF 16-May-01 - Cannot have [DTR1..COMPS < >] (as desired to avoid spurious
; parse for "he is ten pounds heavier" where "pound" takes optional pp-of),
; since cannot discharge that optional complement if the noun is uninflected,
; as in "the ten pound heavier guy".  So allow spurious analysis for now.
; DPF 21-oct-09 - The SPR of the mother should not be identified with that of
; the right dtr, since it should always be < anti_synsem_min> in order to
; be able to undergo the rule for mnp_deg_c, asin "several feet tall"
;; DPF 2018-06-06 - For next relase, relax 3s constraint AGR..PN to 3s so we
;; can analyze  |those first five kilometers were challenging|.  TO DO.
;; DPF 2020-04-29 - Identify MOD..LPERIPH of adj-dtr with mother, to enable
;; blocking of |tall a foot|
;;
norm_measure_np_phrase := binary_measure_np_phrase &
  [ SYNSEM [ PUNCT.PNCTPR #ppair,
	     LOCAL.AGR.PNG.PN 3s,
	     MODIFD.LPERIPH #lperiph ],
    DTR1 #dtr1 & [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.NORM quantity_rel,
					VAL.COMPS < > ],
			    PUNCT.PNCTPR #ppair ] ],
    DTR2 #dtr2 &
         [ SYNSEM [ PUNCT.RPUNCT hyphen_sgl_or_no_punct,
		    LOCAL.CAT.HEAD.MOD.FIRST.MODIFD.LPERIPH #lperiph ] ],
    ARGS < #dtr2, #dtr1 > ].

;; DPF 2020-04-26 - Propagate ORTH.CLASS from right dtr to mother (for now)
;; to enable restricting of mnp_vp_phr to only meas-NPs with `%'.
;;
measure_np_phrase := norm_measure_np_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
	     NONLOC.SLASH 0-dlist ],
    ORTH.CLASS #class,
    ARGS.REST.FIRST.ORTH.CLASS #class ].

;; DPF 2020-04-16 - For extraction of pp-of in pied piping, as with
;; |these accounts, of which ten percent are overdrawn|
;;
measure_np_ppof_phrase := norm_measure_np_phrase &
  [ SYNSEM [ LOCAL [ CAT.VAL.COMPS < [ --MIN _of_p_sel_rel,
				       LOCAL [ CAT [ HEAD prep & 
							  [ PRD -,
							    TAM.TENSE nontense],
						     VAL.COMPS < > ],
					       CONT.HOOK [ LTOP #lbl,
							   INDEX #arg ] ],
				       NONLOC [ REL #rel,
						SLASH #slash ],
				       OPT - ] >,
		     CONT.HOOK.LTOP #lbl ],
	     NONLOC [ REL #rel,
		      SLASH #slash ] ],
    DTR1.SYNSEM.LOCAL.CONT.HOOK.XARG #arg ].

; For $ 100 (100 dollars) where the head precedes the integer.  
; DPF 16-May-01 - Suggests that the rule for measure_nps should be a 
; non-branching rule.  Especially given the difficulty of pp-of nouns noted 
; just above. But would have to allow "sixty" and "dollar" to combine in
; general, then block most of the time - sigh.  Leave for now.
;; DPF 2012-09-12 - To trim down ambiguity, let's try excluding conjoined
;; numerals here, as in dubious |$20 or 30|
;; DPF 2017-09-15 - Leave the number unmarked for these, so we allow both
;; |$10 million are invested| and |$10 million is invested|.  It may be that
;; a better account would produce a partitive analysis of |$10 million| for
;; `are invested', so maybe FIX someday.
;; Also added CASE real_case to mother, to avoid these as input to the
;; bare meas-NP rule.
;; DPF 2017-11-18 - But the CASE constraint blocks |prices rose $10|, so
;; instead let's constrain the mother synsem here to be lex_phr_synsem,
;; incompatible with the dtr in bare_measure_np_phrase.
;; DPF 2020-03-30 - Changed INFLECTD + to na_or_+, to get |$10 Cabernet|
;;
measure_np_symbol_phrase := binary_measure_np_phrase & 
  [ SYNSEM lex_phr_synsem &
	   [ PUNCT.PNCTPR #ppair,
	     LOCAL.CAT.VAL.COMPS < >,
	     NONLOC.SLASH 0-dlist,
	     --SIND.PNG png-unsp ],
    DTR1 #dtr1 & [ INFLECTD na_or_+,
		   SYNSEM [ LOCAL.CAT [ HEAD.MINORS [ MIN mnp_symb_rel,
						      NORM norm_rel ],
					VAL.COMPS *anti_cons* ],
                            PUNCT.RPUNCT no_punct ] ],
    DTR2 #dtr2 & [ SYNSEM [ PUNCT.PNCTPR #ppair,
			    LOCAL.CONT.HOOK.INDEX non_conj_event ] ],
    ARGS < #dtr1, #dtr2 > ].

; DPF 18-jul-06 - Added ARGS..MODIFD notmod_or_lmod to still block
; (((ten meters) (in Paris)) (under Berlin)) while once again allowing
; "directly down under Berlin".
;; DPF 2012-04-08 - Propagate POSTHD from SPEC, to block e.g.
;; |the three-foot taller than Kim tree|
;; DPF 2012-09-12 - Let's try blocking these as spr's of nominal phrases,
;; (changing HEAD n_or_p_or_a to a_or_p), to avoid extra ambiguity of e.g. 
;; |Kim arose a year earlier| where |earlier| is the noun.
;; DPF 2020-04-21 - Changed dtr to be SPEC *anti_list* instead of < >, since
;; changed basic_measure_np_phrase to have non-empty SPEC (see 2020-04-18
;; there).
;; DPF 20-05-15 - Block spurious |[ten cents] [a share]| where |a share| is
;; itself npadv-mnp, by adding NORM norm_or_no_rel.  Also add NORM quantity_rel
;; to block |a share| as itself mnp-degadv.
;; DPF 20-05-16 - Generalize dtr's MIN from meas_nom_rel to abstr_meas_nom_rel,
;; now that we have dropped the unary meas-NP rule.  Also added hack similar
;; to that for meas-NP, imposing CASE no_case on dtr to exclude nouns such as
;; mass "time" whose MIN is compatible with abstr_meas_nom_rel.  FIX someday.
;;
meas_np_degadv_phrase := basic_unary_phrase &
  [ INFLECTD #bool,
    SYNSEM phr_degree_spec_synsem &
           [ LOCAL [ CAT [ HEAD adv & 
                                [ MINORS [ MIN much_or_very_deg_rel,
                                           ALTMIN #min,
					   NORM quantity_rel ] ],
                           VAL [ SPEC < synsem &
                                       [ LOCAL [ CAT [ HEAD n_or_a_or_p_or_adv &
							[ MINORS.NORM 
							  norm_or_no_rel ],
						       POSTHD #ph ],
                                                 CONT.HOOK.LTOP #sphand ] ] >,
                                 SPR < [ LOCAL.CAT.HEAD adv,
					 LEX + ] >,
                                 COMPS < > ],
			   POSTHD #ph ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
	     PUNCT #punct ],
    ARGS < [ INFLECTD #bool,
             SYNSEM [ LOCAL [ CAT [ HEAD noun & 
                                         [ MINORS.MIN #min & 
						      abstr_meas_nom_rel,
					   CASE no_case ],
                                    VAL [ SPR.FIRST synsem & 
						    [ LOCAL.CAT.HEAD det ], 
					  COMPS *olist*,
                                          SPEC *anti_list* ] ],
                              CONT.HOOK [ LTOP #nhand,
					  INDEX #nindex ],
                              CONJ cnil ],
		      NONLOC non-local_none_phr,
                      MODIFD notmod,
		      PUNCT #punct ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #sphand,
                    INDEX #nindex,
                    XARG #argind ],
             RELS <! arg12_relation & 
                     [ PRED measure_rel,
                       LBL #sphand,
                       ARG0.E [ TENSE no_tense,
                                ASPECT no_aspect ],
                       ARG1 #argind,
                       ARG2 #nindex,
		       CFROM #from, CTO #to ],
		     [ PRED udef_q_rel,
		       ARG0 #nindex & ref-ind,
                       RSTR #rhand,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq &
                      [ HARG #rhand,
                        LARG #nhand ] !>,
	     ICONS <! !> ] ].

; If used with attrib adj, the integer need not have picked up its specifier:
; |the hundred meter tall building| or |the one hundred meter tall building|
;; DPF 2020-05-23 - To avoid overlap of this with the bare variant below,
;; constrain dtr to nonlex_synsem
meas_np_degadv_attr_phrase := meas_np_degadv_phrase &
  [ INFLECTD #bool,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD [ PRD - & #bool ] ] >,
    ARGS.FIRST.SYNSEM nonlex_synsem ].

;; DPF 2020-03-25 - Added for the special case of |the centuries-old house|
;; where bare plural meas noun can be degree-specifier with attrib adj.
;; DPF 2020-04-27 - Need dtr's CASE no_case to block non-bare measure nouns
;; such as |cents|, but this already comes from parent type.
;; DPF 2020-05-16 - Need dtr MODIFD notmod to avoid this rule for |four times|,
;; but this already comes from parent type.
;; DPF 2020-05-23 - Block bare |$| as dtr
;;
meas_np_degadv_bare_attr_phrase := meas_np_degadv_phrase &
  [ INFLECTD +,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.PRD - ] >,
    ARGS < [ SYNSEM basic_lex_synsem &
		    [ LOCAL.AGR.PNG.PN 3p ] ] > ].

; If used with predicative adj, the integer must have picked up its specifier:
; |*the building is hundred meters tall|
;; 20-04-21 - Constrain dtr to nonlex_synsem, to prevent NP-N cmpnd dtr as in 
;; |40 kilometers tall|.
;; 20-04-23 - Re 20-04-21: But this excludes |$10| which is also lex_phr_synsem.
;; so instead constrain SPR.REST to *unexpcons* instead of *unexplist*, which
;; excludes compounds but allows both types of measure phrases.
;; DPF 20-05-16 - Generalized SPEC..HEAD from a_or_adv to a_or_p_or_adv to
;; get |is two miles away|
;;
meas_np_degadv_pred_phrase := meas_np_degadv_phrase &
  [ INFLECTD #bool,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD a_or_p_or_adv & 
						 [ PRD + & #bool ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.VAL.SPR.REST *unexpcons* ] ] > ].

; DPF 5-Apr-01 - For "two hundred is enough"
; DPF 13-May-01 - Added [SYNSEM..LPERIPH +] to prevent these numbers from
; being modified.
; DPF 31-Oct-01 - But this blocks "order 123 for a chair was cancelled."
; DPF 22-May-01 - Added [LEX -] to prevent these from appearing as left members
; of noun-noun compounds as in "sixty books".
; DPF 29-May-02 - Removed MOD < synsem > from ARGS.FIRST, so "one" can also
; undergo this rule.
; DPF 31-May-02 - Added [ARGS..FIRST..HEAD.PRD -] to block "a/an"
; DPF 19-Oct-02 - Want to preserve LEX value on mother from dtr, so change
; from 22-May-01 and instead make mother be ALTMIN never_unify_rel, to still 
; prevent n-n-cmpnd participation.  Also make sign not phrasal.
; DPF 28-Nov-02 - HOOK comes only from C-CONT, since rule further specifies
; keyrel integer relation to named_num_rel.
; DPF 01-Feb-03 - Required daughter's SPR to be saturated, to block e.g.
; "*hundred arrives".
; DPF 23-May-03 - Returned to issue from 31-Oct-01, and put back constraint
; preventing modification - getting too many spurious parses for "ten to three"
; and that purported counterexample is presumably non-restrictive modification
; of some kind (cf oddness of NP without title: "123 for a chair").
; DPF 5-Sep-03 - Changed ALTMIN never_unify_rel to number_q_rel so it will
; still undergo hdn_bnp-num_c rule.
; DPF 5-Sep-03 - Added CARDINAL + to prevent num. "third" from becoming a noun.
; DPF 16-oct-03 - Added SORT number to mother, to prevent "Abrams five" compnd.
; DPF 03-may-04 - But this SORT constraint prevented e.g. "that box is number
; five" and "my candidate, number five, lost".  So instead make use of the
; nonpro_rel constraint on heads of N-N-compounds, and make named_num_rel not
; be a subtype of nonpro_rel.
; DPF 03-may-04 - Changed SPR number_q_rel to def_or_proper_q_rel (and same
; for HEAD..ALTMIN) to also allow "My (number) five arrived" 
; DPF 03-may-04 - Changed LPERIPH from + to na in order to prevent simple
; num-nouns from appearing as appositives ("*Abrams five"), while allowing
; modified numbers there ("Abrams, number five, arrived")
; DPF 07-jul-06 - Recently added MODIFD lmod to block aj-hdn_adjn_c rule, but
; this interacts badly with constraint on titles as in "Highway 66 near Phx"
; so change to notmod instead.
; DPF 31-dec-08 - RE 03-may-04: SPR.--MIN needs to be more general, to allow
; "She rolled a six", "Every six is even".
;; DPF 2012-12-21 - Constrain SPR..HEAD to prevent e.g. reduced rels
;; DPF 2014-03-07 - Moved INFLECTD + down to number subtype, so we can get
;; color nouns in compounds, as in |the red-green light|
;;
num_or_color_noun_phrase := basic_unary_phrase &
  [ SYNSEM [ LOCAL [ CAT basic_nbar_cat & 
                         [ HEAD noun & [ MOD < > ],
                           VAL [ SPR < [ --MIN quant_rel,
                                         LOCAL [ CAT [ HEAD det,
					               VAL.SPR *olist* ],
                                                 AGR.PNG.PN 3s ],
					 NONLOC [ QUE #que,
						  REL #rel ],
                                         OPT - ] >,
                                 SPEC < anti_synsem_min >,
				 SPCMPS < > ] ],
                     CONT nom-obj &
                         [ HOOK [ LTOP #nhand,
                                  INDEX #index & nonconj_ref-ind &
                                       [ SORT entity,
                                         PNG.PN 3s ] ]],
                     CONJ cnil,
                     AGR.PNG.PN 3s ],
             NONLOC [ SLASH 0-dlist,
		      QUE #que,
		      REL #rel ],
             LEX #lex,
             MODIFD.LPERIPH #lperiph,
	     PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD adj_or_intadj &
					 [ MINORS.MIN integer_or_color_rel,
					   PRD - ],
				    VAL.COMPS < > ],
                              CONJ cnil,
                              CONT.HOOK [ LTOP #nhand,
                                          INDEX #index & nonconj_indiv ] ],
                      LEX #lex,
		      NONLOC.SLASH 0-dlist,
                      MODIFD notmod & [ LPERIPH #lperiph ],
		      PUNCT #punct ] ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 14-nov-09 - Can't make integers be of SORT `number' distinct from
; 'entity' (tempting, to block "Abrams one") because we also want
; "Kim is ten" which we currently treat as identity-copula with NP "ten"
;; DPF 2014-10-14 - Added DIV - to mother, to avoid this phrase undergoing
;; bare_np rule (spurious alongside the intended hdn_bnp-num_c).
;; DPF 2015-09-05 - Surprisingly, identify CASE on dtr and mother, so we can
;; stop roman numerals from eventually being admitted by the npadv rule, to
;; avoid spurious analysis for |I arrive| where the roman numeral |I| has
;; been made into an adverbial, and extracted from the imperative |arrive|.
;; DPF 2016-04-16 - The SPEC *synlist* constraint on the daughter unhappily
;; blocks "six hundred" as in "six hundred is a large number".  Let's try
;; removing it, and see if we can reconstruct why it was there.
;
basic_num_noun_phrase := num_or_color_noun_phrase &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT.HEAD [ MINORS.MIN #altmin & named_num_or_fract_rel,
				CASE #case ],
		     CONT.HOOK.INDEX.SORT entity,
	     AGR.DIV - ],
	     PHON #phon ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD [ CARDINAL +,
					 MINORS [ MIN integer_rel,
						  ALTMIN #altmin ],
					 CASE #case ],
				  VAL [ SPR *anti_list* ] ],
		      PHON #phon ] ] > ].

num_noun_phrase := basic_num_noun_phrase &
  [ SYNSEM.MODIFD notmod ].

;; DPF 2019-03-27 - Added ARGS..SPR *olist* to prevent oblig-spr adjectives
;; such as "like" from having this rule apply.
;; DPF 2020-03-24 - Added ARGS..SPR *olist* as per trunk.
;;
color_noun_phrase := num_or_color_noun_phrase &
  [ INFLECTD bool,
    SYNSEM [ LOCAL [ CAT.HEAD.MINORS [ MIN norm_nom_rel,
				       NORM norm_rel ],
		     CONT.HOOK.INDEX.SORT entity ],
	     MODIFD notmod ],
    ARGS < [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.MIN color_rel,
				VAL.SPR *olist* ] ] > ].

; DPF 19-Oct-02 - Restricted dtrs to be LEX + to avoid spurious ambiguity
; for e.g. "two thirty to five".  Also made mother LEX + to allow recursion,
; removing phrasal parent as well, 
; and made mother ALTMIN number_q_rel to still prevent these guys in 
; n-n-compnds.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 02-jul-09 - Added HD-DTR..LPERIPH na to prevent these from heading
; np_title_cmpnd_phr, as in "June 12, 2002".  Also added nonconj_ref-ind
; to each dtr, to avoid spurious analysis for "2002 and Kim, 2004"

num_noun_sequence_phrase := binary_phrase &
 [ SYNSEM [ LOCAL [ CAT nomp_cat & 
                        [ HEAD noun & 
                               [ MOD < >,
                                 MINORS [ MIN num_seq_nom_rel,
                                          ALTMIN number_q_rel ] ],
			  VAL.SPCMPS < > ],
                    CONT nom-obj &
                        [ HOOK [ INDEX #index & [ SORT #sort ] ] ],
                    CONJ cnil,
                    AGR #index & [ PNG.PN 3s ] ],
            NONLOC #nonlocal,
	    MODIFD.LPERIPH na,
            LEX +,
            PUNCT.PNCTPR #ppair ],
   ARGS < [ SYNSEM [ LOCAL [ CAT nomp_cat &
                                 [ HEAD [ MINORS.MIN named_num_or_seq_rel ] ],
                             CONJ cnil,
                             CONT.HOOK.INDEX nonconj_ref-ind & #index1 ],
                     NONLOC #nonlocal,
                     PUNCT.RPUNCT hyphen_sgl_or_no_punct,
                     LEX + ] ],
          [ SYNSEM [ LOCAL [ CAT nomp_cat &
                                 [ HEAD.MINORS.MIN named_num_rel ],
                             CONJ cnil,
                             CONT.HOOK.INDEX nonconj_ref-ind & #index2 & 
				             [ SORT #sort ] ],
                     NONLOC #nonlocal,
                     PUNCT [ RPUNCT comma_or_rbc_or_clause_or_pair_or_no_punct,
                             PNCTPR #ppair ],
                     LEX + ] ] >,
   ORTH [ FROM #from, TO #to ],
   C-CONT [ RELS <! [ PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #rhand,
		       CFROM #from, CTO #to ],
		    [ LBL #nhand,
		      PRED num_seq_rel,
		      ARG0 #index & ref-ind,
		      ARG1 #index1,
		      ARG2 #index2,
		      CFROM #from, CTO #to ] !>,
	    HCONS <! qeq &
                      [ HARG #rhand,
                        LARG #nhand ] !>,
	    ICONS <! !> ] ].


; DPF 12-Mar-99 - Can't simply identify HEAD of HD-DTR with SLASH..HEAD of 
; NH-DTR, since these two HEAD values themselves include MOD, which 
; includes SUBJ values, which include CONT, and since the free relative
; combines with an S (not a VP), that SUBJ.CONT of the S/NP is now identified
; with the semantics of the S/NP's subject, but now it's not possible to
; use the free_rel phrase as a VP modifier, because it will eventually want to
; unify that same MOD.SUBJ.CONT with that of the subject of the VP that the
; free_rel modifies, but the RELS value of that attribute is already bound to 
; the earlier subject's RELS.
;   So we have each free-rel lexical entry specify the relevant constraints on
; the SLASH of its sister in this construction.
;   The QUE value of the free relatives is a singleton list containing an index
; instead of a handle - this distinguishes free relatives from question words,
; and makes available this index for interpretation at the ltop of the phrase,
; which may be desirable if there is indeed ambiguity in the meaning of
; examples like "I'll interview whoever's frog wins this race."  (We're not
; doing anything with that index just now, beyond checking for its presence.)
; DPF (1-May-99) Removed identification of HD-DTR..MIN and NHD-DTR..SLASH..MIN
; since the slash's MIN is already identified with the main verb's MIN in the
; non-head dtr, for independent reasons.  Don't know what work this was 
; supposed to do, anyway.
;
; DPF 10-Jun-99 - Added SUBJ *olist* to head-dtr, to prevent e.g. "one to three".
; DPF 24-Mar-01 - Removed [MODIFD notmod] from mother, since free-rels need
; to be able to undergo npadv_mod_phrase.

; DPF 8-Nov-01 - Made non-hd-dtr be either infinitival or finite in
; order to get "advise me on where to go" as well as "advise me on where I 
; should go"
;; DPF 2010-jul-21 - Changed SUBJ < > to SUBJ < anti_synsem_min > to block
;; free relatives in appositives and as possessive NPs.  Maybe not strictly
;; impossible, but let's exclude them for now.  FIX?
;; DPF 2010-sept-09 - Changed HD-DTR..SPR *olist* to *anti_list*, since we
;; recently added second SPR list element (anti_synsem) which is marked OPT - 
;; (for reasons not immediately recallable).
;; DPF 2012-11-14 0 Added phr_synsem to HD-DTR to enforce the discharging
;; of the optional SPR for free relatives, to avoid spurious ambiguity.
;; DPF 2017-09-12 - Removed identity of hd-dtr's XARG with LTOP of nh-dtr
;; (see note on same date for generic_bare_np_phrase).
;;
basic_free_rel_phrase := head_initial_infl &
  [ SYNSEM [ LOCAL [ CAT [ HEAD n_or_p,
			   MC na,
			   VAL [ SUBJ < anti_synsem_min >,
				 COMPS < >,
				 SPR #spr,
                                 SPEC < anti_synsem_min >,
				 SPCMPS < > ],
			   POSTHD + ],
                     CONJ cnil ],
	     NONLOC [ SLASH 0-dlist,
		      QUE 0-dlist,
		      REL 0-dlist ],
	     MODIFD #modif,
             LEX -,
             PUNCT.PNCTPR #ppair ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN independent_rel,
                                  VAL [ COMPS < >,
					SPR #spr & [ FIRST unexpressed &
							   [ OPT - ] ],
					SUBJ *olist* ] ],
			    CONT.HOOK [ LTOP #ltop,
					INDEX #index,
					XARG #xarg  ] ],
		    MODIFD #modif,
		    NONLOC [ QUE 1-dlist & <! ref-ind !>,
                             SLASH 1-dlist ],
                    PUNCT.RPUNCT no_punct ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VFORM fin,
						INV -,
						TAM #tam & [ MOOD indicative ],
						--ADDIN [ ADDTAM #tam,
							  ADDPN #pn ] ],
                                  VAL [ SUBJ *olist*,
					SPR *olist*,
                                        COMPS < > ],
                                  MC - ],
			    AGR.PNG.PN #pn,
                            CONT [ HOOK [ LTOP #ltop,
					  INDEX.SF prop ] ] ],
                    NONLOC [ QUE 0-dlist,
                             REL 0-dlist ],
                    PUNCT.PNCTPR #ppair ],
    C-CONT [ HOOK [ INDEX #index,
		    XARG #xarg ],
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

free_rel_phrase := basic_free_rel_phrase &
  [ HD-DTR.SYNSEM.NONLOC.SLASH <! #loc !>,
    NH-DTR.SYNSEM.NONLOC.SLASH 1-dlist &
                                   <! #loc & [ CAT.VAL [ COMPS < >,
							 SPR *olist* ] ] !> ].
;; DPF 2020-07-02 - Add variant for "We did what we could" where there is no
;; gap, but instead VP-ellipsis
;;
free_rel_ellip_phrase := basic_free_rel_phrase &
  [ NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN ellipsis_rel,
		    NONLOC.SLASH 0-dlist ] ].

; For "two hundred twenty remain"
; DPF 31-May-02 - Added [ARGS..FIRST..HEAD.PRD -] to block "a/an"
; DPF 3-Jul-02 - Added [ARGS..INDEX..PN 3p] to block "one", since already
; get determiner-partitive for "one".
; DPF 19-Oct-02 - Made SPR be LEX + to avoid getting complex measure-NPs
; as specifiers.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 01-Feb-03 - Since we now require the COMPS list to be empty for all NPs,
; and we also constrain the hdn_optcmp_c rule to apply only to lexical heads (to
; get the interaction with noun-noun compounds right), we have to have two
; rules for partitive numbers, one for no-complement ones as in "three arrive"
; and one for those with of-PP complement, as in "three of them arrive".  This
; is in fact parallel to what we've decided to do for ordinary partitives, so
; no real surprise.
; DPF 13-May-03 - From 3-Jul-02, undid this since now using this rule instead
; for "one" partitive.
; DPF 05-Dec-03 - Added [SORT entity] to prevent spurious parses for 'from ten
; o'clock to eleven'.
; DPF 10-dec-03 - ARGS..SPEC *synlist* excludes ordinary NPs which have
; SPEC < anti_synsem > to distinguish them from measure NPS.  So this rule
; applies to numerals ('ten', 'forty-two') and measure NPs: 'ten miles of road'
; DPF 20-sept-04 - Removed SPR..QUE 0-dlist from mother, since we need e.g.
; "which one (of the students) arrived?"
; DPF 7-mar-05 - Removed ARGS..MOD < [ LOCAL.AGR #index ] > since this
; prevented meas-NPs from undergoing it.  Maybe redundant anyway?
; DPF 14-mar-05 - Added LPERIPH na to prevent these from being modified by 
; pre-head cardinal adjectives, as in spurious "The twenty seven arrive"
; DPF 14-apr-05 - Added MODFID notmod to dtr, to prevent "*three in paris of
; the chairs".
; DPF 08-jul-06 - Re: 7-mar-05: Once again removed SPR..QUE 0-dlist, which
; somehow crept in again here.  Let's try instead pushing this constraint
; down to partitive_np_num_phrase, to avoid WH-adv specifiers for NP
; partitives, while still allowing them for nbar-partitives.
; DPF 15-jul-06 - Re 05-Dec-03: But this blocks coordinations like
; "We stayed for two days or three." - Not really spurious, just uncooperative.
; So removed constraint.
; DPF 27-apr-08 - Added ARGS..MODIFD notmod, at least to block spurious 
; aj-hdn_adjn_c analysis of "tall one" with partitive_intadj_nocomp_rule.  
; We'll see if this was too ambitious.
; DPF 28-apr-08 - Well, yes, too ambitious - this blocks "a hundred" with
; partitive_num_nocomp.  So move notmod down to partitive_intadj_phrase.
; DPF 2010-08-31 - Re 14-mar-05: But this also blocks "the two oldest", so
; push constraint down to subtype partitive_np_num_phrase.
; DPF 2011-04-16 - Re 31-May-02: Removed [PRD -] from dtr, in order to allow
; |this many arose|.  Okay since already using NORM attribute to block |a/an|
; while allowing |one| here.
;; DPF 2014-06-01 - Identified SLASH of mother and dtr (formerly unconstrained)
;; DPF 2017-07-14 - Further restricted C-CONT..INDEX from overt_non_expl-ind
;; to nonconj_overt-ind, in order to avoid spurious ambig with the possessive
;; |'s| for conjoined NPs.
;; DPF 2017-10-03 - Constrain dtr's MOD to be unexpressed, so we can exclude
;; adjs that are only to be used attributively, such as robust `fewer'.
;; DPF 2018-06-06 - Constrain dtr's MODIFD to exclude right modification,
;; to avoid spurious partitive analysis with |many possible| as the dtr.
;;
basic_partitive_num_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD partn &
                                [ MOD < >,
                                  POSS -,
				  --BARE - ],
                           VAL [ SUBJ < >,
                                 SPR < synsem &
                                       [ LOCAL [ CAT.VAL [ SPR  *olist*,
                                                           COMPS < > ],
                                                 AGR #index ],
                                         NONLOC.REL 0-dlist,
                                         LEX + ], ... >,
                                 SPEC < anti_synsem_min >,
				 SPCMPS < > ],
                           HC-LEX - ],
                     CONT nom-obj,
                     CONJ cnil,
                     AGR #agr ],
	     PUNCT #punct ],
    ARGS < [ INFLECTD +,
             SYNSEM 
	      [ LOCAL 
		 [ CAT [ HEAD adj_or_intadj &
			      [ MOD < unexpressed &
				      [ LOCAL.AGR #agr &
						  [ PNG #png,
						    DIV #div ] ] > ],
			 VAL [ SUBJ < >,
			       COMPS < > ] ],
		   CONJ cnil,
		   CONT.HOOK [ LTOP #nhand,
			       XARG #index  ] ],
		NONLOC.SLASH 0-dlist,
		MODIFD notmod_or_lmod,
		PUNCT #punct & 
		      [ LPUNCT lital_or_pair_or_comma_or_no_punct ] ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #nhand,
                    INDEX #index & nonconj_overt-ind &
			           [ PNG #png & png-reg & [ PN 3 ],
				     DIV #div ] ],
	     RELS.LIST < [ LBL #nhand,
                           ARG0 #index,
			   CFROM #from, CTO #to ], ... > ] ].

; DPF 9-apr-05 - Try making SPR..MIN be just_only_deg_rel rather than
; just_only_degree_rel, excluding 'very' and its ilk: "*very five of the 
; chairs"
; DPF 30-may-06 - ALTMIN was def_explicit_q_rel, but this undesirably feeds
; the appos_phr_prpnct rule's non-hd dtr as in "Abrams more arrived".  So
; try making it def_implicit_q_rel (more intuitively), and see.
; DPF 28-apr-08 - Removed ARGS.SPEC *synlist* since this blocks 
; "a dozen (of them) arrived", and its original motivation is (maybe) gone.
; Also added ARGS..ALTMIN norm_rel to block "an arrived"
;; DPF 2017-09-28 - Constrained dtr to exclude ordinals, so we don't get
;; |*first of the cats arrived| (using a different rule for |the first of the 
;; cats arrived|).
;;
partitive_np_num_phrase := basic_partitive_num_phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.ALTMIN def_implicit_q_rel,
			 VAL.SPR < [ --MIN just_only_deg_rel,
				     LOCAL [ CAT.HEAD adv,
					     CONT.HOOK.LTOP #hand ],
				     NONLOC.QUE 0-dlist ],
				   anti_synsem_min & [ OPT - ] > ],
	     NONLOC.QUE #que,
             MODIFD.LPERIPH na ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD intadj_or_comp &
					 [ MINORS.ALTMIN comp_or_poss_rel,
					   CARDINAL + ],
				    VAL.SPR *olist* ],
			      CONT.HOOK.INDEX event & [ E.TENSE no_tense ] ],
                      NONLOC.QUE #que ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS <! [ LBL #nhand,
                       ARG0 #index ],
                     [ LBL #hand,
                       PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #phand,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! qeq & [ HARG #phand,
                              LARG #nhand ] !>,
	     ICONS <! !> ] ].

; DPF 03-may-04 - Changed generic_entity_rel to num_nocmpnd_rel to prevent
; these in N-N-cmpnds or appositives
;; DPF 2017-11-08 - Constrain dtr to SLASH 0-dlist, to avoid spurious analysis 
;; of |one| as dtr here after it undergoes hd_xaj-int-vp_c
;;
basic_partitive_num_nocomp_phrase := basic_partitive_num_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
             NONLOC [ SLASH #slash,
                      REL 0-dlist ] ],
    ARGS < [ SYNSEM [ NONLOC [ SLASH #slash,
                               REL 0-dlist ],
                  PUNCT.RPUNCT comma_or_rbc_or_clause_or_pair_or_no_punct ] ] >,
    C-CONT.RELS.LIST.FIRST.PRED generic_entity_rel ].

; DPF 03-oct-06 - Removed following constraint: blocked "many of the cats"
; ARGS < [ SYNSEM.LOCAL.CAT.VAL.SPR *anti_list* ] >,
;; DPF 2017-07-18 - For some reason, the reentrancy of COMPS..INDEX with
;; RELS.FIRST.ARG1 was dropped, but this is wrong at least some of the time,
;; as in |three of the cats|.  So put it back, and check for possible FIX?
;; DPF 2017-11-27 - We can't constrain SLASH to be LIST *arglist* because this
;; SLASH will eventually be unified with SLASH values of larger phrases, where
;; the SLASH value may be *modlist*, as in 
;; |here, he slept near cats before much of the crowd|
;; where the SLASH for |slept| is *modcons*, incompatible with *arglist*
;; imposed by |much of the rice| which is constructed using this type.
;; So remove this constraint, and see what it costs us in expanded search space.
;; Note that this casts doubt in general on the enterprise of constraining
;; SLASH list types.  FIX if needed.
;;
basic_partitive_num_ppof_phrase := basic_partitive_num_phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD.MINORS.MIN part_of_rel,
                         VAL.COMPS < synsem &
                                 [ --MIN _of_p_sel_rel,
                                   LOCAL [ CAT [ HEAD prep & 
                                                  [ PRD -,
                                                    TAM [ TENSE nontense,
                                                          ASPECT no_aspect ] ],
                                                 VAL.COMPS < > ],
                                           CONT.HOOK [ INDEX #arg,
						       XARG #xarg ] ],
                                   NONLOC [ SLASH #slash,
					    QUE 0-dlist,
					    REL #rel ],
				   OPT - ] > ],
             NONLOC [ SLASH #slash,
		      REL #rel ] ],
    C-CONT [ HOOK [ INDEX.SORT #sort,
		    XARG #xarg ],
	     RELS.LIST.FIRST [ PRED part_of_rel,
			       ARG1 overt_non_expl-ind & #arg &
				    [ SORT #sort ] ] ] ].

;; DPF 2012-05-12 - Added INDEX nonconj_ref-ind to prevent these from being
;; subj of do-be VPs.
;;
partitive_num_nocomp_phrase := partitive_np_num_phrase &
                               basic_partitive_num_nocomp_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.MIN num_nocmpnd_rel,
    C-CONT.HOOK.INDEX nonconj_ref-ind ].

partitive_num_ppof_phrase := partitive_np_num_phrase &
                             basic_partitive_num_ppof_phrase.

; Added variant of this rule for "the first (of the papers) was long" and
; "those two were good", where the conversion from adj to noun produces
; a common noun (still requiring a determiner), rather than an NP.
; DPF 26-aug-04 - Restrict ordinals to being DIV -, so they only appear
; with a determiner, to block "*I hired seventh (of the applicants)"
;; DPF 2013-05-10 - Restrict the obligatory SPR to be definite, to block
;; |*a taller (of the two) arrived|: --MIN def_or_demon_q_rel
;; 2013-09-25 - Constrain SORT of mother to be entity, in order to block
;; unwanted apposition in |*April the two|.
;; DPF 2013-12-09 - Re 2013-05-10: But this is tricky, since we do want 
;; |a blue one| where |one| has undergone the partitive_num_nocomp rule,
;; which is the same rule used for |the taller (of the two)|.  FIX, but
;; in the meantime we'll overgenerate |*a taller of the two|.
;; DPF 2014-04-30 - Re 2013-09-25 - But making the SORT be entity blocks
;; identity-copula with gerund arguments, as in "chasing cats is the best."
;; So generalize to non-time-sort.
;; DPF 2015-09-05 - As with num_noun_phrase, identify CASE of dtr and mother,
;; so we can prevent decimal numbers from appearing other than in compounds
;; as in |the 1.0 release|.
;; DPF 2016-08-24 - Re 2014-04-30: But even this isn't good enough, since we
;; want |on one of those days|, where |day|'s indes has a time sort.  So push
;; the SORT restriction down to the non-ppof variant, to still block
;; |April the two|.
;; DPF 2018-06-06 - The dtr was constrained to MODIFD hasmod, but this is
;; surprising, and undesirable since we want to exclude |many possible| as
;; the dtr, where |possible| is a subconj_prdp_adj.  Let's change to
;; notmod_or_lmod, and see what happens.
;;
partitive_intadj_phrase := basic_partitive_num_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.ALTMIN explicit_q_rel,
				  CASE #case ],
                           VAL [ SPR < canonical_synsem &
				     [ LOCAL.CAT.HEAD det,
				       NONLOC.QUE #que,
				       OPT - ] >,
				 SPCMPS < > ],
			   HS-LEX - ],
		     CONT.HOOK.INDEX.PNG #png,
                     AGR #agr & [ PNG #png ] ],
             NONLOC.QUE #que,
	     MODIFD notmod ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD adj_or_intadj &
					 [ MOD < [ LOCAL.AGR #agr ] >,
					   MINORS.ALTMIN comp_or_superl_rel,
					   CASE #case ],
				    VAL [ SPEC < anti_synsem_min >,
					  SPR *anti_list* ] ],
			      CONT.HOOK.INDEX non_conj_event ],
		      MODIFD [ LPERIPH na_or_+ ] ] ] >,
    C-CONT [ HOOK.LTOP #nhand,
             RELS <! [ LBL #nhand ] !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2014-07-10 - Divide each of these into dtr intadj vs partn, because
;; the partn ones can take an indefinite det, as in |a blue one|, while
;; the comparative/superlative ones cannot: |*a tallest|
;; DPF 2017-03-01 - Removed last vestiges of SORT non-time-sort, generalizing
;; to basic-entity-or-event.
;; DPF 2020-03-24 - Removed ARGS..CARDINAL + so we can get |I prefer the
;; second.| meaning "the second one".
;;
partitive_intadj_nocomp_phrase := partitive_intadj_phrase &
                                  basic_partitive_num_nocomp_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.MINORS [ MIN part_nc_rel,
				     ALTMIN abstract_q_rel ],
		   CONT.HOOK.INDEX.SORT basic-entity-or-event ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD intadj ] > ].

;; DPF 2014-10-19 - Split this one into two, one for morphologically marked
;; comparatives/superlatives (|more|, |tallest|), and one for phrasal comp/sup
;; adjectives |more beautiful|, |most beautiful|.  Need two since |beautiful|
;; must be just HEAD adj, with an underspecified ALTMIN value and an optional
;; specifier, while |tallest| also has an optional specifier which can also
;; be |very|.  Sigh.
;;
partitive_adj_nocomp_phrase := partitive_intadj_phrase &
			       basic_partitive_num_nocomp_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS [ MIN part_nc_rel,
				     ALTMIN abstract_q_rel ],
		       VAL.SPR < expressed_synsem &
				 [ --MIN def_or_demon_q_rel ] > ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD basic_adj ] > ].

;; |the very tallest arose|
;;
partitive_adj_lex_nocomp_phrase := partitive_adj_nocomp_phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD compar_or_superl_adj ] > ].

;; |the most beautiful arose|
;; |*the wide arose|
;; |*the more beautiful arose|
;;
partitive_adj_phr_nocomp_phrase := partitive_adj_nocomp_phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD adj &
				     [ MINORS.ALTMIN superl_rel ],
				VAL.SPR *anti_list* ] ] > ].

partitive_intadj_ppof_phrase := partitive_intadj_phrase &
                                basic_partitive_num_ppof_phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD intadj ] > ].

;; DPF 2014-08-21 - ARGS..HEAD needs to be basic_adj, since phrasal superlatives
;; are HEAD adj, not superl_adj, as in |the most important of these|
;;
partitive_adj_ppof_phrase := partitive_intadj_phrase &
			     basic_partitive_num_ppof_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < expressed_synsem &
			       [ --MIN def_or_demon_q_rel ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD basic_adj ] > ].

; For 'five chairs arrived' where 'five' is a determiner which can optionally
; take a degree specifier as in 'exactly five chairs arrived', contrasted
; with adjectival 'five' as in 'those five chairs arrived': '*those exactly
; five chairs arrived'.
; DPF 28-jul-06 - Restricted dtr's SPR to be OPT +, to block "*hundred chairs"
; DPF 06-sept-07 - Constrain dtr to be MODIFD notmod_or_rmod, to avoid spurious
; ambiguity for e.g. "at least six cats"
; DPF 20-apr-08 - Made mother be MODIFD hasmod so e.g. "one morning" can
; undergo np_adv_c rule. 
; DPF 04-sep-09 - Re 20-apr-08: But this overgenerates: "*we arrived two years"
; So instead copy MODIFD from dtr to mother, so "one" can allow "hasmod" but
; "two" etc. won't.
; DPF 29-sep-09 - To block spurious analysis of "twenty five cats", require
; SPEC to be LPERIPH -.
;; DPF 2012-03-09 - The LPUNCT no_punct on the daughter is just wrong, since
;; we want to allow NP-initial punctuation like |(one idea| or |`one idea|.
;; So remove, and see what happens.
;; DPF 2015-03-27 - For [PRF -] on mother, see comment (same date) for 
;; type adj_n_int_phrase.
;; DPF 2018-03-10 - Generalize SPEC..LPERIPH from - to na_or_-.
;
basic_num_det_phrase := unary_phrase &
  [ SYNSEM basic_det_synsem &
           [ LOCAL [ CAT [ HEAD.MINORS [ MIN num_q_rel,
                                         ALTMIN dofw_or_poss_q_rel ],
                           VAL [ SPEC < synsem &
					[ LOCAL.CONT.HOOK.LTOP #nhand,
					  MODIFD.LPERIPH na_or_-,
					  --MIN nonpart_nom_rel,
					  PHON #phon ] >,
				 SPR < [ --MIN just_only_deg_rel,
                                         LOCAL [ CAT [ HEAD adv,
						       VAL.SPR *unexplist* ],
						 CONT.HOOK [ LTOP #nhand,
                                                           XARG #aind ] ] ] >,
				 COMPS < >,
				 SPCMPS #comps ] ],
                     CONJ cnil ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             MODIFD #modif & notmod_or_lmod,
	     PUNCT #punct ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD intadj & 
                                         [ CARDINAL +,
                                           PRD -,
                                           MOD < unexpressed &
                                                 [ --MIN norm_nom_rel,
						   PHON #phon ] >,
					   MINORS.MIN norm_rel ],
				    VAL [ SPR *olist*,
                                          COMPS #comps ] ],
                              CONJ cnil,
                              CONT.HOOK [ LTOP #nhand,
                                          INDEX event & #aind &
                                               [ E [ TENSE no_tense,
					             ASPECT.PRF - ] ],
                                          XARG #index  ] ],
                      NONLOC [ SLASH 0-dlist,
                               QUE 0-dlist,
                               REL 0-dlist ],
		      LEX bool,
                      PUNCT #punct & 
			    [ RPUNCT hyphen_or_comma_or_clause_or_no_punct ],
                      MODIFD #modif ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK.INDEX #index,
	     RELS <! [ PRED udef_q_rel,
                       ARG0 #index,
                       RSTR #rstr,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rstr,
                              LARG #nhand ] !>,
	     ICONS <! !> ] ].

;; DPF 2018-03-09 - Propagate MOD..AGR to AGR, to block |one information|
;; for the same reason we block |the one information|.
;;
num_det_phrase := basic_num_det_phrase &
  [ SYNSEM.LOCAL.AGR #agr,
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.AGR #agr ].


; DPF 11-Oct-02 - It seems that this rule is only used for robust parsing
; where a word like "covers" has to be analyzed as a possessive.  So let's
; make it ROBUST + (11-may-05: Now GENRE robust).
; DPF 28-Nov-02 - HOOK comes only from C-CONT

possessed_np_phrase := basic_unary_phrase & phrasal &
 [ INFLECTD +,
   SYNSEM [ LOCAL [ CAT [ HEAD det & [ POSS +,
                                       MOD < >,
                                       MINORS [ MIN def_implicit_q_rel,
                                                ALTMIN poss_rel ] ],
                          VAL [ SUBJ < >,
                                SPR < >,
                                COMPS < >,
                                SPEC < [ LOCAL.CONT.HOOK [ LTOP #phand,
                                                           INDEX #index ]]>] ],
                    CONJ cnil ],
            NONLOC #nonlocal,
	    PUNCT #punct ],
   ARGS < [ INFLECTD +,
            SYNSEM [ LOCAL [ CAT nomp_cat_min &
                                 [ HEAD.MINORS.MIN nonpro_rel ],
                             CONT.HOOK.INDEX #pindex & individual,
                             CONJ cnil ],
                     NONLOC #nonlocal,
		     PUNCT #punct ] ] >,
   ORTH [ FROM #from, TO #to ],
   C-CONT [ HOOK.INDEX #index,
            RELS <! [ PRED def_implicit_q_rel,
                      ARG0 #index & ref-ind,
                      RSTR #rhand,
		      CFROM #from, CTO #to ],
                    [ LBL #phand,
                      PRED poss_rel,
                      ARG2 #pindex,
                      ARG1 #index,
		      CFROM #from, CTO #to ] !>,
            HCONS <! qeq & [ HARG #rhand,
                             LARG #phand ] !>,
	    ICONS <! !> ],
   GENRE robust ].

; For "the book's is red"
; DPF 10-jan-09 - For the present, block mass nouns, to at least avoid
; silly overgeneration in paraphrasing, as in "the metal box" => "the
; box of metal's"
;; DPF 2014-04-11 - Having MIN pron_part_rel prevented post-head modif as
;; in |Kim's, in Paris, remained|.  So try part_nom_rel instead.

partitive_np_phrase := basic_unary_phrase & phrasal &
 [ INFLECTD +,
   SYNSEM [ LOCAL [ CAT [ HEAD partn &
                               [ MOD < >,
                                 POSS -,
                                 MINORS [ MIN part_nom_rel,
                                          ALTMIN #altmin ] ],
                          VAL [ SPR < anti_synsem_min & [ OPT - ] >,
                                SUBJ < >,
                                COMPS < >,
				SPCMPS < > ] ],
                    AGR #agr,
                    CONJ #conj & cnil,
                    CONT nom-obj & [ HOOK #hook & [ INDEX #agr ] ] ],
            NONLOC #nonloc,
	    PUNCT #punct ],
   ARGS < [ INFLECTD +,
            SYNSEM phr_synsem & 
                  [ LOCAL [ CAT [ HEAD det & [ POSS +,
                                               MINORS [ MIN #altmin &
                                                          explicit_q_rel,
                                                        ALTMIN poss_rel ] ],
                                  VAL [ SPR < >,
                                        COMPS < >,
                                        SPEC < [ LOCAL.CONT.HOOK #hook &
                                                      [ LTOP #phand,
                                                        INDEX #index ] ] > ] ],
			    CONT.HOOK.XARG.IND +,
                            CONJ #conj ],
                    NONLOC #nonloc,
		    PUNCT #punct ] ] >,
   ORTH [ FROM #from, TO #to ],
   C-CONT [ HOOK.INDEX #index,
            RELS <! [ LBL #phand,
                      PRED generic_entity_rel,
                      ARG0 #index & [ PNG.PN 3 ],
		      CFROM #from, CTO #to ] !>,
            HCONS <! !>,
	    ICONS <! !> ] ].


; Vocatives
; Restrict to LEX +, to avoid appositives as vocatives (spurious ambiguity)
; DPF 06-mar-06 - XARG ??
; DPF 13-jun-07 - Removed identif of MOD..XARG with the addressee_rel's LBL,
; since it was clearly wrong (prevented this rule from ever succeeding with
; attachment to S).
; DPF 22-apr-09 - Changed PRD to + to block these in frag_l_mod
;; DPF 2014-04-02 - Extend this rule slightly to include overt possessives, as
;; in |my friend, we should disappear|
;; DPF 2015-03-11 - Changed MOD..HEAD adverbee to verb_or_frag, to
;; allow |yes, Kim.|
;; DPF 2015-03-13 - Pushed MOD..SUBJ *olist* down to the pre-head variant, so
;; we can get |we know, Kim, that you arrived|.
;; DPF 2015-05-04 - Added NORM no_rel to block year and month naems.
;; DPF 2016-11-02 - Added MIN reg_nom_rel to dtr to block np_cp_wh phrases
;; such as |in which we arise|
;; DPF 2017-11-02 - Let's try constraining this to LEX +, to cut down on the
;; spurious edges introduced in the parse chart.
;; DPF 2018-02-23 - Allow pronoun-headed vocatives such as "you scoundrel", 
;; but block first-person, and disallow post-modified phrases to avoid
;; unwanted ambiguity.
;;
vocative_np_phrase := basic_unary_phrase & phrasal &
 [ INFLECTD +,
   SYNSEM disc_adv_phr_synsem &
            [ LOCAL [ CAT [ HEAD [ PRD -,
                                   MOD < [ LOCAL scopal_mod &
                                            [ CAT [ HEAD verb_or_frag &
                                                      [ TAM.TENSE real_tense ]],
                                              CONT.HOOK [ LTOP #ltop,
                                                          INDEX #index ] ],
					   OPT - ] >,
                                   MINORS.MIN abstr_excl_rel ],
                            MC bool ],
                      CONJ #conj,
		      AGR.PNG.PN 2 ],
              NONLOC #nonloc,
	      PUNCT #punct ],
   ARGS < [ INFLECTD +,
            SYNSEM 
	     [ LOCAL [ CAT [ HEAD basic_noun & mobile &
			     [ MINORS [ MIN non_temp_nom_rel,
					ALTMIN def_poss_or_barepl_or_prop_q_rel,
					NORM no_rel ],
			       CASE no_case ],
			     VAL [ SPR *olist*,
				   COMPS < >,
				   SPEC < anti_synsem_min > ] ],
		       CONT.HOOK.INDEX #argind & non_expl-ind,
		       AGR.PNG.PN 3+2s,
		       CONJ #conj ],
	       NONLOC #nonloc,
	       LEX +,
	       PUNCT #punct &
		     [ LPUNCT lparen_or_dq_or_comma_or_no_punct,
		       RPUNCT hyphen_or_comma_or_pair_or_clause ] ] ] >,
   ORTH [ FROM #from, TO #to ],
   C-CONT [ HOOK [ LTOP #ltop,
		   INDEX #arg0 ],
            RELS <! [ LBL #ltop,
                      PRED addressee_rel,
		      ARG0 #arg0,
                      ARG1 #argind,
                      ARG2 #index,
		      CFROM #from, CTO #to ] !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

; DPF 15-feb-10 - Might consider generalizing the punctuation marker to 
; allow opening single and double quotes, as well as explicit italics marker
; (replacing lital_punct with dq_or_sq_or_lital_punct), but at present we
; already get a N-N compound analysis for sequences of unknown words, so an
; additional FW analysis is not obviously useful.
;; DPF 2012-02-18 - We want double quoted phrases to be analyzable here,
;; since some are quoted sequences of ordinary English words, as in 
;; |"Can't wait" is a familiar phrase.|
;; DPF 2016-09-12 - Restricted left dtr's RPUNCT from pair_or_no_punct to
;; just no_punct, to exclude pair_punct, since this was allowing us to zoom 
;; past the end of an italicized sequence without terminating.  Likewise
;; for right dtr's RPUNCT.
;; DPF 2017-10-29 - Changed INFLECTD na to na_or_+ on left dtr, since this one 
;; can be either a word or a fw-sequence.
;; DPF 2017-11-02 - Made right dtr be INFLECTD na, since this can now only be
;; the generic_quoted entry introduced by token mapping (foreign_token_tmr)
;; for each cell in the chart.
;; DPF 2020-05-12 - It would seem that we want to constrain the right dtr to
;; exclude double-quote punct, to force termination on the right of a quoted
;; phrase.
;;
fw_sequence_left_phrase := generic_binary_phrase &
			   word_or_punct_or_bracketed_phrase &
 [ INFLECTD na,
   ORTH [ LD bracket_null, RD bracket_null ],
   SYNSEM [ LOCAL [ CAT [ HEAD fw & [ MINORS.ALTMIN def_implicit_q_rel ],
                          VAL [ SPR < >,
                                SUBJ < >,
                                COMPS < >,
                                SPEC < >,
				SPCMPS < > ] ],
                    CONT nom-obj &
                        [ HOOK [ LTOP #hand,
                                 INDEX #index ] ],
                    CONJ cnil ],
            NONLOC #nonlocal & non-local_none,
	    PUNCT [ LPUNCT #lpunct,
                    PAIRED #paired,
		    RPUNCT #rpunct & non_double_quote_punct,
                    RCLSTR #rclstr ],
            LEX + ],
   ARGS < [ INFLECTD na_or_+,
	    DERIVED -,
	    SYNSEM basic_lex_synsem &
		   [ LOCAL [ CAT.HEAD fw,
			     CONJ cnil,
                             CONT.HOOK [ LTOP #hand,
                                         INDEX #index1 & non_conj_sement ] ],
                     NONLOC #nonlocal,
		     PUNCT.LPUNCT #lpunct & dq_or_sq_or_lital_punct,
                     LEX + ] ],
          [ INFLECTD na,
	    DERIVED -,
	    SYNSEM [ LOCAL [ CAT.HEAD fw,
			     CONJ cnil,
                             CONT.HOOK [ LTOP #hand,
                                         INDEX #index2 & non_conj_sement ] ],
                     NONLOC #nonlocal,
                     LEX +,
		     PUNCT [ PAIRED #paired,
			     RPUNCT #rpunct,
                             RCLSTR #rclstr ] ] ] >,
   ORTH [ FROM #from, TO #to ],
   C-CONT [ RELS <! [ LBL #hand,
		      PRED fw_seq_rel,
		      ARG0 #index & ref-ind,
		      ARG1 #index1,
		      ARG2 #index2,
		      CFROM #from, CTO #to ] !>,
	    HCONS <! !>,
	    ICONS <! !> ] ].


;; DPF 2016-01-27 - Changed mysterious RFP feature's value from + to bool, in
;; order to admit |"glimp glump"| as foreign word sequence.
;; DPF 2016-01-29 - Changed MIN from norm_nom_rel to abstr_named_np_rel so these
;; FW sequences can appear in NP-n compounds.
;; DPF 2016-09-12 - Added RPUNCT..IGNOREQ - to left dtr so we don't overrun the
;; right boundary of a foreign-word sequence where we've ignored the closing
;; right ital or quote.  Also changed right dtr's INFLECTD from + to na_or_+, 
;; since the right-ital rule imposes INFLECTD na.  Also added SPEC < > to mother
;; to prevent these from undergoing the vocative NP rule.  Also added 
;; MODIFD notmod to prevent these from undergoing the npadv rule.
;; DPF 2017-01-31 - Surprised that the right dtr's RPUNCT was
;; comma_or_clause_or_pair_punct, so changed it to dq_or_sq_or_rital_punct.
;; But we also have to allow for comma or clause punct following the quote
;; marks, as in |the verb "to be".| so the comma/clause punct would hide the 
;; presence of the closing right quotes, blocking the fw-seq rule.  Hence added
;; another feature RITAL to the RCLSTR group, and have the three right-punct 
;; rules for quotes and italics set the value of this feature to +.  Then just
;; preserve the RPUNCT value from dtr to mother, and set mother's RITAL to -.
;; DPF 2018-05-31 - Added HD-DTR..LPERIPH - to block these with pre-title.
;; DPF 2019-11-18 - Changed mother's ALTMIN from explicit_q_rel to proper_q_rel,
;; to admit NP-N compounds as in |the "admire Kim" group arrived|.
;; DPF 2019-11-28 - Re 2019-11-18: But we also want |the "id est"| so generalize
;; ALTMIN to explicit_or_proper_q_rel.
;;
fw_sequence_right_phrase := basic_binary_phrase &
 [ INFLECTD +,
   SYNSEM [ LOCAL [ CAT [ HEAD noun & 
                               [ MOD < >,
				 MINORS [ MIN named_np_rel,
				          ALTMIN explicit_or_proper_q_rel,
					  NORM norm_rel ] ],
                          VAL [ SPR < [ LOCAL.CAT.HEAD det,
			                OPT - ] >,
			        SUBJ *olist*,
				COMPS < >,
				SPEC < anti_synsem_min >,
				SPCMPS < > ] ],
                    CONT nom-obj &
                        [ HOOK [ LTOP #hand,
                                 INDEX #index ] ],
                    CONJ cnil,
                    AGR #index & [ PNG.PN 3s, DIV - ] ],
            NONLOC #nonlocal & non-local_none,
            LEX +,
	    MODIFD notmod & [ LPERIPH - ],
            PUNCT [ LPUNCT no_punct,
                    RPUNCT #rpunct,
		    PAIRED #paired,
		    RCLSTR [ RPAREN #rparen,
			     RITAL - ] ] ],
   ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD fw,
                             CONJ cnil,
                             CONT.HOOK [ LTOP #hand,
                                         INDEX #index1 & non_conj_sement ] ],
                     NONLOC #nonlocal,
                     PUNCT [ LPUNCT dq_or_sq_or_lital_punct,
                             RPUNCT comma_or_clause_or_pair_or_no_punct,
			     RCLSTR.IGNOREQ - ],
		     MODIFD notmod,
                     LEX + ],
	    DERIVED -,
	    INFLECTD na_or_+ ],
          [ SYNSEM basic_lex_synsem &
		   [ LOCAL [ CAT.HEAD fw,
                             CONJ cnil,
                             CONT.HOOK [ LTOP #hand,
                                         INDEX #index2 & non_conj_sement ] ],
                     NONLOC #nonlocal,
                     PUNCT [ LPUNCT no_punct,
                             RPUNCT #rpunct,
			     PAIRED #paired,
			     RCLSTR [ RPAREN #rparen,
				      RFP bool,
				      RITAl + ] ],
                     LEX + ],
	    DERIVED -,
	    INFLECTD na ] >,
   ORTH [ FROM #from, TO #to ],
   C-CONT [ RELS <! [ LBL #hand,
		      PRED fw_seq_rel,
		      ARG0 #index & ref-ind,
		      ARG1 #index1,
		      ARG2 #index2,
		      CFROM #from, CTO #to ] !>,
	    HCONS <! !>,
	    ICONS <! !> ] ].

;; DPF 2020-03-09 - Removed PNCTPR ppair, even though this was on its ancestor
;; lexical rule, because the motive is no longer clear, and it prevents paired
;; commas as in |We admire a consonant, such as Kim for "spider").|, where in
;; the old universe we got away with it because the right paren attached later,
;; and failed to preserve that PNCTPR value.
;; DPF 2020-04-14 - Generalized AGR..PN 3s to 3, so we can also get
;; |"sarakin" which lend to individiuals|
;;
unary_fw_phrase := unary_phrase &
  [ SYNSEM lex_phr_synsem &
	   [ LOCAL [ CAT basic_nbar_cat &
			 [ HEAD noun & 
				[ MOD < >,
				  MINORS [ MIN named_np_rel,
					   ALTMIN #spmin,
					   NORM quantity_or_norm_rel ] ],
			   VAL [ SPR < synsem &
				       [ --MIN quant_rel & #spmin,
					 LOCAL.CAT [ HEAD det,
						     VAL [ SUBJ < >,
							   SPR *olist* ] ],
					 LEX +,
					 OPT - ] >,
				 SPCMPS < > ] ],
		     CONT nom-obj &
			 [ HOOK.INDEX nonconj_ref-ind & #index ],
		     CONJ cnil,
		     AGR #index & [ PNG.PN 3, DIV - ] ],
	     MODIFD notmod,
	     NONLOC #nonloc & non-local_none,
	     LEX +,
	     LKEYS #lkeys & [ KEYREL [ CFROM #from, CTO #to ] ],
             PUNCT [ LPUNCT no_punct,
		     RPUNCT #rpunct,
		     RCLSTR [ RPAREN #rp,
			      RFP #rfp,
			      RITAL +,
			      LITAL + ],
		     LCLSTR #lclstr  ],
	     PHON.ONSET #onset ],
 ARGS < [ INFLECTD na_or_+,
	  DERIVED -,
	  SYNSEM basic_lex_synsem &
		 [ LOCAL [ CONT.HOOK [ LTOP #hand,
				       INDEX #index1 ] ],
		   NONLOC #nonloc,
                   PUNCT [ LPUNCT dq_or_sq_or_lital_punct,
			   RPUNCT #rpunct,
			   RCLSTR [ RPAREN #rp,
				    RFP #rfp,
				    RITAL +,
				    LITAL - ],
			   LCLSTR #lclstr ],
		   LKEYS #lkeys,
		   PHON.ONSET #onset ] ] >,
    C-CONT [ HOOK [ LTOP #hand,
		    INDEX #index ],
	     RELS <! [ LBL #hand,
		       PRED fw_seq_rel,
		       ARG0 #index,
		       ARG1 #index1,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; Verbal gerund N-bars: 'hiring Kim' is important.
; DPF 23-jun-09 - Try restricting dtr to phr_synsem, to avoid spurious
; ambiguity with nominal gerund for simple intransitives, e.g. "arriving"
; DPF 28-jun-09 - Add RPERIPH + to prevent spurious ambiguity of post-modif.
; DPF 28-jan-10 - Generalized SUBJ..HEAD from noun to basic_noun, to allow
; partitive subjects, as in "none hiring Kim"
;; DPF 2010-10-24 - Discovered that we cannot identify the SPR..INDEX with
;; the SUBJ..INDEX (and thus the XARG of the dtr), since the spr's index
;; is already going to be identified with the INDEX of the nominalized
;; phrase, which is certainly not the ARG1 of the dtr.  Instead, it's the
;; XARG of the possessive which presents the pronoun's index that we want.
;; DPF 2013-09-26 - Removed PRD - since this prevented both |my hiring Kim|
;; and |me hiring Kim|.  We'll see what work it was doing.
;; DPF 2017-04-02 - Rextrict dtr to MC na_or_- to enable blocking of spurious
;; analysis with robust rule that analyzes |the seat sleeping| as an (MC +) S.
;; DPF 2017-09-16 - Constrained dtr to have SUBJ synsem in order to block
;; |our me admiring Kim| where |me admiring Kim| is again input to this rule.
;; DPF 2017-11-19 - Removed OPT - from the second element of SPR list, since
;; this blocked |his admiring the snow surprised us|.  Instead, have the
;; head-subj rule impose this on the spr.
;; DPF 2017-12-10 - Constrained dtr to nonlex_synsem to avoid spurious ambig
;; for unadorned intransitives, which can also be nominal gerunds.
; 
vgerund_phrase := unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD gerund &
				[ MOD < >,
                                  POSS -,
                                  MINORS.MIN gerund_rel ],
			   VAL [ SUBJ < synsem &
				    [ LOCAL [ CAT nomp_cat_acc_min &
                                                  [ HEAD basic_noun ],
					      CONJ cnil ],
				      NONLOC.SLASH 0-dlist,
				      --SIND #subjind ] >,
                                 SPR < [ LOCAL local &
					   [ CAT [ HEAD det & 
						    [ POSS + ],
                                                   VAL [ SUBJ < >,
							 SPR *olist*,
							 COMPS < > ] ],
                                             CONT.HOOK.XARG #subjind ],
					 OPT -,
                                         NONLOC #snonloc ],
				       anti_synsem >,
                                 COMPS < >,
				 SPCMPS < > ],
			   MC na,
			   HS-LEX - ],
		     CONT nom-obj &
                          [ HOOK [ LTOP #hand,
                                   INDEX #ind ] ],
		     AGR [ PNG png & [ PN 3s,
				       GEN neut ],
			   DIV + ] ],
	     MODIFD.RPERIPH +,
	     NONLOC #nonlocal & [ REL 0-dlist ],
	     PUNCT #punct ],
  ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
				       [ VFORM prp,
					 PRD + ],
				  VAL [ SUBJ < synsem &
					       [ --SIND #subjind,
						 LOCAL.CAT.HEAD noun,
						 NONLOC #snonloc ] >,
					COMPS < > ],
				  MC na_or_- ],
			    CONT.HOOK [ LTOP #vhand,
					INDEX [ E.TENSE no_tense,
						SF prop ] ],
			    CONJ cnil ],
		    NONLOC #nonlocal,
		    PUNCT #punct ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS <! gerund_relation &
		   [ LBL #hand,
		     ARG0 #ind,
		     ARG1 #vhand,
		     CFROM #from, CTO #to ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Coordinate structures
;;
;   We set the MIN of the mother to be that of the right-hand daughter, rather
; arbitrarily, but the MIN needs to be set, since many lexical types select
; an argument based on the MIN value.
;   We also need to set the type of the index on the mother, to match the types
; of the indices on the daughters.  It looks like this will force us to make 
; the kind of index a feature, not just a type, but for now we wrongly make the
; index be that of the right-hand daughter.  This does not break subject-verb
; agreement for plural NPs, since we only change INDEX in this hack, not AGR.
;   And we have to make sure that the BODY attributes of two conjoined 
; quantified phrases are identified, but not clear how to do this.
; DPF (27-Apr-99) Both conjuncts have MIN constrained to independent_rel, since
; they may be relations underspecified for use as particles - by doing this, we
; exclude coordination of particles themselves, but this is probably okay.
; DPF (1-May-99) At present we overgenerate with conjoined propositions because
; we cannot identify the MSG values of the two conjuncts - that would wrongly
; make the MARG values of those two messages be identified. Hence we accept eg.
; "*I wonder who left and that Sandy arrived".  As long as MSG values are
; typed relations, there doesn't seem to be a way out of this awkwardness.
; DPF (1-May-99) In the long run, we cannot simply identify the whole local 
; values of SLASH for the two conjuncts, since this would mean that the handles
; of the two extracted elements would be wrongly identified - wrong at least 
; for ordinary complements, which identify their LTOP handle with that of their
; head, meaning that in "the book Kim saw and Sandy liked" the handles for 
; "saw" and "liked" would be identified, which is bad since these handles each 
; fill a MARG role in distinct messages.  
; DPF 20-Nov-99 - Made all coord_phr's be LEX - in order to avoid, among other
; things, coordinate structures as right members of noun-noun compounds, as in
; 'the seventeenth, twentieth, or twenty-third'.
; DPF 20-Jun-00 - Made LEX match on both conjuncts, to avoid e.g. "Kim [ had
; Sandy and would ] arise" (with causative "have")  
; DPF 28-Aug-00 - But this will block "Kim and the cat arrived", so removed it.
; DPF 3-Feb-01 - Moved [ CONJ complex-conj ] on right dtr to subtypes, in order
; to let us treat run-on sentences as coordination.
; DPF 22-Mar-01 - Moved AGR.DIV reentrancy down to NP coordination, since
; want to allow non-like AGR.DIV values for sentence coordination, as in
; "I arrived and consultants left."
; DPF 29-may-07 - Changed constraint on RCONJ-DTR to be [LEX bool] rather
; than nonlex_synsem, so we can allow "etc," as right dtr.  Conjunction words
; are now [LEX na].
; DPF 25-jun-09 - Can't recall why mother's SLASH.LIST is *arglist*, excluding
; extracted modifiers.  This blocks "In paris, we hire him with abrams or 
; browne."  FIX
; DPF 27-jul-09 - Block |an| in AP coord: "tall and an understanding arrived"
; Also remove nonloc identif from basic_coord_phr.
; DPF 2011-04-26 - Re 25-jun-09: This constraint also blocks "during which
; Kim arrived and Abrams arose".  But it is well-motivated: there is no good
; way to construct a semantics for an extracted modifier across-the-board, 
; since the modifier has to take its modifiee's INDEX event as its ARG1, and 
; for a coordinated phrase, that has to be the conjoined index, not the 
; (spurious) unification of the two individual events.  So will have to 
; allow for an extracted adjunct from a conjoined S (likely a new rule).
; For related fix to 25-jun-09 ex., see 2011-05-01 change to head_adj_phrase.
;; DPF 2020-05-07 - Changed parent from basic_binary_phrase to
;; generic_binary_phrase as in trunk
;;
min_coord_phr := generic_binary_phrase & non_headed_phrase & 
  [ SYNSEM [ NONLOC #nonloc,
	     PHON.ONSET #onset ],
    LCONJ-DTR sign & [ SYNSEM.NONLOC #nonloc ], 
    RCONJ-DTR sign & [ SYNSEM.NONLOC #nonloc ],
    ARGS.FIRST.SYNSEM.PHON.ONSET #onset ].

;; DPF 2017-05-24 - Pushed the ident of PNCTPR on mother and right dtr down
;; to coord_phr, so that we can admit coord NPs which contain comma-marked 
;; modifiers, as in
;; |Both Kim, in Paris, and Browne, in Rome, arose|
;; DPF 2017-10-07 - Add NOCONJ - to left dtr, to avoid spurious analysis of
;; |[dog, cat, horse] and cow|
;;
basic_coord_phr := min_coord_phr &
  [ INFLECTD #infl,
    SYNSEM.LOCAL.CONJ.NOCONJ #nc,
    LCONJ-DTR sign & #left &
           [ INFLECTD #infl,
             SYNSEM [ LOCAL [ CONT.HOOK.INDEX individual,
			      CONJ.NOCONJ - ],
		      LEX #lex ] ],
    RCONJ-DTR #right &
           [ INFLECTD #infl,
             SYNSEM [ LOCAL [ CONT.HOOK.INDEX individual,
			      CONJ [ CLEX #lex,
				     NOCONJ #nc ] ],
                      LEX bool ] ],
    ARGS < #left, #right > ].

gen_coord_phr := basic_coord_phr &
  [ SYNSEM.PUNCT.RCLSTR #rclstr,
    RCONJ-DTR.SYNSEM.PUNCT.RCLSTR #rclstr ].

coord_phr := gen_coord_phr &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD #mod,
	     PUNCT.PNCTPR #ppair ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD #mod,
    RCONJ-DTR.SYNSEM [ LOCAL [ CAT.HEAD.MOD #mod,
			       CONJ complex-conj ],
		       PUNCT.PNCTPR #ppair ] ].

; DPF 10-mar-05 - Pushed [LEX -] down to dtrs, since need to allow
; at least non-finite verbs to be able coordinate as LEX + since the
; passives can be attributive adjectives: "The admired and hated politicians"
;; DPF 2012-06-22 - Moved AGR.PNG unif of mother and right dtr down to some 
;; subtypes, excluding s_coord, since we want to be able to coordinate 
;; sentences with unlike AGR, and then have that coordinated S be a 
;; complement, as in |we describe what happened and how it felt|, where for 
;; ;other reasons the AGR of the mother is unified with the AGR of the 
;; left dtr.
;;
norm_coord_phr := coord_phr &
  [ INFLECTD +,
    ARGS < [ INFLECTD +,
	     SYNSEM.LOCAL.CONT.HOOK.INDEX #lindex ],
           [ INFLECTD +,
	     SYNSEM.LOCAL.CONJ.CREL.ARG1 #lindex ] > ].


; [SPR..no_rel] prevented attachment of modifiers to no_cop phrases, but
; this incorrectly blocks "rain possible today".
; ARGS..SPR *olist* blocks e.g. "ago" as nocop_vp
; DPF 10-Sep-01 - Changed MIN to be no_rel, to block nocop_vp as root phrase.
; DPF 13-Sep-01 - Removed ROBUST - from dtr, since want "message received"
; DPF 25-aug-04 - Changed SYNSEM..SUBJ..CASE from nom to acc, since want
; 'with me in Paris', not '*with I in Paris'.
;; DPF 2016-04-21 - Changed mother's HEAD value from frag to verb
;; DPF 2016-05-02 - Re 10-Sep-01: Changed MIN no_rel to norm_rel so we can
;; get robust |Why you strict?| with adjunct extraction for |strict| as VP.

no_copula_be_phrase := basic_unary_phrase & phrasal &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD verb & [ PRD -,
                                         MINORS [ MIN v_event_rel,
                                                  ALTMIN #min ],
						  VFORM fin ],
                           VAL [ SUBJ < synsem &
                                        [ LOCAL [ CAT nomp_cat_min &
                                                      [ HEAD basic_noun,
						        VAL.SPR *olist* ],
                                                  CONT [ HOOK.INDEX #ind ]]] >,
                                 SPR < anti_synsem_min >,
                                 COMPS < >,
				 SPCMPS < > ],
                           MC na ],
                     CONT [ HOOK [ XARG #ind & ref-ind ] ],
                     CONJ cnil ],
             NONLOC #nonloc & [ REL 0-dlist,
                                QUE 0-dlist ],
	     PUNCT #punct ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                                    VAL [ COMPS < >,
                                          SPR *olist*,
					  SUBJ *unexplist* ],
                                    MC na ],
                              CONJ cnil ],
                      NONLOC #nonloc,
		      PUNCT #punct ] ] >,
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 28-Nov-02 - HOOK comes only from C-CONT

no_copula_prd_phrase := no_copula_be_phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < >,
                   CONT.HOOK.XARG #xarg,
                   AGR #agr ],
    ARGS < [ SYNSEM.LOCAL 
                    [ CAT [ HEAD v_or_a_or_p &
                            [ PRD +,
                              MOD < [ --MIN event_rel,
                                      LOCAL intersective_mod ] > ] ],
                      CONT.HOOK [ LTOP #hand,
                                  INDEX non_expl,
                                  XARG #xarg ],
                      AGR #agr ] ] >,
    C-CONT [ HOOK.LTOP #hand,
             RELS <! !> ] ].

; DPF 21-Nov-01 - Added ROBUST - to dtr, to block bare-sing-nps.
; DPF 28-Nov-02 - HOOK comes only from C-CONT
;; DPF 2016-04-21 - Re 21-Nov-01: Changed to HEAD.--BARE -, since we want
;; the resulting phrase to be GENRE robust

no_copula_id_phrase := no_copula_be_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MOD < >,
                                TAM #tam ],
                         VAL.SUBJ < [ LOCAL [ CAT nomp_cat_min,
                                              AGR #agr ],
                                      --SIND #id1ind ] > ],
                   CONT.HOOK.INDEX.E #tam,
                   AGR #agr ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun &
                                       [ MINORS [ MIN nonpro_rel,
                                                  ALTMIN non_conj_rel ],
					 --BARE - ],
                                  VAL [ SUBJ < >,
                                        SPR < >,
                                        COMPS < > ] ],
                            CONT.HOOK.INDEX #id2ind ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #hand,
                    INDEX #event ],
             RELS <! arg12_relation &
                     [ LBL #hand,
                       PRED _be_v_id_rel,
                       ARG0 #event & [ E.TENSE no_tense ],
                       ARG1 #id1ind,
                       ARG2 #id2ind,
		       CFROM #from, CTO #to ] !> ] ].

; DPF 25-Sept-01 - Changed SPR *olist* to < >, to prevent e.g. PPs from
; attaching to no_cop S rather than to the no_cop VP.
; DPF 28-Nov-02 - HOOK comes only from C-CONT

no_copula_nosubj_phrase := non_rel_clause & head_valence_phrase & head_only &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN #min,
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
                           MC + ],
                     CONT.HOOK.INDEX.SF prop ],
             NONLOC #nonloc,
	     PUNCT #punct ],
    HD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                         [ MOD < >,
                                           PRD -,
                                           VFORM fin,
                                           TAM.TENSE no_tense,
                                           MINORS.MIN #min ],
                                    VAL [ SUBJ < synsem & [ OPT + ] >,
                                          COMPS < > ],
                                    MC na ],
                              CONT.HOOK.LTOP #hdtop,
                              CONJ cnil ],
		    NONLOC #nonloc & [ SLASH 0-dlist,
				       REL 0-dlist,
				       QUE 0-dlist ],
		    PUNCT #punct ],
    C-CONT [ HOOK.LTOP #hdtop,
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; For clause-as-modifier, as in |you will, _I am sure_, be happy|
;; DPF 2015-09-11 - Added VFORM finite to dtr, to block |considered|, which has
;; an optional SUBJ.  Also constrain to MC bool, in case a relative clause
;; might try to sneak in.
;; DPF 2017-02-20 - Added PRD + to prevent these from appearing as fragments
;; in e.g. NP-Adv rule.
;; DPF 2017-11-24 - We see a lot of candidate edges using this rule in phrases
;; such as |was [[writing a report after Jones] was writing __]|.  So let's
;; constrain the slashed VP to be no_aspect, as a concession to efficiency.
;; DPF 2018-05-31 - Add MODIFD notmod for efficiency.
;; DPF 2018-07-28 - Constrain XARG to exclude WH-CP subject, to block this 
;; analysis for |which is determined|
;;
cl_adv_phrase := basic_unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adv &
			   [ MOD < [ LOCAL scopal_mod &
				     [ CAT [ HEAD verb,
					     VAL.COMPS < >,
					     MC #mc ],
				       CONT.HOOK.LTOP #sltop,
				       CONJ cnil ],
				     LEX -,
				     PUNCT.RPUNCT comma_or_pair_or_no_punct ] >,
			     PRD + ],
			   POSTHD +,
			   MC #mc,
			   VAL [ SUBJ < >,
				 SPR < >,
                                 COMPS < >,
				 SPEC < >,
				 SPCMPS < > ] ],
                     CONJ cnil,
                     CTXT #ctxt ],
             NONLOC non-local_none_phr,
             PUNCT #punct,
	     --BRDG na ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD verb & 
					 [ VFORM fin,
					   TAM #tam & [ ASPECT no_aspect ],
					   --ADDIN [ ADDTAM #tam,
						     ADDPN #pn ] ],
				    VAL [ SPR *olist*,
                                          SUBJ *olist*,
					  COMPS < > ],
				    POSTHD +,
				    MC bool ],
			      CONT.HOOK [ LTOP #vltop,
					  INDEX #vind,
					  XARG #vxarg ],
			      AGR.PNG.PN #pn,
			      CONJ cnil,
                              CTXT #ctxt ],
                      NONLOC.SLASH 1-dlist & 
			    <! arg-local & 
			       [ CAT s_cat_v_c &
				     [ HEAD [ MINORS.MIN v_event_rel,
					      VFORM fin,
					      CASE non_nom,
					      PRD - ] ],
				 CONT.HOOK.LTOP #sltop ] !>,
		      MODIFD notmod,
		      PUNCT #punct & [ RPUNCT comma_or_no_punct ] ] ] >,
    C-CONT [ HOOK [ LTOP #vltop,
		    INDEX #vind,
		    XARG #vxarg & [ SORT entity ] ],
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    INFLECTD + ].

;; For VP-modifying indefinite NP, as in
;; |he arrived in London a rich man|
;; The [LPERIPH bool] blocks appositives, to avoid unwanted ambiguity.
;; And the MOD..ALTMIN prevents spurious analysis for |Kim is a cat|
;; DPF 2015-07-02 - Make result PRD - to avoid these as complement of copula.
;; DPF 2016-02-01 - Removed MOD..SLASH 0-dlist because we also want e.g.
;; |yesterday we arose early, an unusual event|
;; DPF 2017-01-31 - Added NORM no_rel to the dtr, to block appositives where
;; the first NP is indefinite, as in [[an autumn hike in][the mountains]]
;; DPF 2017-05-25 - Added ALTMIN no_rel to mother, to prevent these from
;; appearing between verb and its complement (using v_mod rule).
;; DPF 2018-03-10 - Re LPERIPH bool: now that default value for nouns is na,
;; find another way to block appositives.  FIX?
;; DPF 2018-09-10 - This type was wrongly identifying its MOD's XARG with its
;; own, but intersective modifiers should always take their MOD's INDEX as their
;; XARG.  The intution was perhaps to identify the referent of this phrase with
;; the subject of the verbal phrase it modifies, but this is not always the case:
;; |no fool, it was clear that Kim had already found out.|  So the co-referent
;; of the indef-NP modifier must be worked out as anaphora, not control.
;;
indef_np_adv_phrase := basic_unary_phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ HEAD adv &
			   [ MINORS.ALTMIN no_rel,
			     MOD < [ LOCAL intersective_mod &
			   	     [ CAT [ HEAD verb & 
					      [ AUX -,
						MINORS.ALTMIN non_ellipt_rel ],
					     VAL [ SPR < synsem_min, ...>,
						   COMPS < > ] ],
				       CONT.HOOK.INDEX #vind,
				       CONJ cnil ],
				     OPT -,
				     PUNCT.RPUNCT comma_or_pair_or_no_punct] >,
		             PRD - ],
			   POSTHD +,
			   VAL [ SUBJ < >,
				 SPR < >,
                                 COMPS < >,
				 SPEC < >,
				 SPCMPS < > ] ],
                     CONJ cnil,
                     CTXT #ctxt ],
             NONLOC non-local_none_phr,
             PUNCT #punct ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD noun & 
					 [ MINORS [ MIN norm_nom_rel,
						    ALTMIN a_or_no_q_rel,
						    NORM no_rel ],
					   --BARED - ],
				    VAL [ SPR *olist*,
					  SUBJ < >,
					  COMPS < > ] ],
			      CONT.HOOK.INDEX #nind,
			      CONJ cnil,
                              CTXT #ctxt ],
		      NONLOC non-local_none_phr,
		      PUNCT #punct & 
			    [ RPUNCT comma_or_clause_or_pair_or_no_punct ] ]] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX #ind ],
	     RELS <! [ PRED mod_rel,
		       LBL #ltop,
		       ARG0 #ind & event,
		       ARG1 #vind,
		       ARG2 #nind,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    INFLECTD + ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Proto-instance types
; DPF 12-Nov-03 - Experimentally, make the XARG of this phrase be the LTOP
; of the head-dtr, in order to support "on Tuesday who arrived" where the
; PP should share the handle of the VP (as if it had been extracted).
; DPF 30-aug-04 - Split subj_rule_decl into MC+ and MC- in order to enforce
; unification of msg from punctuation mark on main clause phrases only, to
; get "Kim arrived?" but not "*I wonder Kim arrived?"
;; DPF 2013-09-26 - INDEX.SF was allowing for value `comm', but it is maybe
;; wrong to aim to treat "everybody be quiet" as a subj-head - better to
;; treat "everybody" as vocative.  Allowing `comm' leaves the SF value too
;; underspecified for ordinary declarative clauses, so let's try blocking it.
;; DPF 2015-03-17 - Re 2013-09-26 - But adding SF here forces the index to
;; be an event, but verbal gerunds as in |we approve of his hiring Kim|
;; need to have an index unifiable with non_expl-ind, as in
;; |Kim was bothered by me admiring cats|.  So let's push the SF constraint
;; down to lower type.
;;
;; 		  CONT.HOOK.INDEX.SF prop-or-like-or-pol-ques ],
subjh_rule_basic := binary_rule_right_to_left & basic_binary_headed_phrase &
                    head_valence_phrase &
  [ SYNSEM.LOCAL [ CAT [ MC bool,
			 POSTHD + ],
		   CONT.HOOK.XARG #xarg ],
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK.XARG #xarg,
		    NONLOC.QUE 0-dlist ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.POSS -,
                    NONLOC.QUE 0-dlist ] ].

subjh_rule_decl := subjh_rule_basic & basic_decl_phrase.

;; DPF 2010-jul-24 - FIX: Identifying PSF and SF wrongly makes [SF ques]
;; for "Kim wondered, who arose?"
;; DPF 2010-sept-10 - Since all filler-head rules require MC na_or_- for
;; the hd-dtr, we can constrain this rule to be SLASH 0-dlist.
;; DPF 2016-11-18 - Re 2015-03-17 above, and 2015-09-09 for head_adj_scop_prpnct
;; -- we want to get |we arrived, so arise.| with imperative in dependent 
;; clause.  But the main clause variant of the hd-aj rule needs to unify the
;; RPUNCT.PSF of the adjunct with that of the mother's index, at least for
;; questions, and arguably that is also right for commands, so that the desired
;; SF value of |we arrived, so arise.| is comm, not prop.  But this means we
;; can't restrict SF on the subjh_mc_rule to exclude comm.  So if we don't want
;; a subj-head analysis of |everybody be quiet, we'll have to find another way
;; to block it.  Maybe just accept it, since we presumably want |nobody move| as
;; an imperative admitted via this rule.
;;

; CSY - changed verbal to v_or_a to allow adjectives to join with subjects for Singlish and
; commented out VFORM fin
; CSY 5-1-2020 - uncommented VFORM as adj now has it
;     6-1-2020 - changed VFORM from fin to fin_or_bse_or_prp 
subjh_mc_rule := subjh_rule_decl & head_subj_phrase & clause &
"""
For sentences like
<ex> The cat is pretty.
<ex> The cat pretty.
<ex> The cat sleeping.
"""
  [ SYNSEM [ LOCAL [ CAT [ HEAD v_or_a &
				[ VFORM fin_or_prp,
                                  TAM indic_tam,
				  PRD -,
				  CASE non_nom ],
			   VAL.SPR *olist*,
                           MC + ],
                     CONT.HOOK [ INDEX.SF #pred ] ],
	     NONLOC.SLASH 0-dlist,
             PUNCT.RPUNCT.PSF #pred ] ].

; Constrain nh-dtr to be HEAD n_or_v to exclude locative inversion in
; non-main clauses
; Note that this rule does not exploit the PSF marking, unlike the main
; clause variant, so we get "Did Kim deny that Browne arrived?" even though
; 'deny' doesn't take an interrogative CP complement.
;; DPF 2011-jun-11 - Recalled why this type does not inherit from `clause':
;; since we're still underspecifying bse-or-n3sg verb forms, and we treat
;; one of the subjunctive forms as just the base form, we can't require that
;; embedded clauses add-in the n3s constraint on the subject, if we still
;; want to parse "we demand that he remain."  Instead, need to impose the
;; add-in unification for the complement of non-subjunctive-CP-taking verbs
;; (and presumably other non-main-clause contexts).  Hmm...
;; DPF 2014-04-01 - Re first comment above, we do actually want to allow
;; locative inversion in embedded clauses, such as verbs of saying:
;; "Kim said, here we are." So remove constraint.
;; DPF 2017-04-03 - Generalized VFORM from fin_or_bse to fin_or_bse_or_prp
;; to allow verbal gerunds.
;;

; CSY 10-12-2020 two nonmc rules: one for verb headed and one for adj headed clauses
;     5-1-2020 - since adj now have vform, this can apply to both types of clauses
;                there's no need for the special adj daughter
subjh_nonmc_rule := subjh_rule_decl & head_subj_phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin_or_bse_or_prp,
		       MC - ] ].

;subjh_nonmc_rule := subjh_nonmc_rule_super &
;  [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin_or_bse_or_prp ].

;subjh_adj_nonmc_rule := subjh_nonmc_rule_super &
;  [ SYNSEM.LOCAL.CAT.HEAD adj ].

subjh_rule_wh_insitu := binary_rule_right_to_left & head_subj_phrase & 
                        clause &
  [ SYNSEM [ LOCAL [ CAT [ HEAD v_or_g &
                                [ VFORM fin,
                                  INV -,
                                  PRD -,
                                  TAM indic_tam,
				  CASE non_nom ],
                           MC +,
                           POSTHD + ],
                     CONT.HOOK.INDEX.SF #pred & ques ],
             NONLOC [ SLASH 0-dlist,
                      QUE 0-dlist,
                      REL 0-dlist ],
             PUNCT.RPUNCT.PSF #pred ],
    HD-DTR.SYNSEM [ LOCAL [ CAT.VAL.SPR *olist*,
			    CONT.HOOK [ LTOP #ltop,
					INDEX #ind ] ],
                      NONLOC [ QUE 1-dlist,
                               REL 0-dlist,
                               SLASH 0-dlist ] ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD.POSS -,
                    NONLOC.QUE 0-dlist ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind & [ SF ques ] ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

hcomp_rule := binary_rule_left_to_right & head_comp_phrase.
h2comp_rule := binary_rule_left_to_right & head_second_comp_phrase.

hoptcomp_rule := rule & head_opt_comp_phrase.
noptcomp_rule := rule & noun_opt_comp_phrase.

;; To allow robust processing where normally obligatory transitive verbs
;; omit the direct object, as in dictionary definitions: |to devour|
hoptcomp_mal_rule := rule & basic_head_opt_comp_phrase &
  [ SYNSEM nonlex_synsem,
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL.CAT [ HEAD verb,
				  VAL.COMPS < unexpressed_reg &
					      [ OPT -,
						LOCAL.CAT.HEAD noun ] > ],
	              LEX + ] ],
    GENRE robust ].

hmark_e_phr_rule := binary_rule_left_to_right & head_marker_phrase_e_phr.
hmark_s_phr_rule := binary_rule_left_to_right & head_marker_phrase_s_phr.
hmark_a_lex_rule := binary_rule_left_to_right & head_marker_phrase_a_lex.
hmark_nom_rule := binary_rule_left_to_right & head_marker_phrase_nom.
hmark_nbar_rule := binary_rule_left_to_right & head_marker_phrase_nbar.
hmark_atomic_rule := binary_rule_left_to_right & head_marker_phrase_atomic.

extracomp_rule := rule & extracted_comp_phrase.

extrasubj_fin_rule := rule & extracted_subj_phrase_fin.
;extrasubj_inf_rule := rule & extracted_subj_phrase_inf.

hspec_rule := binary_rule_right_to_left & head_spec_phrase.
hspec_hc_rule := binary_rule_right_to_left & head_spec_hc_phrase.
hspec_hc_cmp_rule := binary_rule_right_to_left & head_spec_hc_cmp_phrase.

adjh_s_rule := binary_rule_left_to_right & adj_head_scop_phrase.
;adjh_s_xp_rule := binary_rule_left_to_right & adj_head_scop_xp_phrase.
adjh_s_prpnct_rule := binary_rule_left_to_right & adj_head_scop_prpnct_phrase.
adjh_s_nopair_rule := binary_rule_left_to_right & adj_head_scop_nopair_phrase.
;adjn_i_rule := binary_rule_left_to_right & adj_n_infl_phrase.
;adjn_ni_rule := binary_rule_left_to_right & adj_n_noninfl_phrase.
adj_n_rule := binary_rule_left_to_right & adj_n_phrase.
adj_n_crd_comma_rule := binary_rule_left_to_right & adj_n_crd_comma_phrase.
adj_adjn_rule := binary_rule_left_to_right & adj_adjn_phrase.
adjh_i_rule := binary_rule_left_to_right & adj_h_int_phrase.
;adj_adjh_i_rule := binary_rule_left_to_right & adj_adjh_int_phrase.
adjh_i_inv_rule := binary_rule_left_to_right & adj_head_inv_phrase.
adjh_i_whsbj_rule := binary_rule_left_to_right & adj_head_whsbj_phrase.
adjh_i_rel_rule := binary_rule_left_to_right & adj_head_rel_phrase.

hadj_s_prpnct_nmc_rule := binary_rule_right_to_left & head_adj_scop_prpnct_nmc.
hadj_s_prpnct_mc_rule := binary_rule_right_to_left & head_adj_scop_prpnct_mc.
hadj_s_nopair_rule := binary_rule_right_to_left & head_adj_scop_nopair.
hadj_s_no_clpunct_rule := binary_rule_right_to_left & head_adj_scop_no_clpunct.
hadj_i_relcl_pr_rule := binary_rule_right_to_left & n_adj_relcl_prpnct.
hadj_i_relcl_npr_rule := binary_rule_right_to_left & n_adj_relcl_nopair.
hadj_i_relcl_asympr_rule := binary_rule_right_to_left & n_adj_relcl_asympr.
hadj_i_relcl_proper_rule := binary_rule_right_to_left & n_adj_relcl_proper_phr.
hadj_i_redrel_pr_rule := binary_rule_right_to_left & n_adj_redrel_prpnct.
hadj_i_redrel_npr_rule := binary_rule_right_to_left & n_adj_redrel_nopair.
hadj_i_redrel_asympr_rule := binary_rule_right_to_left & n_adj_redrel_asympr.
hadj_i_title_rule := binary_rule_right_to_left & n_adj_title_phrase.

hadj_i_unsl_rule := binary_rule_right_to_left & h_adj_unsl_phrase.
hadj_i_sl_rule := binary_rule_right_to_left & h_adj_sl_phrase.

v_mod_int_rule := binary_rule_left_to_right & v_mod_int_phrase.
v_mod_scop_rule := binary_rule_left_to_right & v_mod_scop_phrase.
v_mod_noun_scop_rule := binary_rule_left_to_right & v_mod_noun_scop_phrase.

conj_mod_int_rule := binary_rule_left_to_right & conj_mod_int_phrase.
conj_mod_scop_rule := binary_rule_left_to_right & conj_mod_scop_phrase.

prep_mod_prep_rule := binary_rule_left_to_right & prep_mod_prep_phrase.

extradj_i_vp_rule := rule & extracted_adj_int_vp_phrase.
extradj_i_s_rule := rule & extracted_adj_int_s_phrase.
extradj_i_s_coord_rule := rule & extracted_adj_coord_s_phrase.

;;extradj_npadv_rule := rule & extracted_adj_npadv_phrase.

fin_non_wh_rel_rule := rule & fin_non_wh_rel_cl.

inf_non_wh_rel_rule := rule & inf_non_wh_rel_cl.
inf_non_wh_subj_rel_rule := rule & inf_non_wh_subj_rel_cl.

instr_inf_non_wh_rel_rule := rule & instr_inf_non_wh_rel_cl.

fin_modgap_rel_rule := rule & fin_modgap_rel_cl.
inf_modgap_rel_rule := rule & inf_modgap_rel_cl.

red_rel_cl_rule := rule & red_rel_cl.

subconj_prdp_prp_rule := rule & subconj_prdp_prp_phr.
subconj_prdp_pas_rule := rule & subconj_prdp_pas_phr.
;subconj_prdp_pas_sl_rule := rule & subconj_prdp_pas_sl_phr.
;subconj_prdp_pas_lex_rule := rule & subconj_prdp_pas_lex_phr.
subconj_prdp_adj_rule := rule & subconj_prdp_adj_phr.
subconj_prdp_ellip_rule := rule & subconj_prdp_ellip_phr.
subconj_prdp_a_init_rule := rule & subconj_prdp_a_init_phr.
subconj_prdp_v_init_lex_rule := rule & subconj_prdp_v_init_lex.
subconj_prdp_v_init_rule := rule & subconj_prdp_v_init_phr.
np_pred_post_rule := binary_rule_right_to_left & np_pred_phr &
  [ SYNSEM [ PUNCT [ LPUNCT no_punct,
		     RPUNCT comma_or_clause_or_pair_or_no_punct ],
	     LOCAL.CAT [ HEAD.MOD.FIRST.PUNCT.RPUNCT hyphen_or_comma_or_clause,
			 POSTHD + ] ] ].

np_pred_pre_rule := binary_rule_right_to_left & np_pred_phr &
  [ SYNSEM [ PUNCT [ LPUNCT no_punct,
		     RPUNCT comma_or_rbc_punct ],
	     LOCAL.CAT [ HEAD.MOD.FIRST.PUNCT.RPUNCT comma_or_clause,
			 POSTHD - ] ] ].

np_pred_paren_rule := binary_rule_right_to_left & np_pred_phr &
  [ SYNSEM [ PUNCT.LPUNCT lparen_punct,
	     LOCAL.CAT.HEAD.MOD.FIRST.PUNCT.RPUNCT pair_or_no_punct ] ].

; ERB (19-01-98) The single non_wh_rel_rule dream didn't come true.
; non_wh_rel_rule := rule & non_wh_rel_cl.

bare_np_rule := rule & bare_np_phrase.
bare_np_prd_rule := rule & bare_np_prd_phrase.
;bare_nomger_rule := rule & bare_nomger_phrase.
proper_np_rule := rule & proper_np_phrase.
;proper_np_conj_rule := rule & proper_np_conj.
num_np_rule := rule & num_np_noconj.
;num_np_conj_rule := rule & num_np_conj.
bare_npq_rule := rule & bare_npq_phrase.

bare_np_sg_rule_robust := rule & bare_np_sg_phrase_robust.
detlesspp_np_nmod_rule := rule & detlesspp_np_nmod_phrase.
detlesspp_np_jmod_rule := rule & detlesspp_np_jmod_phrase.
detlesspp_np_nomod_rule := rule & detlesspp_np_nomod_phrase.

bare_vger_rule := rule & bare_vger_phrase.

np_n_cmpnd_rule := binary_rule_right_to_left & np_n_cmpnd_phr.
np_n_cmpnd_pr_rule := binary_rule_right_to_left & np_n_cmpnd_pr_phr.
np_title_cmpnd_rule := binary_rule_right_to_left & np_title_cmpnd_phr.
np_title_cmpnd_pl_rule := binary_rule_right_to_left & np_title_cmpnd_pl_phr.
np_name_cmpnd_rule := binary_rule_right_to_left & np_name_cmpnd_phr.
np_num_cmpnd_rule := binary_rule_right_to_left & np_num_cmpnd_phr.
np_city_state_rule := binary_rule_right_to_left & np_city_state_phr.
noun_n_cmpnd_rule := binary_rule_right_to_left & noun_n_cmpnd_phr.
noun_adjn_cmpnd_rule := binary_rule_right_to_left & noun_adjn_cmpnd_phr.

;; DPF 2020-04-01 - Added NH-DTR..PNG norm-png to exclude redundant
;; analysis for |$100 project|.
;; DPF 2020-04-02 - Removed HD-DTR.SYNSEM basic_lex_synsem, since it
;; excludes compound head.
noun_n_cmpnd_pl_rule := binary_rule_right_to_left & noun_n_cmpnd_pl_phr &
  [ NH-DTR.SYNSEM [ PUNCT.RPUNCT hyphen_or_pair_or_no_punct,
		    --SIND.PNG norm-png ] ].
;; DPF 2018-01-07 - Removed recently added ND.DTR..COMPS *nogapnull* since it
;; prevents such compounds with any relational noun, as in
;; |the $55 million cash-and-stock acquisition of IBM|
;; Check to see what ambiguity this constraint was avoiding and FIX?
;; This is for comma-marked non-head with compound hd-dtr, as in
;; |$10 million, three-year contract|
;;
noun_n_cmpnd_pl_nonlex_rule := binary_rule_right_to_left & noun_n_cmpnd_pl_phr &
  [ HD-DTR.SYNSEM nonlex_or_lex_phr_synsem,
    NH-DTR.SYNSEM.PUNCT.RPUNCT rbcomma_punct ].

noun_n_cmpnd_pl_mnp_rule := binary_rule_right_to_left & noun_n_cmpnd_pl_mnp_phr.

;n_v-or-adj_cmpnd_eg_rule := binary_rule_right_to_left & 
;			    n_v-or-adj_cmpnd_eg_phr.
;n_v-or-adj_cmpnd_ig_rule := binary_rule_right_to_left & 
;			    n_v-or-adj_cmpnd_ig_phr.
n_v_cmpnd_rule := binary_rule_right_to_left & n_v_cmpnd_phr.
n_adj_cmpnd_rule := binary_rule_right_to_left & n_adj_cmpnd_phr.
n_adj_intr_cmpnd_rule := binary_rule_right_to_left & n_adj_intr_cmpnd_phr.
n-adj_rule := rule & n-adj_phrase.
adj_v_cmpnd_rule := binary_rule_right_to_left & adj_v_cmpnd_phr.
mnp_vp_rule := binary_rule_left_to_right & mnp_vp_phr.
;appos_prpnct_rule := binary_rule_right_to_left & appos_phr_prpnct.
appos_prpnct_rule := binary_rule_right_to_left & appos_phr_nonprop_prpnct.
appos_prpnct_pnr_rule := binary_rule_right_to_left & appos_phr_prop_prpnct.
appos_prpnct_num_rule := binary_rule_right_to_left & appos_phr_num_prpnct.
appos_nopair_rule := binary_rule_right_to_left & appos_phr_nonprop_nopair.
appos_nopair_pnr_rule := binary_rule_right_to_left & appos_phr_prop_nopair.
appos_rbc_rule := binary_rule_right_to_left & appos_phr_rbc.
appos_prop_rbc_rule := binary_rule_right_to_left & appos_phr_prop_rbc.
appos_indef_rule := binary_rule_right_to_left & appos_indef_phr.
appos_indef_paren_rule := binary_rule_right_to_left & appos_indef_paren_phr.
appos_indef_rbc_rule := binary_rule_right_to_left & appos_indef_rbc_phr.
appos_nbar_rule := binary_rule_right_to_left & appos_nbar_phr.
appos_reverse_rule := binary_rule_left_to_right & appos_np_reverse_phr.
appos_measnp_rule := binary_rule_right_to_left & appos_phr_meas_prpnct.
appos_deictic_rule := binary_rule_right_to_left & appos_phr_deictic_prpnct.
npadv_mod_rule := rule & npadv_mod_phrase.
;;npadv_yofc_rule := rule & npadv_yofc_phrase.
;; DPF 2020-03-24 - Added MOD..HEAD non_noun as per trunk.
npadv_measnp_rule := rule & npadv_measnp_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD non_noun ].
;; DPF 2020-03-24 - Added rule as per trunk.
npadv_measnp_nommod_rule := rule & npadv_measnp_phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST [ LOCAL.CAT.HEAD basic_noun,
				      MODIFD rmod ] ].
measure_np_rule := binary_rule_right_to_left & measure_np_phrase.
measure_np_ppof_rule := binary_rule_right_to_left & measure_np_ppof_phrase.
measure_np_symbol_rule := binary_rule_left_to_right & measure_np_symbol_phrase.
bare_measure_np_rule := rule & bare_measure_np_phrase.
meas_np_degadv_attr_rule := rule & meas_np_degadv_attr_phrase.
meas_np_degadv_bare_attr_rule := rule & meas_np_degadv_bare_attr_phrase.
meas_np_degadv_pred_rule := rule & meas_np_degadv_pred_phrase.
num_noun_rule := rule & num_noun_phrase.
num_noun_seq_rule := rule & num_noun_sequence_phrase.
color_noun_rule := rule & color_noun_phrase.
;np_cp_rule := rule & np_cp_phrase.
np_cp_wh_rule := rule & np_cp_wh_phrase.
cp_subj_rule := rule & cp_subj_phrase.
cp_subj_inf_rule := rule & cp_subj_inf_phrase.

;; DPF 2018-04-20 - For VPs other than simple intransitives, where the subject
;; is optional: |chasing cats amuses dogs|
;;
vgerund_rule := rule & vgerund_phrase &
  [ SYNSEM.NONLOC.SLASH 0-dlist,
    ARGS < [ SYNSEM nonlex_synsem ] > ].

;; DPF 2018-04-20 - For simple intransitive VPs, where the subject is oblig,
;; to avoid spurious ambiguity with nominal gerunds: not for |barking amuses
;; dogs| but for |Fido barking amuses everyone|.
;;
vgerund_intr_rule := rule & vgerund_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.SPR.FIRSt unexpressed,
	     NONLOC.SLASH 0-dlist ],
    ARGS < [ SYNSEM lex_synsem &
		    [ LOCAL.CAT.VAL.SUBJ.FIRST.OPT -,
		      PUNCT no_punctuation ] ] > ].

vgerund_slash_rule := rule & vgerund_phrase &
  [ SYNSEM.NONLOC.SLASH 1-dlist & 
			[ LIST *arglist* &
			       [ FIRST.CAT.HEAD n_or_p & [ CASE non_nom ] ] ],
    ARGS < [ SYNSEM nonlex_synsem &
		    [ LOCAL.CAT.VAL.SUBJ.FIRST.NONLOC.SLASH 0-dlist ] ] > ].

cl_adv_rule := rule & cl_adv_phrase.
npindef_adv_rule := rule & indef_np_adv_phrase.

fw_seq_l_rule := fw_sequence_left_phrase & binary_rule_left_to_right.
fw_seq_r_rule := fw_sequence_right_phrase & binary_rule_left_to_right.
fw_w_rule := unary_fw_phrase.

;; DPF 22-Dec-98 - Modified filler_head_rule_non_wh to require head to be 
;; VFORM fin, in order to block "*Kim hire".  The VFORM used to be fin_or_imp,
;; to allow an extraction analysis of "On Monday hire Kim", but this also
;; allowed a spurious second analysis for "On Monday tell Kim that Sandy left".
;; So a new construction for left dislocation is needed for "On Monday hire Kim",
;; one which would also admit "As for that book, who did it offend?" where a
;; (double) extraction analysis would otherwise be required.

;; DPF 29-Jan-99 - Constrained nonhead_dtr to be HEAD n_or_p, in order to block
;; Yoda examples like "Happy you will be" or "Making a mess you are".  More
;; generally these should simply be dispreferred, but we'll block them for now.
;
; DPF 10-Jun-99 - Note that filler_head_rule_non_wh does not currently inherit 
; from non_rel_clause, but perhaps should.
; 
; DPF 10-Jun-99 - Removed mc_fillhead_phrase from filler_head_rule_non_wh since
; topicalized constructions can be embedded, as in "Kim thinks on Tuesday we
; should be in Berlin"
; -- DPF 24-Mar-01 - But this is too weak: we still need to block "*I'm sure 
; bananas he likes" - cf. examples with "bet".  So put back mc_fillhead_phrase,
; and wait for more inspiration about allowing S-init adjuncts for embedded S's
; DPF 2-Feb-01 - Generalized HEAD value of nonhead_dtr to include adverbs as
; well as n_or_p, to get "Quietly kim left"
; DPF 2-Apr-01 - Removed INV - from head-dtr to allow "here are my questions"
; DPF 13-May-01 - Added [HD-DTR..MODIFD notmod_or_rmod] to prevent root
; exclamatives like "oh" from modifying the head of the head-filler.
; DPF 25-Sep-01 - From 2-Apr-01: But this overgenerates too much, so putting
; it back in (cf "*There is Kim Sandy")
; DPF 12-Apr-02 - Apparently INV - was put back on head-dtr (see 2-Apr-01) --
; this blocks non-wh PP-fronting for yes-no questions, as in "On Tuesday did
; Kim arrive".  Maybe right not to treat these as unbounded dependencies -
; note lack of ambiguity for "tomorrow can you ask Sandy to call me?"
; DPF 1-Jun-02 -Added HD-DTR..MSG.PRED prop-or-ques_m_rel to exclude imperatives
; since sometime between 22-Dec-98 and now (see above) the VFORM constraint was
; removed, but we still want to block "*kim hire".
; DPF 13-Oct-03 - But blocking "Kim hire" also prevents us from getting PPs
; fronted for imperatives, as with "On Sunday, buy two books".  It also blocks
; "Books about elephants, buy only on Sundays" which seems fine.  So removed
; this constraint, and expect punctuation to catch "*Kim hire" since we want
; a comma after fronted phrase for imperatives.
; DPF 26-Nov-03 - Further constrained head-dtr's MODIFD (see 13-May-01) to
; exclude rmod, to avoid spurious parse for "Kim we hired, singing".
; DPF 21-aug-04 - Try relaxing hd-dtr's MODIFD value to notmod_or_lmod, to
; allow e.g. "on Tuesday, if you wish, leave early"
; DPF 27-aug-04 - Removed parent mc_fillhead_phrase to allow these as
; subordinate clauses, as in "since on Tuesday they'll leave"
; DPF 8-apr-05 - Removed NH-DTR..MSG no_msg to get "Kim arrived, Abrams said."
; DPF 05-sept-05 - Tried making NH-DTR..RPUNCT include clause_punct, to
; allow "Who arrived? asked Kim."  But this means unwanted overgeneration
; like "Kim. we hired" and "Kim? we hired".  So we'll have to find another
; analysis for this stripped down clause-fronting - note that if the 
; fronted sentence is quoted, all is well with the existing pair_punct
; constraint on the non-hd dtr.
; DPF 9-oct-05 - The nonhd-dtr was marked [CASE non_obliq] as a hack to
; prevent lexical PPs from fronting (see 25-mar-05 in lextypes.tdl)
; but this prevents us from getting "Here Kim slept" now that we want "here" 
; to be [CASE obliq] in order to prevent these as direct objects as in "here 
; kim plunged into the lake". So we'll look for another way to block the
; unwanted parse for "on the first kim arrived" if indeed we should.
; DPF 23-nov-06 - Re: 27-aug-04: Restored MC + since we now distinguish two
; types of subordinating preps, one class like "since" which allow topicalized
; complement S, and the other class like "after" which don't.
;; DPF 21-mar-10 - Added CASE non-obliq to prevent these from appearing e.g.
;; as complements of subordinating conjunctions that don't want them.
;; DPF 2010-10-23 - FIX: We're wrongly asserting here that embedded non-wh
;; filler-head constructions cannot have bse-form verb, thus blocking
;; |we demanded that on Monday he be released|.  But we would have to 
;; add main-clause and non-mc variants of this rule, which is already split
;; with respect to comma-marked filler.  So undergenerate for now.
;; DPF 2011-08-07 - Re: 21-aug-04: removing HD-DTR.MODIFD notmod_or_lmod,
;; now that we propagate value in subj-head phrase, since we still want
;; extraction from VP modifying PP: "that office, the consultants work in.'
;; DPF 2012-02-12 - Can't see why the mother wasn't REL 0-dlist, but the lack
;; meant we get the phrase |I feel like a little kid| as the filler in the
;; fillhead_rel rule.  Corrected.
;; DPF 2016-02-26 - We can't identify RPUNCT.PSF with INDEX.SF on hd-dtr,
;; because when this filler-head phrase is a complement, we can get a clash with
;; what the higher verb wants as in the imperative
;; |note that in Paris we arise.|  
;; So undo this link, and FIX eventually, maybe by introducing non-branching
;; root rule(s).
;; DPF 2020-08-14 - Re 2016-02-26: In general, we need this identity, to avoid
;; generating "Yesterday, we arose?" from "Yesterday, we arose."  So split each
;; instance of this rule into MC +/- where the main clause one does identity.
;;
basic_filler_head_rule_non_wh := binary_rule_right_to_left & 
                           basic_head_filler_phrase_fin &
                           head_compositional & clause &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD.CASE non_obliq,
			   VAL.SUBJ *olist* & < anti_synsem_min >,
                           MC bool ],
                     CONT [ HOOK.XARG #xarg ] ],
             NONLOC non-local_none ],
    HD-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD verbal & [ TAM indic_tam ],
                                    VAL.SUBJ *anti_cons* ],
                              CONT.HOOK [ XARG #xarg,
					  INDEX #vind ] ],
                      NONLOC [ SLASH <! [ CAT.MC #mc,
                                          CONT.HOOK.INDEX #nhind ] !>,
                               QUE 0-dlist ] ] ],
    NH-DTR [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD subst_or_adv_or_frag,
                                    MC #mc ],
                              CONT.HOOK.INDEX #nhind ],
                      NONLOC [ QUE 0-dlist,
                               REL 0-dlist ] ] ],
    C-CONT [ HOOK.INDEX #vind,
             RELS <!  !>,
             HCONS <! !>,
	     ICONS <! focus & [ IARG1 #vind,
				IARG2 #nhind ] !> ] ].

filler_head_rule_non_wh := basic_filler_head_rule_non_wh &
  [ HD-DTR.SYNSEM.LOCAL.CAT [ HEAD.INV -,
			      MC - ] ].

;; Non-WH inversion:
;; |Only yesterday did he arrive.|
;; |Not until today were the packages opened.|
;;
filler_head_rule_non_wh_inv := basic_filler_head_rule_non_wh &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF basic-prop,
    HD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV +,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD p_or_adv ].

filler_head_rule_non_wh_inv_mc := filler_head_rule_non_wh_inv &
  [ SYNSEM.LOCAL.CAT.MC +,
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.SF #psf,
		    PUNCT.RPUNCT.PSF #psf ] ].

filler_head_rule_non_wh_inv_nonmc := filler_head_rule_non_wh_inv &
  [ SYNSEM.LOCAL.CAT.MC - ].

; DPF 21-jan-10 - For now, change RPUNCT from comma_or_clause_or_pair_punct,
; but see note from 05-sept-05 above.  In particular, we will eventually
; want to generate e.g. |More coffee? she asked, along with |Victory! he
; exclaimed.  FIX.

filler_head_rule_non_wh_edgen := filler_head_rule_non_wh &
  [ NH-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_punct ].

filler_head_rule_non_wh_edgen_mc := filler_head_rule_non_wh_edgen &
  [ SYNSEM.LOCAL.CAT.MC +,
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.SF #psf,
		    PUNCT.RPUNCT.PSF #psf ] ].

filler_head_rule_non_wh_edgen_nonmc := filler_head_rule_non_wh_edgen &
  [ SYNSEM.LOCAL.CAT.MC - ].

;; DPF 2011-09-24 - Added NH-DTR..ALTMIN non_ellipt_rel in order to avoid
;; annoying (but stricly speaking, not spurious) ambiguity with do-be where
;; clause ending with elliptical copula be is treated as extracted from the
;; imperative clause that follows.
;; DPF 2012-10-09 - We don't want a filler-hd + imperative analysis for
;; |you work here|, but we do want to admit |on Friday eat fish|,


filler_head_rule_non_wh_infgen := filler_head_rule_non_wh &
  [ HD-DTR.SYNSEM.LEX -,
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD non_noun_or_adv &
				   [ MINORS.ALTMIN non_ellipt_rel ],
		    PUNCT.RPUNCT no_punct ],
    GENRE nonformal ].

filler_head_rule_non_wh_infgen_mc := filler_head_rule_non_wh_infgen &
  [ SYNSEM.LOCAL.CAT.MC +,
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.SF #psf,
		    PUNCT.RPUNCT.PSF #psf ] ].

filler_head_rule_non_wh_infgen_nonmc := filler_head_rule_non_wh_infgen &
  [ SYNSEM.LOCAL.CAT.MC - ].

filler_head_rule_non_wh_np := filler_head_rule_non_wh &
  [ HD-DTR.SYNSEM [ LEX -,
		    LOCAL.CONT.HOOK.INDEX.SF prop ],
    NH-DTR.SYNSEM [ LOCAL.CAT.HEAD basic_noun,
		    PUNCT.RPUNCT no_punct ],
    GENRE nonformal ].

filler_head_rule_non_wh_np_mc := filler_head_rule_non_wh_np &
  [ SYNSEM.LOCAL.CAT.MC +,
    HD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.SF #psf,
		    PUNCT.RPUNCT.PSF #psf ] ].

filler_head_rule_non_wh_np_nonmc := filler_head_rule_non_wh_np &
  [ SYNSEM.LOCAL.CAT.MC - ].

; CSY 3-12-2020 - take away INV + to allow sentences like
; <ex>what you want?
filler_head_rule_wh_super := binary_rule_left_to_right & 
			    head_filler_phrase_wh_fin & wh_interrog_fin & 
                            mc_fillhead_phrase &
  [ SYNSEM.LOCAL [ CAT [ ;HEAD.INV +,
                         VAL.SUBJ *olist* & < anti_synsem_min > ],
                   CONT.HOOK [ LTOP #hdtop,
                               INDEX #index ] ],
    HD-DTR.SYNSEM.LOCAL [ CAT.MC luk,
                          CONT.HOOK [ LTOP #hdtop,
                                      INDEX #index ] ],
    NH-DTR.SYNSEM [ PUNCT.RPUNCT comma_or_pair_or_no_punct ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

filler_head_rule_wh_root := filler_head_rule_wh_super &
 [ SYNSEM.LOCAL.CAT.HEAD.INV +,
   HD-DTR.SYNSEM.LOCAL.CAT.MC na ].

; CSY 3-12-2020
filler_head_rule_wh_mc := filler_head_rule_wh_super &
"""
<ex>What you want?
"""
 [ SYNSEM.LOCAL.CAT.HEAD.INV -,
   HD-DTR.SYNSEM.LOCAL.CAT.MC luk ].


; DPF (21-Apr-98) To block use of fill_head_wh_subj in "Kim knows who Sandy 
; saw" added constraint that filler must be [CASE NOM].
; DPF 15-Oct-01 - Removed [AUX -]: was wrong.
; DPF 15-May-02 - Changed HEAD.INV - to HEAD.INV -* to allow for coordination 
; of inverted and non-inverted sentences.
; DPF 31-May-02 - Added restriction on head-dtr for MSG.PRED prop-or-ques_m_rel 
; to block imperative S-comp, as in "*I know which manager hire"
; DPF 24-jun-05 - Further restricted the head-dtr's MSG to always be
; prpstn_m_rel.
; 
filler_head_rule_wh_subj := binary_rule_left_to_right & 
			    head_filler_phrase_wh_fin & wh_interrog_fin & 
			    mc_fillhead_phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD.INV -,
			 VAL.SUBJ *olist* & < anti_synsem_min > ],
                   CONT.HOOK.XARG #xarg ],
    HD-DTR.SYNSEM.LOCAL [ CAT [ VAL.SUBJ < > ],
                          CONT.HOOK.XARG #xarg ],
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD basic_noun & [ CASE nom ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF (21-Apr-98) Removed constraint making HD-DTR [MC -], since this was
; blocking "Abrams knows who Kim saw."
; DPF 31-May-02 - Added restriction on head-dtr for MSG.PRED prop-or-ques_m_rel
; to block imperative S-comp, as in "*I know which manager hire"
; DPF 24-jun-05 - Further restricted the head-dtr's MSG to always be
; prpstn_m_rel.
; DPF 03-mar-06 - Without messages, we no longer have the 'double message' 
; option where we could make the head_subj_nonmc type be MSG prop, and still 
; use it in constructing the sentential complement of 'whether'.  Now that
; construction has to leave MOOD underspecified, so it must be assigned by 
; the head that selects it, or by the construction that embeds it.  Hence it 
; must itself have some property incompatible with the complement of 'wonder',
; but not a HEAD property since the head-filler phrase used for 'wonder who 
; Abrams hired' is a headed phrase.  So instead we make use of a contrast in 
; the SUBJ value for head-filler phrases vs head-subject phrases: the latter
; make it a non-empty *anti_list* while complementizers have a simple empty
; list.  So we make non-root WH head-filler phrases also assign SUBJ < >, 
; and have 'wonder' verbs impose this constraint on their complements.
;; DPF 2012-06-22 - Changed SUBJ < > to *anti_null* to prevent these from 
;; undergoing the non-clause head_marker_event rule.
;; DPF 2018-04-29 - Added CASE nom_or_obliq to prevent finite-WH clauses from
;; undergoing the np_frag rule, to avoid spurious analysis for e.g.
;; |Kim asked who arrived|, and similarly for infinitival variant.
;;
filler_head_rule_wh_nr_fin := binary_rule_left_to_right & 
			      head_filler_phrase_wh_fin & wh_interrog_fin &
  [ SYNSEM.LOCAL.CAT [ HEAD [ INV -,
			      CASE nom_or_obliq ],
                       VAL.SUBJ *anti_null*,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL [ CAT.MC -,
                          CONT.HOOK.LTOP #hdtop ],
    NH-DTR.SYNSEM [ PUNCT.RPUNCT comma_or_rbc_or_pair_or_no_punct ],
    C-CONT [ HOOK.LTOP #hdtop,
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 13-Nov-99 - Restricted SUBJ on mother to be 'unexpressed' to prevent
; the subject-extraction rule from applying.
; DPF 13-Nov-99 - Changed [MC na] to [MC -] since e.g. "know" wants an MC -
; complement, as in "kim knows who to hire".
; DPF 26-Mar-01 - Added to head-dtr: SUBJ..SLASH 0-dlist to avoid wrong
; subj-extraction parse for "Kim knew who to approach".
; DPF 03-mar-06 - Changed SUBJ value to < >, to prevent "whether who to hire"
;; DPF 2012-06-22 - Changed SUBJ < > to *anti_null* to prevent these from 
;; undergoing the non-clause head_marker_event rule.

filler_head_rule_wh_nr_inf := binary_rule_left_to_right & 
			      head_filler_phrase_inf & wh_interrog &
  [ SYNSEM.LOCAL.CAT [ HEAD [ CASE nom_or_obliq ],
		       VAL.SUBJ *anti_null*,
		       MC - ],
    HD-DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < synsem >,
                          CONT [ HOOK.LTOP #hdtop ] ],
    C-CONT [ HOOK.LTOP #hdtop,
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 25-Nov-01 - Added SYNSEM..RPERIPH + to enable blocking of thatless-rel
; attaching after WH-relative
; DPF 8-Jul-02 - Changec C-CONT.HOOK.LTOP to be re-entrant with head-dtr's 
; LTOP rather than with its MSG..LBL, since the latter does the wrong thing
; at least for coordinated relative clauses as in "The programmar Abrams
; interviewed and Browne hired arrived".
; DPF 19-dec-03 - Added propagation of NORM constraint from nbar-filler 
; "that" for "the place that Kim bought the book" - modable_rel preserved, 
; to get same effect as with actual gap in simple that-less rel construction.
; This is just a hack, but the right solution is elusive.
; DPF 29-jun-09 - Re 25-Nov-01: Changed RPERIPH to na_or_+: see related note 
; for n_adj_relcl_phrase.
; DPF 02-jul-09 - Removed identification of SUBJ on mother and dtr, since
; we want these rel clauses to be admitted in the head_marker_event rule
; (for verbal projections that are MC na), but that rule rejects
; SUBJ *anti_list*.
;; DPF 2013-08-26 - Changed RPUNCT on NH-DTR from rparen_or_rbc_or_no_punct
;; to rparen_or_no_punct, to avoid generating |the cat, which, arose, arrives|
;; DPF 2014-07-22 - Identifying MOD..XARG with filler's REL..XARG is part of
;; the analysis of do-be, but gets in the way of pied-piping as in
;; |its debt on which we admire last month| - -FIX?
;; DPF 2014-10-20 - Re 2013-08-26: But we want |the cat which, in Paris, slept|
;; so we take advantage of the punctuation pairing to distingish this from
;; the unwanted |the cat, which, arose|, by adding |PNCTPR ppair|.
;; DPF 2016-07-04 - Re 19-dec-03: Now that we want NORM to distinguish that-rel
;; from WH-rel (for fragments; see 2016-07-04 on filler_head_fin_rel_rule),
;; try dropping propagation of NORM from filler to MOD's NORM.
;; DPF 2016-09-05 - Re 2014-07-22: To be more precise, the do-be analysis needs
;; the XARG of the NP |the thing we did| to be the index of the subject of the
;; verb `do', so that the do-be copula can identify its subject's XARG with its
;; complement's XARG, to get the control right for who does the winning in
;; |the thing we did was win|.  That XARG of the NP thus has to be passed up
;; even through clausal boundaries: |the thing she thought we did was win|. So
;; we identify the XARG of that `do' with its SLASH's XARG, and then at the top
;; of the relative clause, identify the SLASH..XARG with the REL..XARG and with
;; the MOD..XARG, so it gets identified with the head noun's XARG.
;;   The problem with |my couch on which we sat arrived| is that the XARG of
;; the SLASH in |on which we sat| is the normal XARG of the PP |on which|, 
;; namely the event INDEX of the VP it is modifying.  So identifying that XARG
;; with the noun's XARG leads to a clash when there is a possessive determiner,
;; because our analysis of possessive idioms needs to expose the possessor
;; INDEX, which is of course a ref-ind, not an event.
;;   Fortunately, the do-be construction does not allow pied-piping relative
;; clauses, so we can split the each of the finite and nonfinite 
;; filler-head-relative rules into two rules, one for NP fillers, where the 
;; SLASH..XARG is identified with MOD..XARG, and one for PP fillers, where 
;; this identification is not made.
;; DPF 2016-10-22 - Re 2014-10-20: Alas, this ppair constraint prevents
;; |cat which, though happy, jumped| because the rule requires the filler to
;; have a non-robust comma (if any).  However, we really want the structure to
;; be |[which, though happy,] jumped], and if we had this, the commas would
;; likely be content.  So FIX to allow subord-phrase post-modifiers of rel pros.
;;

; CSY 17-12-2020 - superset to create two branches for the verb and adjective COMPS
; by removing HEAD verbal & [ VFORM #vform & fin_or_inf, from 2nd ARGS and VFORM from the mother
;;    5-1-2020 - #totest uncomment the vform values
filler_head_rel_super_rule := binary_rule_left_to_right & rel_cl & 
			basic_head_filler_phrase & 
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ ;VFORM #vform,
				  TAM #tam,
				  AUX #aux,
				  INV #inv,
				  PRD -,
				  MOD < [ --SIND #ind ] >,
				  --ADDIN #addin,
				  MINORS.MIN #min ],
			   VAL [ SUBJ < >,
				 SPR < > ] ],
		     AGR #agr ],
             MODIFD.RPERIPH na_or_+ ],
    ARGS < [ INFLECTD na_or_+,
	     SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
                              CONJ cnil ],
		      NONLOC [ QUE 0-dlist,
                               REL 1-dlist &
                                   [ LIST < [ INDEX #ind,
					      XARG #xarg ] > ] ],
                      PUNCT [ RPUNCT rparen_or_comma_or_no_punct,
			      PNCTPR ppair ] ] ],
	   [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD v_or_a & [ ;VFORM #vform & fin_or_inf,
                                                    TAM #tam,
                                                    AUX #aux,
                                                    INV #inv,
						    --ADDIN #addin,
                                                    MINORS.MIN #min ],
				    VAL.SUBJ *olist_or_prolist*,
				    MC - ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #event & [ SF prop-comm ] ],
			      AGR #agr,
			      CONJ cnil ],
                      NONLOC [ QUE 0-dlist,
                               REL 0-dlist,
			       SLASH <! [ CONT.HOOK.XARG #xarg ] !> ] ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

filler_head_rel_rule := filler_head_rel_super_rule &

  [ SYNSEM.LOCAL.CAT.HEAD.VFORM #vform,
    ARGS < [ INFLECTD na_or_+,
	     SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
                              CONJ cnil ],
		      NONLOC [ QUE 0-dlist,
                               REL 1-dlist &
                                   [ LIST < [ INDEX #ind,
					      XARG #xarg ] > ] ],
                      PUNCT [ RPUNCT rparen_or_comma_or_no_punct,
			      PNCTPR ppair ] ] ],
	   [ INFLECTD +,
             SYNSEM.LOCAL.CAT.HEAD verbal &
				 [ VFORM #vform & fin_or_inf ] ] > ].  


; DPF 03-mar-06 - In order to block "*The book which to buy." while
; allowing "the book on which to rely" and "the book which he bought", divide
; the flr-hd_rel-fin_c rule into two, one for infinitivals which requires the
; filler to be a non-np, and the other for finite rels.
;; DPF 2011-09-30 - Leave the left dtr unmarked for INFLECTD, so we can treat
;; the relative pronoun `that' as uninflected, to prevent it from appearing
;; in pied-piping relative clauses, since the head-complement rule requires
;; the non-head to be INFLECTD +.
;; DPF 2016-07-04 - Propagate NORM value from left dtr to mother, so we
;; can distinguish that-relatives from WH-relatives, to allow the latter as
;; fragments but not the former, as in |Which we said earlier.|
;; DPF 2018-05-28 - Also propagate ALTMIN from right dtr so we can choose to 
;; exclude elliptical relative clauses as post-VP modifiers
;;

basic_filler_head_fin_rel_rule := filler_head_rel_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS [ ALTMIN #altmin,
				   NORM #norm ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM #norm ],
	   [ SYNSEM.LOCAL.CAT [ HEAD verbal & [ VFORM fin,
					        MINORS.ALTMIN #altmin ],
				VAL.SUBJ *olist* ] ] > ].

; just for adj headed COMPS
basic_filler_head_fin_rel_adj_rule := filler_head_rel_super_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS [ ALTMIN #altmin,
				   NORM #norm ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM #norm ],
	   [ SYNSEM.LOCAL.CAT [ HEAD adj &
					      [ MINORS.ALTMIN #altmin ],
				VAL.SUBJ *olist* ] ] > ].

;; DPF 2016-09-05 - Also split finite rule into NP gap vs PP gap, since only 
;; the NP one identifies the SLASH..XARG with the MOD..XARG, to enable 
;; long-distance control in the do-be construction
;;
filler_head_fin_np_rel_rule := basic_filler_head_fin_rel_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CONT.HOOK.XARG #xarg,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.SPR *olist* ],
	   [ SYNSEM.NONLOC.SLASH <! [ CAT.HEAD noun_or_nomger,
				      CONT.HOOK.XARG #xarg ] !> ] > ].

; CSY 17-12-2020 - rule for adj headed COMPS
filler_head_fin_np_arel_rule := basic_filler_head_fin_rel_adj_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CONT.HOOK.XARG #xarg,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.SPR *olist* ],
	   [ SYNSEM.NONLOC.SLASH <! [ CAT.HEAD noun_or_nomger,
				      CONT.HOOK.XARG #xarg ] !> ] > ].

filler_head_fin_pp_rel_rule := basic_filler_head_fin_rel_rule &
  [ ARGS < [ ], [ SYNSEM.NONLOC.SLASH <! [ CAT.HEAD a_or_p ] !> ] > ].

;; DPF 16-jul-10 - Also constrain the infinitival variant to only allow the
;; head to be a VP, to block |*cats with which Abrams to play|

filler_head_inf_rel_rule := filler_head_rel_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD prep ],
           [ INFLECTD +,
             SYNSEM.LOCAL.CAT [ HEAD.VFORM inf,
				VAL.SUBJ < synsem > ] ] > ].


; ERB (05-10-96) This no longer inherits from (old) mc_phrase because it also
; serves to make nonroot phrases, such as the bracketed phrase in: "On Tuesday
; [plan to meet Kim]".

imperative_mc_rule := rule & imp_phrase.
;imperative_slash_rule := rule & imp_slash_phrase.

yesno_rule := rule & yesno_phrase.
inv_decl_rule := rule & inv_decl_phrase.

; The top_coord_rule is for building the ltop of a (potential iterated)
; coordinate structure and the mid_coord_rule is for building intermediate
; parts of an iterated coordinate structure.  The mid_coord_rule (and the
; head/marker schema) collect the handels and indices of the conjuncts under
; the CONJ feature and passes them (with the lexically specified coordination
; relation) up from the right conjunct.  The top_coord_rule uses handels and
; liszts from the CONJ value to build the values for an n-ary coordination 
; relation.  We could skip all this feature passing if we weren't limited by 
; performance considerations to binary trees.  That is, we could build 
; coordinate structures like:					  
;       						  
;       						  
;      coord_phrase					  
;             +-			          -+	  
;             | conj_rel  		           |	  
;      RELS  | C-HNDLS  [h1], [h2], ..., [hn]   |	  
;             | C-INDICES  [i1], [i2], ..., [in]   |	  
;             +-    		                  -+	  
;             /             /                \ 	 	  
;            /  	   /    	      \  	  
;           /   	  /     	       \ 	  
;          /    	 /      		\ 	  
;         /     	/       		 \ 	  
;      phrase        phrase    	       	       phrase	  
;      LTOP   [h1]    LTOP   [h2] ...            LTOP   [hn]
;      INDEX [i1]    INDEX [i2]                INDEX [in]
;        |             |                	 |  
;        |             |                         |  
;       Kim          Sandy       ...            Lee 
;       			     
; then we could eliminate the features HNDLS and INDICES.  These
; feature are just for bookkeeping.  The feature LEFT, on the other hand, is
; essential to the analysis.  The LEFT value is a list of (up to) two
; elements.  The first element is the required CONJ value of the left conjunct
; in a top_coord_phrase and the second element is the CONJ value of the left
; conjunct in a mid_coord_phrase.  For example, a LEFT value of < either, or >
; permits a coordinate structure like "either Kim or Sandy or Chris or Lee".

; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 6-Jun-03 - Tried making the MIN of mother be that of left dtr rather than
; right dtr, given that neither is right in principle.  Want to get "an hour
; and a half" to still be temporal-noun.  But this fails because the MIN of
; "either Monday" is a conj_rel (in "either Monday or Tuesday") while the MIN
; of "Monday" is a day_rel (in "Monday or Tuesday").  So only the right dtr
; consistently puts the right conjunct's MIN in one place: the ALTMIN of
; "and Tuesday".  So let's consider making "a half" unspecified for SORT.
;
basic_top_coord_rule := binary_rule_right_to_left & gen_coord_phr &
  [ SYNSEM [ LOCAL [ CONT.HOOK.INDEX #ind,
                     CONJ cnil & [ LCHEAD #left ] ],
             PUNCT [ LPUNCT #lpunct,
                     PAIRED #rpnctpr,
                     RPUNCT #rpunct ] ],
    LCONJ-DTR.SYNSEM [ LOCAL local & [ CONJ conj_min & #left ],
                       PUNCT [ LPUNCT #lpunct,
                               RPUNCT comma_or_rbc_or_semi_or_pair_or_no_punct,
                               PNCTPR #pnctpr ] ],
    RCONJ-DTR.SYNSEM [ LOCAL local &
                       [ CONT.HOOK.INDEX #ind,
                         CONJ complex-conj & 
                              [ CHEAD #left,
                                CPUNCT #pnctpr ] ],
                       PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
                               RPUNCT #rpunct,
                               PAIRED #pnctpr,
                               PNCTPR #rpnctpr ] ],
    C-CONT.HOOK.INDEX #ind & conj-ind ].

top_coord_rule := basic_top_coord_rule &
  [ RCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #cltop,
    C-CONT.HOOK.LTOP #cltop ].

; DPF 28-Nov-02 - HOOK comes only from C-CONT
; Require RCONJ-DTR..LPUNCT comma_punct to rule out "Kim arose arrived and
; laughed" but allow both "Kim arose, arrived and laughed" and also
; "Kim arose, arrived, and laughed"  This assumes that conj_words do not 
; lexically constrain LPUNCT, unlike most words.  So in the base case (the
; first time this rule applies in a series of mid-conj's), the left dtr is
; optionally marked with a comma (RPUNCT comma_or_no_punct), but since the
; mother is [LPUNCT no_punct, RPUNCT comma_punct], the only way this rule
; can reapply is if the phrase picks up a left comma in order to match the
; requirement on the right dtr's LPUNCT.  (This arrangement looks like it
; would in principle accept a double comma on the left dtr in a recursively
; applied structure, as in "Abrams, Browne,, Chiang, and Devito", but the
; preprocessor doesn't admit the two successive commas, so we can live with
; this flaw for now.)
;   [ abrams [, [ browne [ and Chiang ]]]]
;   [ abrams [, [ [ browne ,] [ and Chiang ]]]]]
;   [ devito [, [ abrams [, [ [ browne ,] [ and Chiang ]]]]]
; This means that we get a spurious analysis for complex conjunctions where the
; conjoined phrase ends in a comma or period, since that licenses a left comma
; on the final conjunct: [arise [, smile [, [and [ go .]]]]].  FIX?? later.

; DPF 10-may-05 - Use new feature PUNCT.PAIRED to enable constraint on presence
; of commas in three (or more) part coordination, ensuring that if the 
; next-to-last conjunct is comma-marked, all leftward conjuncts are too,
; while if the next-to-last conjunct is not comma-marked, the next one
; doesn't have to be either, but can be.  The way it works is that the 
; affixation rule for comma punctuation stamps [PAIRED no-ppair], while
; a non-punctuated sign is underspecified for PAIRED.  This mid_coord_rule 
; type propagates that PAIRED property up from its left dtr, so it's still 
; visible on the mid-coordinated phrase.  Then the top_coord_rule requires 
; that its left dtr unifies its PUNCT.PNCTPR value with the PAIRED value of 
; its right dtr.  The effect is that if the next-to-last conjunct is unmarked, 
; it will not restrict the PNCTPR value of the top conjunct, but if the 
; next-to-last is comma-marked, it imposes a constraint (eventually) on the 
; top conjunct's PNCTPR value, forcing it to be a comma.
;; DPF 2014-10-19 - Changed left dtr's RPUNCT to also allow quotes, as in
;; |we arise, admire "Kim Browne" and sing songs.|
;;
basic_mid_coord_rule := binary_rule_right_to_left & min_coord_phr &
  [ SYNSEM [ LOCAL.CONJ phr-conj &
                        [ CHEAD #chead,
                          CREL basic_conj_relation &
                                [ LBL #ltop,
                                  PRED implicit_conj_rel,
                                  ARG0 #cind & non_expl ] ],
             PUNCT [ LPUNCT comma_or_no_punct,
                     RPUNCT #rpunct,
                     PAIRED #paired,
                     PNCTPR #rpnctpr] ],
    ARGS < [ SYNSEM [ LOCAL.CONJ cnil,
		      PUNCT [ LPUNCT comma_or_no_punct,
			      RPUNCT comma_or_semi_or_pair_or_no_punct,
			      PNCTPR #pnctpr,
			      PAIRED #paired ] ] ],
	   [ SYNSEM [ LOCAL [ CONJ complex-conj & 
				   [ CHEAD #chead ] ],
		      PUNCT [ LPUNCT no_punct,
			      RPUNCT #rpunct,
			      PAIRED #pnctpr,
			      PNCTPR #rpnctpr ] ] ] >,
    C-CONT.HOOK [ LTOP #ltop,
                  INDEX #cind & conj-ind ] ].

; Not NP mid-coord, whose LTOP must be free.
;
mid_coord_rule := basic_mid_coord_rule &
  [ SYNSEM.LOCAL.CONJ.CREL.LBL #ltop,
    C-CONT.HOOK.LTOP #ltop ].

; Edited variant requires left dtr to be comma marked.
mid_coord_edgen_rule := mid_coord_rule &
  [ ARGS.FIRST.SYNSEM.PUNCT.RPUNCT comma_or_semicol ].

; Informal variant has no comma on left dtr.
;; DPF 2018-06-01 - Right conjunct is CONJ lex-conj, to block iteration of
;; non-comma-marked coordination as in |cows cats dogs and mice| - efficiency.
;;
mid_coord_infgen_rule := mid_coord_rule &
  [ ARGS < [ SYNSEM.PUNCT.RPUNCT pair_or_no_punct ],
	   [ SYNSEM.LOCAL.CONJ lex-conj ] >,
    GENRE nonformal ].

; Coordination of non-nominal phrases (S's and VPs)
;; DPF 25-Feb-01 - Changed division of labor with these two rules, so the 
;; first now conjoins all phrases with event index values, while the second 
;; conjoins nominal phrases.

;; DPF 21-Aug-01 - Added E-INDEX.E.TENSE real_tense to both dtrs in order to
;; block conjunction of no-copula VPs (want the no-cop after conjunction).
;; DPF 12-Oct-06 - Changed determination of mother's TAM to come from first
;; daughter rather than second.  Seemingly arbitrary, and some prefer it.
;; DPF 2018-03-26 - Re 12-Oct-06: Moved identity of mother's and first dtr's
;; TAM down to top_coord subtype, since on mid_coord it wrongly forces the
;; first and second of three or more conjuncts to have the same tense.
;;
;; DPF 2019-11-25 nonlex_synsem
event_coord_rule := gen_coord_phr &
  [ SYNSEM nonlex_synsem,
    LCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    RCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #ltop,
				       INDEX conj_event ] ].

basic_top_coord_event_rule := basic_top_coord_rule & event_coord_rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX conj_event & [ E #tam ],
    LCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event_or_deg-ind & [ E #tam ] ].

top_coord_event_rule := basic_top_coord_event_rule & top_coord_rule &
  [ C-CONT.RELS <! !> ].

;; DPF 2018-06-09 - Corrected ARG2 of the implicit_conj_rel to be the INDEX
;; of RCONJ-DTR rather than the (old) LTOP.
;;
mid_coord_event_rule := mid_coord_rule & event_coord_rule &
  [ SYNSEM.LOCAL [ CONJ.CREL #rel ],
    RCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #ltop,
				       INDEX #rind ],
    ORTH [ FROM #from, TO #to ],
    C-CONT.RELS <! #rel & [ LBL #ltop,
			    ARG2 #rind,
			    CFROM #from, CTO #to ] !> ].

mid_coord_event_edgen_rule := mid_coord_event_rule & mid_coord_edgen_rule.
mid_coord_event_infgen_rule := mid_coord_event_rule & mid_coord_infgen_rule.

;; DPF 2018-02-27 - Added SLASH.LIST *arglist* to each of the dtrs, to block
;; the unwanted ATB extraction of adjuncts, as for |in Paris, we sang and
;; danced|, where if the PP were extracted from each of the conjuncts, its
;; ARG1 would have to be the unif of the ARG0s of both, forcing them to be
;; the same event.
;; DPF 2018-05-21 - The above constraint was propagating more than desired, 
;; as in |Here, we arrived as a way to sing and dance.| where the
;; VP |sing and dance| has SLASH.LIST *arglist*, so if `way' takes |to sing
;; and dance| as a complement rather than as a relative clause, the NP |a way 
;; to sing and dance| will also be SLASH.LIST *arglist*, and the same for the
;; PP |as a way ...|, but that unhappily prevents |arrived| from undergoing 
;; adjunct extraction (which makes the resulting SLASH.LIST be *modcons*), 
;; since the SLASH values of the two dtrs in the hd-adj rule are appended and 
;; their LIST values unified.  The correctoin was to observe that the head-adj
;; subtypes do not actually ever append the SLASH values of the dtrs, normally
;; instead passing up the SLASH value of the hd-dtr, except for the subtype that
;; allows a SLASH in the adjunct (but not in the head, ignoring parasitic gaps).
;; So changed basic_head_adj_phrase accordingly.
;;
;; DPF 2019-11-25 phr_synsem (LEX - is then redundant)
;;
basic_basic_verbal_coord_phr := gen_coord_phr &
  [ SYNSEM phr_synsem &
	   [ LEX -,
             LOCAL.CAT [ HEAD verbal,
			 VAL.SPCMPS < >,
                         MC #mc ] ],
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal,
				     MC #mc ],
			       CONT.HOOK.LTOP #ltop ],
		       NONLOC.SLASH.LIST *arglist*,
                       PUNCT.RPUNCT comma_or_semi_or_pair_or_no_punct ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD verbal,
				     MC #mc ],
			       CONT.HOOK.LTOP #ltop ],
		       NONLOC.SLASH.LIST *arglist* ] ].


; CSY 19-10-2020 - a parallel of the verbal coord rule to use of predicative (nocop) adj for Singlish
; CSY 31-10-2020 - take away intrans_nocop_pred_adj_synsem from the rconj
basic_basic_adj_coord_phr := gen_coord_phr &
  [ SYNSEM phr_synsem &
	   [ LEX -,
             LOCAL.CAT [ HEAD adj,
			 VAL.SPCMPS < >,
                         MC #mc ] ],
    LCONJ-DTR.SYNSEM nocop_pred_adj_synsem &
		     [ LOCAL [ CAT [ HEAD adj,
				     MC #mc ],
			       CONT.HOOK.LTOP #ltop ],
		       NONLOC.SLASH.LIST *arglist* ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD adj,
				     MC #mc ],
			       CONT.HOOK.LTOP #ltop ],
		       NONLOC.SLASH.LIST *arglist* ] ].

basic_verbal_coord_phr := basic_basic_verbal_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD #prd,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD #prd,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD #prd ].

; CSY 19-10-2020 - nocop adj version
basic_adj_nocop_coord_phr := basic_basic_adj_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD #prd,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD #prd,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD #prd ].

; CSY 19-10-2020 - nocop adj version, to allow "she pretty and smart."
nocop_adj_coord_phr := basic_adj_nocop_coord_phr & norm_coord_phr.

verbal_coord_phr := basic_verbal_coord_phr & norm_coord_phr.

; DPF 13-nov-05 - Removed HEAD verb on mother and daughters, since this
; prevented coordination of infinitival VPs: "Kim tried to sing and to dance"
; DPF 18-jun-07 - Instead, only put [HEAD verb] on the finite subtype, in
; part to block spurious application of the frag-sbar rule.

; DPF 31-jan-09 - Whereas we have finally realized that we cannot simply unify
; valence feature values for mother and daughters in coordinate phrases
; (because then the LTOP values of the heads would also be wrongly unified,
; since we now ensure, as per the semantic algebra, that heads unify their
; LBLs with those of their complements unless they are 'scopal' heads),
; we must therefore cross-classify verbal phrases (at least) by their
; valence variants.  For now, we'll only deal with coordination of lexical
; two-argument verbs (transitive, subj-equi, etc.)
;; DPF 2020-04-10 - Pushed mother's HEAD verb down to subtypes, because we
;; also want to coordinate infinitival VPs, which need to stay HEAD comp
;; since the rule allowing sentential (and VP) subjects requires the subject
;; to be HEAD comp, so we were losing |to arrive and to leave are difficult|
;; DPF 2020-04-21 - Propagate subj's --MIN from dtrs to mother, since just
;; identifying CAT values isn't enough, given our use of the shortcut feature
;; --MIN.  Sigh.
;;
basic_basic_v_coord_phr := basic_basic_verbal_coord_phr &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MINORS #mins,
                                --ADDIN #addin ],
                         VAL [ SUBJ < synsem &
				      [ LOCAL [ CAT #cat,
						CONT.HOOK [ LTOP #ltop,
							    INDEX #sind ],
						AGR #agr ],
					NONLOC #nonloc,
					--SIND #sind,
					--MIN #smin,
					OPT #opt ] >,
			       SPR #spr,
			       SPEC #spec] ],
                   CONT.HOOK [ LTOP #ltop,
			       XARG #xarg ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ TAM.MOOD #mood,
                                          --ADDIN #addin & [ ADDPN #pn ] ],
                                   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							CONT.HOOK.INDEX #sind,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						--MIN #smin,
						OPT #opt ] >,
					 SPR #spr,
					 SPEC #spec ] ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ TAM.MOOD #mood,
                                          MINORS #mins,
					  --ADDIN.ADDPN #pn ],
				   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							CONT.HOOK.INDEX #sind,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						--MIN #smin,
						OPT #opt ] >,
					 SPR #spr,
					 SPEC #spec ] ],
			     CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

; CSY 19-10-2020 to allow for coordination of nocop adj (Singlish)
basic_basic_a_nocop_coord_phr := basic_basic_adj_coord_phr &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ MINORS #mins,
                                --ADDIN #addin ],
                         VAL [ SUBJ < synsem &
				      [ LOCAL [ CAT #cat,
						CONT.HOOK [ LTOP #ltop,
							    INDEX #sind ],
						AGR #agr ],
					NONLOC #nonloc,
					--SIND #sind,
					--MIN #smin,
					OPT #opt ] >,
			       SPR #spr,
			       SPEC #spec] ],
                   CONT.HOOK [ LTOP #ltop,
			       XARG #xarg ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ --ADDIN #addin & [ ADDPN #pn ] ],
                                   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							CONT.HOOK.INDEX #sind,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						--MIN #smin,
						OPT #opt ] >,
					 SPR #spr,
					 SPEC #spec ] ],
                             CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ MINORS #mins,
					  --ADDIN.ADDPN #pn ],
				   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							CONT.HOOK.INDEX #sind,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind,
						--MIN #smin,
						OPT #opt ] >,
					 SPR #spr,
					 SPEC #spec ] ],
			     CONT.HOOK [ XARG #xarg,
                                         INDEX.SF #iforce ] ],
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

basic_v_coord_phr := basic_basic_v_coord_phr & basic_verbal_coord_phr.

; CSY 19-10-2020 - For nocop adj coordination
basic_a_coord_phr := basic_basic_a_nocop_coord_phr & basic_adj_nocop_coord_phr.

;; DPF 2020-04-10 - Mother's AGR depends on whether the VP is finite or not,
;; since nonfinite coord VP can be either singular or plural:
;; |to speak and to listen is/are important|.  So push identity down to
;; subtypes
;;
v_coord_phr := basic_v_coord_phr & verbal_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.VFORM #vform,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM #vform,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.VFORM #vform ].

; CSY 19-10-2020 - without the vform restrictions
; CSY 31-10-2020 - add in HEAD adj, not sure if necessary
a_nocop_coord_phr := basic_a_coord_phr & nocop_adj_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD adj,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD adj ].

x_onecomp_coord_phr := gen_coord_phr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT #cat,
					   AGR #agr ],
				   NONLOC #nonloc,
				   OPT -,
				   --SIND #sind ] >,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT #cat,
						     AGR #agr ],
					     NONLOC #nonloc,
					     OPT -,
					     --MIN #min,
					     --SIND #sind ] >,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT #cat,
						     AGR #agr ],
					     NONLOC #nonloc,
					     OPT -,
					     --MIN #min,
					     --SIND #sind ] > ].
;; DPF 2019-11-25 nonlex_synsem
xp_coord_phr := gen_coord_phr &
  [ SYNSEM nonlex_synsem &
	   [ LOCAL.CAT.VAL.COMPS < > ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

;; DPF 2020-01-08 - Removed LCONJ-DTR..TAM reentrancy with mother's TAM, since
;; this blocked coord of three VPs with different TENSE values, as in
;; |We arrived yesterday, perform today, and should leave tomorrow.|
basic_v_coord_phr_fin := basic_v_coord_phr &
  [ SYNSEM.LOCAL [ CAT.HEAD verb &
                          [ VFORM fin_or_imp & #vform,
                            TAM indic_tam & #tam,
			    INV #inv ],
		   CONT.HOOK.INDEX.E #tam ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD verb &
                                   [ VFORM #vform,
                                     MINORS.NORM norm_rel,
                                     TAM indic_tam &
                                           [ MOOD ind_or_modal_subj ],
				     INV #inv ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD verb &
				      [ VFORM #vform,
					TAM indic_tam & #rtam,
					INV #inv,
					--ADDIN [ ADDTAM #rtam,
						  ADDPN #pn ] ],
			     AGR.PNG.PN #pn ] ].

v_coord_phr_fin := basic_v_coord_phr_fin & v_coord_phr &
  [ SYNSEM.LOCAL.AGR.PNG #png,
    RCONJ-DTR.SYNSEM.LOCAL.AGR.PNG #png ].

; CSY 31-10-2020 - for the nocop adj coord
;basic_a_coord_phr_fin := basic_a_coord_phr &
;  [ SYNSEM.LOCAL [ CAT.HEAD adj,
;		   CONT.HOOK.INDEX.E #tam ],
;    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
;    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD adj &
;				      [ --ADDIN [ ADDTAM #rtam,
;						  ADDPN #pn ] ],
;			     AGR.PNG.PN #pn ] ].

; CSY 31-10-2020 nocop_coord that prevents overgeneration
; CSY 2-11-2020 add in COMPS <> to tak
a_nocop_coord_phr_fin := a_nocop_coord_phr & basic_top_coord_event_rule &
  [ SYNSEM.LOCAL.CAT [ HEAD.MINORS.NORM norm_rel,
		       VAL.COMPS < > ],
    C-CONT.RELS <! !> ].
    
; Restrict to [PRD -] since predicative phrases are coordinated via
; distinct construction.
;; DPF 2012-12-21 - Removed RCONJ-DTR..CREL..MOOD indicative since this
;; blocked e.g. |We prefer that he arise and arrive|
;;
v_coord_phr_nonfin := v_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
			    TAM #tam ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
				      TAM #tam,
				      PRD - ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD [ VFORM non_fin,
					TAM #tam,
					PRD - ] ] ].

v_coord_fin_top_phr := v_coord_phr_fin & basic_top_coord_event_rule &
                       top_coord_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM norm_rel,
    C-CONT.RELS <! !> ].

vp_coord_fin_top_phr := v_coord_fin_top_phr & xp_coord_phr.
v_onecomp_coord_fin_top_phr := v_coord_fin_top_phr & x_onecomp_coord_phr.

v_coord_fin_mid_eg_phr := v_coord_phr_fin & mid_coord_event_edgen_rule.
vp_coord_fin_mid_eg_phr := v_coord_fin_mid_eg_phr & xp_coord_phr.
v_onecomp_coord_fin_mid_eg_phr := v_coord_fin_mid_eg_phr & x_onecomp_coord_phr.

v_coord_fin_mid_ig_phr := v_coord_phr_fin & mid_coord_event_infgen_rule.
vp_coord_fin_mid_ig_phr := v_coord_fin_mid_ig_phr & xp_coord_phr.
v_onecomp_coord_fin_mid_ig_phr := v_coord_fin_mid_ig_phr & x_onecomp_coord_phr.

; For two coordinated VPs with no conjunction
; DPF 10-sept-07 - Added NORM no_rel to block these as conjuncts in ordinary
; VP coordination, to avoid spurious parse for e.g. "Kim arose, sang, and left"
;; DPF 2016-10-27 - Constraint of non_conj_event on LCONJ-DTR..INDEX is wrong,
;; since we want to allow right-node-raised VPs, as in 
;; |we chased and caught cats, took naps|.  So remove, and monitor (FIX?).
;; DPF 2020-08-26 - Removed strange stamping of SLASH 0-dlist on mother, which
;; allowed non-empty SLASH on dtrs, and prevented slashed-VP root for e.g.
;; "rely on, depend on" (for dictionary definitions)
;;
basic_v_coord_top_noconj_phr := basic_v_coord_phr & xp_coord_phr &
				binary_rule_right_to_left & 
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD verb &
				[ VFORM #vform,
				  MOD #mod,
                                  MINORS.NORM no_rel ],
                           VAL [ SUBJ < synsem >,
				 COMPS < > ] ],
                     CONT.HOOK.INDEX conj_event & #cind & [ E #tam ],
                     CONJ cnil,
                     AGR.PNG #png ],
	     NONLOC.SLASH #slash,
             PUNCT [ LPUNCT #lpunct,
                     PAIRED #rpnctpr,
                     RPUNCT #rpunct ] ],
    LCONJ-DTR.SYNSEM [ LOCAL local & 
                             [ CAT [ HEAD [ VFORM #vform,
					    MOD #mod,
                                            MINORS.ALTMIN non_ellipt_rel ],
                                     VAL [ SUBJ < synsem >,
                                           COMPS < > ] ],
                               CONT.HOOK.INDEX #lindex & [ E #tam ],
                               CONJ cnil ],
		       NONLOC.SLASH #slash,
                       PUNCT [ LPUNCT #lpunct,
                               RPUNCT comma_or_semicol,
                               PNCTPR #pnctpr ] ],
    RCONJ-DTR.SYNSEM [ LOCAL local &
                       [ CAT [ HEAD [ VFORM #vform,
				      MOD #mod,
                                      MINORS [ ALTMIN non_ellipt_rel ] ],
                               VAL [ SUBJ < synsem >,
                                     COMPS < > ] ],
                         CONT.HOOK.INDEX #rindex,
                         CONJ cnil,
                         AGR.PNG #png ],
		       NONLOC.SLASH #slash,
                       PUNCT [ RPUNCT #rpunct,
                               PAIRED #pnctpr,
                               PNCTPR #rpnctpr ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #cind & conj-ind ],
             RELS <! [ LBL #ltop,
                       PRED implicit_conj_rel,
                       ARG0 #cind & non_expl,
                       ARG1 #lindex,
                       ARG2 #rindex,
		       CFROM #from, CTO #to ] !>,
             HCONS <! !>,
	     ICONS <! !> ],
    GENRE nonformal,
    ARGS < [ INFLECTD + ],
           [ INFLECTD + ] > ].


v_coord_fin_top_noconj_phr := basic_v_coord_top_noconj_phr & 
			      basic_v_coord_phr_fin &
  [ RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.MINORS.NORM no_rel ].

;; Added nonfin variant, for |We tried to hire Abrams, hire Browne.|
v_coord_nonfin_top_noconj_phr := basic_v_coord_top_noconj_phr &
  [ SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
			    TAM #tam ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
				      TAM #tam,
				      PRD - ],
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ VFORM non_fin,
				      TAM #tam,
				      PRD - ] ].

;; DPF 2020-04-10 - Need to assign HEAD verb or comp to subtypes of nonfin
;; FIX.
v_coord_nonfin_top_phr := v_coord_phr_nonfin & basic_top_coord_event_rule &
                          top_coord_rule &
  [ C-CONT.RELS <! !> ].
vp_coord_nonfin_top_phr := v_coord_nonfin_top_phr & xp_coord_phr.
v_onecomp_coord_nonfin_top_phr := v_coord_nonfin_top_phr & x_onecomp_coord_phr.

v_coord_nonfin_mid_eg_phr := v_coord_phr_nonfin & mid_coord_event_edgen_rule.
vp_coord_nonfin_mid_eg_phr := v_coord_nonfin_mid_eg_phr & xp_coord_phr.
v_onecomp_coord_nonfin_mid_eg_phr := v_coord_nonfin_mid_eg_phr & 
				    x_onecomp_coord_phr.

v_coord_nonfin_mid_ig_phr := v_coord_phr_nonfin & mid_coord_event_infgen_rule.
vp_coord_nonfin_mid_ig_phr := v_coord_nonfin_mid_ig_phr & xp_coord_phr.
v_onecomp_coord_nonfin_mid_ig_phr := v_coord_nonfin_mid_ig_phr & 
				    x_onecomp_coord_phr.

; DPF 16-nov-09 - Cannot identify SUBJ values, since we want to coordinate
; S-bar and S.  Try leaving just as *olist* on each, and identify left dtr's
; with mother (arbitrarily).
;; DPF 2014-07-02 - Changed LCONJ-DTR..CONJ from either_or_cnil to 
;; cnil_or_atomconj in order to admit |Kim said not only that S but that S|
;; and similarly with |said both that S and that S|, |...neither that S nor...|
;; DPF 2015-04-18 - Surprisingly, propagate CASE from left dtr to mother, so
;; we can still distinguish |that S and S| from |S and S|, now that 
;; HEAD value is now generalized to `verbal'.  Needed to block |that that S|
;; with double complementizer, among other undesirables.  Note that sbj-hd
;; type now stamps [CASE non_nom] on mother, while |that| (already) imposes
;; [CASE nom].
;; DPF 2017-09-16 - Re 2015-14-18: We can't say that non-MC clauses are always
;; CASE non_nom (because we admit |him chasing cats surprised us| with that
;; verbal gerund as a clause whose CASE must be compatible with nom), yet we
;; don't want to let |we arise and they arrive| be mistaken for a that-S (as
;; input to the frag_sbar rule).  (And we don't propagate the HEAD type to
;; the mother from either dtr.)  So let's try making CASE on the mother always
;; be non_nom instead of propagating from the left dtr.
;; DPF 2017-11-17 - But this CASE constraint has to be on the normal subtype, 
;; since we want to still coordinate that-S phrases lacking a conjunct via the
;; s_coord_top_noconj_phr type, with the complementizer "that" being CASE nom.
;; DPF 2019-04-26 - Identify --ADDIN with TAM and AGR..PN for the left conjunct
;; in order to block |We know Kim arise and Browne arises|.
;; DPF 2020-05-08 - Not sure why 2019-04-26 change was missing below, but it
;; needs to be here, so restore and CHECK.
;;
basic_s_coord_phr := basic_verbal_coord_phr &
  [ SYNSEM phr_synsem &
	   [ LOCAL [ CAT [ HEAD.VFORM fin_or_inf_or_imp,
                           VAL [ SUBJ #subj & *olist*,
                                 COMPS < >,
				 SPR #spr,
				 SPEC < >,
				 SPCMPS < > ],
                           MC bool ] ] ],
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD [ TAM #tam & 
						[ MOOD ind_or_modal_subj ],
					    --ADDIN [ ADDTAM #tam,
						      ADDPN #pn ] ],
				     VAL [ SUBJ #subj,
					   COMPS < > ] ],
			       AGR.PNG.PN #pn,
			       CONJ cnil_or_atomconj ],
		       NONLOC.SLASH.LIST *arglist* ],
    RCONJ-DTR.SYNSEM [ LOCAL.CAT [ HEAD.TAM.MOOD ind_or_modal_subj,
				   VAL [ SUBJ *olist*,
					 SPR #spr,
					 COMPS < > ] ],
		       NONLOC.SLASH.LIST *arglist* ],
    C-CONT.ICONS <! !> ].


s_coord_phr := basic_s_coord_phr & verbal_coord_phr &
  [ SYNSEM.lOCAL.CAT.HEAD.CASE non_nom,
    LCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #lindex,
    RCONJ-DTR.SYNSEM.LOCAL.CONJ.CREL.ARG1 #lindex,
    C-CONT.HCONS <! !> ].

; Exclude S-coord from NP-CP rule unless complementizer present.
;; DPF 2015-04-17 - We were identifying this rule's HEAD value with
;; that of its first dtr, but can't, since we also constrain VP adjuncts to 
;; exclude AUX + VPs, in order to avoid spurious ambiguity for 
;; |Kim is performing in Paris|, and hence were not getting 
;; |the city in which Kim is performing and we are visiting exists.|
;; So change to identify the non-AUX attributes on left dtr and mother.
;; DPF 2016-10-16 - Allow semicolon with LCONJ..RPUNCT for interrogatives,
;; but still exclude for non-interrogatives.
;;
basic_s_coord_top_phr := s_coord_phr & basic_top_coord_event_rule &
  [ SYNSEM.LOCAL.CAT.HEAD [ MINORS #min,
			    MOD #mod,
			    TAM #tam,
			    VFORM #vform ],
    LCONJ-DTR.SYNSEM [ LOCAL.CAT.HEAD [ MINORS #min,
					MOD #mod,
					TAM #tam,
					VFORM #vform ] ],
    RCONJ-DTR.SYNSEM.LOCAL.CONT [ HOOK [ LTOP #conjltop,
                                         INDEX #ind ] ],
    C-CONT [ HOOK [ LTOP #conjltop,
                    INDEX #ind ],
             RELS <! !> ] ].

;; DPF 2020-03-24 - Changed LCONJ..RPUNCT to comma_or_semi_or_pair_or_no_punct
;; from comma_or_pair_or_no_punct
;;
s_coord_top_phr := basic_s_coord_top_phr &
  [ SYNSEM.LOCAL.CAT.HEAD.INV #inv,
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT.HEAD.INV #inv,
			       CONT.HOOK.INDEX.SF prop-or-comm ],
		       PUNCT.RPUNCT comma_or_semi_or_pair_or_no_punct ] ].
    
; This variant requires that if the first conjunct is a question,
; the second must be as well.  Needed to avoid leaving the first
; conjunct spuriously underspecified for its message (which then would
; do damage to efficiency in generation, since would then add interrogative
; alternatives even when not wanted.
;; DPF 2012-06-22 - Removed INV + since we want to allow coordination of 
;; embedded WH-clauses too, as in |we described what happened and how it felt|
;; DPF 2017-01-31 - Added RPUNCT comma_or_clause_or_pair_punct to right dtr, 
;; to avoid invoking this rule on non-question S-coord in mid-sentence, where 
;; SF is typically still underspecified.
;; DPF 2018-05-31 - Re 2012-06-22; For efficiency, it is tempting to try to
;; impose either INV + or MC + on the dtrs, but both are wrong: |whether we 
;; arrive and whether we arise| is neither, and likewise |who arrived| is not
;; INV +. And we can't just treat these as NP coord, since we see such coord 
;; as complement of e.g. "sure" which does not take an NP complement as in 
;; |he wasn't sure whether we arose or wheter we arrived|.  Regrettable, since
;; embedded clauses don't resolve SF, which means we'll apply this rule to
;; any two clauses in the chart, as long as the right one is punctuated.
;;
s_coord_int_top_phr := basic_s_coord_top_phr &
  [ LCONJ-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF ques ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CONT.HOOK.INDEX.SF ques ],
		       PUNCT.RPUNCT comma_or_clause_or_pair_punct ] ].

s_coord_mid_eg_phr := s_coord_phr & mid_coord_event_edgen_rule.
s_coord_mid_ig_phr := s_coord_phr & mid_coord_event_infgen_rule.

;; |we learned that Abrams arrived, that Browne won|
;; DPF 2017-04-26 - This type is largely copied from the v-v noconj type
;; basic_v_coord_top_noconj_phr, and hence some better use of inheritance is 
;; in order.  FIX someday.
;; DPF 2020-04-29 - Constrain MOOD of the two conjuncts, to avoid spurious
;; ambiguity with coord of that-S's with either being subjunctive.
;;
s_coord_top_noconj_phr := basic_s_coord_phr & binary_rule_right_to_left & 
  [ SYNSEM [ LOCAL [ CAT.HEAD #head,
		     CONT.HOOK.INDEX conj_event & #cind & [ E #tam ],
                     CONJ cnil ],
	     NONLOC.SLASH 0-dlist,
             PUNCT [ LPUNCT #lpunct,
                     PAIRED #rpnctpr,
                     RPUNCT #rpunct ] ],
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT.HEAD comp,
			       CONT.HOOK.INDEX #lindex & 
					[ E.MOOD ind_or_modal_subj ],
                               CONJ cnil ],
                       PUNCT [ LPUNCT #lpunct,
                               RPUNCT hyphen_or_comma_or_semicol_punct,
                               PNCTPR #pnctpr ] ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CAT.HEAD #head & comp,
			       CONT.HOOK.INDEX #rindex & 
					[ E #tam &
					    [ MOOD ind_or_modal_subj ] ],
			       CONJ cnil ],
                       PUNCT [ RPUNCT #rpunct,
                               PAIRED #pnctpr,
                               PNCTPR #rpnctpr ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #cind & conj-ind ],
             RELS <! [ LBL #ltop,
                       PRED implicit_conj_rel,
                       ARG0 #cind & non_expl,
                       ARG1 #lindex,
                       ARG2 #rindex,
		       CFROM #from, CTO #to ] !>,
             HCONS <! !>,
	     ICONS <! !> ],
    GENRE nonformal ].

;; DPF 2017-02-22 - Generalized VFORM from fin to fin_or_inf, to allow
;; coord of infinitival relatives, as in |people to admire and to emulate|
;; Note that this now overgenerates for |people to sleep and to admire| where
;; only the second conjunct is a gapped inf-rel.  FIX?
;;
relcl_coord_phr := verbal_coord_phr &
  [ SYNSEM phr_synsem &
	   [ LOCAL.CAT [ HEAD verb &
                            [ VFORM fin_or_inf & #vform,
                              INV -,
                              MOD < synsem >,
                              MINORS #mins ],
                       VAL [ SUBJ *olist* & #subj,
			     SPR #spr,
                             COMPS < >,
			     SPCMPS < > ],
                       MC na ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
					  INV -,
					  MOD < synsem >,
					  MINORS #mins ],
				   VAL [ SUBJ #subj,
					 SPR #spr,
					 COMPS < > ],
				   MC na ],
			     CONT.HOOK.INDEX #lindex ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ VFORM #vform,
					  INV -,
					  MOD < synsem > ],
				   VAL [ SUBJ #subj,
					 SPR #spr,
					 COMPS < > ],
				   MC na ],
			     CONJ.CREL.ARG1 #lindex ],
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

relcl_coord_top_phr := relcl_coord_phr & basic_top_coord_event_rule &
                       top_coord_rule &
  [ C-CONT.RELS <! !> ].

; DPF 21-dec-05 - Removed SPR..MIN much_deg_rel, since this prevented
; coordination of subordinating preps as in 'we arise to arrive and to fall'
; DPF 2010-10-01 - Added LEX - to both dtrs, to prevent coord analysis of
; degree phrases |[so that is] not [too]|.
;; DPF 2011-06-12 - Re 2010-10-01: But we're using this rule for lexical
;; adverbs as well (and we do in principle want to allow degree-phr coord,
;; as in |the less and less obvious idea|).
;; DPF 2017-08-17 - We were stamping the mother's HEAD value as prep, but
;; this prevented us from admitting |too [quickly and quietly]| because `too'
;; doesn't want to specify PPs.  Let's try preserving the HEAD value from the
;; left dtr.
;; DPF 2018-06-11 - We were identifying the XARGs of mother and two dtrs, but
;; need to push this down to the semantically contentful subtype, since we don't
;; want to unify the XARGs of two NPs as in |Most die of their remedies and
;; not of their illnesses|, where possessed NPs have the XARG point to the
;; pron's ARG0, to support possessive idioms.
;;
;; DPF 2019-11-25 nonlex_synsem
prep_coord_phr := norm_coord_phr &
  [ SYNSEM nonlex_synsem &
	   [ LEX #lex,
             LOCAL [ CAT [ HEAD #head & [ PRD #prd,
					  MINORS #mins,
					  MOD #mod,
					  TAM #tam,
					  CASE #case ],
                           VAL [ SPR < [ LOCAL
                                           [ CAT [ HEAD adv,
                                                   VAL [ SPR *olist*,
                                                         COMPS < > ] ],
                                             CONT.HOOK [ LTOP #ltop,
                                                         INDEX #ind ] ],
                                         NONLOC.QUE 0-dlist,
					 OPT + ] >,
				 SPCMPS < > ],
			   MC #mc,
                           POSTHD #ph ],
                     CONT.HOOK [ LTOP #ltop,
                                 INDEX #ind ],
		     AGR.PNG #png ] ],
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD p_or_adv & #head &
                                        [ PRD #prd,
                                          MINORS #mins,
                                          MOD #mod,
                                          TAM #tam,
                                          CASE #case ],
				     VAL [ SPR *olist* ],
				     MC #mc,
				     POSTHD #ph ],
			       CONT.HOOK.LTOP #ltop ],
		       LEX #lex ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD p_or_adv & 
                                        [ PRD #prd,
                                          MOD #mod,
                                          TAM #tam,
                                          CASE #case ],
				     VAL.SPR *olist*,
				     MC #mc,
				     POSTHD #ph ],
			       AGR.PNG #png ],
		       LEX #lex ],
    C-CONT.ICONS <! !> ].

norm_prep_coord_phr := prep_coord_phr &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    LCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK [ INDEX #lindex,
				       XARG #xarg ],
    RCONJ-DTR.SYNSEM.LOCAL [ CONT.HOOK.XARG #xarg,
			     CONJ.CREL.ARG1 #lindex ],
    C-CONT.HCONS <! !> ].

prep_coord_top_phr := norm_prep_coord_phr & top_coord_event_rule.
    
pp_coord_top_phr := prep_coord_top_phr & xp_coord_phr.
p_coord_top_phr := prep_coord_top_phr & x_onecomp_coord_phr.

;; DPF 2014-07-09 - Added separate rules to conjoin selected PPs.  Needed 
;; since semantic composition is like for NP coordination, not event coord.
;; Also, need to require the MIN values of the two conjuncts to be the same,
;; to avoid |Kim was hired both by Abrams and of Browne|
;; DPF 2016-10-21 - Strangely, this type included an identification of
;; C-CONT.HOOK.XARG with RCONJ-DTR..LTOP, but this conflicts with the current
;; treatment of possessive NPs as in |we rely on your cat and on you|, since
;; (for possessive idioms) we make the XARG of a possessed NP be the index of
;; the possessor, so it can't be a handle.  Keep an eye on this to see what
;; that identity with LTOP was doing.
;;
pp_sel_coord_top_phr := prep_coord_phr & basic_top_coord_rule & xp_coord_phr &
  [ LCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN selected_rel & #min,
			     CONT.HOOK.INDEX #lind ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN #min,
                             CONT.HOOK [ LTOP #rtop,
					 INDEX #ind ],
			     CONJ.CREL basic_conj_relation & [ ARG1 #lind ]],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS <! [ PRED udef_q_rel,
		       ARG0 #ind & ref-ind,
		       RSTR #harg,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #harg,
                              LARG #rtop  ] !>,
	     ICONS <! !> ] ].

pp_sel_coord_mid_phr := prep_coord_phr & basic_mid_coord_rule & xp_coord_phr &
  [ SYNSEM.LOCAL.CONJ.CREL #rel & [ ARG2 #ind ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN selected_rel & #min,
			     CONT.HOOK.INDEX #lind ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD.MINORS.MIN #min,
                             CONT.HOOK [ LTOP #rtop,
					 INDEX #ind ],
			     CONJ.CREL basic_conj_relation & [ ARG1 #lind ]],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ INDEX #cind ],
             RELS <! [ PRED udef_q_rel,
		       ARG0 #ind & ref-ind,
		       RSTR #harg,
		       CFROM #from, CTO #to ],
		     #rel & [ ARG0 #cind,
			      CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #harg,
                              LARG #rtop  ] !>,
	     ICONS <! !> ] ].

; DPF 29-oct-06 - To avoid generally spurious ambiguity with coordinated
; depictive phrases as in "You enjoy hut to hut walking or staying in one 
; place and sleeping", constrain ternary (or more) coord to intersective
; PPs only
;; DPF 2020-04-14 - But this prevents the intended analysis for
;; |When you arrive, when we depart, and when everyone else remains, the party
;; thrives.| (cf. wsj08a:20819013) So remove, and CHECK.
#|
prep_coord_mid_eg_phr := norm_prep_coord_phr & mid_coord_event_edgen_rule &
  [ LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL intersective_mod ] > ].
|#
prep_coord_mid_eg_phr := norm_prep_coord_phr & mid_coord_event_edgen_rule.
 
pp_coord_mid_eg_phr := prep_coord_mid_eg_phr & xp_coord_phr.
p_coord_mid_eg_phr := prep_coord_mid_eg_phr & x_onecomp_coord_phr.

prep_coord_mid_ig_phr := norm_prep_coord_phr & mid_coord_event_infgen_rule &
  [ LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL intersective_mod ] >,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL intersective_mod ] > ].

pp_coord_mid_ig_phr := prep_coord_mid_ig_phr & xp_coord_phr.
p_coord_mid_ig_phr := prep_coord_mid_ig_phr & x_onecomp_coord_phr.

; DPF - 23-aug-04 - For now, disallow specifiers on conjoined APs, since it's
; hard to match them correctly as long as we are not using unary rule to
; discharge the SPR first.  This means stamping QUE 0-dlist on mother, since
; we can't propagate constraints from the dtrs' specifiers (since we don't
; know if they've been picked up).  So we lose e.g. "how big and wide is it?"
; DPF 31-jul-06 - Re 23-aug-04: While waiting for a better solution, at least
; make the SPR < anti_synsem_min > so we can extract adjuncts from coordinated
; AP, as in "Today Kim is happy and cheerful."
;; DPF 2012-09-12 - Constrain the SPRs on the dtrs to be *olist*, to block
;; |*million or ten cats|
;; DPF 2013-10-26 - Moved SLASH 0-dlist of mother and dtrs down to attr-adj
;; subtype, since we want to admit |who is Kim larger than or smaller than?|
;; DPF 2014-10-13 - Re 23-aug-04: Let's try adding deg-spec to mother, to 
;; remind ourselves what goes wrong, maybe, and to admit "so big and 
;; tall that S".
;; DPF 2016-11-04 - Re 23-aug-04: Try identifying the mother's QUE with its
;; SPR's, so we can get |how tall and wide is it|.  To do this, also change
;; dtrs' SPRs to not say *olist* (since this makes the list `unexpressed'
;; which constrains NONLOC to nonlocal_none).
;; DPF 2016-11-19 - Can't require the MIN values of the dtrs' sprs to be the
;; same, since we want |tall but older|, where the two differ.  So let's
;; propagate the one from the left dtr, arbitrarily.
;; DPF 2018-07-11 - Removed the requirement that the dtr SPR values be non-empty
;; lists, since we want to admit coord of specified number phrases, as in
;; |ten thousand or twenty thousand people|, and these have empty SPRs.  Instead
;; require dtrs to have SPR *olist*.  Note that we are still sadly admitting
;; |the [very [heavy and angrier]] cat| since we don't have a good way to
;; ensure that the sprs' --MIN values match appropriately.  FIX someday?
;; DPF 2018-03-06 - Re 2017-07-11: But making the SPRs of the dtrs be *olist*
;; means the dtr's QUE value will be 0-dlist, and since NONLOC is identified on
;; dtrs and mother, this blocks |how tall and wide|.  So we remove this *olist*
;; constraint, and depend on the requirement in the filler-hd construction 
;; that the SPR of the non-hd is *olist*, so if there is no overt specifier, 
;; the coord phrase must be non-QUE, to block |tall and happy is Kim?| but
;; allow |how tall and happy is Kim?|
;; DPF 2018-03-07 - Considered adding MOD *synlist* to block as left daughter 
;; an adj phrase that is modified by a depictive, to avoid seemingly spurious 
;; analysis for |fun, inventive, and adventurous|.  But consider |Kim could be
;; fun drunk and annoying sober|.  Also, adding the *synlist* runs afoul of
;; the constraint on adjunct extraction, which requires the dtr to be MOD
;; *anti_list* for other reasons.
;; DPF 2018-03-07 - As we did for verbal coord phrases, we impose 
;; SLASH.LIST *arglist* on each of the conjuncts, to avoid unwanted ATB modifier
;; extraction.
;; DPF 2018-04-03 - Re 2018-03-06: Tried adding new list type *optlist*
;; which requires OPT + elements for SPR on both dtrs, but does not also 
;; impose the unexpressed synsem type that *olist* does.  However, these new
;; types would need to interact correctly with the *olist* types throughout,
;; and don't, so back to the drawing board ...
;; DPF 2019-09-10 - Re 2018-04-03: Since ordinary adj always has a non-empty
;; SPR list even if a spr has been picked up, let's try constraining the first
;; elem of that list to be OPT +, so we can avoid |we admire million or two 
;; cats|
;; DPF 2019-11-25 nonlex_synsem
;; DPF 2020-03-24 - Added LCONJ..SPR.FIRST.OPT + as per trunk.
;; DPF 2020-04-13 - Re 2019-09-10 and 2020-03-24: But constructed cardinals
;; such as |five million| currently have an empty SPR, so remembering from
;; 2018-03-06 that we can't have SPR *olist* on the dtrs here, let's change
;; |five million| to have a non-empty SPR. Sigh.
;;
adj_coord_phr := gen_coord_phr &
  [ SYNSEM nonlex_synsem &
	   [ LOCAL [ CAT 
		     [ HEAD #head &
			    [ MOD #mod,
			      PRD #prd, MINORS #min, TAM #tam ],
		       VAL [ SPR < synsem_min &
				   [ LOCAL 
				     [ CAT 
				       [ HEAD adv,
					 VAL 
					 [ SPR *olist*,
					   SPEC < [ LOCAL.CAT.HS-LEX #hslex ]>],
					 MC na ],
				       CONT.HOOK [ LTOP #ctop,
						   XARG #arg0  ] ],
				     NONLOC [ SLASH 0-dlist,
					      QUE #que ],
				     OPT + ], 
				   anti_synsem_min >,
			     COMPS < >,
			     SPCMPS < > ],
		       HS-LEX #hslex,
		       POSTHD #ph ],
		     CONT.HOOK [ LTOP #ctop,
				 INDEX #arg0,
				 XARG #xarg ] ],
	     NONLOC.QUE #que,
	     MODIFD [ LPERIPH #lperiph,
		      RPERIPH #rperiph ] ],
    LCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD adj_or_intadj & #head &
					  [ MOD #mod, PRD #prd, MINORS #min, 
					    TAM #tam ],
				     VAL [ SPR.FIRST.OPT +,
					   COMPS < > ],
				     POSTHD #ph ],
                               CONT.HOOK [ LTOP #ltop,
					   INDEX #lindex,
					   XARG #xarg ] ],
		       NONLOC.SLASH.LIST *arglist*,
		       MODIFD.LPERIPH #lperiph ],
    RCONJ-DTR.SYNSEM [ LOCAL [ CAT [ HEAD adj_or_intadj & 
					  [ PRD #prd, TAM #tam ],
				     VAL [ SPR.FIRST.OPT +,
					   COMPS < > ],
				     POSTHD #ph ],
                               CONT.HOOK [ LTOP #ltop,
					   XARG #xarg ],
			       CONJ complex-conj &
				   [ CREL.ARG1 #lindex ] ],
		       NONLOC.SLASH.LIST *arglist*,
		       MODIFD.RPERIPH #rperiph ],
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].


; Attributive APs are LEX + (unusual for coordinate structures):
;  "*The angry at Kim and sad child"
;  "*The angry and taller child than Kim"
;; Require MINORS.MIN to unify on two dtrs, to avoid |two and tall|
;; DPF 2017-09-16 - Can't require MIN to match on daughters, because we want
;; |the first and most important idea| where first is MIN ord_rel but the
;; other is norm_adj_rel.  Alas, this means we'll also coordinate in
;; |*the tall and fifteen cats|.  So let's instead require unif of CARDINAL,
;; to block |tall and fifteen| but keep |first and oldest|.
;;
adj_attr_coord_phr := adj_coord_phr &
  [ INFLECTD +,
    SYNSEM [ LEX + & #lex,
             LOCAL.CAT [ HEAD.PRD -,
                         POSTHD - ],
	     NONLOC.SLASH 0-dlist ],
    LCONJ-DTR [ SYNSEM [ LEX #lex,
			 LOCAL.CAT.HEAD.CARDINAL #card,
			 NONLOC.SLASH 0-dlist ],
                INFLECTD + ],
    RCONJ-DTR [ SYNSEM [ LEX #lex,
			 LOCAL.CAT.HEAD.CARDINAL #card,
			 NONLOC.SLASH 0-dlist ],
                INFLECTD + ] ].

; Predicative APs may have LEX + or - conjuncts, but preserve LEX value of
; (say) right conjunct, to avoid e.g. "the child angry and loud cried."
; DPF 31-jul-06 - But this also blocks "visitors young and old", so opt for
; slight overgeneration here, and stamp LEX - on mother.

adj_pred_coord_phr := adj_coord_phr & norm_coord_phr &
  [ SYNSEM [ LEX -,
             LOCAL [ CAT [ HEAD.PRD +,
			   POSTHD + ],
		     AGR.PNG #png ] ],
    RCONJ-DTR.SYNSEM.LOCAL.AGR.PNG #png ].

adj_attr_coord_top_phr := adj_attr_coord_phr & top_coord_event_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct ].
; Let's try doing without these, since there is already a semantically 
; equivalent parse for "The big furry and black cat arrived." given that
; we assume all adjectives are intersective.
; DPF 14-jul-09 - But this equivalence does not hold for disjunction, as in
; "The big, furry, or black cats arrived."  So restrict these mid ones to
; disjunction.  FIX
;; DPF 2018-07-28 - Re 14-jul-09: Finally got around to fixing this.
;;
adj_attr_coord_mid_eg_phr := adj_attr_coord_phr & mid_coord_event_edgen_rule &
  [ RCONJ-DTR.SYNSEM.LOCAL.CONJ.CREL.PRED _or_c_rel ].

adj_attr_coord_mid_ig_phr := adj_attr_coord_phr & mid_coord_event_infgen_rule &
  [ RCONJ-DTR.SYNSEM.LOCAL.CONJ.CREL.PRED _or_c_rel ].

adj_pred_coord_top_phr := adj_pred_coord_phr & top_coord_event_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct ].
adj_pred_coord_mid_eg_phr := adj_pred_coord_phr & mid_coord_event_edgen_rule.
adj_pred_coord_mid_ig_phr := adj_pred_coord_phr & mid_coord_event_infgen_rule.

; DPF 21-jun-07 - Instead of requiring that the dtrs have SUBJ *anti_list*
; (which is incompatible with VP adverbs requiring that their modifiee be
; *synlist*, so we wouldn't get "poorly understood and unhappy"), we make
; the two dtrs be SPR *cons*, since this is true of all predicative phrases
; including VPs, but not true of Ss.
; DPF 15-jul-07 - But this isn't true, of course - "very tall" is a predp
; with an empty SPR list.  Anyway, PRD + should be enough to block Ss.
; DPF 02-nov-07 - Changed SPR from < anti_synsem_min > to < > so these can
; undergo frag_pp rule.
; DPF 07-apr-08 - Removed reentrancy of MOD on RCONJ-DTR (with LCONJ and 
; mother), to allow e.g. "cats happy and smiling" where the VP blocks
; modification to avoid spurious reduced relative analysis.  Instead,
; stamp nominal modifiee on mother.
; Change predp_coord_phr to push HEAD value down to three subtypes, so 
; vp_predp can be 'verb' to allow "Kim arose, arriving and arising."
; DPF 21-apr-09 - Changed MOD synsem to MOD synsem_min in order to
; let these conjoined phrases undergo adjunct-extraction, as in
; 'Suddenly, Kim was fired and ejected.'
; Also changed SUBJ < anti_synsem_min > to < synsem_min > for same reason.
; DPF 25-jan-10 - Propagate MODIFD from right dtr - this isn't really right, 
; but we want to avoid spurious RNR analysis for "of or related to Abrams"
; DPF 2010-10-31 - Re 25-jan-10: But this blocks extracted-adj for coord-VP
; as in "In Paris, he was admired and [toasted on Tuesday]" (given the
; constraint to do extracted modifiers before attaching modifiers).  So
; remove, and reconsider the above analysis if it's still problematic.
;; DPF 2016-10-02 - Re 02-nov-07: But making SPR <> prevents for example
;; |near him, they are built-in and invisible|.  So go back to < anti_syn >,
;; since we now admit the fragment using the adj-frag rule.
;; DPF 2017-03-02 - Added MOD..LOCAL intersective_mod to each of the dtrs, to
;; avoid spurious coord of |to arise and to arrive|.
;; DPF 2018-06-03 - Tried adding SUBJ unexpressed_reg to mother, presumably
;; to prevent extraction of subject, but this conflicts with at least 
;; subj-equi-ing verbs such as "consider", which constrain the VP comp's subj 
;; to be pro_ss.
;; DPF 2019-11-25 nonlex_synsem
;; DPF 2020-01-14 - Added AUX - to each dtr, to exclude infinitival relatives
;; as in |*the cat to arrive and too happy disappeared|
;
basic_predp_coord_phr := gen_coord_phr &
  [ INFLECTD +,
    SYNSEM nonlex_synsem &
     [ LEX -,
       LOCAL 
	[ CAT [ HEAD [ PRD +,
		       MINORS #min,
		       MOD < synsem_min &
			     [ LOCAL intersective_mod &
				     [ AGR #xarg,
				       CAT [ HEAD basic_nom_or_ttl &
						  [ POSS - ],
					     VAL [ SUBJ < >,
						   SPR < synsem & 
							[ --MIN 
							 quant_or_deg_rel ] >,
						   COMPS *olist*,
						   SPCMPS < > ],
					     MC na ] ],
			       NONLOC.REL 0-dlist,
			       --SIND #xarg ] > ],
                           VAL [ SUBJ < [ NONLOC.SLASH 0-dlist ] >,
				 SPR *anti_cons*,
				 SPCMPS < > ],
                           POSTHD #ph & + ],
                     CONT.HOOK.XARG #xarg ],
             NONLOC [ SLASH #slash,
                      QUE 0-dlist ] ],
    LCONJ-DTR [ INFLECTD +,
                SYNSEM [ LOCAL [ CAT [ HEAD v_or_a_or_p &
                                          [ PRD +,
					    AUX -,
					    MOD.FIRST.LOCAL intersective_mod ],
				       VAL [ SPCMPS < > ],
				       POSTHD #ph ],
                                 CONT.HOOK [ LTOP #ltop,
					     INDEX #lindex,
					     XARG #xarg ] ],
                         NONLOC.SLASH #slash ] ],
    RCONJ-DTR [ INFLECTD +,
                SYNSEM [ LOCAL [ CAT [ HEAD v_or_a_or_p &
                                          [ PRD +,
					    AUX -,
					    MOD.FIRST.LOCAL intersective_mod,
					    MINORS #min ],
				       VAL [ SPCMPS < > ],
                                       POSTHD #ph ],
                                 CONT.HOOK [ LTOP #ltop,
					     XARG #xarg ],
                                 CONJ complex-conj &
				      [ CREL.ARG1 #lindex ] ],
                         NONLOC.SLASH #slash ] ],
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].


predp_coord_phr := basic_predp_coord_phr &
  [ SYNSEM.LOCAL.CAT [ HEAD.TAM #tam,
		       VAL.COMPS < > ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD.TAM #tam,
				 VAL.COMPS < > ],
    RCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD.TAM #tam,
				 VAL.COMPS < > ] ].

;; DPF 2012-04-09 - Added RCONJ-DTR..AUX - to block infinitival relatives
;; as in *|kim is happy and to arrive|
;;
ap_predp_coord_phr := predp_coord_phr &
  [ SYNSEM [ LOCAL.CAT.HEAD adj ],
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD v_or_p & [ MINORS.MIN event_rel,
					       AUX - ] ].

;; DPF 2018-03-15 - Generalized right dtr from HEAD adj to a_or_p, so we
;; also get |is singing and in the shower|.  Should also rename the
;; construction to reflect the order of dtrs with vp first.
;; DPF 2020-08-26 - Mother's SLASH 0-dlist prevents analysis of e.g.
;; "an abstraction belonging to or characteristic of something", so remove
;; and evaluate the cost of added ambiguity; FIX if needed.
;;
vp_a-or-p_predp_coord_phr := predp_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD adj,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD a_or_p ].

; DPF 31-may-09 - Note that this still overgenerates when interacting with 
; the verbal-gerund rule: "*Hiring Kim and fired by Abrams bothers Browne.
; FIX
;; DPF 2020-05-14 - Propagate HEAD.TAM from left dtr to mother, to keep
;; ASPECT visible, to block e.g. |Kim seems arriving and departing|
;
verbal_predp_coord_phr := basic_predp_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD verb & [ VFORM non_fin & #vform,
				   MOD < anti_synsem >,
				   TAM #tam ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD verbal & [ VFORM #vform,
						   TAM #tam ],
				   VAL [ SUBJ < synsem &
					      [ LOCAL [ CAT #cat,
							AGR #agr ],
						NONLOC #nonloc,
						--SIND #sind ] >,
					 SPR *anti_cons* ] ] ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.VAL [ SUBJ < synsem &
					    [ LOCAL [ CAT #cat,
						      AGR #agr ],
					      NONLOC #nonloc,
					      --SIND #sind ] >,
				       SPR *anti_cons* ] ] ].

pp_predp_coord_phr := predp_coord_phr &
  [ SYNSEM.LOCAL.CAT.HEAD prep,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD prep_or_modnp,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD v_or_a  & [ MINORS.MIN event_rel ] ].

ap_predp_coord_top_phr := ap_predp_coord_phr & top_coord_event_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct ].
ap_predp_coord_mid_eg_phr := ap_predp_coord_phr & mid_coord_event_edgen_rule.
ap_predp_coord_mid_ig_phr := ap_predp_coord_phr & mid_coord_event_infgen_rule.

vp_a-or-p_predp_coord_top_phr := vp_a-or-p_predp_coord_phr & 
				 top_coord_event_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct ].
vp_a-or-p_predp_coord_mid_eg_phr := vp_a-or-p_predp_coord_phr & 
				    mid_coord_event_edgen_rule.
vp_a-or-p_predp_coord_mid_ig_phr := vp_a-or-p_predp_coord_phr & 
				    mid_coord_event_infgen_rule.

verbal_predp_coord_top_phr := verbal_predp_coord_phr & top_coord_event_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct  ].
vp_predp_coord_top_phr := verbal_predp_coord_top_phr & xp_coord_phr.
v_onecomp_predp_coord_top_phr := verbal_predp_coord_top_phr & 
				 x_onecomp_coord_phr.

vp_predp_coord_mid_eg_phr := verbal_predp_coord_phr & 
			     mid_coord_event_edgen_rule & xp_coord_phr.
vp_predp_coord_mid_ig_phr := verbal_predp_coord_phr & 
			     mid_coord_event_infgen_rule & xp_coord_phr.
v_onecomp_predp_coord_mid_eg_phr := verbal_predp_coord_phr & 
			     mid_coord_event_edgen_rule & x_onecomp_coord_phr.
v_onecomp_predp_coord_mid_ig_phr := verbal_predp_coord_phr & 
  			     mid_coord_event_infgen_rule & x_onecomp_coord_phr.

pp_predp_coord_top_phr := pp_predp_coord_phr & top_coord_event_rule &
  [ LCONJ-DTR.SYNSEM.PUNCT.RPUNCT comma_or_pair_or_no_punct ].
pp_predp_coord_mid_eg_phr := pp_predp_coord_phr & mid_coord_event_edgen_rule.
pp_predp_coord_mid_ig_phr := pp_predp_coord_phr & mid_coord_event_infgen_rule.


; Coordination of all nominals
; DPF 4-Jun-03 - Added identification of SORT values for left and right and
; mother - see if this can fly.  We want to block e.g. the spurious parse for
; "the ninth and tenth kim danced" where the temp-np rule erroneously applied.
; DPF 26-aug-04 - But this excludes coordination of nouns and nominal gerunds,
; as in "His singing and dress were unusual", so push down to NP-coord only.
;; DPF 2020-04-21 - Replaced dtrs' SUBJ *anti_list* with *anti_or_synnull* se
;; we can conjoin two NPs where one contains a so-called v-mod phrase, as in 
;; |and a report by Kim that we arrived|. 
;;
basic_nom_coord_rule := basic_coord_phr &
  [ SYNSEM synsem &
           [ LOCAL [ CAT [ HEAD noun & [ MOD *anti_list*,
                                         MINORS #mins,
                                         PRD #prd ],
                           VAL [ SUBJ #subj,
				 COMPS < >,
				 SPCMPS < > ] ],
		     CONT [ HOOK.INDEX conj-ind ] ] ],
    LCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD supnoun & [ MINORS #mins,
                                                    PRD #prd ],
                                   VAL [ SUBJ #subj & *anti_or_synnull*,
                                         COMPS < > ] ],
                             CONT.HOOK.INDEX non_expl_or_conj-ind ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD supnoun & [ PRD #prd ],
                                   VAL [ SUBJ *anti_or_synnull*,
					 COMPS < > ] ],
                             CONT.HOOK.INDEX non_expl_or_conj-ind ] ].

nom_coord_rule := basic_nom_coord_rule & coord_phr &
  [ LCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    RCONJ-DTR.SYNSEM.LOCAL.CONJ.CREL basic_conj_relation & [ ARG1 #ind ] ].

; DPF 29-may-07 - Mother was [LEX na], but we need to use this value to
; distinguish lexical conjunction from head-marker-phrase (to avoid simple
; conjunction as right dtr in coord phrase), and it's not clear what work
; this [LEX na] was doing.  Note that it was also unhappily blocking
; "[Kim and Sandy] Browne".
; DPF 20-apr-08 - Removed INFLECTD + from dtrs, since we want to get
; "the Abrams and Browne children".  Yes, more ambiguity, but ...
; DPF 27-jul-09 - Allow non-empty SPR for coord-NP, since NP-n-cmpnd rule 
; expects it.
; DPF 18-may-10 - Removed RPERIPH reentrancy from RCONJ-DTR and mother, since
; we want to allow high attachment for PP in |Kim and Sandy in Paris|.
;; DPF 2012-10-01 - Changed C-CONT..XARG from reentrant with RCONJ-DTR's XARG
;; to its LTOP, since (a) couldn't recall why it should be XARG, and (b) we
;; need to have the conj_rel's handle in order to get right semantics for
;; title-compound |writers Abrams and Browne| 
;; DPF 2018-07-25 - Leave mother's HEAD.--BARE unconstrained here (it was -), 
;; and adjust in educ specialization.
;; DPF 2019-11-25 - nonlex_synsem
;; DPF 2020-04-22 - Added SPR..HEAD adv, since some rules such as N-N cmpnd
;; constrain dtrs with ref to HEAD, not to --MIN, though it would be nice to
;; get the inference somehow.  Consider FIX someday.
;;
np_coord_rule := nom_coord_rule &
  [ SYNSEM nonlex_synsem &
	   [ LOCAL [ CAT [ VAL [ SPR < synsem_min &
				     [ --MIN just_only_deg_rel,
				       LOCAL [ CAT [ HEAD adv,
						     VAL.SPR *unexplist* ],
					       CONT.HOOK.LTOP #splbl ],
				       OPT + ] >,
				 SPCMPS < > ] ],
                     CONT.HOOK.INDEX conj_ref-ind &
			             [ PNG #png,
				       SORT #sort ],
                     AGR [ PNG #png,
                           DIV #div ] ],
             MODIFD notmod &
                    [ LPERIPH #lper ] ],
    LCONJ-DTR [ SYNSEM [ LOCAL [ CAT.VAL [ SPR *olist*,
					   SPCMPS < > ],
				 CONT.HOOK.LTOP #rtop ],
                         MODIFD.LPERIPH #lper ],
                INFLECTD #infl ],
    RCONJ-DTR [ SYNSEM [ LOCAL [ CAT.VAL [ SPR *olist*,
					   SPCMPS < > ],
                                 CONT.HOOK [ LTOP #rtop,
                                             INDEX #ind ],
                                 CONJ.CREL [ ARG1.SORT basic-entity-or-event,
                                             ARG2.SORT basic-entity-or-event
							  & #sort ],
                                 AGR [ PNG #png,
                                       DIV #div ] ] ],
                INFLECTD #infl ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK.XARG #rtop,
             RELS.LIST.FIRST [ PRED udef_q_rel,
			       LBL #splbl,
                               ARG0 #ind & ref-ind,
                               RSTR #harg,
			       CFROM #from, CTO #to ],
             HCONS <! qeq & [ HARG #harg,
                              LARG #rtop  ] !>,
	     ICONS <! !> ],
    INFLECTD #infl ].

; DPF 16-jul-04 - Can't make the left dtr RPUNCT no_punct, even though this
; would nicely block "*Kim, and Sandy arrive", because it also blocked the
; acceptable coordination of longer NPs, as in "the chair next to the
; table by the window, and the stool by the door are new."
; We'll leave the strong constraint on nbar-coord until forced to give it up.
;; DPF 2019-11-11 - Identify LCONJ's ALTMIN with mother's, to avoid making all
;; conjoined NPs be treatable as numbers for apposition using app-num rule.
;; DPF 2020-03-24 - CHECK: Removed above identity in mo, for good reason?
;;
basic_np_coord_top_rule := basic_top_coord_rule & np_coord_rule &
  [ LCONJ-DTR.SYNSEM.MODIFD.RPERIPH bool,
    C-CONT [ HOOK.INDEX #ind,
             RELS <! relation & [ ARG0 #ind ] !> ] ].

np_coord_top_rule := basic_np_coord_top_rule &
  [ LCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    RCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case ].

;; DPF 2018-04-30 - Don't propagate CASE to top of coord, since we want to
;; admit |the message reports the names of members and how many cars they have|
;; where we use CASE to block the nominalization of WH-CP as an immediate
;; argument of a transitive verb, to avoid spurious ambiguity for
;; |the message reports how many cars they have|
;; DPF 2020-04-21 - Re 2018-04-30: But leaving mother's CASE unconstrained
;; wrongly allows |we admire he and you|.  FIX, maybe via separate coord rule
;; for |NP and WH-CP|.
;;
np_coord_top_eg_rule := np_coord_top_rule.

np_coord_top_ig1_rule := np_coord_top_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom,
    LCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN pron_rel,
                                        CASE acc ],
                             AGR.PNG.PN -2s ],
    GENRE nonformal ].

np_coord_top_ig2_rule := np_coord_top_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom,
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN nonrefl_or_refl_rel,
                                        CASE acc ],
			     CONJ.CREL.ARG2.PNG.PN -2s ],
    GENRE nonformal ].

; DPF 02-jun-09 - Restrict to 1st person only (for hypercorrection), to avoid
; spurious ambiguity
;; DPF 2016-04-13 - Added LCONJ-DTR..SUBJ < > to prevent conjunction with
;; nominalized WH-clauses, as in |who arose, him or you?|
;;
np_coord_top_ig3_rule := np_coord_top_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE acc,
    LCONJ-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD [ MINORS.MIN pron_rel,
                                        CASE nom ],
			     CONJ.CREL.ARG2.PNG.PN 1 ],
    GENRE nonformal ].

np_coord_mid_rule := basic_mid_coord_rule & np_coord_rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
		   CONJ.CREL #rel & [ ARG2 #rind ] ],
    LCONJ-DTR.SYNSEM [ LOCAL.CAT.HEAD.CASE #case,
		       MODIFD.RPERIPH bool ],
    RCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
			     CONT.HOOK.INDEX #rind ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK.INDEX #ind,
             RELS <! relation, #rel & [ ARG0 #ind,
					CFROM #from, CTO #to ] !> ] ].

np_coord_mid_eg_rule := np_coord_mid_rule & mid_coord_edgen_rule.
np_coord_mid_ig_rule := np_coord_mid_rule & mid_coord_infgen_rule.

; For sequence of coordinated NPs and nbars without final conjunction
; Constrain to be GENRE nonformal
; Restrict right conjunct to be nonprominal
;; DPF 2016-02-01 - Removed constraints on each dtr to be nonconj_ref-ind,
;; since we want e.g. |Kim (or Browne), Abrams (or Chiang)| via this rule.
;; DPF 2017-05-02 - Constrain the right dtr to not already be a coord phrase,
;; to avoid spurious analyses for |butter and salt| in 
;; |combine flour, milk, butter and salt|
;;
nom_coord_mid_noconj_rule := binary_rule_right_to_left & basic_nom_coord_rule &
  [ SYNSEM [ LOCAL [ CAT.HEAD.CASE non_obliq,
		     CONT.HOOK.INDEX conj_ref-ind,
		     AGR.DIV #div,
                     CONJ phr-conj & [ CHEAD cnil,
                                       CREL #rel,
				       NOCONJ + ] ],
             PUNCT [ LPUNCT no_punct,
                     PAIRED no_ppair,
                     RPUNCT #rpunct,
		     RCLSTR #rclstr ],
             MODIFD.RPERIPH na ],
    LCONJ-DTR [ SYNSEM [ LOCAL [ CAT.HEAD.CASE non_obliq & #case,
                                 CONT.HOOK.INDEX #lind,
                                 CONJ cnil ],
                         PUNCT [ LPUNCT no_punct,
                                 RPUNCT comma_or_semicol ],
                         MODIFD.RPERIPH bool ],
                INFLECTD + ], 
    RCONJ-DTR [ SYNSEM [ LOCAL [ CAT.HEAD [ CASE #case,
					    MINORS.MIN nonpro_rel ],
                                 CONT.HOOK.INDEX #rind & nonconj_ref-ind,
				 AGR.DIV #div,
                                 CONJ cnil ],
                         PUNCT [ LPUNCT no_punct,
                                 RPUNCT #rpunct,
				 RCLSTR #rclstr ],
                         MODIFD.RPERIPH bool ],
                INFLECTD + ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #cind & conj-ind ],
             RELS.LIST < [ PRED udef_q_rel,
                           ARG0 #cind2 & ref-ind,
                           RSTR #harg,
			   CFROM #from, CTO #to ],
                         basic_conj_relation &
                         [ LBL #ctop2,
                           PRED implicit_conj_rel,
                           ARG0 #cind2 & non_expl,
                           ARG1 #lind,
                           ARG2 #rind,
			   CFROM #from, CTO #to ],
                         basic_conj_relation & #rel &
                         [ LBL #ltop,
                           PRED implicit_conj_rel,
                           ARG0 #cind & non_expl,
                           ARG2 #cind2,
			   CFROM #from, CTO #to ], ... >,
             HCONS.LIST < qeq & [ HARG #harg,
                                  LARG #ctop2 ], ... >,
	     ICONS <! !> ] ].

np_coord_mid_noconj_rule := nom_coord_mid_noconj_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    LCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.NORM quantity_or_norm_rel,
				 VAL.SPR *olist* ],
    RCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD.MINORS.NORM quantity_or_norm_rel,
				 VAL.SPR *olist* ],
    C-CONT [ RELS <! relation, relation, relation !>,
             HCONS <! qeq !>,
	     ICONS <! !> ] ].

nbar_coord_mid_noconj_rule := nom_coord_mid_noconj_rule &
  [ SYNSEM.LOCAL [ CAT [ VAL.SPR < synsem &
                                 [ LOCAL [ CAT [ HEAD det,
                                                 VAL [ SUBJ < >,
                                                       SPR *olist* ] ],
                                           AGR #agr & [ PNG.PN 3p ] ],
                                   NONLOC #nonloc,
                                   LEX +,
                                   OPT - ] >,
			 HS-LEX #hslex ],
                   AGR #agr ],
    LCONJ-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD.PRD -,
				       VAL.SPR < expressed_synsem & 
                                          [ --MIN #sprmin,
                                            OPT -,
                                            LOCAL.CAT.HEAD det,
                                            NONLOC #nonloc ] >,
				       HS-LEX #hslex ],
				 CONT.HOOK [ LTOP #ltop,
					     INDEX #lind ] ],
			 PUNCT.RPUNCT comma_or_rbc_punct ],
		ORTH [ FROM #from1, TO #to1 ] ],
    RCONJ-DTR [ SYNSEM.LOCAL [ CAT.VAL.SPR < expressed_synsem & 
                                           [ --MIN #sprmin,
                                             OPT -,
                                             LOCAL.CAT.HEAD det,
                                             NONLOC #nonloc ] >,
			       CONT.HOOK [ LTOP #rtop,
					   INDEX #rind ] ],
		ORTH [ FROM #from2, TO #to2 ] ],
    C-CONT [ RELS <! relation, relation, relation,
                     [ PRED udef_q_rel,
		       ARG0 #lind & ref-ind,
		       RSTR #lrstr,
		       CFROM #from1, CTO #to1 ],
                     [ PRED udef_q_rel,
		       ARG0 #rind & ref-ind,
		       RSTR #rstr,
		       CFROM #from2, CTO #to2 ] !>,
             HCONS <! qeq, 
                      qeq & [ HARG #lrstr,
                              LARG #ltop ],
                      qeq & [ HARG #rstr,
                              LARG #rtop ] !>,
	     ICONS <! !> ] ].

; DPF 05-apr-09 - Restrict to parenthesized NPs, as in "students (Kim, Pat)"
; even though this undergenerates, to avoid unwanted ambiguity for every
; comma-separated appositive.
;; DPF 2020-03-24 - Changed to RCONJ-DTR..RPAREN na_or_+ from + as per trunk.
;
np_coord_top_noconj_rule := binary_rule_right_to_left & basic_nom_coord_rule &
  [ INFLECTD +,
    SYNSEM [ LOCAL [ CAT [ HEAD [ CASE non_obliq,
				  --BARE - ],
			   VAL.SPR < > ],
		     CONT.HOOK.INDEX conj_ref-ind,
                     CONJ cnil ],
             PUNCT [ LPUNCT lparen_punct,
                     PAIRED no_ppair,
                     RPUNCT #rpunct ] ],
    LCONJ-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD [ CASE non_obliq & #case,
					      MINORS.NORM quantity_or_norm_rel],
				       VAL.SPR *olist* ],
                                 CONT.HOOK.INDEX #lind & nonconj_ref-ind,
                                 CONJ cnil ],
                         PUNCT [ LPUNCT lparen_punct,
                                 RPUNCT comma_or_semicol ] ],
                INFLECTD + ], 
    RCONJ-DTR [ SYNSEM [ LOCAL 
			 [ CAT [ HEAD [ CASE #case,
					MINORS [ MIN nonpro_rel,
						 NORM quantity_or_norm_rel ] ],
				 VAL.SPR *olist* ],
			   CONT.HOOK.INDEX #rind & nonconj_ref-ind,
			   CONJ cnil ],
			 PUNCT [ LPUNCT no_punct,
                                 RPUNCT #rpunct,
				 RCLSTR.RPAREN na_or_+ ],
                         MODIFD.RPERIPH bool ],
                INFLECTD + ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ INDEX #cind & conj-ind ],
             RELS <! [ PRED udef_q_rel,
                           ARG0 #cind & ref-ind,
                           RSTR #harg,
			   CFROM #from, CTO #to ],
                         basic_conj_relation &
                         [ LBL #ctop,
                           PRED implicit_conj_rel,
                           ARG0 #cind & non_expl,
                           ARG1 #lind,
                           ARG2 #rind,
			   CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #harg,
			      LARG #ctop ] !>,
	     ICONS <! !> ],
    GENRE nonformal ].

; Exclude proper name nbar coord for now at least.
; DPF 26-aug-04 - Generalized dtrs' HEAD from noun to noun_or_nomger
; DPF 25-feb-05 - Added unif of NORM on mother and dtrs to preserve
; non-compoundability as in "*[paper and other] garbage"
; DPF 13-mar-05 - Added MODIFD notmod to mother, to capture apparent and
; interesting fact that coordination of nbars results in a phrase that can 
; again take either a posthead or prehead modifier: '[cats and small dogs] 
; in Paris' and 'small [cats in boxes and large dogs]'.
; DPF 2-apr-05 - But this addition overconstrains the rule, disallowing e.g.
; 'the tenth and eleventh I am out of town'.  So leave underspecified.
; DPF 14-nov-05 - Removed identification of LEX on dtrs and mother, since
; want to coordinate e.g. "garden with dogs and flower garden".  This could
; raise nice puzzle, since want to allow "flower and vegetable garden"
; but block "*flower and vegetable with leaves garden".  Happily, making
; non-head in compounds be non-inflected blocks the latter, since head-mod
; rule (for "vegetable with leaves" requires inflected dtrs).  So for now
; identify LEX of mother with right dtr - maybe unnecessary. FIX?  But to
; avoid too much ambiguity, for now still require #lex identity for 
; mid-coord rule.
; DPF 14-nov-05 - Re 2-apr-05: The adj_adjh rule needs to have some MODIFD
; value for its modifiee, so leaving value unconstrained is unsatisfactory.
; Here try propagating the value from the left dtr, arbitrarily.
; DPF 13-mar-10 - Constrain the conjoined phrase to have same spr's MIN
; value, to block e.g. [[every cat] and dog] where adj `every' requires 
; explicit determiner.
;; DPF 2018-02-13 - We can't require the SPRs on the dtrs to be SLASH 0-dlist
;; since free relative "whatever" has SLASH non-empty, as in |whatever cats
;; and dogs we admire|
;; DPF 2020-05-16 - Change mother's SPR to append the rest of left dtr's SPR,
;; so when we coordinate two measure-NPs, the result preserves the distinctive
;; property that allows measnp-deg-adv, namely a non-empty rest of SPR, as in
;; |[one meter or two meters] tall|
;;
nbar_coord_rule := nom_coord_rule &
  [ INFLECTD #infl,
    SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.NORM #norm,
				  CASE #case ],
                           VAL.SPR < synsem &
                                     [ LOCAL [ CAT [ HEAD det &
						      [ MINORS.MIN #sprmin ],
                                                     VAL [ SUBJ < >,
                                                           SPR *olist* ] ],
                                               AGR #agr ],
				       NONLOC #nonloc,
                                       LEX +,
                                       OPT - ] . #lsprst >,
			   HS-LEX #hslex ],
		     CONJ [ LPERNUM #lpn,
			    RPERNUM #rpn ],
                     AGR #agr ],
             MODIFD #modif,
             LEX #lex ],
    LCONJ-DTR [ INFLECTD #infl,
                SYNSEM [ LOCAL [ CAT [ HEAD noun_or_nomger_or_nadj & 
                                            [ MINORS.NORM #norm,
					      CASE #case ],
                                       VAL.SPR < expressed_synsem & 
                                                 [ --MIN #sprmin,
                                                   OPT -,
                                                   LOCAL [ CAT.HEAD det,
							   AGR.PNG.PN #lpn ],
						   NONLOC #nonloc ] . #lsprst >,
				       HS-LEX #hslex ],
                                 CONT.HOOK [ LTOP #lhndl,
                                             INDEX #lind ] ],
                         MODIFD #modif ],
		ORTH [ FROM #from, TO #to ] ],
    RCONJ-DTR [ INFLECTD #infl,
                SYNSEM [ LOCAL.CAT [ HEAD noun_or_nomger_or_nadj & 
					  [ MINORS.NORM #norm,
					    CASE #case ],
				     VAL.SPR.FIRST expressed_synsem & 
                                                 [ --MIN #sprmin,
						   OPT -,
                                                   LOCAL [ CAT.HEAD det,
							   AGR.PNG.PN #rpn ],
						   NONLOC #nonloc ] ],
			 LEX #lex ] ],
    C-CONT [ RELS.LIST.FIRST [ PRED udef_q_rel,
                               ARG0 #lind & ref-ind,
                               RSTR #lrstr,
			       CFROM #from, CTO #to ],
             HCONS.LIST.FIRST qeq & [ HARG #lrstr,
                                      LARG #lhndl ],
	     ICONS <! !> ] ].

; DPF 31-jul-06 - Push identity of SPR..PNG on both conjuncts down to the
; subrule which has [DIV -] LCONJ, so we can coordinate mass and plural, as
; in "camping and cabins".  But note that this also allows spurious ambig
; for plur + sing, as in "the woods and field" - FIX.

nbar_coord_symmet_rule := nbar_coord_rule &
  [ SYNSEM.LOCAL.AGR.PNG #png,
    RCONJ-DTR.SYNSEM.LOCAL.AGR.PNG #png ].

; DPF 11-oct-05 - If there is a [DIV -] dtr, then mother must also be [DIV -],
; to block "*car and money are necessary".  Need two subtypes of symmetric
; coord rule to capture this.
;; 2013-01-15 - Since there are now div and nondiv subtypes, it's wrong to
;; demand that the left dtr always be DIV + (see e.g. |the tenth and eleventh|)
;; so push LCONJ-DTR..DIV down to the two subtypes.
;
nbar_coord_top_1_rule := top_coord_rule & nbar_coord_symmet_rule &
  [ SYNSEM.LOCAL [ AGR.DIV #div,
		   CONT.HOOK.INDEX conj_ref-ind ],
    RCONJ-DTR.SYNSEM.LOCAL.AGR.DIV #div,
    C-CONT [ RELS <! relation !>,
             HCONS <! qeq !>,
	     ICONS <! !> ] ].

;; DPF 2011-09-02 - Since the coordination of two mass nouns can still show
;; singular agreement (|how much sand and gravel is in the pit?|), we divide 
;; this rule into count vs. mass subtypes
;; DPF 2012-12-17 - Removed INFLECTD + constraints on dtrs, since we also
;; need this rule for |the rice and corn cat arises|
;; DPF 2013-05-10 - Re 2011-09-02: But only get singular agreement if both
;; conjuncts are mass; otherwise have to use the conjunction's CAGR value:
;; |*cats and rice arises|, |*how much cats and rice arose?|
;; So it seems that we need a different split: one rule just for conjoined
;; mass nouns (the surprising case of agreement), and the second rule for
;; everything else.  Fortunately, |how much sand and gravel are needed| is
;; not too bad, so we can have the second rule uniformly take the CAGR.
;; DPF 2013-06-10 - But we still need to preserve DIV value on mother in
;; the "nondiv" rule, to block |*cat and dog arose|.  This is tricky, since
;; (a) we don't want to force identity of DIV on the two dtrs (|cats and
;; rice disappeared|), (b) if either of the two dtrs is DIV -, the mother
;; must be.  To avoid splitting the rule, we'll just stamp DIV - on the
;; mother, and accept the spurious second reading for |the sand and gravel
;; arose|.

;; DPF 2013-05-10 - Changed mother's PNG.PN to identify with right dtr's
;; ARG2..PN rather than its AGR..PN, since the AGR in the head-marker
;; phrase is not constrained.  This now correctly blocks |cats and dogs arises|
;; |the [cats and dogs] are ...|, |the [cats and rice] are ...|,
;; |the [sand and gravel] are ...|
;; DPF 2015-09-06 - Trying underspecification of number on mother, since we
;; want |how much sand and gravel arrives?| with singular agreement, but also
;; |sand and gravel arrive|.
;; DPF 2016-02-16 - Also need to split the div rule to preserve the LEX value,
;; to avoid non-head coord nbar where one of the conjuncts is nonlex, as in 
;; |the [[[knowledge of cats] and ignorance] debate]|
;; DPF 2017-10-07 - Re 2015-09-06: Well, but this also allows 
;; |*the dogs and cats sleeps|. So it looks like we instead need to add a 
;; special rule for the singular coord of mass nouns.  Not a perfect solution 
;; yet, since we can still use the normal div-coord rule to get a parse 
;; for |sand and gravel|, but excluding it would be a hassle, so maybe FIX 
;; someday.
;;
nbar_coord_top_1_div_rule := nbar_coord_top_1_rule &
  [ SYNSEM.LOCAL.AGR.PNG.PN #pn,
    LCONJ-DTR.SYNSEM. LOCAL.AGR.DIV +,
    RCONJ-DTR.SYNSEM.LOCAL [ AGR.DIV +,
			     CONJ.CPNG.PN #pn ] ].

;; DPF 2017-10-23 - Let's at least constrain this rule to only be used where
;; subj-verb agreement occurs, namely when inflected and nominative case.
;; DPF 2017-11-08 - But this means we can't get |how much sand and gravel did 
;; you find| since divis is incompatible with "how much".  So remove CASE 
;; constraint, and live with the unlovely ambiguity everywhere of mass vs div.
;;
nbar_coord_top_1_mass_rule := nbar_coord_top_1_rule &
  [ INFLECTD +,
    SYNSEM.LOCAL [ AGR.PNG.PN 3,
		   CAT.HEAD.CASE real_case ],
    LCONJ-DTR.SYNSEM.LOCAL.AGR [ DIV +,
				 IND - ],
    RCONJ-DTR.SYNSEM.LOCAL.AGR [ DIV +,
				 IND - ] ].

nbar_coord_top_1_div_samelex_rule := nbar_coord_top_1_div_rule &
  [ LCONJ-DTR.SYNSEM.LEX #lex,
    RCONJ-DTR.SYNSEM.LEX #lex ].

nbar_coord_top_1_div_asymlex1_rule := nbar_coord_top_1_div_rule &
  [ LCONJ-DTR.SYNSEM.LEX -,
    RCONJ-DTR.SYNSEM.LEX + ].

nbar_coord_top_1_div_asymlex2_rule := nbar_coord_top_1_div_rule &
  [ LCONJ-DTR.SYNSEM.LEX +,
    RCONJ-DTR.SYNSEM.LEX - ].

nbar_coord_top_1_nondiv_rule := nbar_coord_top_1_rule &
  [ INFLECTD +,
    SYNSEM.LOCAL.AGR [ PNG.PN #pn,
		       DIV - ],
    LCONJ-DTR [ INFLECTD +,
		SYNSEM.LOCAL.CAT.HEAD basic_noun ],
    RCONJ-DTR [ INFLECTD +,
		SYNSEM.LOCAL [ CAT.HEAD basic_noun,
			       CONJ.CPNG.PN #pn ] ] ].

; Require both dtrs to be INFLECTD + to avoid spurious ambiguity for N-N
; compounds with a conjoined left dtr: "summer and winter routes"
; DPF 31-jul-06 - Let's try requiring unif of MINORS.MIN values for the
; two conjuncts, to avoid unwanted coord as "Kim and Sara cat Browne"
; DPF 19-apr-08 - Re 31-jul-06 - But this prevents coordination of e.g.
; "hand and book" since n-ed nouns have distinct MIN value. So undo.
; DPF 30-nov-09 - Re 19-apr-08 - However, we still want to block 
; "*Kim and tree disappeared"
;; DPF 2016-03-14 - It seems that this rule is subsumed by a combination of
;; n-n_crd-t_c and n-n_crd-asym-t_c, so let's try doing without it.
; Special coord rule for e.g. 'that legendary hunter and guide arrives',
; which adds semantic constraint that equates the two nbar indices
; DPF 8-aug-07 - Restrict to lexical conjuncts to avoid spurious ambiguity.
;; DPF 2014-06-09: Dropped MODIFD notmod on both dtrs of nbar_coord_top_3_rule,
;; to allow |Kim, corporate secretary and legal counsel, ...|
;; DPF 2020-04-15 - Re 8-aug-07: But this excludes 
;; |Kim, president of the company and chief bottlewasher|, so go back to MODIFD,
;; but constrain to notmod_or_lmod.
;;
nbar_coord_top_3_rule := top_coord_rule & nbar_coord_symmet_rule &
  [ INFLECTD +,
    SYNSEM.LOCAL [ CAT.HEAD.--BARE -,
		   CONT.HOOK.INDEX conj_ref-ind,
                   AGR [ PNG.PN 3s,
			 DIV - ] ],
    LCONJ-DTR [ INFLECTD +,
                SYNSEM [ LOCAL [ CAT [ HEAD noun &
					    [ MINORS.MIN #min & norm_nom_rel ],
                                       VAL.SPR < [ LOCAL.AGR.PNG #spng ] > ],
                                 CONT.HOOK.INDEX #lind,
                                 AGR.DIV - ],
			 MODIFD notmod_or_lmod ] ],
    RCONJ-DTR [ INFLECTD +,
                SYNSEM [ LOCAL [ CAT [ HEAD noun &
					    [ MINORS.MIN #min ],
                                       VAL.SPR < [ LOCAL.AGR.PNG #spng ] > ],
				 AGR.DIV -,
                                 CONJ.CREL [ PRED _and_c_rel,
                                             ARG2 #rind ] ],
			 MODIFD notmod_or_lmod ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK.LTOP #ltop,
             RELS <! relation,
                     [ LBL #ltop,
                       PRED id_rel,
                       ARG1 #lind,
                       ARG2 #rind,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq !>,
	     ICONS <! !> ] ].


nbar_coord_mid_rule := mid_coord_rule & nbar_coord_symmet_rule &
  [ SYNSEM.LOCAL.CONJ [ CREL #rel & [ ARG2 #rind ],
			CPNG.PN #pn ],
    LCONJ-DTR.SYNSEM [ LOCAL.CAT.HEAD.MINORS.ALTMIN impl_or_expl_q_rel,
                       LEX #lex ],
    RCONJ-DTR [ SYNSEM [ LOCAL [ CAT.HEAD.MINORS.ALTMIN impl_or_expl_q_rel,
				 CONT.HOOK.INDEX #rind,
				 CONJ [ CREL [ LBL #lbl,
					       ARG0 #arg0 ],
					CPNG.PN #pn ] ],
			 LEX #lex ],
		ORTH [ FROM #from2, TO #to2 ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS <! relation, 
   		     #rel & [ CFROM #from, CTO #to ],
		     [ PRED udef_q_rel,
		       ARG0 #arg0 & ref-ind,
		       RSTR #rstr,
		       CFROM #from2, CTO #to2 ] !>,
             HCONS <! qeq, qeq & [ HARG #rstr,
                                   LARG #lbl ] !>,
	     ICONS <! !> ] ].

nbar_coord_mid_eg_rule := nbar_coord_mid_rule & mid_coord_edgen_rule.

; DPF 01-sep-07 - This one is too expensive given interaction with compounds.
; DPF 12-feb-08 - But we need this to get e.g. "cat, dog and bird infested"
; so restore it, but for now constrain it to only uninflected conjuncts, so
; only for compounds.
; DPF 05-aug-08 - We also need this for quite ordinary coordination like
; "tools, prototyping and programming", so restore full use, and look for
; other ways to improve efficient interaction with compounds.
nbar_coord_mid_ig_rule := nbar_coord_mid_rule & mid_coord_infgen_rule.

; For coord of singular and plural nbar: "husband and children", with
; AGR value to block both "*this husband and children" and "*these husband
; and children" but allow "my husband and children"
; DPF 2-Mar-05 - Removed ALTMIN explicit_q_rel because it prevented
; 'without husband and children'.
; DPF 09-apr-09 - Block mid-coord right dtr, since that conjunction will
; always be plural, and thus falsely permit e.g. "Abrams, cat and dog" as
; a plural NP.
;; DPF 2016-10-21 - Also for singular-count + singular-mass, as in 
;; |my cat and rice|, so change PN 3p to DIV +.

nbar_coord_asym_rule := nbar_coord_rule &
  [ INFLECTD +,
    SYNSEM.LOCAL.AGR [ PNG.PN 3p,
                       DIV - ],
    LCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL.CAT [ HEAD noun,
				   VAL.SPR < [ LOCAL.AGR [ PNG.PN 3s,
							   DIV - ] ] > ] ],
    RCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL [ CAT [ HEAD noun,
				     VAL.SPR < [ LOCAL.AGR.DIV + ] > ],
			       CONJ lex-conj ] ] ].

nbar_coord_asym_2_rule := nbar_coord_rule &
  [ INFLECTD +,
    SYNSEM.LOCAL [ CAT.HEAD.MINORS.ALTMIN explicit_q_rel,
                   AGR [ PNG.PN 3p,
                         DIV + ] ],
    LCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL.CAT [ HEAD noun,
				   VAL.SPR < [ LOCAL.AGR.PNG.PN 3p ] > ] ],
    RCONJ-DTR [ INFLECTD +,
                SYNSEM.LOCAL.CAT [ HEAD noun,
				   VAL.SPR < [ LOCAL.AGR [ PNG.PN 3s,
							   DIV - ] ] > ] ] ].

nbar_coord_asym_top_rule := top_coord_rule & nbar_coord_asym_rule &
  [ C-CONT [ HOOK.INDEX conj_ref-ind,
	     RELS <! relation !>,
             HCONS <! qeq !>,
	     ICONS <! !> ] ].

nbar_coord_asym_top_2_rule := top_coord_rule & nbar_coord_asym_2_rule &
  [ C-CONT [ HOOK.INDEX conj_ref-ind,
	     RELS <! relation !>,
             HCONS <! qeq !>,
	     ICONS <! !> ] ].

; For coordination of prenominal adj + noun modifiers, as in 
; "the wooden and marble staircase"
; DPF 02-jul-09 - Add the reverse order as well: "the marble and wooden X"
;; DPF 2017-05-25 - Finally noticed that this type failed to constrain CONJ
;; on the mother, which for example admitted an unwanted coord-adj phrase
;; [more [[seasoning] [if needed]]].
;; DPF 2018-07-28 - Generalized to also allow addition of the mid-coord
;; variant, for |the tall, angry, or monster cat|
;; DPF 2019-09-10 - Since we also want |the pharmaceutical and health 
;; products company|, change second dtr to INFLECTD +, but constrain to
;; N-bar.
;; DPF 2020-03-24 - CHECK: Undid the above change in mo, for good reason?
;;
basic_adj_noun_coord_rule := min_coord_phr &
			     binary_rule_right_to_left &
  [ INFLECTD +,
    SYNSEM synsem &
           [ LOCAL [ CAT [ HEAD adj &
				[ MOD #mod & 
				      < [ LOCAL.CONT.HOOK.INDEX #mind ] >,
				  PRD #prd,
				  MINORS #minors & [ MIN norm_adj_rel ] ],
			   VAL #val & [ SPR < unexpressed, anti_synsem_min >,
					COMPS < > ],
			   POSTHD #posthd & - ] ],
	     LEX + & #lex,
	     NONLOC non-local_none_phr,
	     PUNCT [ LPUNCT #lpunct,
		     RPUNCT #rpunct,
		     RCLSTR #rclstr ] ],
    LCONJ-DTR [ INFLECTD +,
		SYNSEM [ LOCAL [ CAT [ HEAD adj & 
					    [ MOD #mod,
					      PRD #prd & -,
					      MINORS #minors & 
						  [ NORM norm_rel ] ],
				       VAL #val & [ COMPS < > ],
				       POSTHD #posthd ],
				 CONT.HOOK [ XARG #mind ] ],
			 LEX #lex,
			 NONLOC non-local_none_phr ] ],
    RCONJ-DTR [ INFLECTD -,
		SYNSEM [ LOCAL.CAT [ HEAD noun & 
					  [ MINORS [ MIN gen_nom_nbar_rel,
						     NORM no_rel ] ],
				     VAL.COMPS < > ],
			 NONLOC non-local_none_phr ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ INDEX conj-ind ],
	     RELS.LIST < prep_notense_relation &
			 [ PRED compound_rel,
			   ARG1 #mind,
			   CFROM #from, CTO #to ], ... > ],
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpunct ],
           [ SYNSEM [ LOCAL.CONJ complex-conj,
		      PUNCT [ RPUNCT #rpunct,
			      RCLSTR #rclstr ] ] ] > ].


;; DPF 2012-08-25 - Added CONJ cnil to left daughter blocking spurious ambig
;;
norm_adj_noun_coord_rule := basic_adj_noun_coord_rule &
  [ LCONJ-DTR #ldtr & [ SYNSEM.LOCAL.CONT.HOOK.LTOP #lctop ],
    RCONJ-DTR #rdtr,
    C-CONT [ HOOK.LTOP #lctop,
	     RELS <! [ LBL #lctop,
		       ARG2 #rcind,
		       CFROM #from, CTO #to ],
		     [ PRED udef_q_rel,
		       ARG0 #ind & ref-ind,
		       RSTR #rstr,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! qeq & [ HARG #rstr, LARG #lbl ] !>,
	     ICONS <! !> ],
    ARGS < #ldtr & [ SYNSEM [ LOCAL [ CONT.HOOK.INDEX #lcind,
				      CONJ cnil ],
			      PUNCT.RPUNCT comma_or_rbc_or_pair_or_no_punct ]],
	   #rdtr & [ SYNSEM.LOCAL [ CONJ.CREL [ ARG1 #lcind,
						ARG2 #rcind ],
				    CONT.HOOK [ LTOP #lbl,
						INDEX #ind ] ] ] > ].

adj_noun_coord_rule := norm_adj_noun_coord_rule &
  [ SYNSEM.LOCAL.CONJ cnil ].

;; DPF 2020-03-20 - Changed parent type as per trunk.
; adj_noun_coord_mid_rule := norm_adj_noun_coord_rule & mid_coord_rule.
;;
adj_noun_coord_mid_rule := norm_adj_noun_coord_rule & mid_coord_infgen_rule.

;; Note that RCONJ-DTR is the leftmost dtr here (the noun)
;; DPF 2012-08-25 - Added CONJ cnil to left dtr, blocking spurious ambig
;;
norm_noun_adj_coord_rule := basic_adj_noun_coord_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #mltop ] >,
    LCONJ-DTR #ldtr,
    RCONJ-DTR #rdtr & [ SYNSEM [ LOCAL.CONT.HOOK [ LTOP #lbl,
						   INDEX #ind ],
				 PUNCT.RPUNCT comma_or_no_punct ] ],
    C-CONT [ RELS <! [ LBL #lbl,
		       ARG0 #clind,
		       ARG2 #ind,
		       CFROM #from, CTO #to ],
		     [ PRED udef_q_rel,
		       ARG0 #ind & ref-ind,
		       RSTR #rstr,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rstr,
			      LARG #lbl ] !>,
	     ICONS <! !> ],
    ARGS < #rdtr & [ SYNSEM.LOCAL.CONJ cnil ],
	   #ldtr & [ SYNSEM.LOCAL [ CONJ.CREL [ LBL #mltop,
						ARG1 #clind ] ] ] > ].

noun_adj_coord_rule := norm_noun_adj_coord_rule &
  [ SYNSEM [ LOCAL.CONJ cnil,
             PUNCT [ LPUNCT #lpunct,
                     PAIRED #rpnctpr,
                     RPUNCT #rpunct ] ],
    LCONJ-DTR.SYNSEM.PUNCT [ LPUNCT #lpunct,
			     RPUNCT comma_or_rbc_or_semi_or_pair_or_no_punct,
			     PNCTPR #pnctpr ],
    RCONJ-DTR.SYNSEM.PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
			     RPUNCT #rpunct,
			     PAIRED #pnctpr,
			     PNCTPR #rpnctpr ] ].

;; DPF 2019-05-15 - Added CPUNCT no_ppair to block this analysis for no-comma
;; |green hill and blue water|
;; DPF 2020-03-20 - CHECK parent type and addition of CPUNCT
;;
; noun_adj_coord_mid_rule := norm_noun_adj_coord_rule & mid_coord_rule.
noun_adj_coord_mid_rule := norm_noun_adj_coord_rule & mid_coord_infgen_rule &
  [ SYNSEM.LOCAL.CONJ.CPUNCT no_ppair ].

; DPF 28-Nov-02 - HOOK comes only from C-CONT
; DPF 27-Nov-04 - Removed SPR *anti-list* from left dtr, to allow N-bars
; like "act of kindness; assistance"
; DPF 27-Nov-04 - Added LPERIPH + as hack to prevent these from being
; modified by subconj_prdp phrases, as in "coming next after the ninety-ninth"
; DPF 14-aug-05 - Limit to run-ons where message is same on both conjuncts,
; to avoid underspecification of message on left dtr which leads to unwanted
; triggering for generation
; DPF 03-sep-05 - But this doesn't work so well with fragments.  So just
; restrict left conjunct to prop_imp_m_rel, and ignore for now run-ons with a
; left interrogative -- annoying in treebanking, but manageable.
; DPF 31-may-07 - Removed ALTMIN no_rel from mother to allow recursive
; application of this rule.
;; DPF 2012-12-21 - Moved MC + down to subtypes, but not on npindef_s_rule,
;; to allow embedded clauses of the form 
;; |Kim said "a famous doctor, Abrams cured thousands"|
;; DPF 2017-11-18 - Removed right dtr's SUBJ *anti_list* constraint since it
;; is already on the two relevant subtypes, and we don't want it on run-on NP
;; where the NP can have a *synlist* constraint on its SUBJ (namely when the 
;; head noun has undergone so-called v-mod rule, as in |the claim yesterday 
;; that he arrived|
;; DPF 2020-05-07 - Changed parent from basic_binary_phrase to
;; generic_binary_phrase as in trunk
;;
basic_run_on_rule := binary_rule_right_to_left & generic_binary_phrase &
  [ INFLECTD +,
    SYNSEM phr_synsem &
	   [ LOCAL [ CAT [ HEAD conj-s & [ MOD < >,
                                           MINORS.MIN discourse_rel ],
                           VAL [ SPR *anti_list*,
                                 COMPS < >,
				 SPCMPS < > ] ],
		     CONJ cnil,
                     AGR.PNG #png ],
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct,
		     PAIRED #paired ] ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL local & 
                            [ CAT.VAL.COMPS < >,
                              CONJ cnil_or_lex_or_atomconj ],
                      NONLOC.SLASH 0-dlist & [ LIST < > ],
                      PUNCT [ LPUNCT #lpunct ] ] ],
           [ INFLECTD +,
             SYNSEM [ LOCAL local & 
                            [ CAT.VAL.COMPS < >,
                              AGR.PNG #png,
                              CONJ cnil_or_lexconj & [ CHEAD cnil ] ],
                      NONLOC.SLASH 0-dlist & [ LIST < > ],
                      PUNCT [ RPUNCT #rpunct & [ PSF #sf ],
			      PAIRED #paired ] ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK [ LTOP #cltop,
                    INDEX #ind & event &
                         [ SF #sf ] ],
	     RELS.LIST < conj_relation & 
                         [ PRED implicit_conj_rel,
                           LBL #cltop,
                           ARG0 #ind,
			   CFROM #from, CTO #to ], ... > ] ].

; DPF 23-jun-07 - Changed RCONJ-DTR..RPUNCT from clause_or_semicol to
; clause_or_semicol_or_no_punct in order to allow e.g. |2. Kim| without
; final period.  May cause trouble since this rule is now right-recursive.
; DPF 25-aug-07 - Try relaxing LCONJ-DTR..RPUNCT to include comma, as in
; "This man's isolation is not merely momentary, it is permanent."
;; DPF 2012-01-29 - Removed RCONJ-DTR..LPERIPH - to allow 
;; |we arise, maybe they arrive.|
;; DPF 2016-07-03 - Removed ALTMIN norm_rel from each of two dtrs, since
;; this prevented clauses such as |this is to say that we arise| as either dtr.
;; DPF 2018-03-25 - Also add MOD *anti_list* to right dtr, to avoid e.g.
;; inverted-conditional as run-on.
;;
basic_run_on_coord_rule := basic_run_on_rule & basic_coord_phr &
 [ SYNSEM [ LOCAL.CAT [ VAL.SUBJ #subj & *anti_list*,
			MC + ],
	    PUNCT [ RCLSTR #rclstr,
		    PNCTPR #ppair ] ],
   LCONJ-DTR #lconj &
             [ SYNSEM [ LOCAL [ CAT [ HEAD verb_or_frag &
                                          [ TAM.MOOD ind_or_modal_subj,
					    MOD *anti_list*,
                                            MINORS [ MIN norm_rel ] ],
                                      VAL.SUBJ #subj,
                                      MC + ],
                                CONT.HOOK [ LTOP #ltop,
					    INDEX #lindex &
						 [ E indic_tam ] ] ] ] ],
   RCONJ-DTR #rconj &
             [ SYNSEM [ LOCAL [ CAT [ HEAD verb_or_conj_or_frag &
                                           [ MINORS.MIN norm_rel,
					     MOD *anti_list* ],
                                      VAL.SUBJ *anti_list*,
                                      MC + ],
                                CONT [ HOOK [ LTOP #ltop,
                                              INDEX #rindex &
						    [ SF #sf ] ] ] ],
                        PUNCT [ RPUNCT clause_or_semi_or_pair_or_no_punct &
				       [ PSF #sf ],
				PNCTPR #ppair,
				RCLSTR #rclstr ] ] ],
   C-CONT [ HOOK.LTOP #ltop,
	    RELS <! [ ARG1 #lindex,
		      ARG2 #rindex ] !>,
            HCONS <! !>,
	    ICONS <! !> ],
   ARGS < #lconj, #rconj > ].

;; DPF 2017-02-03 - Since we now allow fragments for either dtr, let's restrict
;; this rule to spanning-only, to avoid lots of unwanted edges in chart.
;;
run_on_coord_rule := basic_run_on_coord_rule &
 [ SYNSEM [ MODIFD.LPERIPH +,
	    LOCAL.CONT.HOOK.INDEX.E #e ],
   LCONJ-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.E #e,
		      PUNCT.RPUNCT clause_or_semicol_or_hyphen ],
   RCONJ-DTR.SYNSEM [ LOCAL.CAT.HEAD verb_or_conj_or_frag,
                      PUNCT.LPUNCT lparen_or_dq_or_comma_or_no_punct ] ].

;; DPF 2016-07-04 - Not clear why we want HEAD verb_or_conj-s for right dtr,
;; since this gives spurious analysis for |we arrive, and Kim arises|.  So
;; change to just HEAD verb, and see what we lose.
;; -- Well, we need conj-s to admit |we arise, we arrive, we sleep.|  So
;; restore, and instead make the fragment |and we arise| not be HEAD conj-s.
;;
run_on_coord_comma_rule := basic_run_on_coord_rule &
 [ LCONJ-DTR.SYNSEM phr_synsem &
		    [ LOCAL.CAT.HEAD verb,
		      PUNCT.RPUNCT comma_punct ],
   RCONJ-DTR.SYNSEM [ LOCAL [ CAT.HEAD verb_or_conj-s,
                              CONJ cnil ],
		      PUNCT.LPUNCT lparen_or_dq_or_comma_or_no_punct ],
   GENRE nonformal ].

;; DPF 22-apr-09 - Block WH-NP as right dtr (via SUBJ < >), to 
;; avoid spurious analysis of 'Abrams lost, which Abrams suspected.'
;; DPF 2016-04-13 - Removed SF prop-or-comm from first dtr since we also want
;; to admit |Who won, me or you?|
;; DPF 2017-01-31 - Let's restrict the first dtr to be HEAD v_or_g instead of
;; verb_or_frag, to avoid e.g. |considerate of game, farm animals|
;; DPF 2017-03-03 - Re 2017-01-31: But this blocks our analysis of
;; |Located in Vang, Oppland, 50 beds|.  So instead let's restrict this rule to
;; spanning-only, but return to HEAD verb_or_frag.
;; DPF 2020-03-24 - Moved second dtr's SPR and NONLOC to dtr, per trunk
;; DPF 2020-05-07 - Changed second dtr's HEAD from noun to basic_noun per trunk
;;
basic_run_on_np_rule := basic_run_on_rule & non_headed_phrase &
 [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS.ALTMIN no_rel ],
			VAL.SUBJ *anti_list*,
			MC + ],
	    NONLOC #nonloc,
	    MODIFD.LPERIPH + ],
   ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb_or_frag & [ MINORS.MIN norm_rel ],
                                   VAL.SUBJ *anti_list*,
                                   MC + ],
                             CONT.HOOK [ LTOP #ltop,
					 INDEX #lindex & [ SF #sf ] ] ],
		     NONLOC #nonloc ] ],
          [ SYNSEM [ LOCAL [ CAT [ HEAD basic_noun & [ MINORS.MIN norm_rel,
						       CASE non_nom,
						       --BARE - ],
                                   VAL [ SUBJ < > ] ],
                             CONJ cnil_or_lexconj,
                             CONT.HOOK.INDEX #nind ] ] ] >,
   ORTH [ FROM #from, TO #to ],
   C-CONT [ HOOK [ LTOP #ltop,
		   INDEX.SF #sf ],
	    RELS <! [ ARG1 #lindex,
		      ARG2 #rindex ],
                    [ PRED unknown_rel,
                      LBL #ltop,
		      ARG0 #rindex,
                      ARG #nind,
		      CFROM #from, CTO #to ] !>,
            HCONS <! !>,
	    ICONS <! !> ],
   GENRE nonformal ].

;; Comma marked sentence, followed by NP
;; DPF 2016-11-02 - Generalized second dtr's LPERIPH from - to na_or_- to allow
;; appositive NPs.
;;
run_on_np_rule := basic_run_on_np_rule &
 [ SYNSEM.PUNCT.RCLSTR #rclstr,
   ARGS < [ SYNSEM [ PUNCT.RPUNCT comma_or_clause_or_pair_punct,
		     NONLOC #nonloc ] ], 
	  [ SYNSEM [ MODIFD.LPERIPH na_or_-,
		     LOCAL.CAT [ HEAD noun,
				 VAL.SPR *olist* ],
		     NONLOC #nonloc,
		     PUNCT [ LPUNCT lparen_or_dq_or_comma_or_no_punct,
			     RCLSTR #rclstr ] ] ] > ].

run_on_np_paren_rule := basic_run_on_np_rule &
 [ ARGS < [ SYNSEM [ PUNCT [ RPUNCT no_punct,
		  	     RCLSTR.RFP #rfp ], 
		     NONLOC #nonloc ] ], 
	  [ SYNSEM [ PUNCT [ LPUNCT lparen_punct,
			     RCLSTR [ RPAREN na_or_+,
				      RFP #rfp ] ],
		     LOCAL.CAT [ HEAD noun,
				 VAL.SPR *olist* ],
		     NONLOC #nonloc ] ] > ].

;; DPF 2020-02-23 - Moved second dtr's SF prop-or-comm down to dtr, since we 
;; want np-cl-numitem to include questions: |3. Can you sing?|
;;
np_s_phrase := basic_run_on_rule & non_headed_phrase &
 [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS.ALTMIN no_rel ],
			VAL.SUBJ *anti_list* ],
	    NONLOC #nonloc,
	    MODIFD.LPERIPH +,
	    PUNCT.RCLSTR #rclstr ],
   ARGS < [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ *anti_list*,
				       SPR *olist* ],
			     CONT.HOOK.INDEX #lind ],
		     NONLOC #nonloc ] ],
	  [ SYNSEM [ LOCAL [ CAT [ HEAD verb_or_frag & [ MINORS.MIN norm_rel ],
				   VAL.SUBJ *anti_list*,
                                   MC + ],
                             CONT.HOOK [ LTOP #ltop,
					 INDEX #rind & 
					       [ SF #sf ] ] ],
                     NONLOC #nonloc,
		     PUNCT [ LPUNCT lparen_or_dq_or_comma_or_no_punct,
			     RPUNCT.PSF #sf,
			     RCLSTR #rclstr ] ] ] >,
   C-CONT [ HOOK.LTOP #ltop,
	    RELS <! [ ARG1 #lind, ARG2 #rind ] !>,
            HCONS <! !>,
	    ICONS <! !> ] ].

;; DPF 01-feb-2011 - Added rule for numbered items: |2. We arrived.|
;; Also added hack ONSET unk_onset to allow this analysis for |2 cats arrived|
;; but not for |Two cats arrived|, to avoid generally spurious ambiguity
;; DPF 2012-09-26 - Added MODIFD notmod to left dtr to avoid spurious ambig
;; DPF 2012-11-06 - Changed PHON.ONSET to PHON.DIGIT. Also added ALTMIN
;; number_q_rel, to avoid admitting complex phrases headed by a number, 
;; such as |[the one Devito] we arrived|
;; DPF 2015-05-06 - Added SPR *olist*, to avoid admitting compound |Dec. 4|.
;; DPF 2015-05-09 - Right dtr was ALTMIN norm_rel, for mysterious reasons, but
;; it blocks |5. Kim is to arise.| since that |is| has ALTMIN no_rel.  Let's
;; try generalizing to norm_or_no_rel.
;; DPF 2015-09-05 - Let's exclude a number with no punctuation, to avoid
;; a lot of spurious ambiguity.  It's true that we won't get this analysis
;; for |3 Kim arose.| but let's say that's an error in punctuation, and we'll
;; treat it as robustly parsable.
;;
npnum_s_rule := np_s_phrase &
 [ SYNSEM.LOCAL.CAT.MC +,
   ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD noun & 
					[ MINORS [ MIN named_num_rel,
						   ALTMIN number_q_rel ] ],
				   VAL [ SPR *olist*,
					 SUBJ < > ] ],
			     CONJ cnil_or_lexconj ],
		     PUNCT.RPUNCT hyphen_or_comma_or_rparen_or_clause &
			          [ PSF prop ],
		     MODIFD notmod,
		     PHON.DIGIT + ] ],
	  [ SYNSEM.LOCAL.CAT.HEAD.MINORS.ALTMIN norm_or_no_rel ] > ].

;; DPF 2011-08-14 - Added rule for NP+S where initial NP is indefinite
;; `depictive', such as |A competent programmer, Devito works for Abrams.|
;;
npindef_s_rule := np_s_phrase &
 [ SYNSEM.LOCAL.CAT.MC bool,
   ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD basic_noun & 
				      [ MINORS [ MIN norm_nom_rel,
						 ALTMIN a_or_freerel_q_rel ] ],
			     CONJ cnil ],
		     PUNCT.RPUNCT comma_punct ] ],
	  [ SYNSEM.LOCAL [ CAT.HEAD verb,
			   CONT.HOOK.INDEX.SF prop-or-comm ] ] > ].

;; DPF 2011-08-14 - Added extraposed (restrictive) relatives which attach to 
;; VP, and which introduce an underspecified relation to be interpreted as 
;; anaphoric link to some NP in the clause.  Exclude proper names as subjects
;; here, to avoid |*Kim arrived, who arose|
;; DPF 2013-01-09 - Constrain vp-final-relcl_phrase to exclude s-final punct 
;; on hd-dtr. (See generator for "a cat arrived who arose.")
;; DPF 2015-09-10 - Re 2011-08-14: But this blocks |Kim arrived, which surprised
;; us.|  So until and unless we differentiate between the "event-modifying"
;; relative clauses with "which" and the "extraposed" ref-ind-modifying ones
;; (they can include "which"), let's let them in.
;; DPF 2016-09-09 - Re 2011-08-14: Replaced dtr's SUBJ.FIRST expressed_synsem 
;; with SUBJ..--MIN non_proper_rel, since we want to admit finite-VP fragments
;; such as |admires Kim, which surprises us|, where the frag-fin-VP rule 
;; constrains the SUBJ to be unexpressed.  But this prevents e.g.
;; |Kim put cats here that we admired|.  So let's remove the constraint, and
;; live with |Kim arrived, who arose| since in any case we want 
;; |Kim admired Browne today, who arose| and the rule doesn't distinguish 
;; subj from obj relatives.
;; DPF 2017-01-30 - Re 2016-09-09: But we still don't want these relcl's 
;; attaching to S, but only to VP, so construct hd-dtr's SUBJ to be *syncons*.
;; DPF 2017-09-14 - Added NORM no_rel to second dtr to enable blocking
;; of |it was Kim that we relied| with special "that" used for it-clefts as in
;; |it was on Kim that we relied|, where the "that" identifies its NORM with
;; the selected prep's MIN value.
;; DPF 2018-05-28 - For efficiency, it's tempting to add ALTMIN non_ellipt_rel 
;; to block unwanted ambig for e.g. |someone said that is|, but for now we make
;; use of this rule to handle elided relative clauses, as in |we have several
;; books that he doesn't|, where the locative PP-rel-pro `that' won't unify
;; with `books'.
;; DPF 2018-06-09 - Added quant_rel to bind the relative clause's MOD..--SIND,
;; since it doesn't get bound otherwise, for examples like |He left, which led
;; to trouble|, where the INDEX pointed to by "which" is not bound.  
;; But note that this leads to double quantification for examples such as
;; |We left, at which time he appeared|, where the variable for "which" is
;; already quantified.  FIX.
;; DPF 2019-11-15 - The restriction SUBJ..HEAD basic_noun strangely excludes
;; gerunds, as in |Buying stocks angered Kim, which pleased Browne.|  So
;; generalize to supnoun, and monitor.
;; DPF 2020-03-24 - Changed to ARGS.FIRST..SUBJ..HEAD supnoun from basic_noun
;; as per trunk.
;; DPF 2020-40-29 - Block modgap rel-cls for efficiency, via MOD..SORT.
;;
vp-final-relcl_phrase := head_initial_infl & binary_rule_right_to_left &
 [ SYNSEM phr_synsem &
	  [ LOCAL [ CAT #cat,
		    CONJ cnil ],
	    NONLOC #nonloc ],
   ARGS < [ SYNSEM [ LOCAL [ CAT #cat &
			     [ HEAD verb & [ MINORS.MIN norm_rel ],
			       VAL [ SUBJ *syncons* &
					  < [ LOCAL.CAT.HEAD supnoun ] >,
				     COMPS < > ] ],
			     CONT.HOOK #hook,
			     CONJ cnil ],
		     PUNCT.RPUNCT comma_or_rbc_or_pair_or_no_punct,
		     NONLOC #nonloc ] ],
	  [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
					  INV -,
					  MOD < synsem & 
						[ --SIND #modind & 
						      [ SORT entity-or-event ],
						  LOCAL.CONT.HOOK.XARG
							         basic_non_expl,
						  MODIFD.RPERIPH na_or_+ ] >,
					  MINORS.NORM no_rel ],
				   VAL [ SUBJ < >,
					 SPR < >,
					 COMPS < > ],
				   MC na ],
			     CONT.HOOK.LTOP #rcltop,
			     CONJ cnil ],
		     MODIFD.RPERIPH na,
		     NONLOC non-local_none_phr ] ] >,
   C-CONT [ HOOK #hook & [ LTOP #ltop ],
	    RELS <! [ PRED relative_mod_rel,
		      LBL #ltop,
		      ARG1 #modind,
		      ARG2 #rcltop,
		      CFROM #from, CTO #to ],
		    [ PRED udef_q_rel,
		      ARG0 #modind & ref-ind,
		      RSTR #rhand,
		      CFROM #from, CTO #to ],
		    [ LBL #nhand,
		      PRED generic_entity_rel,
		      ARG0 #modind,
		      CFROM #from, CTO #to ] !>,
	    HCONS <! qeq & [ HARG #rhand,
			     LARG #nhand ] !>,
	    ICONS <! !> ],
    ORTH [ FROM #from, TO #to ] ].

;; Currently only used for robust processing
no_copula_prd_vp_rule := no_copula_prd_phrase & rule.
no_copula_id_vp_rule := no_copula_id_phrase & rule.
;;no_copula_nosubj_rule := no_copula_nosubj_phrase & rule.

free_rel_rule := binary_rule_left_to_right & free_rel_phrase.
free_rel_ellip_rule := binary_rule_left_to_right & free_rel_ellip_phrase.

partitive_num_nocomp_rule := partitive_num_nocomp_phrase & rule.

partitive_num_ppof_rule := partitive_num_ppof_phrase & rule.

partitive_intadj_nocomp_rule := partitive_intadj_nocomp_phrase & rule.

partitive_intadj_ppof_rule := partitive_intadj_ppof_phrase & rule.

partitive_adj_lex_nocomp_rule := partitive_adj_lex_nocomp_phrase & rule.

partitive_adj_phr_nocomp_rule := partitive_adj_phr_nocomp_phrase & rule.

partitive_adj_ppof_rule := partitive_adj_ppof_phrase & rule.

possessed_np_rule := possessed_np_phrase & rule.

partitive_np_rule := partitive_np_phrase & rule.

vocative_np_rule := vocative_np_phrase & rule &
  [ SYNSEM [ LOCAL.CAT [ POSTHD +,
                         HEAD.MOD < [ PUNCT.RPUNCT comma_punct ] > ],
             MODIFD.RPERIPH -,
	     --BRDG na ],
    ARGS < [ SYNSEM [ LOCAL.CONT.HOOK.INDEX nonconj_ref-ind,
		      MODIFD.RPERIPH na_or_+ ] ] > ].

;; DPF 2012-03-13 - Restrict to HEAD verb_or_frag to avoid modifying
;; conj-initial sentence: |Kim hired Abrams and we quit.|
vocative_np_lmod_rule := vocative_np_phrase & rule &
  [ SYNSEM [ LOCAL.CAT [ POSTHD -,
                         HEAD.MOD < [ MODIFD.LPERIPH -,
				      LOCAL [ CAT [ HEAD verb_or_frag,
                                                    VAL.SUBJ *olist* ],
					      CONJ cnil ] ] > ],
             MODIFD.LPERIPH + ],
    ARGS < [ SYNSEM.PUNCT.RPUNCT comma_or_pair_punct ] > ].

; This normal rule ensures number agreement of the determiner and head noun.
; (but allows the supertype to be used for a robustness rule on number)
; Propagate dtr's MOD..--BARE value to SPEC, in order to constrain robust 
; "all" as in "all pizza"
;; DPF 2020-04-01 - Removed ident. of SPEC..PN and ARGS..MOD..PN, since this
;; excluded |One group of cats arrive tomorrow|
;;
num_det_rule := num_det_phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.--BARE #bare ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.--BARE #bare ] > ] >].


; DPF 14-aug-05 - Made frags be MC + (rather than na_or_+) to prevent non-MC
; modifiers (like 'not') from modifying fragments.
;; DPF 2020-05-10 - Stamping SLASH.LIST < > on mother prevents fragments from
;; being complements of verbs that need an extracted subject, as in
;; |Who would think "probably Kim"?|.  So remove.

basic_frag_rule := phrase & rule &
  [ INFLECTD +,
    SYNSEM phr_synsem &
	   [ LOCAL [ CAT [ HEAD.MINORS.MIN unknown_rel,
                           VAL [ SUBJ < anti_synsem_min >,
                                 COMPS < >,
				 SPCMPS < > ],
                           MC + ],
                     CONJ cnil_or_lexconj ],
             NONLOC non-local_none,
	     PHON.ONSET #onset ],
    ARGS.FIRST.SYNSEM.PHON.ONSET #onset ].

norm_frag_rule := basic_frag_rule &
  [ SYNSEM.LOCAL.CAT.HEAD frag,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ HOOK.INDEX #arg0,
             RELS.LIST < unknown_relation 
			 & [ ARG0 #arg0,
			     CFROM #from, CTO #to ], ... > ] ].

basic_unary_frag_rule := norm_frag_rule & basic_unary_phrase &
  [ SYNSEM [ LOCAL [ CONT.HOOK.INDEX.SF #pred,
		     CONJ #conj ],
	     LEX -,
	     PUNCT #punct ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT.VAL.COMPS < >,
                              CONJ #conj ],
                      LEX bool,
                      NONLOC.REL 0-dlist,
                      PUNCT #punct &
			    [ RPUNCT comma_or_clause_or_pair_or_no_punct &
				     [ PSF #pred ] ],
		      --BRDG na_or_- ] ] >,
    C-CONT.HOOK.INDEX.SF prop-or-ques ].

unary_frag_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    ARGS < [ SYNSEM.NONLOC.SLASH 0-dlist & [ LIST < > ] ] >,
    C-CONT [ HOOK [ LTOP #ulbl,
		    INDEX non_conj_event ],
             RELS <! [ LBL #ulbl ] !> ] ].

basic_frag_nom_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD supnoun &
				       [ CASE non_obliq ],
                                  VAL [ SUBJ *olist*,
                                        SPR #spr ] ],
                            CONT.HOOK.INDEX #ind ] ] >,
    C-CONT [ HOOK [ LTOP #ulbl,
		    INDEX non_conj_event ],
             RELS.LIST.FIRST [ LBL #ulbl,
                               ARG #ind ] ] ].

frag_nom_rule := basic_frag_nom_rule &
  [ ARGS.FIRST.SYNSEM.NONLOC.SLASH 0-dlist & [ LIST < > ] ].

;; DPF 2016-11-10 - Removed constraint on dtr for SUBJ *synlist* since this
;; now blocks NP coord, which has SUBJ *anti_list*.
;; DPF 2016-11-20 - But we want to block nominalized WH-clauses, to avoid
;; ambiguity for matrix WH-questions such as |who hired browne|, so restrict
;; SUBJ to empty list.
;; DPF 2016-12-10 - Re 2016-11-20: But this prevents free relative NP fragments,
;; so drop SUBJ < >, and instead constrain dtr's SORT to norm-entity-or-event
;; which excludes nominalized questions but includes free rels.
;; DPF 2018-01-06 - Re 2016-12-10: We also want to admit questions as fragments
;; when they are non-finite, as in |how to use it|, but we apparently need to 
;; add a separate rule to do this.  Sigh.
;; DPF 2020-06-02 - Re 2016-11-20: But we want |Difficult problems and how to
;; solve them|, where the SORT of the conjoined NP is q-event.
;; 
frag_np_rule := frag_nom_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR *olist*,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD 
				  [ CASE acc,
				    MINORS.NORM quantity_or_norm_or_no_rel ] ],
			    CONT.HOOK [ LTOP #ltop,
					INDEX non_expl ],
			    CONJ cnil ] ] >,
    C-CONT [ RELS <! [ LBL #ltop ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

frag_np_conj_rule := frag_nom_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR *olist*,
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD 
			      [ CASE acc,
				MINORS.NORM quantity_or_norm_or_no_rel ],
			    CONT.HOOK.LTOP #ltop,
			    CONJ lex-conj & [ CHEAD cnil ] ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS <! [ LBL #ltop,
		       ARG #index ],
		     [ PRED udef_q_rel,
		       ARG0 #index & ref-ind,
		       RSTR #rhand,
		       CFROM #from, CTO #to ],
		     [ LBL #nhand,
		       PRED generic_entity_rel,
		       ARG0 #index,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !>,
	     ICONS <! !> ] ].

;; DPF 2016-11-23 - Removed dtr's NORM no_rel constraint, since we mark all
;; non-sortally restricted nouns like "idea" or "alternative" as NORM norm_rel,
;; and we still want nbar fragments for e.g. |strong alternative|.
;; DPF 2018-01-07 - Removed DIV - from dtr, even though this leads to ambiguity
;; for most plural nouns, so we can get ones missing an oblig specifier, such as
;; |1980's: a long decade|
;; 
frag_nbar_rule := frag_nom_rule &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < unexpressed &
                                 [ LOCAL.CAT.HEAD det & 
                                                  [ MINORS.ALTMIN no_rel ],
                                   OPT - ] >,
                   AGR.DIV - ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD.MINORS [ MIN nbar_or_dofm_rel ],
				  VAL.SPR < synsem &
				            [ LOCAL.CAT.HEAD.MINORS.MIN #min &
			                                    implicit_q_rel,
					      --MIN #min ] > ],
			    CONT.HOOK [ LTOP #nhand,
                                        INDEX #index & [ DIV - ] ] ] ] >,
    ORTH [ FROM #from, TO #to ],
    C-CONT [ RELS <! relation, [ PRED udef_q_rel,
                                 ARG0 #index & ref-ind,
                                 RSTR #rhand,
				 CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhand ] !>,
	     ICONS <! !> ] ].

; DPF 28-aug-07 - Added ALTMIN no_rel to prevent these from appearing as
; right-hand dtr in cl-cl_runon_c rule, e.g. "Kim arrived yesterday, in Paris."
; DPF 08-apr-08 - Removed ARGS..SPR *synlist* so we can admit NP-adverbials
; like "here in Paris".
;; DPF 2012-11-06 - Added ARGS..SPR *olist* to avoid admitting PPs whose
;; head has an obligatory specifier, such as the prenominal `a' of
;; |$10-a-share cat|
;; DPF 02-mar-15 - Re 28-aug-07: But this no_rel now conflicts with allowing
;; these PP fragments as complements of "say" as in |Kim said, "in the park".|
;; Happily, the example |Kim arrived yesterday, in Paris| is now blocked in
;; cl-cl_runon_c for other reasons. But |When did Kim arise?| now slips
;; through.
;; DPF 2020-08-26 - We were identifying the XARG of the PP with the event index
;; of the mother (the implicit verbal predication), but this excluded PP fragmts
;; for nominal-only modifying PPs and for coordinate fragments such as
;; "[beside Kim] and [admiring the view]".  So leave XARG of dtr unbound.
;; DPF 2020-08-26 - Not clear why [ARGS..MOD..OPT +], but this blocks e.g.
;; "near him but not always", so remove, and see where we get unwanted frags,
;; and FIX if needed.
;; 
;;
frag_pp_ind_rule := unary_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD prep_or_modnp & 
                                     [ MOD < [ LOCAL intersective_mod ] >,
                                       MINORS.MIN independent_rel ],
				  VAL.SPR *olist* ],
			    CONT.HOOK.LTOP #klbl ] ] >,
    C-CONT [ RELS.LIST.FIRST.LBL #klbl,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 05-Dec-03 - Try excluding expletive-it subject adjectives, to prevent eg
; spurious analysis for 'okay I will stay'
; DPF 10-apr-05 - But this also blocks "Impossible to know" and
; "how convenient that Kim left!" so live with the above ambiguity
; DPF 21-dec-05 - Removed [PRD +] since it blocked coord of adj and passive VP
; DPF 28-jul-06 - Corrected semantics to make ARG1 of adj_rel be same as
; the ARG of unknown_rel.
;; DPF 2012-04-07 - Re 05-Dec-03: But this blocks a fragment analysis for e.g.
;; |Strange that Kim wasn't here|, so remove this constraint.

; CSY 19-11-2020 added in MC - to prevent a sentence from becoming a frag
; 5-1-2020 change to MC na to prevent an adj headed NMC from becoming a frag
frag_adj_rule := unary_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD adj & 
				      [ MINORS.MIN norm_rel],
				  VAL.COMPS < >,
				  MC na ],
			    CONT.HOOK [ LTOP #lbl,
					XARG #ind ] ] ] >,
    C-CONT [ HOOK.LTOP #lbl,
             RELS.LIST.FIRST [ LBL #lbl,
                               ARG #ind ],
             HCONS <! !>,
	     ICONS <! !> ] ].

frag_adv_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD adv_or_no_head &
                                   [ MOD < synsem &
                                           [ LOCAL scopal_mod &
                                              [ CONT.HOOK.LTOP #klbl ] ] >,
				     MINORS.MIN norm_or_no_rel ],
				  POSTHD - ],
			    CONT.HOOK.LTOP #ltop ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX non_conj_event ],
             RELS <! [ LBL #klbl ] !> ,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2016-11-01 - Removed MOD..OPT + since this was preventing lexical
;; adverbs, such as "happily"
frag_int_adv_rule := unary_frag_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD basic_adv &
                                [ MOD < synsem &
                                        [ LOCAL intersective_mod &
                                          [ CAT.HEAD adverbee,
                                            CONT.HOOK.LTOP #klbl ] ] >,
				  MINORS [ MIN norm_rel,
					   ALTMIN norm_rel ] ] ] ] >,
    C-CONT [ RELS.LIST.FIRST.LBL #klbl,
             HCONS <! !>,
	     ICONS <! !> ] ].

; For conditionals, among others, but blocking subconj_prdp guys.
frag_sent_adv_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD prep &
                                     [ MOD < synsem &
                                             [ LOCAL scopal_mod &
                                                [ CONT.HOOK.LTOP #klbl ] ] >,
                                       MINORS.NORM norm_rel ] ],
                              CONT.HOOK.LTOP #ltop ],
                      NONLOC.SLASH 0-dlist & [ LIST < > ] ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX non_conj_event ],
             RELS <! relation & [ LBL #klbl ]  !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; 'And Kim arrived.'
;; Restrict dtr to CONJ lex-conj to avoid mid-coord S as fragment
;; DPF 2011-06-23 - Changed dtr's SUBJ from < anti_synsem_min > to *anti_list*
;; in order to admit e.g. |and should he arise?|
;;
frag_sent_conj_rule := basic_frag_rule & basic_unary_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD frag & 
                              [ MOD < >,
                                MINORS.ALTMIN no_rel ],
                         VAL.SPR < > ],
		     CONJ cnil ],
	     LEX #lex,
	     PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
					 [ MINORS.MIN norm_rel ],
                                    VAL [ SUBJ *anti_list*,
                                          SPR *anti_list*,
                                          COMPS < > ],
				    MC + ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #arg0 ],
                              CONJ lex-conj & [ CHEAD cnil ] ],
                      LEX #lex & bool,
                      NONLOC.SLASH 0-dlist & [ LIST < > ],
		      PUNCT #punct ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #arg0 ],
             RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 23-aug-04 - Added DTRA..NORM norm_rel to enable blocking of phrases
; that cannot be fragments, such as the derived subconj_prdp 'hiking' as in
; 'hiking in Aurland'
;; DPF 2016-11-23 - Re 23-aug-04: Generalized NORM value from norm_rel to
;; quantity_or_norm_rel, so we can admit e.g. |tour T16 ten miles|
;; DPF 2018-03-27 - Removed C-CONT..INDEX non_conj_event, since we now propagate
;; INDEX from subordinating head's complement to the mother, and yet we want
;; |cats [: they sleep and they run]|
;; So let's remind ourselves of what this constraint was doing and FIX?
;;
binary_frag_rule := norm_frag_rule & binary_punct_phrase &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < >,
                   CONJ cnil ],
    DTRA [ INFLECTD +,
           SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < synsem &
                                               [ --MIN norm_rel,
                                                 LOCAL.CONT.HOOK 
                                                       [ LTOP #ulbl,
                                                         INDEX #uind ] ] >,
                                         MINORS [ MIN independent_rel,
                                                  NORM quantity_or_norm_rel ] ],
                                  VAL [ SUBJ *olist*,
                                        COMPS < > ] ],
                            CONT [ HOOK [ INDEX.SF #pred ] ],
                            CONJ cnil_or_lexconj ],
                    NONLOC [ SLASH 0-dlist & [ LIST < > ],
                             REL 0-dlist,
                             QUE 0-dlist ] ] ],
    DTRB [ INFLECTD +,
           SYNSEM [ LOCAL [ CAT [ HEAD.MINORS.MIN independent_rel,
                                  VAL.COMPS < > ],
                            CONJ cnil_or_lexconj ],
                    NONLOC [ SLASH 0-dlist & [ LIST < > ],
                             REL 0-dlist ] ],
           KEY-ARG + ],
    ARGS < sign, [ SYNSEM.PUNCT.RPUNCT.PSF #pred ] >,
    C-CONT [ RELS.LIST < [ LBL #ulbl,
                           ARG0 #uind ], ... > ] ].

binary_left_frag_rule := binary_frag_rule &
  [ SYNSEM [ PUNCT.PNCTPR #ppair ],
    DTRA #dtr1 &
         [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adverbee ] > ],
                    PUNCT.RPUNCT hyphen_or_comma_or_clause_or_no_punct ] ],
    DTRB #dtr2 & [ SYNSEM [ LOCAL.CAT [ VAL.SPR *olist* ],
                            PUNCT.PNCTPR #ppair ] ],
    ARGS < #dtr1, #dtr2 >,
    C-CONT [ HOOK [ INDEX.SF prop-or-ques ],
             RELS <! relation !> ] ].


frag_l_mod_np_rule := binary_left_frag_rule & binary_rule_left_to_right &
  [ ARGS < sign & 
           [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #lbl ] >,
			    CONT.HOOK.LTOP #ltop ] ],
	   [ SYNSEM.LOCAL [ CAT.HEAD basic_noun & [ CASE non_obliq ],
                            CONT.HOOK [ LTOP #lbl,
					INDEX #ind ],
                            CONJ cnil ] ] >,
    C-CONT [ HOOK.LTOP #ltop,
	     RELS.LIST.FIRST [ LBL #lbl,
                               ARG #ind ],
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 25-apr-04 - Added POSTHD - to modifier, like for frag_l_mod_pp_rule.
;; DPF 22-apr-09 - Added PRD + to block vocatives

frag_l_mod_s_np_rule := frag_l_mod_np_rule &
  [ ARGS < sign & 
           [ SYNSEM.LOCAL.CAT [ HEAD [ MOD < [ LOCAL scopal_mod ] >,
				       PRD + ],
				POSTHD - ] ],
           sign > ].

;; DPF 2011-08-20 - Add phr_synsem to constrain left daughter to be phrasal, to avoid 
;; e.g. |away the trash|
;; DPF 2017-10-27 - Re 2011-08-20: But this blocks |the evildoer (sometimes the cat)|,
;; so undo.
frag_l_mod_i_np_rule := frag_l_mod_np_rule &
  [ ARGS < sign & 
           [ SYNSEM [ LOCAL.CAT.HEAD.MOD < expressed_synsem &
					   [ LOCAL intersective_mod &
						   [ CONT.HOOK.LTOP #ltop ],
					   --SIND event ] > ] ],
           sign >,
    C-CONT.HOOK.LTOP #ltop ].

; DPF 22-jan-08 - Try removing the MOD..scopal_mod constraint, to allow
; e.g. "eventually in Paris" as a fragment.
;; DPF 09-dec-09 - Added PRD + to first dtr, to block vocatives.
;; DPF 2015-04-18 - Re 22-jan-08: But we do have to draw the scopal/isect
;; distinction for the left dtr, since for the intersective ones we need to
;; identify LTOPs of the two dtrs, while for the scopal ones we don't.  So
;; split this rule into two, accordingly.
;;
frag_l_mod_pp_rule := binary_left_frag_rule & binary_rule_left_to_right &
  [ ARGS < sign & [ SYNSEM.LOCAL.CAT [ HEAD.PRD +,
				       POSTHD - ] ],
           [ SYNSEM.LOCAL [ CAT.HEAD prep & 
                                [ MOD < synsem &
                                        [ LOCAL intersective_mod,
                                          --SIND #kev ] >,
                                  MINORS.MIN independent_rel ],
                            CONT.HOOK.LTOP #klbl ] ] >,
    C-CONT [ RELS.LIST.FIRST [ LBL #klbl,
                               ARG0 #kev ],
             HCONS <! !>,
	     ICONS <! !> ] ].

frag_l_mod_scop_pp_rule := frag_l_mod_pp_rule &
  [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL scopal_mod ].

frag_l_mod_isect_pp_rule := frag_l_mod_pp_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD.MOD.FIRST.LOCAL intersective_mod,
			    CONT.HOOK.LTOP #ltop ] ],
           [ SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop ] > ].

;; DPF 28-jun-09 - Added PRD + to block vocatives
frag_l_mod_adv_rule := binary_left_frag_rule & binary_rule_left_to_right &
  [ ARGS < sign & [ SYNSEM.LOCAL [ CAT [ HEAD p_or_adv_or_dadv &
					      [ MOD < [ LOCAL scopal_mod ] > ],
					 POSTHD - ],
				   CONT.HOOK.LTOP #ltop ] ],
	   [ SYNSEM.LOCAL [ CAT [ HEAD [ MOD < synsem &
					     [ LOCAL scopal_mod &
						 [ CONT.HOOK.LTOP #ltop ] ] >,
					 MINORS.NORM norm_rel,
					 PRD + ],
				  POSTHD + ],
			    CONT.HOOK.LTOP #ltop2 ] ] >,
    C-CONT [ HOOK.LTOP #ltop2,
	     HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 05-dec-03 - Try restricting left dtr to non-WH, also to avoid spurious 
; parses for e.g 'what is a good time to meet'
binary_right_frag_rule := binary_frag_rule &
  [ SYNSEM.PUNCT.PNCTPR #ppair,
    DTRA #dtr1 & [ SYNSEM [ PUNCT.PNCTPR #ppair,
			    LOCAL.CONT.HOOK [ LTOP #ltop,
					      INDEX #index ] ] ],
    DTRB #dtr2 &
         [ SYNSEM [ NONLOC.QUE 0-dlist,
                    PUNCT.RPUNCT rparen_or_comma_or_clause_or_no_punct ] ],
    C-CONT.HOOK [ LTOP #ltop,
		  INDEX #index ],
    ARGS < #dtr2, #dtr1 > ].

;; DPF 2017-12-08 - Constrain right dtr to be CONJ cnil, to avoid spurious
;; analysis for e.g. |dogs, cats, etc| with |etc| as the `modifier'.
;;
basic_frag_r_mod_np_rule := binary_right_frag_rule & binary_rule_right_to_left &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                       [ CASE acc,
                                         MINORS.ALTMIN non_freerel_q_rel,
                                         --BARE - ],
                                    VAL.SPR *olist* ],
                              CONT [ HOOK [ LTOP #lbl,
					    INDEX #ind ] ] ],
                      PUNCT.RPUNCT #rpunct ] ],
           sign & [ SYNSEM.LOCAL 
                            [ CAT.HEAD.MOD < [ PUNCT.RPUNCT #rpunct ] >,
			      CONJ cnil ] ] >,
    C-CONT [ RELS <! [ LBL #lbl,
		       ARG #ind ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

frag_r_mod_np_rule := basic_frag_r_mod_np_rule &
  [ ARGS < sign,
           sign & 
           [ SYNSEM.LOCAL.CAT [ HEAD p_or_adv_or_dadv &
                                     [ MOD < [ LOCAL scopal_mod ] >,
				       PRD - ],
				POSTHD + ] ] > ].

; For intersective adverbs or non-nom-modifying PPs, as in
; "many problems afterwards"
; DPF 9-aug-07 - But allowing PPs means we get annoying fragment parse for
; "roads to Rome" with the non-noun-modifying "to".  Let's try restricting
; this to adverbs only.
; DPF 3-nov-07 - But this also blocks "2. To Paris".  So put prep back in.
;
frag_r_mod_np_i_rule := basic_frag_r_mod_np_rule &
  [ ARGS < sign,
           sign & 
	   [ SYNSEM.LOCAL [ CAT [ HEAD p_or_adv_or_dadv &
				     [ MOD < [ LOCAL intersective_mod &
                                                     [ CAT.HEAD v_or_a,
						       CONT.HOOK.LTOP #ltop]]>],
				  VAL.SPR *olist*,
				  POSTHD + ],
			    CONT.HOOK.LTOP #ltop ] ] >,
    C-CONT.HOOK.LTOP #ltop ].

; For "pizza ready"
frag_r_mod_np_adj_rule := basic_frag_r_mod_np_rule &
  [ ARGS < sign,
           sign & [ SYNSEM [ LOCAL [ CAT.HEAD adj_or_intadj & 
				      [ PRD +,
					MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ]> ],
				     CONT.HOOK.LTOP #ltop ],
                             LEX + ] ] >,
    C-CONT.HOOK.LTOP #ltop ].

frag_r_mod_nbar_rule := binary_right_frag_rule & binary_rule_right_to_left &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                       [ CASE acc,
                                         MINORS.ALTMIN non_freerel_q_rel ],
                                    VAL.SPR < [ LOCAL.CAT.HEAD det,
						OPT - ] > ],
                              AGR [ PNG.PN 3s,
                                    DIV - ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #ind ] ],
                      PUNCT.RPUNCT #rpunct ],
	     ORTH [ FROM #from, TO #to ] ],
           sign & [ SYNSEM.LOCAL 
                            [ CAT [ HEAD p_or_adv_or_dadv &
					 [ MOD < [ LOCAL scopal_mod,
						   PUNCT.RPUNCT #rpunct ] > ],
				    POSTHD + ] ] ] >,
    C-CONT [ RELS <! [ ARG #ind ], 
                     [ PRED udef_q_rel,
                       ARG0 #ind & ref-ind,
                       RSTR #rstr,
		       CFROM #from, CTO #to ] !>,
	     HCONS <! qeq & [ HARG #rstr,
                              LARG #ltop ] !>,
	     ICONS <! !> ] ].

; 'into the room before Kim arrives'
frag_r_mod_scop_pp_rule := binary_right_frag_rule & binary_rule_right_to_left &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.HEAD p_or_adv &
                                     [ MOD < synsem &
                                             [ LOCAL intersective_mod,
                                               --SIND #kev,
					       OPT + ] >,
                                       MINORS.MIN independent_rel ],
                            CONT.HOOK.LTOP #klbl ] ],
           sign & [ SYNSEM.LOCAL.CAT [ HEAD p_or_adv_or_dadv &
                                          [ MINORS.MIN subord_rel,
                                            MOD < [ LOCAL scopal_mod &
                                                     [ CAT.HEAD adverbee,
                                                       CONT.HOOK.LTOP #klbl ],
                                                    --SIND #kev ] > ],
				       POSTHD + ] ] >,
    C-CONT [ HOOK.INDEX.SF prop-or-ques,
             RELS <! [ ARG0 #kev ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

frag_r_mod_ap_rule := binary_right_frag_rule & binary_rule_right_to_left &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD adj & [ PRD + ],
                              CONT [ HOOK [ LTOP #klbl,
                                            INDEX #ind ] ] ],
                      NONLOC.QUE 0-dlist ] ],
           sign & [ SYNSEM.LOCAL [ CAT [ HEAD p_or_adv_or_dadv &
                                          [ MOD < [ LOCAL scopal_mod &
                                                     [ CAT.HEAD adverbee,
                                                       CONT.HOOK.LTOP #klbl ],
                                                    --SIND #ind ] > ],
					 POSTHD + ],
				   AGR.PNG.PN 3 ] ] >,
    C-CONT [ HOOK.INDEX.SF prop-or-ques,
             RELS <! [ ARG #ind ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; DPF 21-aug-04 - Added nonempty SYNSEM..ALTMIN to prevent these from 
; appearing in run_on_s rule.
;; DPF 2016-11-02 - Re 21-aug-04: But this prevents VP fragments in fronted
;; quoted construction, as in |"Done yet?" asked Kim|.  And anyway, the run-on
;; rule now excludes fragments.
;;
basic_frag_verbal_rule := basic_frag_rule & unary_phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD frag,
			   VAL.SPR < > ],
		     CONT.HOOK #hook ],
             PUNCT #punct & [ RPUNCT.PSF #sf ] ],
    ARGS < [ INFLECTD +,
             SYNSEM [ LOCAL [ CAT [ HEAD verbal & 
                                         [ INV - ],
                                    VAL.COMPS < >,
                                    MC na_or_- ],
			      CONT.HOOK #hook,
                              CONJ cnil_or_lexconj ],
                      NONLOC [ REL 0-dlist,
			       QUE 0-dlist ],
		      PUNCT #punct ] ] >,
    C-CONT [ HOOK.INDEX.SF prop-or-ques & #sf,
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

frag_verbal_rule := basic_frag_verbal_rule &
  [ ARGS < [ SYNSEM.NONLOC.SLASH 0-dlist & [ LIST < > ] ] > ].

;; DPF 2012-06-23 - Can't see why the zero-pronoun semantics was introduced,
;; since the ref-ind has no link to the rest of the VP.  So delete it.
;; DPF 2019-10-28 - Push down constraint SUBJ..--SIND non_expl-ind to non-fin
;; subtype, since we also want |Turns out that Kim won.|
;; DPF 2020-08-26 - Note that ARGS..VFORM non_bse prevents (non-imperative)
;; fragments with copula, as in dictionary definitions such as 
;; "be steadfast or upright".  So push down to subtypes, and add special case
;; for base-copula fragments
;;
frag_vp_rule := frag_verbal_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD [ MINORS.MIN norm_rel,
                                       TAM.MOOD ind_or_modal_subj,
                                       MOD *cons* ],
                                VAL.SUBJ < synsem &
                                           [ LOCAL.CAT.HEAD noun,
					     NONLOC.SLASH 0-dlist ] > ] ] >,
    C-CONT [ HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2016-08-07 - Generalized dtr's ALTMIN from role_rel to 
;; basic_event_dim_rel in order to also admit predicative copula VPs such as
;; |is fine with me|
;; DPF 2018-04-30 - Constrain to notmod_or_rmod, so we don't get frag analysis
;; of ordinary |cats beside Kim have slept| as absolutive premod of fin-VP.
;;
frag_vp_fin_rule := frag_vp_rule &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD [ VFORM fin,
					   TAM.TENSE real_tense,
					   MINORS.ALTMIN basic_event_dim_rel ],
				    VAL.SUBJ.FIRST unexpressed_min ],
			      CONT.HOOK #hook ],
		      MODIFD notmod_or_rmod ] ] >,
    C-CONT [ HOOK #hook & [ XARG.SORT entity ],
             RELS <! !> ] ].
 
frag_vp_nonfin_rule := frag_vp_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD.VFORM non_fin_non_bse,
				  VAL.SUBJ.FIRST.--SIND non_expl-ind ],
                            CONT.HOOK #hook  ] ] >,
    C-CONT [ HOOK #hook,
             RELS <! !> ] ].

;; For special case of non-imperative "be steadfast" as in dictionary definition
frag_vp_bse_cop_rule := frag_vp_rule &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD [ VFORM bse_only,
                                         AUX + ],
				  VAL.SUBJ.FIRST.--SIND non_expl-ind ],
                            CONT.HOOK #hook  ] ] >,
    C-CONT [ HOOK #hook,
             RELS <! !> ] ].

;; DPF 2017-09-16 - Let's try blocking these as complements to verbs that
;; allow fragments in place of sentence complements, to avoid spurious ambig
;; for |we know that he arrived|: make the mother also CASE nom.
;;
frag_sbar_rule := frag_verbal_rule &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD comp &
                                       [ MINORS.MIN norm_rel,
                                         VFORM fin,
                                         CASE nom ],
                                  VAL.SUBJ *anti_list* ],
                            CONJ cnil ] ] >,
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2016-07-03 - Added dtr's MOD..MIN reg_nom_rel to exclude modable_rel
;; in order to avoid fragment analysis for mod-gap relative clauses such as
;; |Kim arrived happy.|
;;
frag_relcl_rule := frag_verbal_rule &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
                                       [ MINORS [ MIN norm_rel,
                                                  NORM norm_rel ],
                                         VFORM fin,
                                         MOD < synsem &
					       [ --MIN reg_nom_rel,
						 MODIFD.RPERIPH na_or_+ ] > ],
                                    MC na,
                                    VAL.SUBJ *anti_list* ],
                              CONJ cnil ],
                      PUNCT.RPUNCT.PSF prop ] ] >,
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

; "To devour or consume" - used in dictionary defs
frag_vp_slash_rule := basic_frag_verbal_rule &
  [ ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS.MIN norm_rel,
                                         VFORM non_fin ],
                                  VAL.SUBJ < nongappro > ],
                      NONLOC.SLASH 1-dlist & 
                                <! [ CAT.HEAD noun & 
                                         [ MINORS.MIN reg_nom_rel,
                                           MOD < > ] ] !> ] ] > ].

; |The signal means and includes ___|
;; DPF 2020-08-26 - Exclude subj gap, to avoid spurious analysis for
;; "arise, arrive"
frag_s_slash_rule := basic_frag_verbal_rule &
  [ ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD [ MINORS.MIN norm_rel,
                                         VFORM fin ],
                                  VAL.SUBJ *anti_list* ],
                      NONLOC.SLASH 1-dlist & 
                                <! [ CAT.HEAD noun & 
                                         [ MINORS.MIN reg_nom_rel,
					   CASE non_nom,
                                           MOD < > ] ] !> ] ] > ].

; Also used in dictionary definitions
frag_pp_slash_rule := basic_unary_frag_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD prep & 
                                     [ MOD < synsem &
                                             [ LOCAL intersective_mod ] >,
                                       MINORS.MIN independent_rel ],
                                    VAL.SPR *synlist* ],
                              CONT.HOOK [ LTOP #klbl,
                                          INDEX #arg ] ],
                      NONLOC.SLASH 1-dlist ] ] >,
    C-CONT [ RELS <! [ LBL #klbl,
                       ARG0 #arg ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2020-08-26 - Dictionary definitions, as in "the inside of"
frag_np_slash_rule := basic_frag_nom_rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR *olist*,
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD 
				   [ CASE acc,
				     MINORS.NORM quantity_or_norm_or_no_rel ] ],
			      CONT.HOOK [ LTOP #ltop,
					  INDEX non_expl ],
			      CONJ cnil ],
		      NONLOC.SLASH 1-dlist ] ] >,
    C-CONT [ RELS <! [ LBL #ltop ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; |how to use it|
;;
frag_s_wh_nonfin_rule := basic_frag_verbal_rule &
  [ ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD [ MINORS.MIN norm_rel,
					   VFORM inf ],
				    VAL.SUBJ *anti_list* ],
			      CONT.HOOK.INDEX.SF ques ],
                      NONLOC.SLASH 0-dlist ] ] > ].

frag_dadv_rule := norm_frag_rule & basic_unary_phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD frag,
			 VAL.SPR < >,
			 POSTHD - ],
	     LEX -,
	     MODIFD #modif,
	     PUNCT #punct ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD root-marker &
					 [ MOD < [ LOCAL.CAT.MC + ] > ],
                                    POSTHD - ],
                              CONT.HOOK.LTOP #ltop,
                              CONJ cnil_or_lexconj ],
		      MODIFD #modif,
                      LEX bool,
		      PUNCT #punct ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind & non_conj_event &
			 [ SF prop-or-ques ] ],
             RELS <! relation & [ ARG0 #ind ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2020-05-20 - Propagate ORTH.CLASS to mother, at least for robust rules
;; for mis-capitalization: |tea Festival|
punct_marker_phrase := generic_binary_phrase &
		       word_or_punct_phrase &
  [ SYNSEM [ LOCAL [ CAT #cat,
                     CONT #cont,
                     AGR #agr,
                     CONJ #conj ],
	     NONLOC.REL #rel,
	     PHON #phon,
	     LEX #lex,
             MODIFD #modif,
	     PUNCT norm_punctuation ],
    DERIVED #deriv,
    ORTH.CLASS #class,
    PT-DTR [ SYNSEM.LOCAL [ CAT [ HEAD punct_hd,
				  VAL.COMPS < #synsem > ],
			    CONJ cnil ] ],
    NONPT-DTR [ INFLECTD #infl,
	        DERIVED #deriv & bool,
		ORTH.CLASS #class,
	        SYNSEM #synsem & [ LOCAL [ CAT #cat,
					   CONT #cont,
					   AGR #agr,
					   CONJ #conj ],
				   NONLOC.REL #rel,
				   PHON #phon,
				   LEX #lex,
				   MODIFD #modif ] ],
    INFLECTD #infl ].

; Making mother be SYNSEM lex_punct_synsem prevents spurious application of
; derivational rules that are constrained by synsem type.  Assumes that
; right punctuation will attempt to attach to each derivational stage of
; a lexical entry - maybe not pretty, but can't be helped since PUNCT has
; to be inside SYNSEM, so can't identify synsems of hd-dtr and mother.
; DPF 19-sept-04 - Removed parent word_or_lexrule since this causes infinite
; recursion in generation with e.g. period, and it's not clear why we wanted
; recursion here anyway.
;; DPF 2011-06-12 - Removed HD-DTR..LEX +, in order to get sentence-dash to 
;; attach to lexical PPs which are LEX -.
;; DPF 2019-11-24 - Changed HD-DTR word_or_punct_or_bracketed_phrase to
;; just word_or_punct_phrase, to block e.g. |[Chicago-based].| where bracketed
;; phrase underwent punct rule.
;; DPF 2020-03-09 - Let's try forcing suffix punctuation before prefix punct,
;; with the exception of lital_punct, where we attach left before right.
;;
punct_marker_hinit_rule := punct_marker_phrase & binary_rule_right_to_left &
  [ SYNSEM basic_lex_synsem &
           [ PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct,
                     PNCTPR #ppair,
		     PAIRED #paired,
		     LCLSTR #lclstr,
		     RCLSTR #rclstr ],
             NONLOC [ SLASH #slash,
                      QUE #que ] ],
    NONPT-DTR #head &
	   [ SYNSEM #synsem &
		    [ PUNCT [ LPUNCT #lpunct & lital_or_dropped_or_no_punct,
			      LCLSTR #lclstr ],
                      NONLOC.SLASH #slash ] ],
    PT-DTR #non-head &
	 [ SYNSEM [ PUNCT [ LPUNCT no_punct,
                            RPUNCT #rpunct,
                            PNCTPR #ppair,
			    PAIRED #paired,
			    RCLSTR #rclstr ],
		    LOCAL.CAT [ VAL.COMPS < #synsem >,
				POSTHD + ],
                    NONLOC.QUE #que ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #head, #non-head > ].

punct_marker_hinit_nobrk_rule := punct_marker_hinit_rule &
  [ ARGS.FIRST.ORTH.LB bracket_null ].

punct_marker_hinit_brk_rule := punct_marker_hinit_rule &
  [ ORTH [ LD #ld,
	   RD [ LIST #rrest, LAST #rlast ] ],
    ARGS < [ ORTH [ LD #ld,
		    RD bracket_nonnull ] ],
	   [ ORTH.RD bracket_nonnull &
		       [ LIST.REST #rrest,
                         LAST #rlast ] ] > ].

punct_marker_hfinal_rule := punct_marker_phrase & 
                            binary_rule_left_to_right &
  [ SYNSEM basic_lex_synsem &
           [ PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct,
                     PNCTPR #ppair,
		     LCLSTR #lclstr,
		     RCLSTR #rclstr ],
             NONLOC [ SLASH #slash,
                      QUE #que ] ],
    NONPT-DTR #head &
              [ SYNSEM [ PUNCT [ RPUNCT #rpunct,
				 RCLSTR #rclstr ],
			 NONLOC.SLASH #slash ] ],
    PT-DTR #nonhead &
	   [ SYNSEM [ PUNCT [ LPUNCT #lpunct,
			      RPUNCT no_punct,
			      LCLSTR #lclstr,
			      PNCTPR #ppair ],
		      LOCAL.CAT.POSTHD -,
		      NONLOC.QUE #que ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ],
    ARGS < #nonhead, #head > ].

punct_marker_hfinal_nobrk_rule := punct_marker_hfinal_rule &
  [ ARGS.FIRST.ORTH.LB bracket_null ].

punct_marker_hfinal_brk_rule := punct_marker_hfinal_rule &
  [ ORTH [ LD [ LIST #lrest, LAST #llast ],
	   RD #rd ],
    ARGS < [ ORTH.LD bracket_nonnull &
		       [ LIST.REST #lrest,
                         LAST #llast ] ],
	   [ ORTH [ LD bracket_nonnull,
		    RD #rd ] ] > ].


; DPF 11-oct-05 - This rule should ideally check for the presence of a
; matching right paren on the nh-dtr, but this can't simply be the value
; of RPUNCT, since we might have e.g. "The boss (Abrams), who arrived..."
; or "Kim hired the guy (Abrams); we approved."  More generally, we need
; to keep track of a paren being in the punctuation cluster, and presumably
; also for other right paired elements like quotes.  For now, we'll
; over-generate.
; DPF 13-sept-07 - Now trying out use of RCLSTR (right punct cluster).
; DPF 17-sept-07 - Constrained HD-DTR..SPR to determiner, to avoid spurious
; ambiguity for bare NPs.
; DPF 30-apr-09 - So let's try preserving the punctuation on the right dtr,
; so we can e.g. accept |Kim (Browne), the manager| using the hdn-np_app-idf_c rule
; which demands a comma on the hd-dtr.
; DPF 13-may-09 - Re 30-apr-09: Alas, this means the PSF (punctuation-derived
; sentence force) is carried up as 'comm' to the larger sentence - not what
; we want.  So instead for now leave RPUNCT unconstrained on mother, which
; means we also don't get the specialization of prop-or-ques in e.g.
; 'We hired Kim (Browne).'  FIX.
; DPF 14-may-09 - Allow both uninflected and inflected heads, so we can get
; e.g. |A (B) C| as compound noun.
; DPF 14-may-09 - Removed RPERIPH + on mother, since we want to allow e.g.
; 'the [cat (see illustration) in the room] slept'
;; DPF 2012-03-14 - Removed NH-DTR..--TPC -, since we want e.g.
;; |we admire him (in Paris, he is famous)|
;; DPF 2013-02-16 - Re 17-sept-07: Can't require HEAD det since we also want to
;; attach these to e.g. pronouns.
;; DPF 2016-10-08 - In order to allow post-modif as in the NP 
;; |artificial neural networks (ANNs) called marvels|
;; move identif of MODIFD for mother and hd-dtr down to subtypes, so we can
;; drop the identity for the nbar subtype.  Note that if and when we allow
;; pre-nominal mod before post-nominal generally, we can restore this identity
;; (FIX later).
;; DPF 2016-10-14 - We were constraining hd-dtr to have SPR.FIRST synsem ... but
;; this prevents |text-to-speech (TTS) engine|, so let's remove the constraint,
;; and watch for overgeneration (FIX?). 

paren_dash_float_rule := basic_head_initial & head_compositional & 
			 binary_rule_right_to_left &
  [ INFLECTD #infl,
    SYNSEM synsem &
	   [ LOCAL.CAT.VAL #valence,
	     NONLOC #nonloc,
	     LEX #lex,
             PUNCT [ LPUNCT #lpunct,
                     PAIRED #paired ] ],
    HD-DTR [ INFLECTD #infl,
             SYNSEM canonical_synsem &
	     [ LOCAL [ CAT [ HEAD n_or_a_or_det & [ --BARE - ],
                             VAL #valence &
                                  [ SPR.FIRST
					  [ LOCAL.CAT.HEAD det_or_adv ],
                                    COMPS < > ] ],
                       CONT.HOOK [ LTOP #ltop,
                                   INDEX #hdind & non_expl ],
                       CONJ cnil_or_lexconj ],
               NONLOC #nonloc & [ SLASH 0-dlist ],
	       LEX #lex,
               PUNCT.LPUNCT #lpunct ] ],
    NH-DTR [ INFLECTD na_or_+,
             SYNSEM canonical_synsem &
  	     [ NONLOC [ SLASH 0-dlist & [ LIST < > ],
                        QUE 0-dlist,
                        REL 0-dlist ],
               PUNCT.PAIRED #paired ] ],
    ORTH [ FROM #from, TO #to ],
    C-CONT.RELS.LIST < [ LBL #ltop,
                         PRED parenthetical_rel,
                         ARG1 #hdind,
			 CFROM #from, CTO #to ], ... > ].

; DPF 27-jul-09 - Push identity of RPUNCT down from paren_float_rule to 
; nbar subtype, since we don't want SF comm to propagate up from the NH-DTR.
; "Abrams (I mean it) arrived"
;; DPF 2020-03-24 - Changed to NH-DTR..RPAREN na_or_+ from + as per trunk.
;;
paren_float_rule := paren_dash_float_rule &
  [ HD-DTR.SYNSEM.PUNCT.RPUNCT quote_or_hyphen_or_clause_or_no_punct,
    NH-DTR.SYNSEM.PUNCT [ LPUNCT lparen_punct,
			  RCLSTR.RPAREN na_or_+ ] ].

; "Abrams - I mean it - arrived"
;; DPF 2014-08-08 - Added qeq between the ARG2 and the LTOP of the clause,
;; so we don't force quantifiers inside the parenthetical clause to have to
;; scope outside of that clause.
;;
paren_dash_float_s_rule := paren_dash_float_rule &
  [ SYNSEM.MODIFD #modif,
    HD-DTR.SYNSEM [ NONLOC non-local_none,
		    MODIFD #modif ],
    NH-DTR [ INFLECTD +,
	     SYNSEM.LOCAL [ CAT [ HEAD verb_or_conj_or_frag,
				  VAL [ SUBJ *anti_list*,
					SPR < >,
					COMPS < > ],
				  MC + ],
			    CONT.HOOK.LTOP #nhtop ] ],
    C-CONT [ RELS <! [ ARG2 #harg ] !>,
             HCONS <! qeq & [ HARG #harg, LARG #nhtop ] !>,
	     ICONS <! !> ] ].

paren_float_s_rule := paren_dash_float_s_rule & paren_float_rule.

dash_float_s_rule := paren_dash_float_s_rule &
  [ HD-DTR.SYNSEM.PUNCT.RPUNCT hyphen_sgl_or_dbl_or_sdash,
    NH-DTR.SYNSEM.PUNCT.RPUNCT hyphen_sgl_or_dbl_or_sdash ].

; "We visited Turlidfossen (waterfall)."
; DPF 09-aug-07 - Block named entities, to avoid spurious ambiguity for e.g.
; "Abrams (Browne) arrived"
; DPF 02-oct-08 - Re 09-aug-07: But this also blocks post-nominal modification
; after an acronym, as in "the computers (IBM) in Paris are black".  So remove.
;; DPF 2017-07-03 - Restricting NH-DTR's SPR to a singleton list excludes
;; measure-phrases, as in |10 pence (16 cents)|. So only constrain first
;; element.
;; DPF 2018-03-15 - On nh-dtr, copied nbar_cat constraints minus the SUBJ < >,
;; since we want to allow free relatives as in |his words (what he said)|.
;
paren_float_nbar_rule := paren_float_rule & head_initial &
  [ SYNSEM [ PUNCT.RPUNCT #rpunct,
	     MODIFD [ LPERIPH #lperiph,
		      RPERIPH #rperiph ] ],
    HD-DTR.SYNSEM.MODIFD [ LPERIPH #lperiph,
			   RPERIPH #rperiph ],
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD noun_or_nomger &
					 [ --BARE -,
					   CASE non_nom,
					   POSS - ],
				    VAL [ SPR.FIRST unexpressed & [ OPT - ],
					  COMPS < >,
					  SPEC *anti_list* ],
				    MC na ],
			      CONT.HOOK [ LTOP #nhtop,
					  INDEX #nhind ] ],
		      PUNCT.RPUNCT #rpunct ],
	     ORTH [ FROM #from, TO #to ] ],
    C-CONT [ RELS <! [ ARG2 #nhind ],
                     [ PRED udef_q_rel,
                       ARG0 #nhind & ref-ind,
                       RSTR #rhand,
		       CFROM #from, CTO #to ] !>,
             HCONS <! qeq & [ HARG #rhand,
                              LARG #nhtop ] !>,
	     ICONS <! !> ] ].

;; Similar rule for parenthetical adjectives: |cats (small) and dogs (large)|
paren_float_adj_rule := paren_float_rule & head_initial &
  [ SYNSEM [ PUNCT.RPUNCT #rpunct,
	     MODIFD #modif ],
    HD-DTR.SYNSEM.MODIFD #modif,
    NH-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD basic_adj & [ PRD - ],
				    VAL.COMPS *olist* ],
			      CONT.HOOK [ LTOP #ltop,
					  INDEX #nhind,
					  XARG #ind ] ],
		      PUNCT.RPUNCT #rpunct ],
	     INFLECTD + ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind ],
	     RELS <! [ ARG2 #nhind ] !>,
             HCONS <! !>,
	     ICONS <! !> ] ].


;; DPF 2012-11-26 - Constrain dtr's SLASH to be arg-local, to exclude spurious
;; RNR analysis of |Kim is arising and arriving in Paris|, which otherwise gets
;; admitted since |arising and arriving| undergoes adjunct extraction.  (The
;; reason the spurious analysis was blocked for simple |Kim arises and arrives
;; in Paris| is that the dtr is already constrained to [MODIFD notmod], but
;; the copula passes its MODIFD value up in |is arising and arriving|.)
;; DPF 2018-04-21 - Generalized to allow extraction from the second dtr, as in
;; |who did they depend and rely on?|.
;; DPF 2018-04-29 - Added RPERIPH bool to mother, and constrain left dtr to be
;; RPERIPH na, to block unwanted immedicate recursion as in 
;; |[[admired and hired] by] Kim|, while still allowing |who was he admired and
;; hired by|
;;
right_node_raise_phrase := head_initial_infl & phrasal & 
			   binary_rule_left_to_right &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
				 SPR #spr,
				 SPEC #spec,
				 SPCMPS < > ],
			   POSTHD + ],
		     CONJ cnil ],
	     NONLOC [ QUE #que,
		      REL #rel ],
	     MODIFD notmod & [ RPERIPH bool ],
             PUNCT.PNCTPR #ppair ],
    ARGS < [ SYNSEM [ LOCAL [ CAT.VAL [ COMPS < >,
					SPR #spr,
					SPEC #spec ],
                              CONT.HOOK [ LTOP #ltop,
					  INDEX #index & conj-ind,
					  XARG #xarg ],
			      ARG-S < > ],
		      NONLOC [ SLASH 1-dlist &
					[ LIST [ FIRST #slash,
						 REST < > & #last ],
					  LAST #last ],
			       QUE 0-dlist,
			       REL 0-dlist ],
		      MODIFD notmod_or_rmod & [ RPERIPH na ],
                      PUNCT [ LPUNCT lital_or_pair_or_comma_or_no_punct,
			      RPUNCT comma_or_pair_or_no_punct ] ] ],
	   [ SYNSEM [ LOCAL #slash & arg-local &
			    [ CAT.VAL.COMPS < > ],
		      NONLOC [ QUE #que,
			       REL #rel ],
		      PUNCT.PNCTPR #ppair ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX #index,
		    XARG #xarg ],
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2016-11-09 - Constrain the dtr to be AUX - to avoid spurious analysis of
;; |is sad and wise| where the lexical copula undergoes comp-extraction; note 
;; that the AUX feature is not propagated through VP coord.
;;
right_node_raise_vp_phrase := right_node_raise_phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD verb,
			 VAL.SUBJ < synsem &
				    [ LOCAL #loc,
				      NONLOC [ SLASH [ LIST #slfirst,
						       LAST #slmid ],
					       REL #rel,
					       QUE #que ],
				      LEX #lex,
				      MODIFD #mod,
				      PUNCT #punct,
				      --MIN #min,
				      --SIND #sind ] > ],
	     NONLOC [ SLASH [ LIST #slfirst,
			      LAST #sllast ],
		      REL #rel,
		      QUE #que ] ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD.AUX -,
				  VAL.SUBJ < synsem &
					     [ LOCAL #loc,
					       NONLOC [ SLASH 0-dlist,
							REL #rel,
							QUE #que ],
					       LEX #lex,
					       MODIFD #mod,
					       PUNCT #punct,
					       --MIN #min,
					       --SIND #sind ] > ] ] ],
	   [ SYNSEM.NONLOC.SLASH [ LIST #slmid,
				   LAST #sllast ] ] > ].

;; Exclude subordinate clauses with constraint on MOD
;; DPF 2020-08-26 - Not clear why stamped SUBJ < > on mother and left dtr, but 
;; this excludes "near or similar to Kim", so instead identify SUBJ of mother 
;; with left dtr's SUBJ.
;;
right_node_raise_nonvp_phrase := right_node_raise_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.SUBJ #subj,
	     NONLOC.SLASH #slash ],
    ARGS < [ SYNSEM.LOCAL.CAT [ HEAD a_or_p &
				     [ MOD.FIRST.LOCAL intersective_mod ],
				VAL.SUBJ #subj ] ],
	   [ SYNSEM.NONLOC.SLASH #slash ] > ].

right_node_raise_nbar_phrase := right_node_raise_phrase &
  [ SYNSEM [ LOCAL.CAT.VAL.SUBJ < >,
	     NONLOC.SLASH #slash ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD basic_noun,
				  VAL.SPR < synsem & 
					    [ NONLOC.SLASH 0-dlist ] > ],
		      PUNCT.RPUNCT comma_or_no_punct  ] ],
	   [ SYNSEM.NONLOC.SLASH #slash ] > ].	   

right_node_raise_vp_rule := right_node_raise_vp_phrase.
right_node_raise_nonvp_rule := right_node_raise_nonvp_phrase.
right_node_raise_nbar_rule := right_node_raise_nbar_phrase.

;; DPF 2012-11-01 
;; Rule to discharge a pair of brackets introduced in chart-mapping, where
;; all binary rules refuse to cross the brackets.  This rule is blocked by
;; a temporary expedient in the LKB.
;; DPF 2012-11-01 
;; Rule to discharge a pair of brackets introduced overtly as ( ... ), or
;; via chart-mapping, especially for punctuation clitics, where
;; all binary rules refuse to cross the brackets.  This rule is blocked by
;; a temporary expedient in the LKB.
;; DPF 2018-05-16 - Added constraints on ORTH.FIRST to block this rule feeding
;; itself under conditions where the cycle check on diff-lists is not effective.
;; This (ab-)use of ORTH is okay since constructions do not propagate ORTH
;; values, nor do they otherwise make reference to them.
;;
paired_bracket_rule := rule & phrase_or_lexrule & 
		       word_or_punct_or_bracketed_phrase &
  [ SYNSEM #synsem,
    INFLECTD #infl,
    IDIOM #idiom,
    DIALECT #dialect,
    GENRE #genre,
    ORTH [ TO #to,
	   FIRST bool,
	   LB [ LIST #lb, LAST #llast ],
	   RB [ LIST #rb, LAST #rlast ] ],
    ARGS < [ SYNSEM #synsem &
		    [ LOCAL [ CAT.HEAD subst_or_func,
			      CONT.HOOK #hook ] ],
	     ORTH [ TO #to,
		    FIRST string,
		    LB bracket_nonnull &
		       [ LIST.REST #lb,
                         LAST #llast ],
		    RB bracket_nonnull &
		       [ LIST.REST #rb,
                         LAST #rlast ] ],
	     IDIOM #idiom,
	     DIALECT #dialect,
	     GENRE #genre,
	     INFLECTD #infl ] >,
    C-CONT [ HOOK #hook,
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! !> ] ].

;; DPF 2018-06-24 - This type allows a sentence with outermost strong brackets
;; to unify with root_informal, where the types would otherwise clash.
phrasal_bracket := paired_bracket_rule & phrase.

never_unify_rule := rule &
  [ SYNSEM.LOCAL.CAT.HEAD no_head & [ MINORS.MIN never_unify_rel,
				      PRD + ],
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD no_head & 
				   [ MINORS.MIN never_unify_rel,
				     PRD - ] ] > ].

;; DPF 2014-08-01 - Added unary and binary bridging rules to accommodate robust
;; full-forest treebanking.  The strategy is to pump each normal edge in the
;; chart to a "bridge head" edge via the unary rule, and then combine two
;; adjacent such bridge-head edges using the binary rule.  This strategy,
;; proposed by Woodley Packard, results in a mere doubling of the number of
;; edges in each cell of the chart, rather than the square of the number of
;; normal edges that resulted from trying just a binary bridging rule that
;; accepted either bridge or normal edges.
;;
bridge_binary_phrase := basic_binary_phrase &
  [ INFLECTD -,
    SYNSEM [ LOCAL [ CAT [ HEAD bridge_head & [ MINORS.MIN never_unify_rel,
						MOD < > ],
			   VAL [ SUBJ < >,
				 SPR < >,
				 COMPS < >,
				 SPCMPS < > ] ],
		     CONJ cnil ],
	     LEX -,
	     NONLOC non-local_none_phr ],
    C-CONT [ HOOK [ LTOP #lbl, INDEX #arg0 ],
	     RELS <! [ LBL #lbl, PRED "bridge_x_rel",
		       ARG0 #arg0, ARG1 #lind, ARG2 #rind ] !>,
	     HCONS <! !> ],
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD bridge_head,
			    CONT.HOOK.INDEX #lind ],
	     INFLECTD na ],
	   [ SYNSEM.LOCAL [ CAT.HEAD bridge_head,
			    CONT.HOOK.INDEX #rind ] ] > ].

bridge_unary_phrase := basic_unary_phrase &
  [ INFLECTD na,
    SYNSEM [ LOCAL [ CAT [ HEAD bridge_head & [ MINORS.MIN never_unify_rel,
						MOD < > ],
			   VAL [ SUBJ < >,
				 SPR < >,
				 COMPS < >,
				 SPCMPS < > ] ],
		     CONJ cnil ],
	     LEX -,
	     NONLOC non-local_none_phr,
	     PUNCT #punct ],
    C-CONT [ HOOK #hook,
	     RELS <! !>,
	     HCONS <! !> ],
    ARGS < [ INFLECTD bool,
	     SYNSEM [ LOCAL [ CAT.HEAD non_frag,
			      CONT.HOOK #hook ],
		      PUNCT #punct ] ] > ].

basic_bridge_phrase := binary_headed_phrase &
  [ SYNSEM [ LOCAL [ CAT #cat,
		     CONJ #conj ],
	     NONLOC #nonloc,
	     --BRDG + ],
    C-CONT [ HOOK #hook,
	     RELS <! [ LBL #ltop, PRED "bridge_x_rel",
		       ARG1 #lind, ARG2 #rind ] !>,
	     HCONS <! !> ],
    HD-DTR.SYNSEM [ LOCAL [ CAT #cat,
			    CONT.HOOK #hook & [ LTOP #ltop,
						INDEX #rind ],
			    CONJ #conj ],
		    NONLOC #nonloc,
		    --BRDG - ],
    NH-DTR.SYNSEM [ LOCAL [ CAT.VAL [ SPR *olist*,
				      COMPS *olist* ],
			    CONT.HOOK.INDEX #lind ],
		    --BRDG - ],
    GENRE robust ].

;; Nominal bridge
bridge_n_phrase := basic_bridge_phrase & head_final &
  [ HD-DTR.SYNSEM.LOCAL [ CAT [ HEAD basic_noun & [ --BARE - ],
				VAL.SPR.FIRST synsem & [ --MIN quant_rel ] ],
			  CONJ cnil ],
    NH-DTR.SYNSEM [ LOCAL [ CAT [ HEAD non_noun_or_adv &
				       [ MINORS.MIN independent_rel ] ],
			    CONJ cnil ],
		    NONLOC non-local_none_phr,
		    LEX na_or_-,
		    PUNCT.RPUNCT rbc_or_hyphen_or_pair_or_no_punct ] ].

bridge_v_phrase := basic_bridge_phrase & head_initial &
  [ HD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verbal,
				VAL [ SUBJ.FIRST synsem,
				      COMPS < > ] ],
		    NONLOC non-local_none_phr ],
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD non_frag ].

bridge_a_phrase := basic_bridge_phrase & head_initial &
  [ HD-DTR.SYNSEM.LOCAL.CAT.HEAD a_or_adv,
    NH-DTR.SYNSEM.LOCAL.CAT.HEAD non_frag ].

